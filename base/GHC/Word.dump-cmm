
==================== Output Cmm ====================
2018-03-16 15:57:09.9212152 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:09.922368576 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2vec,
                       label: GHC.Word.$fEnumWord8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vec: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vej; else goto c2vek;
       c2vej: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vek: // global
           I64[Sp - 8] = block_c2ve9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2veo; else goto c2vea;
       u2veo: // global
           call _c2ve9(R1) args: 0, res: 0, upd: 0;
       c2vea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ve9() //  [R1]
         { info_tbl: [(c2ve9,
                       label: block_c2ve9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ve9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ven; else goto c2vem;
       c2ven: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vem: // global
           _s2uFW::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.92380166 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2vew,
                       label: GHC.Word.$fEnumWord16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vew: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2veD; else goto c2veE;
       c2veD: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2veE: // global
           I64[Sp - 8] = block_c2vet_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2veI; else goto c2veu;
       u2veI: // global
           call _c2vet(R1) args: 0, res: 0, upd: 0;
       c2veu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vet() //  [R1]
         { info_tbl: [(c2vet,
                       label: block_c2vet_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vet: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2veH; else goto c2veG;
       c2veH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2veG: // global
           _s2uG0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.925143948 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2veQ,
                       label: GHC.Word.$fEnumWord32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2veQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2veX; else goto c2veY;
       c2veX: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2veY: // global
           I64[Sp - 8] = block_c2veN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vf2; else goto c2veO;
       u2vf2: // global
           call _c2veN(R1) args: 0, res: 0, upd: 0;
       c2veO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2veN() //  [R1]
         { info_tbl: [(c2veN,
                       label: block_c2veN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2veN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vf1; else goto c2vf0;
       c2vf1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vf0: // global
           _s2uG4::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.926500814 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2vf9,
                       label: GHC.Word.$fNumWord64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vf9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vfd; else goto c2vfe;
       c2vfd: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vfe: // global
           I64[Sp - 8] = block_c2vf7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vf7() //  [R1]
         { info_tbl: [(c2vf7,
                       label: block_c2vf7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vf7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vfh; else goto c2vfg;
       c2vfh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2vfg: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.927612408 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { info_tbl: [(c2vfm,
                       label: GHC.Word.$fNumWord64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vfm: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.928606347 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { info_tbl: [(c2vfw,
                       label: GHC.Word.$fNumWord64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vfw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vfJ; else goto c2vfK;
       c2vfJ: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vfK: // global
           I64[Sp - 8] = block_c2vft_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vfO; else goto c2vfu;
       u2vfO: // global
           call _c2vft(R1) args: 0, res: 0, upd: 0;
       c2vfu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vft() //  [R1]
         { info_tbl: [(c2vft,
                       label: block_c2vft_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vft: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vfN; else goto c2vfM;
       c2vfN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vfM: // global
           _s2uGd::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.930074767 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2vfW,
                       label: GHC.Word.$fNumWord64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vg8; else goto c2vg9;
       c2vg8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vg9: // global
           I64[Sp - 16] = block_c2vfT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vgf; else goto c2vfU;
       u2vgf: // global
           call _c2vfT(R1) args: 0, res: 0, upd: 0;
       c2vfU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vfT() //  [R1]
         { info_tbl: [(c2vfT,
                       label: block_c2vfT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vfT: // global
           I64[Sp] = block_c2vfZ_info;
           _s2uGh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGh::I64;
           if (R1 & 7 != 0) goto u2vge; else goto c2vg0;
       u2vge: // global
           call _c2vfZ(R1) args: 0, res: 0, upd: 0;
       c2vg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vfZ() //  [R1]
         { info_tbl: [(c2vfZ,
                       label: block_c2vfZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vfZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vgd; else goto c2vgc;
       c2vgd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vgc: // global
           _s2uGk::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.931721544 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2vgn,
                       label: GHC.Word.$fNumWord64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vgz; else goto c2vgA;
       c2vgz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vgA: // global
           I64[Sp - 16] = block_c2vgk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vgG; else goto c2vgl;
       u2vgG: // global
           call _c2vgk(R1) args: 0, res: 0, upd: 0;
       c2vgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vgk() //  [R1]
         { info_tbl: [(c2vgk,
                       label: block_c2vgk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgk: // global
           I64[Sp] = block_c2vgq_info;
           _s2uGo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGo::I64;
           if (R1 & 7 != 0) goto u2vgF; else goto c2vgr;
       u2vgF: // global
           call _c2vgq(R1) args: 0, res: 0, upd: 0;
       c2vgr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vgq() //  [R1]
         { info_tbl: [(c2vgq,
                       label: block_c2vgq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vgE; else goto c2vgD;
       c2vgE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vgD: // global
           _s2uGr::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.933446888 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2vgO,
                       label: GHC.Word.$fNumWord64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vh0; else goto c2vh1;
       c2vh0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vh1: // global
           I64[Sp - 16] = block_c2vgL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vh7; else goto c2vgM;
       u2vh7: // global
           call _c2vgL(R1) args: 0, res: 0, upd: 0;
       c2vgM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vgL() //  [R1]
         { info_tbl: [(c2vgL,
                       label: block_c2vgL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgL: // global
           I64[Sp] = block_c2vgR_info;
           _s2uGv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGv::I64;
           if (R1 & 7 != 0) goto u2vh6; else goto c2vgS;
       u2vh6: // global
           call _c2vgR(R1) args: 0, res: 0, upd: 0;
       c2vgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vgR() //  [R1]
         { info_tbl: [(c2vgR,
                       label: block_c2vgR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vgR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vh5; else goto c2vh4;
       c2vh5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vh4: // global
           _s2uGy::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.934747057 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.935487105 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { info_tbl: [(c2vhe,
                       label: lvl_r2uFF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vhf; else goto c2vhg;
       c2vhf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vhg: // global
           (_c2vhb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vhb::I64 == 0) goto c2vhd; else goto c2vhc;
       c2vhd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vhc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vhb::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.936705699 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2vho,
                       label: GHC.Word.$fIntegralWord64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vho: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vhp; else goto c2vhq;
       c2vhp: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vhq: // global
           I64[Sp - 8] = block_c2vhl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vhC; else goto c2vhm;
       u2vhC: // global
           call _c2vhl(R1) args: 0, res: 0, upd: 0;
       c2vhm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vhl() //  [R1]
         { info_tbl: [(c2vhl,
                       label: block_c2vhl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vhl: // global
           _s2uGB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGB::I64, 0)) goto c2vhA; else goto c2vhB;
       c2vhA: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2vhB: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.939810642 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2uGF_entry() //  [R1]
         { info_tbl: [(c2vhO,
                       label: w1_s2uGF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vhO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vhP; else goto c2vhQ;
       c2vhP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vhQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2vhL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vi2; else goto c2vhM;
       u2vi2: // global
           call _c2vhL(R1) args: 0, res: 0, upd: 0;
       c2vhM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2vhL() //  [R1]
         { info_tbl: [(c2vhL,
                       label: block_c2vhL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vhL: // global
           _s2uGH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGH::I64, 0)) goto c2vi0; else goto c2vi1;
       c2vi0: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2vi1: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uGO_entry() //  [R1, R2]
         { info_tbl: [(c2vib,
                       label: sat_s2uGO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vib: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vic; else goto c2vid;
       c2vic: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vid: // global
           I64[Sp - 8] = block_c2vi8_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vi8() //  [R1, R2]
         { info_tbl: [(c2vi8,
                       label: block_c2vi8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vi8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vig; else goto c2vif;
       c2vig: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vif: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { info_tbl: [(c2vih,
                       label: GHC.Word.$fShowWord3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vih: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2vil; else goto c2vik;
       c2vil: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vik: // global
           I64[Hp - 32] = w1_s2uGF_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2uGO_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.941843117 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2vir,
                       label: GHC.Word.$fShowWord64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vir: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.942839524 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { info_tbl: [(c2viA,
                       label: GHC.Word.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2viA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2viB; else goto c2viC;
       c2viB: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2viC: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2viJ; else goto c2viQ;
       c2viJ: // global
           I64[Sp - 8] = block_c2viH_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2viQ: // global
           I64[Sp - 8] = block_c2viP_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2viH() //  [R1]
         { info_tbl: [(c2viH,
                       label: block_c2viH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2viH: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2viP() //  [R1]
         { info_tbl: [(c2viP,
                       label: block_c2viP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2viP: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.944291179 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { info_tbl: [(c2vj2,
                       label: GHC.Word.$fShowWord64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vj2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vj8; else goto c2vj9;
       c2vj8: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vj9: // global
           I64[Sp - 8] = block_c2viZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vje; else goto c2vj0;
       u2vje: // global
           call _c2viZ(R1) args: 0, res: 0, upd: 0;
       c2vj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2viZ() //  [R1]
         { info_tbl: [(c2viZ,
                       label: block_c2viZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2viZ: // global
           I64[Sp] = block_c2vj5_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vj5() //  [R1, R2]
         { info_tbl: [(c2vj5,
                       label: block_c2vj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vj5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vjd; else goto c2vjc;
       c2vjd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vjc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.946295255 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2uH4_entry() //  [R1]
         { info_tbl: [(c2vjq,
                       label: w1_s2uH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vjq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vjr; else goto c2vjs;
       c2vjr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vjs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2vjn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vjE; else goto c2vjo;
       u2vjE: // global
           call _c2vjn(R1) args: 0, res: 0, upd: 0;
       c2vjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2vjn() //  [R1]
         { info_tbl: [(c2vjn,
                       label: block_c2vjn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vjn: // global
           _s2uH6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uH6::I64, 0)) goto c2vjC; else goto c2vjD;
       c2vjC: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2vjD: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uHf_entry() //  [R1, R2]
         { info_tbl: [(c2vjN,
                       label: sat_s2uHf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vjN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vjT; else goto c2vjU;
       c2vjT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vjU: // global
           I64[Sp - 24] = block_c2vjK_info;
           _s2uH4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2uH4::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vjZ; else goto c2vjL;
       u2vjZ: // global
           call _c2vjK(R1) args: 0, res: 0, upd: 0;
       c2vjL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vjK() //  [R1]
         { info_tbl: [(c2vjK,
                       label: block_c2vjK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vjK: // global
           _s2uH9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2vjQ_info;
           R4 = _s2uH9::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vjQ() //  [R1, R2]
         { info_tbl: [(c2vjQ,
                       label: block_c2vjQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vjQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vjY; else goto c2vjX;
       c2vjY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vjX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c2vk0,
                       label: GHC.Word.$fShowWord64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vk0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2vk4; else goto c2vk3;
       c2vk4: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vk3: // global
           I64[Hp - 40] = w1_s2uH4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2uHf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.948387533 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.949111402 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { info_tbl: [(c2vk9,
                       label: GHC.Word.$fEnumWord5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vk9: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.949935786 UTC

[section ""data" . sat_s2uHh_closure" {
     sat_s2uHh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.950485543 UTC

[section ""data" . sat_s2uHi_closure" {
     sat_s2uHi_closure:
         const :_con_info;
         const sat_s2uHh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.9512663 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { info_tbl: [(c2vki,
                       label: GHC.Word.$fRealWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vkj; else goto c2vkk;
       c2vkj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vkk: // global
           (_c2vkf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vkf::I64 == 0) goto c2vkh; else goto c2vkg;
       c2vkh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vkg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vkf::I64;
           R3 = sat_s2uHi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.95250681 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { info_tbl: [(c2vkr,
                       label: GHC.Word.$w$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vkr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vks; else goto c2vkt;
       c2vks: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vkt: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2vkE; else goto c2vkQ;
       c2vkE: // global
           I64[Sp - 8] = block_c2vky_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2vkQ: // global
           I64[Sp - 8] = block_c2vkL_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vky() //  [R1]
         { info_tbl: [(c2vky,
                       label: block_c2vky_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vky: // global
           I64[Sp] = block_c2vkC_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vkC() //  [R1]
         { info_tbl: [(c2vkC,
                       label: block_c2vkC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vkC: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2vkL() //  [R1]
         { info_tbl: [(c2vkL,
                       label: block_c2vkL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vkL: // global
           I64[Sp] = block_c2vkP_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vkP() //  [R1]
         { info_tbl: [(c2vkP,
                       label: block_c2vkP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vkP: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.954257038 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2vl3,
                       label: GHC.Word.$fRealWord64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vl3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vl9; else goto c2vla;
       c2vl9: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vla: // global
           I64[Sp - 8] = block_c2vl0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vlf; else goto c2vl1;
       u2vlf: // global
           call _c2vl0(R1) args: 0, res: 0, upd: 0;
       c2vl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vl0() //  [R1]
         { info_tbl: [(c2vl0,
                       label: block_c2vl0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vl0: // global
           I64[Sp] = block_c2vl6_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vl6() //  [R1, R2]
         { info_tbl: [(c2vl6,
                       label: block_c2vl6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vl6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vle; else goto c2vld;
       c2vle: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vld: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.955490233 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.956249126 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { info_tbl: [(c2vlo,
                       label: GHC.Word.$fEnumWord10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vlp; else goto c2vlq;
       c2vlp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vlq: // global
           (_c2vlj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vlj::I64 == 0) goto c2vll; else goto c2vlk;
       c2vll: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vlk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vlj::I64;
           I64[Sp - 24] = block_c2vlm_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vlm() //  [R1]
         { info_tbl: [(c2vlm,
                       label: block_c2vlm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.957577524 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { info_tbl: [(c2vlC,
                       label: GHC.Word.$fEnumWord11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vlD; else goto c2vlE;
       c2vlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vlE: // global
           (_c2vlx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vlx::I64 == 0) goto c2vlz; else goto c2vly;
       c2vlz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vly: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vlx::I64;
           I64[Sp - 24] = block_c2vlA_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vlA() //  [R1]
         { info_tbl: [(c2vlA,
                       label: block_c2vlA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.959698262 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { info_tbl: [(c2vlP,
                       label: GHC.Word.neWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vlT; else goto c2vlU;
       c2vlT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vlU: // global
           I64[Sp - 16] = block_c2vlM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vm3; else goto c2vlN;
       u2vm3: // global
           call _c2vlM(R1) args: 0, res: 0, upd: 0;
       c2vlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vlM() //  [R1]
         { info_tbl: [(c2vlM,
                       label: block_c2vlM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlM: // global
           I64[Sp] = block_c2vlS_info;
           _s2uHB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHB::I64;
           if (R1 & 7 != 0) goto u2vm2; else goto c2vlW;
       u2vm2: // global
           call _c2vlS(R1) args: 0, res: 0, upd: 0;
       c2vlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vlS() //  [R1]
         { info_tbl: [(c2vlS,
                       label: block_c2vlS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vlS: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.961711647 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { info_tbl: [(c2vma,
                       label: lvl2_r2uFH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vmb; else goto c2vmc;
       c2vmb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vmc: // global
           (_c2vm7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vm7::I64 == 0) goto c2vm9; else goto c2vm8;
       c2vm9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vm8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vm7::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.962686084 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.963660955 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { info_tbl: [(c2vmk,
                       label: GHC.Word.$fEnumWord8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vmk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vml; else goto c2vmm;
       c2vml: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vmm: // global
           I64[Sp - 8] = block_c2vmh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vmE; else goto c2vmi;
       u2vmE: // global
           call _c2vmh(R1) args: 0, res: 0, upd: 0;
       c2vmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vmh() //  [R1]
         { info_tbl: [(c2vmh,
                       label: block_c2vmh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vmh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vmr; else goto c2vmq;
       c2vmr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vmq: // global
           _s2uHI::I64 = I64[R1 + 7];
           if (_s2uHI::I64 != 0) goto c2vmC; else goto c2vmD;
       c2vmC: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHI::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vmD: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.964920063 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.965522819 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.96656976 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { info_tbl: [(c2vmM,
                       label: GHC.Word.$fEnumWord8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vmM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vmN; else goto c2vmO;
       c2vmN: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vmO: // global
           I64[Sp - 8] = block_c2vmJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vn6; else goto c2vmK;
       u2vn6: // global
           call _c2vmJ(R1) args: 0, res: 0, upd: 0;
       c2vmK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vmJ() //  [R1]
         { info_tbl: [(c2vmJ,
                       label: block_c2vmJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vmJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vmT; else goto c2vmS;
       c2vmT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vmS: // global
           _s2uHO::I64 = I64[R1 + 7];
           if (_s2uHO::I64 != 255) goto c2vn4; else goto c2vn5;
       c2vn4: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHO::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vn5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.968260479 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vne,
                       label: GHC.Word.$fShowWord8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vne: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vns; else goto c2vnt;
       c2vns: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vnt: // global
           I64[Sp - 24] = block_c2vnb_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vnA; else goto c2vnc;
       u2vnA: // global
           call _c2vnb(R1) args: 0, res: 0, upd: 0;
       c2vnc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vnb() //  [R1]
         { info_tbl: [(c2vnb,
                       label: block_c2vnb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnb: // global
           I64[Sp] = block_c2vnh_info;
           _s2uHV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHV::I64;
           if (R1 & 7 != 0) goto u2vnz; else goto c2vni;
       u2vnz: // global
           call _c2vnh(R1) args: 0, res: 0, upd: 0;
       c2vni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vnh() //  [R1]
         { info_tbl: [(c2vnh,
                       label: block_c2vnh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnh: // global
           _s2uHT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2vnp_info;
           R4 = _s2uHT::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vnp() //  [R1, R2]
         { info_tbl: [(c2vnp,
                       label: block_c2vnp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vny; else goto c2vnx;
       c2vny: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vnx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.970286736 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { info_tbl: [(c2vnI,
                       label: GHC.Word.$fShowWord8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vnR; else goto c2vnS;
       c2vnR: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vnS: // global
           I64[Sp - 8] = block_c2vnF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vnX; else goto c2vnG;
       u2vnX: // global
           call _c2vnF(R1) args: 0, res: 0, upd: 0;
       c2vnG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vnF() //  [R1]
         { info_tbl: [(c2vnF,
                       label: block_c2vnF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnF: // global
           I64[Sp] = block_c2vnO_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vnO() //  [R1, R2]
         { info_tbl: [(c2vnO,
                       label: block_c2vnO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vnO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vnW; else goto c2vnV;
       c2vnW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vnV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.972224247 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { info_tbl: [(c2vo5,
                       label: GHC.Word.$fShowWord4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vo5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2voe; else goto c2vof;
       c2voe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vof: // global
           I64[Sp - 16] = block_c2vo2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vok; else goto c2vo3;
       u2vok: // global
           call _c2vo2(R1) args: 0, res: 0, upd: 0;
       c2vo3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vo2() //  [R1]
         { info_tbl: [(c2vo2,
                       label: block_c2vo2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vo2: // global
           _s2uIa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2vob_info;
           R4 = _s2uIa::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vob() //  [R1, R2]
         { info_tbl: [(c2vob,
                       label: block_c2vob_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vob: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2voj; else goto c2voi;
       c2voj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2voi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.974193078 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2vop,
                       label: GHC.Word.$fShowWord8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vop: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.975015859 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.975808913 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { info_tbl: [(c2vow,
                       label: GHC.Word.$wlvl3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vow: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.977017523 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c2voI,
                       label: GHC.Word.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2voI: // global
           _s2uIk::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2voQ; else goto c2voH;
       c2voH: // global
           if (%MO_S_Gt_W64(_s2uIk::I64, 255)) goto c2voQ; else goto c2voU;
       c2voQ: // global
           R2 = _s2uIk::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2voU: // global
           R1 = _s2uIk::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.978392691 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2vp2,
                       label: GHC.Word.$fEnumWord8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vp2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vpa; else goto c2vpb;
       c2vpa: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vpb: // global
           I64[Sp - 8] = block_c2voZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vpg; else goto c2vp0;
       u2vpg: // global
           call _c2voZ(R1) args: 0, res: 0, upd: 0;
       c2vp0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2voZ() //  [R1]
         { info_tbl: [(c2voZ,
                       label: block_c2voZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2voZ: // global
           I64[Sp] = block_c2vp5_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vp5() //  [R1]
         { info_tbl: [(c2vp5,
                       label: block_c2vp5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vp5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vpf; else goto c2vpe;
       c2vpf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2vpe: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.985462079 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2uIP_entry() //  [R1]
         { info_tbl: [(c2vpY,
                       label: sat_s2uIP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vpY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vpZ; else goto c2vq0;
       c2vpZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vq0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIN_entry() //  [R1]
         { info_tbl: [(c2vqa,
                       label: sat_s2uIN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vqa: // global
           _s2uIN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vqb; else goto c2vqc;
       c2vqc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vqe; else goto c2vqd;
       c2vqe: // global
           HpAlloc = 16;
           goto c2vqb;
       c2vqb: // global
           R1 = _s2uIN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vqd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIN::P64;
           _s2uII::I64 = I64[_s2uIN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2vqk; else goto c2vq9;
       c2vq9: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2vqk; else goto c2vqr;
       c2vqk: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vqr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIT_entry() //  [R1]
         { info_tbl: [(c2vqC,
                       label: sat_s2uIT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vqC: // global
           _s2uIT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vqD; else goto c2vqE;
       c2vqE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vqG; else goto c2vqF;
       c2vqG: // global
           HpAlloc = 16;
           goto c2vqD;
       c2vqD: // global
           R1 = _s2uIT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIT::P64;
           _s2uII::I64 = I64[_s2uIT::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2vqM; else goto c2vqB;
       c2vqB: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2vqM; else goto c2vqT;
       c2vqM: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vqT: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uIH_entry() //  [R1, R2]
         { info_tbl: [(c2vqX,
                       label: go_dn_s2uIH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vqX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vr1; else goto c2vr0;
       c2vr1: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vr0: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2vqV; else goto c2vqW;
       c2vqV: // global
           _s2uIF::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uIP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uIF::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uIN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vqW: // global
           I64[Hp - 80] = sat_s2uIT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vr3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vr3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uIU_entry() //  [R1]
         { info_tbl: [(c2vr4,
                       label: sat_s2uIU_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vr4: // global
           _s2uIU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vr5; else goto c2vr6;
       c2vr6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vr8; else goto c2vr7;
       c2vr8: // global
           HpAlloc = 24;
           goto c2vr5;
       c2vr5: // global
           R1 = _s2uIU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vr7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIU::P64;
           _s2uIx::I64 = I64[_s2uIU::P64 + 24];
           _s2uIF::I64 = _s2uIx::I64 - I64[_s2uIU::P64 + 16];
           _s2uIG::I64 = I64[_s2uIU::P64 + 32] - _s2uIF::I64;
           I64[Hp - 16] = go_dn_s2uIH_info;
           I64[Hp - 8] = _s2uIF::I64;
           I64[Hp] = _s2uIG::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIE_entry() //  [R1]
         { info_tbl: [(c2vri,
                       label: sat_s2uIE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vri: // global
           _s2uIE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vrj; else goto c2vrk;
       c2vrk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vrm; else goto c2vrl;
       c2vrm: // global
           HpAlloc = 16;
           goto c2vrj;
       c2vrj: // global
           R1 = _s2uIE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vrl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIE::P64;
           _s2uIw::I64 = I64[_s2uIE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2vrs; else goto c2vrh;
       c2vrh: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2vrs; else goto c2vrz;
       c2vrs: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vrz: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIZ_entry() //  [R1]
         { info_tbl: [(c2vrN,
                       label: sat_s2uIZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vrN: // global
           _s2uIZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vrO; else goto c2vrP;
       c2vrP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vrR; else goto c2vrQ;
       c2vrR: // global
           HpAlloc = 16;
           goto c2vrO;
       c2vrO: // global
           R1 = _s2uIZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIZ::P64;
           _s2uIw::I64 = I64[_s2uIZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2vrX; else goto c2vrM;
       c2vrM: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2vrX; else goto c2vs4;
       c2vrX: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vs4: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJg_entry() //  [R1]
         { info_tbl: [(c2vsA,
                       label: sat_s2uJg_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vsA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vsB; else goto c2vsC;
       c2vsB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vsC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJe_entry() //  [R1]
         { info_tbl: [(c2vsM,
                       label: sat_s2uJe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vsM: // global
           _s2uJe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vsN; else goto c2vsO;
       c2vsO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vsQ; else goto c2vsP;
       c2vsQ: // global
           HpAlloc = 16;
           goto c2vsN;
       c2vsN: // global
           R1 = _s2uJe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vsP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJe::P64;
           _s2uJ9::I64 = I64[_s2uJe::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2vsW; else goto c2vsL;
       c2vsL: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2vsW; else goto c2vt3;
       c2vsW: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vt3: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJk_entry() //  [R1]
         { info_tbl: [(c2vte,
                       label: sat_s2uJk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vte: // global
           _s2uJk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vtf; else goto c2vtg;
       c2vtg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vti; else goto c2vth;
       c2vti: // global
           HpAlloc = 16;
           goto c2vtf;
       c2vtf: // global
           R1 = _s2uJk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vth: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJk::P64;
           _s2uJ9::I64 = I64[_s2uJk::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2vto; else goto c2vtd;
       c2vtd: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2vto; else goto c2vtv;
       c2vto: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vtv: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uJ8_entry() //  [R1, R2]
         { info_tbl: [(c2vtz,
                       label: go_up_s2uJ8_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vtz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vtD; else goto c2vtC;
       c2vtD: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vtC: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2vtx; else goto c2vty;
       c2vtx: // global
           _s2uJ6::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJg_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJ6::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vty: // global
           I64[Hp - 80] = sat_s2uJk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vtF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vtF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uJl_entry() //  [R1]
         { info_tbl: [(c2vtG,
                       label: sat_s2uJl_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vtG: // global
           _s2uJl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vtH; else goto c2vtI;
       c2vtI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vtK; else goto c2vtJ;
       c2vtK: // global
           HpAlloc = 24;
           goto c2vtH;
       c2vtH: // global
           R1 = _s2uJl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vtJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJl::P64;
           _s2uIx::I64 = I64[_s2uJl::P64 + 24];
           _s2uJ6::I64 = _s2uIx::I64 - I64[_s2uJl::P64 + 16];
           _s2uJ7::I64 = I64[_s2uJl::P64 + 32] - _s2uJ6::I64;
           I64[Hp - 16] = go_up_s2uJ8_info;
           I64[Hp - 8] = _s2uJ6::I64;
           I64[Hp] = _s2uJ7::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJ5_entry() //  [R1]
         { info_tbl: [(c2vtU,
                       label: sat_s2uJ5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vtU: // global
           _s2uJ5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vtV; else goto c2vtW;
       c2vtW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vtY; else goto c2vtX;
       c2vtY: // global
           HpAlloc = 16;
           goto c2vtV;
       c2vtV: // global
           R1 = _s2uJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vtX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJ5::P64;
           _s2uIw::I64 = I64[_s2uJ5::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2vu4; else goto c2vtT;
       c2vtT: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2vu4; else goto c2vub;
       c2vu4: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vub: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJq_entry() //  [R1]
         { info_tbl: [(c2vup,
                       label: sat_s2uJq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vup: // global
           _s2uJq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vuq; else goto c2vur;
       c2vur: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vut; else goto c2vus;
       c2vut: // global
           HpAlloc = 16;
           goto c2vuq;
       c2vuq: // global
           R1 = _s2uJq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vus: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJq::P64;
           _s2uIw::I64 = I64[_s2uJq::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2vuz; else goto c2vuo;
       c2vuo: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2vuz; else goto c2vuG;
       c2vuz: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vuG: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vuH,
                       label: GHC.Word.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vuH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vuL; else goto c2vuK;
       c2vuL: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vuK: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2vuV; else goto c2vv4;
       c2vuV: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2vuO; else goto c2vuT;
       c2vuO: // global
           I64[Hp - 80] = sat_s2uIU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uIE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vuT: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2vv2; else goto c2vuR;
       c2vuR: // global
           I64[Hp - 80] = sat_s2uIZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vuP::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vuP::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vv4: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2vuY; else goto c2vv3;
       c2vuY: // global
           I64[Hp - 80] = sat_s2uJl_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uJ5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vv3: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2vv2; else goto c2vv1;
       c2vv2: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vv1: // global
           I64[Hp - 80] = sat_s2uJq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vuZ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vuZ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.993864673 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vvc,
                       label: GHC.Word.$fEnumWord8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vvc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vvl; else goto c2vvm;
       c2vvl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vvm: // global
           I64[Sp - 24] = block_c2vv9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vvv; else goto c2vva;
       u2vvv: // global
           call _c2vv9(R1) args: 0, res: 0, upd: 0;
       c2vva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vv9() //  [R1]
         { info_tbl: [(c2vv9,
                       label: block_c2vv9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vv9: // global
           I64[Sp] = block_c2vvf_info;
           _s2uJv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJv::I64;
           if (R1 & 7 != 0) goto u2vvu; else goto c2vvg;
       u2vvu: // global
           call _c2vvf(R1) args: 0, res: 0, upd: 0;
       c2vvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vvf() //  [R1]
         { info_tbl: [(c2vvf,
                       label: block_c2vvf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vvf: // global
           I64[Sp] = block_c2vvk_info;
           _s2uJx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uJx::I64;
           if (R1 & 7 != 0) goto u2vvw; else goto c2vvp;
       u2vvw: // global
           call _c2vvk(R1) args: 0, res: 0, upd: 0;
       c2vvp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vvk() //  [R1]
         { info_tbl: [(c2vvk,
                       label: block_c2vvk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vvk: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.996467772 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2uJN_entry() //  [R1]
         { info_tbl: [(c2vvY,
                       label: sat_s2uJN_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vvY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vvZ; else goto c2vw0;
       c2vvZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vw0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJG::I64 = I64[R1 + 32];
           if (_s2uJG::I64 == I64[R1 + 24]) goto c2vvX; else goto c2vvW;
       c2vvX: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2vvW: // global
           R2 = _s2uJG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uJF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJK_entry() //  [R1]
         { info_tbl: [(c2vwc,
                       label: sat_s2uJK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwc: // global
           _s2uJK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vwd; else goto c2vwe;
       c2vwe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vwg; else goto c2vwf;
       c2vwg: // global
           HpAlloc = 16;
           goto c2vwd;
       c2vwd: // global
           R1 = _s2uJK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vwf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJK::P64;
           _s2uJG::I64 = I64[_s2uJK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJG::I64, 0)) goto c2vwm; else goto c2vwb;
       c2vwb: // global
           if (%MO_S_Gt_W64(_s2uJG::I64, 255)) goto c2vwm; else goto c2vwt;
       c2vwm: // global
           Hp = Hp - 16;
           R2 = _s2uJG::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vwt: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uJF_entry() //  [R1, R2]
         { info_tbl: [(c2vwv,
                       label: go_s2uJF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vwz; else goto c2vwy;
       c2vwz: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vwy: // global
           _s2uJD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c2vwA,
                       label: GHC.Word.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vwE; else goto c2vwD;
       c2vwE: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vwD: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2vwG; else goto c2vwH;
       c2vwG: // global
           I64[Hp - 8] = go_s2uJF_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uJF_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2vwH: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:09.999101632 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2vwP,
                       label: GHC.Word.$fEnumWord8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vwT; else goto c2vwU;
       c2vwT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vwU: // global
           I64[Sp - 16] = block_c2vwM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vx2; else goto c2vwN;
       u2vx2: // global
           call _c2vwM(R1) args: 0, res: 0, upd: 0;
       c2vwN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vwM() //  [R1]
         { info_tbl: [(c2vwM,
                       label: block_c2vwM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwM: // global
           I64[Sp] = block_c2vwS_info;
           _s2uJR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJR::I64;
           if (R1 & 7 != 0) goto u2vx1; else goto c2vwW;
       u2vx1: // global
           call _c2vwS(R1) args: 0, res: 0, upd: 0;
       c2vwW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vwS() //  [R1]
         { info_tbl: [(c2vwS,
                       label: block_c2vwS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vwS: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.001147117 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2uK4_entry() //  [R1]
         { info_tbl: [(c2vxf,
                       label: sat_s2uK4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vxf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vxg; else goto c2vxr;
       c2vxg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vxr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJZ::I64 = I64[R1 + 16];
           if (_s2uJZ::I64 != 255) goto c2vxd; else goto c2vxe;
       c2vxd: // global
           I64[Sp - 24] = block_c2vxl_info;
           R2 = _s2uJZ::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2vxe: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2vxl() //  [R1, R2]
         { info_tbl: [(c2vxl,
                       label: block_c2vxl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vxl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vxq; else goto c2vxp;
       c2vxq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2vxp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJY_entry() //  [R1]
         { info_tbl: [(c2vxB,
                       label: sat_s2uJY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vxB: // global
           _s2uJY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vxC; else goto c2vxD;
       c2vxD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vxF; else goto c2vxE;
       c2vxF: // global
           HpAlloc = 16;
           goto c2vxC;
       c2vxC: // global
           R1 = _s2uJY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJY::P64;
           _s2uJU::I64 = I64[_s2uJY::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJU::I64, 0)) goto c2vxL; else goto c2vxA;
       c2vxA: // global
           if (%MO_S_Gt_W64(_s2uJU::I64, 255)) goto c2vxL; else goto c2vxS;
       c2vxL: // global
           Hp = Hp - 16;
           R2 = _s2uJU::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2vxS: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJU::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { info_tbl: [(c2vxT,
                       label: GHC.Word.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vxT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2vxX; else goto c2vxW;
       c2vxX: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vxW: // global
           I64[Hp - 40] = sat_s2uK4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uJY_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.003420149 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { info_tbl: [(c2vy5,
                       label: GHC.Word.$fEnumWord8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vy5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vy6; else goto c2vy7;
       c2vy6: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vy7: // global
           I64[Sp - 8] = block_c2vy2_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vy2() //  [R1, R2]
         { info_tbl: [(c2vy2,
                       label: block_c2vy2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vy2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vya; else goto c2vy9;
       c2vya: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vy9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.005895148 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2vyi,
                       label: GHC.Word.$fEnumWord8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vyj; else goto c2vyk;
       c2vyj: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vyk: // global
           I64[Sp - 8] = block_c2vyf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vyw; else goto c2vyg;
       u2vyw: // global
           call _c2vyf(R1) args: 0, res: 0, upd: 0;
       c2vyg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vyf() //  [R1]
         { info_tbl: [(c2vyf,
                       label: block_c2vyf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyf: // global
           _s2uKc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uKc::I64, 255)) goto c2vyu; else goto c2vyv;
       c2vyu: // global
           R2 = _s2uKc::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2vyv: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.007322717 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2vyB,
                       label: GHC.Word.$fEnumWord8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyB: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.008263436 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.009063248 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { info_tbl: [(c2vyM,
                       label: GHC.Word.$fEnumWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vyN; else goto c2vyO;
       c2vyN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vyO: // global
           (_c2vyH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vyH::I64 == 0) goto c2vyJ; else goto c2vyI;
       c2vyJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vyI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vyH::I64;
           I64[Sp - 24] = block_c2vyK_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vyK() //  [R1]
         { info_tbl: [(c2vyK,
                       label: block_c2vyK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.010404832 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { info_tbl: [(c2vz0,
                       label: GHC.Word.$fEnumWord2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vz0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vz1; else goto c2vz2;
       c2vz1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vz2: // global
           (_c2vyV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vyV::I64 == 0) goto c2vyX; else goto c2vyW;
       c2vyX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vyW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vyV::I64;
           I64[Sp - 24] = block_c2vyY_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vyY() //  [R1]
         { info_tbl: [(c2vyY,
                       label: block_c2vyY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vyY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.011775914 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { info_tbl: [(c2vzd,
                       label: GHC.Word.neWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vzd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vzh; else goto c2vzi;
       c2vzh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vzi: // global
           I64[Sp - 16] = block_c2vza_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vzr; else goto c2vzb;
       u2vzr: // global
           call _c2vza(R1) args: 0, res: 0, upd: 0;
       c2vzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vza() //  [R1]
         { info_tbl: [(c2vza,
                       label: block_c2vza_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vza: // global
           I64[Sp] = block_c2vzg_info;
           _s2uKj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKj::I64;
           if (R1 & 7 != 0) goto u2vzq; else goto c2vzk;
       u2vzq: // global
           call _c2vzg(R1) args: 0, res: 0, upd: 0;
       c2vzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vzg() //  [R1]
         { info_tbl: [(c2vzg,
                       label: block_c2vzg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vzg: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.013174462 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { info_tbl: [(c2vzy,
                       label: lvl4_r2uFJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vzz; else goto c2vzA;
       c2vzz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vzA: // global
           (_c2vzv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vzv::I64 == 0) goto c2vzx; else goto c2vzw;
       c2vzx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vzw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vzv::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.014125688 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.015073028 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { info_tbl: [(c2vzI,
                       label: GHC.Word.$fEnumWord16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vzI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vzJ; else goto c2vzK;
       c2vzJ: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vzK: // global
           I64[Sp - 8] = block_c2vzF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vA2; else goto c2vzG;
       u2vA2: // global
           call _c2vzF(R1) args: 0, res: 0, upd: 0;
       c2vzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vzF() //  [R1]
         { info_tbl: [(c2vzF,
                       label: block_c2vzF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vzF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vzP; else goto c2vzO;
       c2vzP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vzO: // global
           _s2uKq::I64 = I64[R1 + 7];
           if (_s2uKq::I64 != 0) goto c2vA0; else goto c2vA1;
       c2vA0: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vA1: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.016326317 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.016874714 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.017885476 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { info_tbl: [(c2vAa,
                       label: GHC.Word.$fEnumWord16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vAa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vAb; else goto c2vAc;
       c2vAb: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vAc: // global
           I64[Sp - 8] = block_c2vA7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vAu; else goto c2vA8;
       u2vAu: // global
           call _c2vA7(R1) args: 0, res: 0, upd: 0;
       c2vA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vA7() //  [R1]
         { info_tbl: [(c2vA7,
                       label: block_c2vA7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vA7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vAh; else goto c2vAg;
       c2vAh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vAg: // global
           _s2uKw::I64 = I64[R1 + 7];
           if (_s2uKw::I64 != 65535) goto c2vAs; else goto c2vAt;
       c2vAs: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vAt: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.019612341 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vAC,
                       label: GHC.Word.$fShowWord16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vAC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vAQ; else goto c2vAR;
       c2vAQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vAR: // global
           I64[Sp - 24] = block_c2vAz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vAY; else goto c2vAA;
       u2vAY: // global
           call _c2vAz(R1) args: 0, res: 0, upd: 0;
       c2vAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vAz() //  [R1]
         { info_tbl: [(c2vAz,
                       label: block_c2vAz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vAz: // global
           I64[Sp] = block_c2vAF_info;
           _s2uKD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKD::I64;
           if (R1 & 7 != 0) goto u2vAX; else goto c2vAG;
       u2vAX: // global
           call _c2vAF(R1) args: 0, res: 0, upd: 0;
       c2vAG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vAF() //  [R1]
         { info_tbl: [(c2vAF,
                       label: block_c2vAF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vAF: // global
           _s2uKB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2vAN_info;
           R4 = _s2uKB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vAN() //  [R1, R2]
         { info_tbl: [(c2vAN,
                       label: block_c2vAN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vAN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vAW; else goto c2vAV;
       c2vAW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vAV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.022184666 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { info_tbl: [(c2vB6,
                       label: GHC.Word.$fShowWord16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vB6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vBf; else goto c2vBg;
       c2vBf: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vBg: // global
           I64[Sp - 8] = block_c2vB3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vBl; else goto c2vB4;
       u2vBl: // global
           call _c2vB3(R1) args: 0, res: 0, upd: 0;
       c2vB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vB3() //  [R1]
         { info_tbl: [(c2vB3,
                       label: block_c2vB3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vB3: // global
           I64[Sp] = block_c2vBc_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vBc() //  [R1, R2]
         { info_tbl: [(c2vBc,
                       label: block_c2vBc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vBk; else goto c2vBj;
       c2vBk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vBj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.023983942 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { info_tbl: [(c2vBt,
                       label: GHC.Word.$fShowWord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vBC; else goto c2vBD;
       c2vBC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vBD: // global
           I64[Sp - 16] = block_c2vBq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vBI; else goto c2vBr;
       u2vBI: // global
           call _c2vBq(R1) args: 0, res: 0, upd: 0;
       c2vBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vBq() //  [R1]
         { info_tbl: [(c2vBq,
                       label: block_c2vBq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBq: // global
           _s2uKS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2vBz_info;
           R4 = _s2uKS::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vBz() //  [R1, R2]
         { info_tbl: [(c2vBz,
                       label: block_c2vBz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vBH; else goto c2vBG;
       c2vBH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vBG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.0270128 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2vBN,
                       label: GHC.Word.$fShowWord16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.027954404 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.028826314 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { info_tbl: [(c2vBU,
                       label: GHC.Word.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vBU: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.029965293 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2vC6,
                       label: GHC.Word.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vC6: // global
           _s2uL2::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2vCe; else goto c2vC5;
       c2vC5: // global
           if (%MO_S_Gt_W64(_s2uL2::I64, 65535)) goto c2vCe; else goto c2vCi;
       c2vCe: // global
           R2 = _s2uL2::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2vCi: // global
           R1 = _s2uL2::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.031158704 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2vCq,
                       label: GHC.Word.$fEnumWord16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vCq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vCy; else goto c2vCz;
       c2vCy: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vCz: // global
           I64[Sp - 8] = block_c2vCn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vCE; else goto c2vCo;
       u2vCE: // global
           call _c2vCn(R1) args: 0, res: 0, upd: 0;
       c2vCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vCn() //  [R1]
         { info_tbl: [(c2vCn,
                       label: block_c2vCn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vCn: // global
           I64[Sp] = block_c2vCt_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vCt() //  [R1]
         { info_tbl: [(c2vCt,
                       label: block_c2vCt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vCt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vCD; else goto c2vCC;
       c2vCD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2vCC: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.036210898 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2uLx_entry() //  [R1]
         { info_tbl: [(c2vDm,
                       label: sat_s2uLx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vDm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vDn; else goto c2vDo;
       c2vDn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vDo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLv_entry() //  [R1]
         { info_tbl: [(c2vDy,
                       label: sat_s2uLv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vDy: // global
           _s2uLv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vDz; else goto c2vDA;
       c2vDA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vDC; else goto c2vDB;
       c2vDC: // global
           HpAlloc = 16;
           goto c2vDz;
       c2vDz: // global
           R1 = _s2uLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vDB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLv::P64;
           _s2uLq::I64 = I64[_s2uLv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2vDI; else goto c2vDx;
       c2vDx: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2vDI; else goto c2vDP;
       c2vDI: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vDP: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLB_entry() //  [R1]
         { info_tbl: [(c2vE0,
                       label: sat_s2uLB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vE0: // global
           _s2uLB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vE1; else goto c2vE2;
       c2vE2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vE4; else goto c2vE3;
       c2vE4: // global
           HpAlloc = 16;
           goto c2vE1;
       c2vE1: // global
           R1 = _s2uLB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vE3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLB::P64;
           _s2uLq::I64 = I64[_s2uLB::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2vEa; else goto c2vDZ;
       c2vDZ: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2vEa; else goto c2vEh;
       c2vEa: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vEh: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uLp_entry() //  [R1, R2]
         { info_tbl: [(c2vEl,
                       label: go_dn_s2uLp_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vEl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vEp; else goto c2vEo;
       c2vEp: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vEo: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2vEj; else goto c2vEk;
       c2vEj: // global
           _s2uLn::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLx_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLn::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vEk: // global
           I64[Hp - 80] = sat_s2uLB_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vEr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vEr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uLC_entry() //  [R1]
         { info_tbl: [(c2vEs,
                       label: sat_s2uLC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vEs: // global
           _s2uLC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vEt; else goto c2vEu;
       c2vEu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vEw; else goto c2vEv;
       c2vEw: // global
           HpAlloc = 24;
           goto c2vEt;
       c2vEt: // global
           R1 = _s2uLC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vEv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLC::P64;
           _s2uLf::I64 = I64[_s2uLC::P64 + 24];
           _s2uLn::I64 = _s2uLf::I64 - I64[_s2uLC::P64 + 16];
           _s2uLo::I64 = I64[_s2uLC::P64 + 32] - _s2uLn::I64;
           I64[Hp - 16] = go_dn_s2uLp_info;
           I64[Hp - 8] = _s2uLn::I64;
           I64[Hp] = _s2uLo::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLm_entry() //  [R1]
         { info_tbl: [(c2vEG,
                       label: sat_s2uLm_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vEG: // global
           _s2uLm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vEH; else goto c2vEI;
       c2vEI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vEK; else goto c2vEJ;
       c2vEK: // global
           HpAlloc = 16;
           goto c2vEH;
       c2vEH: // global
           R1 = _s2uLm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vEJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLm::P64;
           _s2uLe::I64 = I64[_s2uLm::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2vEQ; else goto c2vEF;
       c2vEF: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2vEQ; else goto c2vEX;
       c2vEQ: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vEX: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLH_entry() //  [R1]
         { info_tbl: [(c2vFb,
                       label: sat_s2uLH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vFb: // global
           _s2uLH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vFc; else goto c2vFd;
       c2vFd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vFf; else goto c2vFe;
       c2vFf: // global
           HpAlloc = 16;
           goto c2vFc;
       c2vFc: // global
           R1 = _s2uLH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vFe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLH::P64;
           _s2uLe::I64 = I64[_s2uLH::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2vFl; else goto c2vFa;
       c2vFa: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2vFl; else goto c2vFs;
       c2vFl: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vFs: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLY_entry() //  [R1]
         { info_tbl: [(c2vFY,
                       label: sat_s2uLY_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vFY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vFZ; else goto c2vG0;
       c2vFZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vG0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLW_entry() //  [R1]
         { info_tbl: [(c2vGa,
                       label: sat_s2uLW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vGa: // global
           _s2uLW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vGb; else goto c2vGc;
       c2vGc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vGe; else goto c2vGd;
       c2vGe: // global
           HpAlloc = 16;
           goto c2vGb;
       c2vGb: // global
           R1 = _s2uLW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vGd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLW::P64;
           _s2uLR::I64 = I64[_s2uLW::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2vGk; else goto c2vG9;
       c2vG9: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2vGk; else goto c2vGr;
       c2vGk: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vGr: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM2_entry() //  [R1]
         { info_tbl: [(c2vGC,
                       label: sat_s2uM2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vGC: // global
           _s2uM2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vGD; else goto c2vGE;
       c2vGE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vGG; else goto c2vGF;
       c2vGG: // global
           HpAlloc = 16;
           goto c2vGD;
       c2vGD: // global
           R1 = _s2uM2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM2::P64;
           _s2uLR::I64 = I64[_s2uM2::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2vGM; else goto c2vGB;
       c2vGB: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2vGM; else goto c2vGT;
       c2vGM: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vGT: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uLQ_entry() //  [R1, R2]
         { info_tbl: [(c2vGX,
                       label: go_up_s2uLQ_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vGX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vH1; else goto c2vH0;
       c2vH1: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vH0: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2vGV; else goto c2vGW;
       c2vGV: // global
           _s2uLO::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLY_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLO::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vGW: // global
           I64[Hp - 80] = sat_s2uM2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vH3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vH3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uM3_entry() //  [R1]
         { info_tbl: [(c2vH4,
                       label: sat_s2uM3_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vH4: // global
           _s2uM3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vH5; else goto c2vH6;
       c2vH6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vH8; else goto c2vH7;
       c2vH8: // global
           HpAlloc = 24;
           goto c2vH5;
       c2vH5: // global
           R1 = _s2uM3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vH7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM3::P64;
           _s2uLf::I64 = I64[_s2uM3::P64 + 24];
           _s2uLO::I64 = _s2uLf::I64 - I64[_s2uM3::P64 + 16];
           _s2uLP::I64 = I64[_s2uM3::P64 + 32] - _s2uLO::I64;
           I64[Hp - 16] = go_up_s2uLQ_info;
           I64[Hp - 8] = _s2uLO::I64;
           I64[Hp] = _s2uLP::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLN_entry() //  [R1]
         { info_tbl: [(c2vHi,
                       label: sat_s2uLN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vHi: // global
           _s2uLN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vHj; else goto c2vHk;
       c2vHk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vHm; else goto c2vHl;
       c2vHm: // global
           HpAlloc = 16;
           goto c2vHj;
       c2vHj: // global
           R1 = _s2uLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vHl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLN::P64;
           _s2uLe::I64 = I64[_s2uLN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2vHs; else goto c2vHh;
       c2vHh: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2vHs; else goto c2vHz;
       c2vHs: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vHz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM8_entry() //  [R1]
         { info_tbl: [(c2vHN,
                       label: sat_s2uM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vHN: // global
           _s2uM8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vHO; else goto c2vHP;
       c2vHP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vHR; else goto c2vHQ;
       c2vHR: // global
           HpAlloc = 16;
           goto c2vHO;
       c2vHO: // global
           R1 = _s2uM8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vHQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM8::P64;
           _s2uLe::I64 = I64[_s2uM8::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2vHX; else goto c2vHM;
       c2vHM: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2vHX; else goto c2vI4;
       c2vHX: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vI4: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vI5,
                       label: GHC.Word.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vI5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vI9; else goto c2vI8;
       c2vI9: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vI8: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2vIj; else goto c2vIs;
       c2vIj: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2vIc; else goto c2vIh;
       c2vIc: // global
           I64[Hp - 80] = sat_s2uLC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vIh: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2vIq; else goto c2vIf;
       c2vIf: // global
           I64[Hp - 80] = sat_s2uLH_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vId::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vId::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vIs: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2vIm; else goto c2vIr;
       c2vIm: // global
           I64[Hp - 80] = sat_s2uM3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vIr: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2vIq; else goto c2vIp;
       c2vIq: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vIp: // global
           I64[Hp - 80] = sat_s2uM8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vIn::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vIn::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.044419607 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vIA,
                       label: GHC.Word.$fEnumWord16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vIA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vIJ; else goto c2vIK;
       c2vIJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vIK: // global
           I64[Sp - 24] = block_c2vIx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vIT; else goto c2vIy;
       u2vIT: // global
           call _c2vIx(R1) args: 0, res: 0, upd: 0;
       c2vIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vIx() //  [R1]
         { info_tbl: [(c2vIx,
                       label: block_c2vIx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vIx: // global
           I64[Sp] = block_c2vID_info;
           _s2uMd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMd::I64;
           if (R1 & 7 != 0) goto u2vIS; else goto c2vIE;
       u2vIS: // global
           call _c2vID(R1) args: 0, res: 0, upd: 0;
       c2vIE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vID() //  [R1]
         { info_tbl: [(c2vID,
                       label: block_c2vID_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vID: // global
           I64[Sp] = block_c2vII_info;
           _s2uMf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uMf::I64;
           if (R1 & 7 != 0) goto u2vIU; else goto c2vIN;
       u2vIU: // global
           call _c2vII(R1) args: 0, res: 0, upd: 0;
       c2vIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vII() //  [R1]
         { info_tbl: [(c2vII,
                       label: block_c2vII_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vII: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.047041659 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2uMv_entry() //  [R1]
         { info_tbl: [(c2vJm,
                       label: sat_s2uMv_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vJm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vJn; else goto c2vJo;
       c2vJn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vJo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMo::I64 = I64[R1 + 32];
           if (_s2uMo::I64 == I64[R1 + 24]) goto c2vJl; else goto c2vJk;
       c2vJl: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2vJk: // global
           R2 = _s2uMo::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uMn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMs_entry() //  [R1]
         { info_tbl: [(c2vJA,
                       label: sat_s2uMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vJA: // global
           _s2uMs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vJB; else goto c2vJC;
       c2vJC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vJE; else goto c2vJD;
       c2vJE: // global
           HpAlloc = 16;
           goto c2vJB;
       c2vJB: // global
           R1 = _s2uMs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMs::P64;
           _s2uMo::I64 = I64[_s2uMs::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMo::I64, 0)) goto c2vJK; else goto c2vJz;
       c2vJz: // global
           if (%MO_S_Gt_W64(_s2uMo::I64, 65535)) goto c2vJK; else goto c2vJR;
       c2vJK: // global
           Hp = Hp - 16;
           R2 = _s2uMo::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vJR: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMo::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uMn_entry() //  [R1, R2]
         { info_tbl: [(c2vJT,
                       label: go_s2uMn_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vJT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vJX; else goto c2vJW;
       c2vJX: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vJW: // global
           _s2uMl::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uMv_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uMl::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uMs_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2vJY,
                       label: GHC.Word.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vJY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vK2; else goto c2vK1;
       c2vK2: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vK1: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2vK4; else goto c2vK5;
       c2vK4: // global
           I64[Hp - 8] = go_s2uMn_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uMn_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2vK5: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.050400598 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2vKd,
                       label: GHC.Word.$fEnumWord16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vKh; else goto c2vKi;
       c2vKh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vKi: // global
           I64[Sp - 16] = block_c2vKa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vKq; else goto c2vKb;
       u2vKq: // global
           call _c2vKa(R1) args: 0, res: 0, upd: 0;
       c2vKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vKa() //  [R1]
         { info_tbl: [(c2vKa,
                       label: block_c2vKa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKa: // global
           I64[Sp] = block_c2vKg_info;
           _s2uMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMz::I64;
           if (R1 & 7 != 0) goto u2vKp; else goto c2vKk;
       u2vKp: // global
           call _c2vKg(R1) args: 0, res: 0, upd: 0;
       c2vKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vKg() //  [R1]
         { info_tbl: [(c2vKg,
                       label: block_c2vKg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKg: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.052428068 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2uMM_entry() //  [R1]
         { info_tbl: [(c2vKD,
                       label: sat_s2uMM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vKE; else goto c2vKP;
       c2vKE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vKP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMH::I64 = I64[R1 + 16];
           if (_s2uMH::I64 != 65535) goto c2vKB; else goto c2vKC;
       c2vKB: // global
           I64[Sp - 24] = block_c2vKJ_info;
           R2 = _s2uMH::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2vKC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2vKJ() //  [R1, R2]
         { info_tbl: [(c2vKJ,
                       label: block_c2vKJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vKO; else goto c2vKN;
       c2vKO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2vKN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMG_entry() //  [R1]
         { info_tbl: [(c2vKZ,
                       label: sat_s2uMG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vKZ: // global
           _s2uMG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vL0; else goto c2vL1;
       c2vL1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vL3; else goto c2vL2;
       c2vL3: // global
           HpAlloc = 16;
           goto c2vL0;
       c2vL0: // global
           R1 = _s2uMG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vL2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMG::P64;
           _s2uMC::I64 = I64[_s2uMG::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMC::I64, 0)) goto c2vL9; else goto c2vKY;
       c2vKY: // global
           if (%MO_S_Gt_W64(_s2uMC::I64, 65535)) goto c2vL9; else goto c2vLg;
       c2vL9: // global
           Hp = Hp - 16;
           R2 = _s2uMC::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2vLg: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo_entry() //  [R2]
         { info_tbl: [(c2vLh,
                       label: GHC.Word.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2vLl; else goto c2vLk;
       c2vLl: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vLk: // global
           I64[Hp - 40] = sat_s2uMM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uMG_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.054640377 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { info_tbl: [(c2vLt,
                       label: GHC.Word.$fEnumWord16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vLu; else goto c2vLv;
       c2vLu: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vLv: // global
           I64[Sp - 8] = block_c2vLq_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vLq() //  [R1, R2]
         { info_tbl: [(c2vLq,
                       label: block_c2vLq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vLy; else goto c2vLx;
       c2vLy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vLx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.055949798 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2vLG,
                       label: GHC.Word.$fEnumWord16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vLH; else goto c2vLI;
       c2vLH: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vLI: // global
           I64[Sp - 8] = block_c2vLD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vLU; else goto c2vLE;
       u2vLU: // global
           call _c2vLD(R1) args: 0, res: 0, upd: 0;
       c2vLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vLD() //  [R1]
         { info_tbl: [(c2vLD,
                       label: block_c2vLD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLD: // global
           _s2uMU::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uMU::I64, 65535)) goto c2vLS; else goto c2vLT;
       c2vLS: // global
           R2 = _s2uMU::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2vLT: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.057188532 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2vLZ,
                       label: GHC.Word.$fEnumWord16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vLZ: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.058210568 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.058968515 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { info_tbl: [(c2vMa,
                       label: GHC.Word.$fEnumWord3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vMb; else goto c2vMc;
       c2vMb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vMc: // global
           (_c2vM5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vM5::I64 == 0) goto c2vM7; else goto c2vM6;
       c2vM7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vM6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vM5::I64;
           I64[Sp - 24] = block_c2vM8_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vM8() //  [R1]
         { info_tbl: [(c2vM8,
                       label: block_c2vM8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vM8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.060196972 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { info_tbl: [(c2vMo,
                       label: GHC.Word.$fEnumWord4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vMp; else goto c2vMq;
       c2vMp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vMq: // global
           (_c2vMj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vMj::I64 == 0) goto c2vMl; else goto c2vMk;
       c2vMl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vMk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vMj::I64;
           I64[Sp - 24] = block_c2vMm_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2vMm() //  [R1]
         { info_tbl: [(c2vMm,
                       label: block_c2vMm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.061669166 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { info_tbl: [(c2vMB,
                       label: GHC.Word.neWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vMF; else goto c2vMG;
       c2vMF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vMG: // global
           I64[Sp - 16] = block_c2vMy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vMP; else goto c2vMz;
       u2vMP: // global
           call _c2vMy(R1) args: 0, res: 0, upd: 0;
       c2vMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vMy() //  [R1]
         { info_tbl: [(c2vMy,
                       label: block_c2vMy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMy: // global
           I64[Sp] = block_c2vME_info;
           _s2uN1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uN1::I64;
           if (R1 & 7 != 0) goto u2vMO; else goto c2vMI;
       u2vMO: // global
           call _c2vME(R1) args: 0, res: 0, upd: 0;
       c2vMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vME() //  [R1]
         { info_tbl: [(c2vME,
                       label: block_c2vME_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vME: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.063140675 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { info_tbl: [(c2vMW,
                       label: lvl6_r2uFL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vMX; else goto c2vMY;
       c2vMX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vMY: // global
           (_c2vMT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2vMT::I64 == 0) goto c2vMV; else goto c2vMU;
       c2vMV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2vMU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2vMT::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.064025526 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.06504094 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { info_tbl: [(c2vN6,
                       label: GHC.Word.$fEnumWord32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vN6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vN7; else goto c2vN8;
       c2vN7: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vN8: // global
           I64[Sp - 8] = block_c2vN3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vNq; else goto c2vN4;
       u2vNq: // global
           call _c2vN3(R1) args: 0, res: 0, upd: 0;
       c2vN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vN3() //  [R1]
         { info_tbl: [(c2vN3,
                       label: block_c2vN3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vN3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vNd; else goto c2vNc;
       c2vNd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vNc: // global
           _s2uN8::I64 = I64[R1 + 7];
           if (_s2uN8::I64 != 0) goto c2vNo; else goto c2vNp;
       c2vNo: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uN8::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vNp: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.066379106 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.066990677 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.068806812 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { info_tbl: [(c2vNy,
                       label: GHC.Word.$fEnumWord32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vNy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vNz; else goto c2vNA;
       c2vNz: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vNA: // global
           I64[Sp - 8] = block_c2vNv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vNS; else goto c2vNw;
       u2vNS: // global
           call _c2vNv(R1) args: 0, res: 0, upd: 0;
       c2vNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vNv() //  [R1]
         { info_tbl: [(c2vNv,
                       label: block_c2vNv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vNv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vNF; else goto c2vNE;
       c2vNF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2vNE: // global
           _s2uNe::I64 = I64[R1 + 7];
           if (_s2uNe::I64 != 4294967295) goto c2vNQ; else goto c2vNR;
       c2vNQ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uNe::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vNR: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.07050458 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vO0,
                       label: GHC.Word.$fShowWord32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vO0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vOe; else goto c2vOf;
       c2vOe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vOf: // global
           I64[Sp - 24] = block_c2vNX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vOm; else goto c2vNY;
       u2vOm: // global
           call _c2vNX(R1) args: 0, res: 0, upd: 0;
       c2vNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vNX() //  [R1]
         { info_tbl: [(c2vNX,
                       label: block_c2vNX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vNX: // global
           I64[Sp] = block_c2vO3_info;
           _s2uNl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uNl::I64;
           if (R1 & 7 != 0) goto u2vOl; else goto c2vO4;
       u2vOl: // global
           call _c2vO3(R1) args: 0, res: 0, upd: 0;
       c2vO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vO3() //  [R1]
         { info_tbl: [(c2vO3,
                       label: block_c2vO3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vO3: // global
           _s2uNj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2vOb_info;
           R4 = _s2uNj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vOb() //  [R1, R2]
         { info_tbl: [(c2vOb,
                       label: block_c2vOb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vOk; else goto c2vOj;
       c2vOk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vOj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.072387071 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { info_tbl: [(c2vOu,
                       label: GHC.Word.$fShowWord32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vOD; else goto c2vOE;
       c2vOD: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vOE: // global
           I64[Sp - 8] = block_c2vOr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vOJ; else goto c2vOs;
       u2vOJ: // global
           call _c2vOr(R1) args: 0, res: 0, upd: 0;
       c2vOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vOr() //  [R1]
         { info_tbl: [(c2vOr,
                       label: block_c2vOr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOr: // global
           I64[Sp] = block_c2vOA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vOA() //  [R1, R2]
         { info_tbl: [(c2vOA,
                       label: block_c2vOA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vOI; else goto c2vOH;
       c2vOI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vOH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.074137587 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { info_tbl: [(c2vOR,
                       label: GHC.Word.$fShowWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vP0; else goto c2vP1;
       c2vP0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vP1: // global
           I64[Sp - 16] = block_c2vOO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vP6; else goto c2vOP;
       u2vP6: // global
           call _c2vOO(R1) args: 0, res: 0, upd: 0;
       c2vOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vOO() //  [R1]
         { info_tbl: [(c2vOO,
                       label: block_c2vOO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOO: // global
           _s2uNA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2vOX_info;
           R4 = _s2uNA::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vOX() //  [R1, R2]
         { info_tbl: [(c2vOX,
                       label: block_c2vOX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vOX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vP5; else goto c2vP4;
       c2vP5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vP4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.075537173 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2vPb,
                       label: GHC.Word.$fShowWord32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPb: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.076257662 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.076982362 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { info_tbl: [(c2vPi,
                       label: GHC.Word.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPi: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.078092954 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c2vPu,
                       label: GHC.Word.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPu: // global
           _s2uNK::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2vPC; else goto c2vPt;
       c2vPt: // global
           if (%MO_S_Gt_W64(_s2uNK::I64,
                            4294967295)) goto c2vPC; else goto c2vPG;
       c2vPC: // global
           R2 = _s2uNK::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2vPG: // global
           R1 = _s2uNK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.079225259 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2vPO,
                       label: GHC.Word.$fEnumWord32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vPW; else goto c2vPX;
       c2vPW: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vPX: // global
           I64[Sp - 8] = block_c2vPL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vQ2; else goto c2vPM;
       u2vQ2: // global
           call _c2vPL(R1) args: 0, res: 0, upd: 0;
       c2vPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vPL() //  [R1]
         { info_tbl: [(c2vPL,
                       label: block_c2vPL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPL: // global
           I64[Sp] = block_c2vPR_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vPR() //  [R1]
         { info_tbl: [(c2vPR,
                       label: block_c2vPR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vPR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vQ1; else goto c2vQ0;
       c2vQ1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2vQ0: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.084361687 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2uOf_entry() //  [R1]
         { info_tbl: [(c2vQK,
                       label: sat_s2uOf_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vQL; else goto c2vQM;
       c2vQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vQM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOd_entry() //  [R1]
         { info_tbl: [(c2vQW,
                       label: sat_s2uOd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vQW: // global
           _s2uOd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vQX; else goto c2vQY;
       c2vQY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vR0; else goto c2vQZ;
       c2vR0: // global
           HpAlloc = 16;
           goto c2vQX;
       c2vQX: // global
           R1 = _s2uOd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vQZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOd::P64;
           _s2uO8::I64 = I64[_s2uOd::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2vR6; else goto c2vQV;
       c2vQV: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2vR6; else goto c2vRd;
       c2vR6: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vRd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOj_entry() //  [R1]
         { info_tbl: [(c2vRo,
                       label: sat_s2uOj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vRo: // global
           _s2uOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vRp; else goto c2vRq;
       c2vRq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vRs; else goto c2vRr;
       c2vRs: // global
           HpAlloc = 16;
           goto c2vRp;
       c2vRp: // global
           R1 = _s2uOj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOj::P64;
           _s2uO8::I64 = I64[_s2uOj::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2vRy; else goto c2vRn;
       c2vRn: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2vRy; else goto c2vRF;
       c2vRy: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vRF: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uO7_entry() //  [R1, R2]
         { info_tbl: [(c2vRJ,
                       label: go_dn_s2uO7_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vRJ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vRN; else goto c2vRM;
       c2vRN: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vRM: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2vRH; else goto c2vRI;
       c2vRH: // global
           _s2uO5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOf_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uO5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vRI: // global
           I64[Hp - 80] = sat_s2uOj_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vRP::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vRP::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOk_entry() //  [R1]
         { info_tbl: [(c2vRQ,
                       label: sat_s2uOk_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vRQ: // global
           _s2uOk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vRR; else goto c2vRS;
       c2vRS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vRU; else goto c2vRT;
       c2vRU: // global
           HpAlloc = 24;
           goto c2vRR;
       c2vRR: // global
           R1 = _s2uOk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vRT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOk::P64;
           _s2uNX::I64 = I64[_s2uOk::P64 + 24];
           _s2uO5::I64 = _s2uNX::I64 - I64[_s2uOk::P64 + 16];
           _s2uO6::I64 = I64[_s2uOk::P64 + 32] - _s2uO5::I64;
           I64[Hp - 16] = go_dn_s2uO7_info;
           I64[Hp - 8] = _s2uO5::I64;
           I64[Hp] = _s2uO6::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uO4_entry() //  [R1]
         { info_tbl: [(c2vS4,
                       label: sat_s2uO4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vS4: // global
           _s2uO4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vS5; else goto c2vS6;
       c2vS6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vS8; else goto c2vS7;
       c2vS8: // global
           HpAlloc = 16;
           goto c2vS5;
       c2vS5: // global
           R1 = _s2uO4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vS7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uO4::P64;
           _s2uNW::I64 = I64[_s2uO4::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2vSe; else goto c2vS3;
       c2vS3: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2vSe; else goto c2vSl;
       c2vSe: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vSl: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOp_entry() //  [R1]
         { info_tbl: [(c2vSz,
                       label: sat_s2uOp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vSz: // global
           _s2uOp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vSA; else goto c2vSB;
       c2vSB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vSD; else goto c2vSC;
       c2vSD: // global
           HpAlloc = 16;
           goto c2vSA;
       c2vSA: // global
           R1 = _s2uOp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vSC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOp::P64;
           _s2uNW::I64 = I64[_s2uOp::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2vSJ; else goto c2vSy;
       c2vSy: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2vSJ; else goto c2vSQ;
       c2vSJ: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vSQ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOG_entry() //  [R1]
         { info_tbl: [(c2vTm,
                       label: sat_s2uOG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vTm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vTn; else goto c2vTo;
       c2vTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vTo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOE_entry() //  [R1]
         { info_tbl: [(c2vTy,
                       label: sat_s2uOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vTy: // global
           _s2uOE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vTz; else goto c2vTA;
       c2vTA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vTC; else goto c2vTB;
       c2vTC: // global
           HpAlloc = 16;
           goto c2vTz;
       c2vTz: // global
           R1 = _s2uOE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vTB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOE::P64;
           _s2uOz::I64 = I64[_s2uOE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2vTI; else goto c2vTx;
       c2vTx: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2vTI; else goto c2vTP;
       c2vTI: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vTP: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOK_entry() //  [R1]
         { info_tbl: [(c2vU0,
                       label: sat_s2uOK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vU0: // global
           _s2uOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vU1; else goto c2vU2;
       c2vU2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vU4; else goto c2vU3;
       c2vU4: // global
           HpAlloc = 16;
           goto c2vU1;
       c2vU1: // global
           R1 = _s2uOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vU3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOK::P64;
           _s2uOz::I64 = I64[_s2uOK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2vUa; else goto c2vTZ;
       c2vTZ: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2vUa; else goto c2vUh;
       c2vUa: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vUh: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uOy_entry() //  [R1, R2]
         { info_tbl: [(c2vUl,
                       label: go_up_s2uOy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vUl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vUp; else goto c2vUo;
       c2vUp: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vUo: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2vUj; else goto c2vUk;
       c2vUj: // global
           _s2uOw::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uOw::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vUk: // global
           I64[Hp - 80] = sat_s2uOK_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vUr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vUr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOL_entry() //  [R1]
         { info_tbl: [(c2vUs,
                       label: sat_s2uOL_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vUs: // global
           _s2uOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vUt; else goto c2vUu;
       c2vUu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vUw; else goto c2vUv;
       c2vUw: // global
           HpAlloc = 24;
           goto c2vUt;
       c2vUt: // global
           R1 = _s2uOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOL::P64;
           _s2uNX::I64 = I64[_s2uOL::P64 + 24];
           _s2uOw::I64 = _s2uNX::I64 - I64[_s2uOL::P64 + 16];
           _s2uOx::I64 = I64[_s2uOL::P64 + 32] - _s2uOw::I64;
           I64[Hp - 16] = go_up_s2uOy_info;
           I64[Hp - 8] = _s2uOw::I64;
           I64[Hp] = _s2uOx::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOv_entry() //  [R1]
         { info_tbl: [(c2vUG,
                       label: sat_s2uOv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vUG: // global
           _s2uOv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vUH; else goto c2vUI;
       c2vUI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vUK; else goto c2vUJ;
       c2vUK: // global
           HpAlloc = 16;
           goto c2vUH;
       c2vUH: // global
           R1 = _s2uOv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vUJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOv::P64;
           _s2uNW::I64 = I64[_s2uOv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2vUQ; else goto c2vUF;
       c2vUF: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2vUQ; else goto c2vUX;
       c2vUQ: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vUX: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOQ_entry() //  [R1]
         { info_tbl: [(c2vVb,
                       label: sat_s2uOQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vVb: // global
           _s2uOQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vVc; else goto c2vVd;
       c2vVd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vVf; else goto c2vVe;
       c2vVf: // global
           HpAlloc = 16;
           goto c2vVc;
       c2vVc: // global
           R1 = _s2uOQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vVe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOQ::P64;
           _s2uNW::I64 = I64[_s2uOQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2vVl; else goto c2vVa;
       c2vVa: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2vVl; else goto c2vVs;
       c2vVl: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vVs: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vVt,
                       label: GHC.Word.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vVt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vVx; else goto c2vVw;
       c2vVx: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vVw: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2vVH; else goto c2vVQ;
       c2vVH: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2vVA; else goto c2vVF;
       c2vVA: // global
           I64[Hp - 80] = sat_s2uOk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uO4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vVF: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2vVO; else goto c2vVD;
       c2vVD: // global
           I64[Hp - 80] = sat_s2uOp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vVB::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vVB::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vVQ: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2vVK; else goto c2vVP;
       c2vVK: // global
           I64[Hp - 80] = sat_s2uOL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uOv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vVP: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2vVO; else goto c2vVN;
       c2vVO: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2vVN: // global
           I64[Hp - 80] = sat_s2uOQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2vVL::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2vVL::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.093773505 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2vVY,
                       label: GHC.Word.$fEnumWord32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vVY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vW7; else goto c2vW8;
       c2vW7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vW8: // global
           I64[Sp - 24] = block_c2vVV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2vWh; else goto c2vVW;
       u2vWh: // global
           call _c2vVV(R1) args: 0, res: 0, upd: 0;
       c2vVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vVV() //  [R1]
         { info_tbl: [(c2vVV,
                       label: block_c2vVV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vVV: // global
           I64[Sp] = block_c2vW1_info;
           _s2uOV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uOV::I64;
           if (R1 & 7 != 0) goto u2vWg; else goto c2vW2;
       u2vWg: // global
           call _c2vW1(R1) args: 0, res: 0, upd: 0;
       c2vW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vW1() //  [R1]
         { info_tbl: [(c2vW1,
                       label: block_c2vW1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vW1: // global
           I64[Sp] = block_c2vW6_info;
           _s2uOX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uOX::I64;
           if (R1 & 7 != 0) goto u2vWi; else goto c2vWb;
       u2vWi: // global
           call _c2vW6(R1) args: 0, res: 0, upd: 0;
       c2vWb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vW6() //  [R1]
         { info_tbl: [(c2vW6,
                       label: block_c2vW6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vW6: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.096351756 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2uPd_entry() //  [R1]
         { info_tbl: [(c2vWK,
                       label: sat_s2uPd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vWK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vWL; else goto c2vWM;
       c2vWL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vWM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uP6::I64 = I64[R1 + 32];
           if (_s2uP6::I64 == I64[R1 + 24]) goto c2vWJ; else goto c2vWI;
       c2vWJ: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2vWI: // global
           R2 = _s2uP6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uP5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPa_entry() //  [R1]
         { info_tbl: [(c2vWY,
                       label: sat_s2uPa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vWY: // global
           _s2uPa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vWZ; else goto c2vX0;
       c2vX0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vX2; else goto c2vX1;
       c2vX2: // global
           HpAlloc = 16;
           goto c2vWZ;
       c2vWZ: // global
           R1 = _s2uPa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPa::P64;
           _s2uP6::I64 = I64[_s2uPa::P64 + 16];
           if (%MO_S_Lt_W64(_s2uP6::I64, 0)) goto c2vX8; else goto c2vWX;
       c2vWX: // global
           if (%MO_S_Gt_W64(_s2uP6::I64,
                            4294967295)) goto c2vX8; else goto c2vXf;
       c2vX8: // global
           Hp = Hp - 16;
           R2 = _s2uP6::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vXf: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uP6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uP5_entry() //  [R1, R2]
         { info_tbl: [(c2vXh,
                       label: go_s2uP5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vXh: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2vXl; else goto c2vXk;
       c2vXl: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vXk: // global
           _s2uP3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uPd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uP3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uPa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c2vXm,
                       label: GHC.Word.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vXm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vXq; else goto c2vXp;
       c2vXq: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vXp: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2vXs; else goto c2vXt;
       c2vXs: // global
           I64[Hp - 8] = go_s2uP5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uP5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2vXt: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.099164486 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2vXB,
                       label: GHC.Word.$fEnumWord32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vXF; else goto c2vXG;
       c2vXF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vXG: // global
           I64[Sp - 16] = block_c2vXy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vXO; else goto c2vXz;
       u2vXO: // global
           call _c2vXy(R1) args: 0, res: 0, upd: 0;
       c2vXz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vXy() //  [R1]
         { info_tbl: [(c2vXy,
                       label: block_c2vXy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vXy: // global
           I64[Sp] = block_c2vXE_info;
           _s2uPh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPh::I64;
           if (R1 & 7 != 0) goto u2vXN; else goto c2vXI;
       u2vXN: // global
           call _c2vXE(R1) args: 0, res: 0, upd: 0;
       c2vXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vXE() //  [R1]
         { info_tbl: [(c2vXE,
                       label: block_c2vXE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vXE: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.101309344 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2uPu_entry() //  [R1]
         { info_tbl: [(c2vY1,
                       label: sat_s2uPu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vY1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2vY2; else goto c2vYd;
       c2vY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vYd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uPp::I64 = I64[R1 + 16];
           if (_s2uPp::I64 != 4294967295) goto c2vXZ; else goto c2vY0;
       c2vXZ: // global
           I64[Sp - 24] = block_c2vY7_info;
           R2 = _s2uPp::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2vY0: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2vY7() //  [R1, R2]
         { info_tbl: [(c2vY7,
                       label: block_c2vY7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vY7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vYc; else goto c2vYb;
       c2vYc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2vYb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPo_entry() //  [R1]
         { info_tbl: [(c2vYn,
                       label: sat_s2uPo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vYn: // global
           _s2uPo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2vYo; else goto c2vYp;
       c2vYp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2vYr; else goto c2vYq;
       c2vYr: // global
           HpAlloc = 16;
           goto c2vYo;
       c2vYo: // global
           R1 = _s2uPo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2vYq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPo::P64;
           _s2uPk::I64 = I64[_s2uPo::P64 + 16];
           if (%MO_S_Lt_W64(_s2uPk::I64, 0)) goto c2vYx; else goto c2vYm;
       c2vYm: // global
           if (%MO_S_Gt_W64(_s2uPk::I64,
                            4294967295)) goto c2vYx; else goto c2vYE;
       c2vYx: // global
           Hp = Hp - 16;
           R2 = _s2uPk::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2vYE: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uPk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { info_tbl: [(c2vYF,
                       label: GHC.Word.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vYF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2vYJ; else goto c2vYI;
       c2vYJ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vYI: // global
           I64[Hp - 40] = sat_s2uPu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uPo_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.10351699 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { info_tbl: [(c2vYR,
                       label: GHC.Word.$fEnumWord32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vYR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vYS; else goto c2vYT;
       c2vYS: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vYT: // global
           I64[Sp - 8] = block_c2vYO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2vYO() //  [R1, R2]
         { info_tbl: [(c2vYO,
                       label: block_c2vYO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vYO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2vYW; else goto c2vYV;
       c2vYW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2vYV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.104881393 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2vZ4,
                       label: GHC.Word.$fEnumWord32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vZ5; else goto c2vZ6;
       c2vZ5: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vZ6: // global
           I64[Sp - 8] = block_c2vZ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2vZi; else goto c2vZ2;
       u2vZi: // global
           call _c2vZ1(R1) args: 0, res: 0, upd: 0;
       c2vZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vZ1() //  [R1]
         { info_tbl: [(c2vZ1,
                       label: block_c2vZ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZ1: // global
           _s2uPC::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uPC::I64,
                            4294967295)) goto c2vZg; else goto c2vZh;
       c2vZg: // global
           R2 = _s2uPC::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2vZh: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.106162086 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2vZn,
                       label: GHC.Word.$fEnumWord32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZn: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.107075034 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.107661689 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.108564395 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { info_tbl: [(c2vZx,
                       label: GHC.Word.eqWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2vZB; else goto c2vZC;
       c2vZB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2vZC: // global
           I64[Sp - 16] = block_c2vZu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2vZL; else goto c2vZv;
       u2vZL: // global
           call _c2vZu(R1) args: 0, res: 0, upd: 0;
       c2vZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vZu() //  [R1]
         { info_tbl: [(c2vZu,
                       label: block_c2vZu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZu: // global
           I64[Sp] = block_c2vZA_info;
           _s2uPH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPH::I64;
           if (R1 & 7 != 0) goto u2vZK; else goto c2vZE;
       u2vZK: // global
           call _c2vZA(R1) args: 0, res: 0, upd: 0;
       c2vZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vZA() //  [R1]
         { info_tbl: [(c2vZA,
                       label: block_c2vZA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZA: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.111070425 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { info_tbl: [(c2vZT,
                       label: GHC.Word.$fNumWord64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2vZU; else goto c2vZV;
       c2vZU: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2vZV: // global
           I64[Sp - 8] = block_c2vZQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w03; else goto c2vZR;
       u2w03: // global
           call _c2vZQ(R1) args: 0, res: 0, upd: 0;
       c2vZR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2vZQ() //  [R1]
         { info_tbl: [(c2vZQ,
                       label: block_c2vZQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2vZQ: // global
           if (I64[R1 + 7] == 0) goto c2w02; else goto c2w01;
       c2w02: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w01: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.112059214 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.112861853 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2w0d_srtd" {
     u2w0d_srtd:
         const S2vim_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { info_tbl: [(c2w0a,
                       label: GHC.Word.$fEnumWord7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w0b; else goto c2w0c;
       c2w0b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2w0c: // global
           (_c2w07::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2w07::I64 == 0) goto c2w09; else goto c2w08;
       c2w09: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2w08: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2w07::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.114033159 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2w0n_srtd" {
     u2w0n_srtd:
         const S2vim_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { info_tbl: [(c2w0k,
                       label: GHC.Word.$fEnumWord9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w0l; else goto c2w0m;
       c2w0l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2w0m: // global
           (_c2w0h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2w0h::I64 == 0) goto c2w0j; else goto c2w0i;
       c2w0j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2w0i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2w0h::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.11533279 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { info_tbl: [(c2w0v,
                       label: GHC.Word.neWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w0z; else goto c2w0A;
       c2w0z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w0A: // global
           I64[Sp - 16] = block_c2w0s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w0J; else goto c2w0t;
       u2w0J: // global
           call _c2w0s(R1) args: 0, res: 0, upd: 0;
       c2w0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w0s() //  [R1]
         { info_tbl: [(c2w0s,
                       label: block_c2w0s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0s: // global
           I64[Sp] = block_c2w0y_info;
           _s2uPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPS::I64;
           if (R1 & 7 != 0) goto u2w0I; else goto c2w0C;
       u2w0I: // global
           call _c2w0y(R1) args: 0, res: 0, upd: 0;
       c2w0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w0y() //  [R1]
         { info_tbl: [(c2w0y,
                       label: block_c2w0y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0y: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.117360671 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2uQ6_entry() //  [R1]
         { info_tbl: [(c2w16,
                       label: sat_s2uQ6_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w16: // global
           _s2uQ6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2w19; else goto c2w1a;
       c2w1a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w1c; else goto c2w1b;
       c2w1c: // global
           HpAlloc = 16;
           goto c2w19;
       c2w19: // global
           R1 = _s2uQ6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2w1b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ6::P64;
           _s2uQ5::I64 = I64[_s2uQ6::P64 + 16] % I64[_s2uQ6::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uQ4_entry() //  [R1]
         { info_tbl: [(c2w1j,
                       label: sat_s2uQ4_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w1j: // global
           _s2uQ4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2w1m; else goto c2w1n;
       c2w1n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w1p; else goto c2w1o;
       c2w1p: // global
           HpAlloc = 16;
           goto c2w1m;
       c2w1m: // global
           R1 = _s2uQ4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2w1o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ4::P64;
           _s2uQ3::I64 = I64[_s2uQ4::P64 + 16] / I64[_s2uQ4::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2w1q,
                       label: GHC.Word.$fIntegralWord64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w1q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w1r; else goto c2w1s;
       c2w1r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w1s: // global
           I64[Sp - 16] = block_c2w0O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w1C; else goto c2w0P;
       u2w1C: // global
           call _c2w0O(R1) args: 0, res: 0, upd: 0;
       c2w0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w0O() //  [R1]
         { info_tbl: [(c2w0O,
                       label: block_c2w0O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0O: // global
           I64[Sp] = block_c2w0T_info;
           _s2uPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPZ::I64;
           if (R1 & 7 != 0) goto u2w1B; else goto c2w0U;
       u2w1B: // global
           call _c2w0T(R1) args: 0, res: 0, upd: 0;
       c2w0U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w0T() //  [R1]
         { info_tbl: [(c2w0T,
                       label: block_c2w0T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w0T: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2w1w; else goto c2w1v;
       c2w1w: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w1v: // global
           _s2uQ2::I64 = I64[R1 + 7];
           if (_s2uQ2::I64 != 0) goto c2w1z; else goto c2w1A;
       c2w1z: // global
           I64[Hp - 80] = sat_s2uQ6_info;
           _s2uPZ::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2uPZ::I64;
           I64[Hp - 56] = _s2uQ2::I64;
           I64[Hp - 48] = sat_s2uQ4_info;
           I64[Hp - 32] = _s2uPZ::I64;
           I64[Hp - 24] = _s2uQ2::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w1A: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.120064949 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2w1K,
                       label: GHC.Word.$fIntegralWord64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w1K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w1O; else goto c2w1P;
       c2w1O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w1P: // global
           I64[Sp - 16] = block_c2w1H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w27; else goto c2w1I;
       u2w27: // global
           call _c2w1H(R1) args: 0, res: 0, upd: 0;
       c2w1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w1H() //  [R1]
         { info_tbl: [(c2w1H,
                       label: block_c2w1H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w1H: // global
           I64[Sp] = block_c2w1N_info;
           _s2uQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQa::I64;
           if (R1 & 7 != 0) goto u2w26; else goto c2w1R;
       u2w26: // global
           call _c2w1N(R1) args: 0, res: 0, upd: 0;
       c2w1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w1N() //  [R1]
         { info_tbl: [(c2w1N,
                       label: block_c2w1N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w1N: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2w1X; else goto c2w1W;
       c2w1X: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w1W: // global
           _s2uQd::I64 = I64[R1 + 7];
           if (_s2uQd::I64 != 0) goto c2w24; else goto c2w25;
       c2w24: // global
           (_s2uQf::I64, _s2uQg::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2uQd::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2uQg::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2uQf::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w25: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.122135888 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c2w2f,
                       label: GHC.Word.$fIntegralWord64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w2j; else goto c2w2k;
       c2w2j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w2k: // global
           I64[Sp - 16] = block_c2w2c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w2D; else goto c2w2d;
       u2w2D: // global
           call _c2w2c(R1) args: 0, res: 0, upd: 0;
       c2w2d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w2c() //  [R1]
         { info_tbl: [(c2w2c,
                       label: block_c2w2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2c: // global
           I64[Sp] = block_c2w2i_info;
           _s2uQm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQm::I64;
           if (R1 & 7 != 0) goto u2w2C; else goto c2w2m;
       u2w2C: // global
           call _c2w2i(R1) args: 0, res: 0, upd: 0;
       c2w2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w2i() //  [R1]
         { info_tbl: [(c2w2i,
                       label: block_c2w2i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w2s; else goto c2w2r;
       c2w2s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w2r: // global
           _s2uQp::I64 = I64[R1 + 7];
           if (_s2uQp::I64 != 0) goto c2w2A; else goto c2w2B;
       c2w2A: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2uQp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w2B: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.12392678 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c2w2L,
                       label: GHC.Word.$fIntegralWord64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w2P; else goto c2w2Q;
       c2w2P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w2Q: // global
           I64[Sp - 16] = block_c2w2I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w39; else goto c2w2J;
       u2w39: // global
           call _c2w2I(R1) args: 0, res: 0, upd: 0;
       c2w2J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w2I() //  [R1]
         { info_tbl: [(c2w2I,
                       label: block_c2w2I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2I: // global
           I64[Sp] = block_c2w2O_info;
           _s2uQu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQu::I64;
           if (R1 & 7 != 0) goto u2w38; else goto c2w2S;
       u2w38: // global
           call _c2w2O(R1) args: 0, res: 0, upd: 0;
       c2w2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w2O() //  [R1]
         { info_tbl: [(c2w2O,
                       label: block_c2w2O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w2O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w2Y; else goto c2w2X;
       c2w2Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w2X: // global
           _s2uQx::I64 = I64[R1 + 7];
           if (_s2uQx::I64 != 0) goto c2w36; else goto c2w37;
       c2w36: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2uQx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w37: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.125397344 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.126330071 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { info_tbl: [(c2w3h,
                       label: GHC.Word.$fEnumWord64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w3h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w3i; else goto c2w3j;
       c2w3i: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w3j: // global
           I64[Sp - 8] = block_c2w3e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w3y; else goto c2w3f;
       u2w3y: // global
           call _c2w3e(R1) args: 0, res: 0, upd: 0;
       c2w3f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w3e() //  [R1]
         { info_tbl: [(c2w3e,
                       label: block_c2w3e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w3e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w3o; else goto c2w3n;
       c2w3o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w3n: // global
           _s2uQC::I64 = I64[R1 + 7];
           if (_s2uQC::I64 != 0) goto c2w3w; else goto c2w3x;
       c2w3w: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQC::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w3x: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.127569365 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.128189359 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.129941648 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { info_tbl: [(c2w3G,
                       label: GHC.Word.$fEnumWord64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w3G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w3H; else goto c2w3I;
       c2w3H: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w3I: // global
           I64[Sp - 8] = block_c2w3D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w3X; else goto c2w3E;
       u2w3X: // global
           call _c2w3D(R1) args: 0, res: 0, upd: 0;
       c2w3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w3D() //  [R1]
         { info_tbl: [(c2w3D,
                       label: block_c2w3D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w3D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w3N; else goto c2w3M;
       c2w3N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w3M: // global
           _s2uQH::I64 = I64[R1 + 7];
           if (_s2uQH::I64 != 18446744073709551615) goto c2w3V; else goto c2w3W;
       c2w3V: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQH::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w3W: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.13126934 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2w45_srtd" {
     u2w45_srtd:
         const S2vim_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { info_tbl: [(c2w42,
                       label: GHC.Word.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w42: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.132272443 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { info_tbl: [(c2w4d,
                       label: GHC.Word.$fEnumWord6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w4e; else goto c2w4f;
       c2w4e: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w4f: // global
           I64[Sp - 8] = block_c2w4a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w4j; else goto c2w4b;
       u2w4j: // global
           call _c2w4a(R1) args: 0, res: 0, upd: 0;
       c2w4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w4a() //  [R1]
         { info_tbl: [(c2w4a,
                       label: block_c2w4a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4a: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.133670609 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2w4r,
                       label: GHC.Word.$fEnumWord64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4r: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w4s; else goto c2w4t;
       c2w4s: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w4t: // global
           I64[Sp - 8] = block_c2w4o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w4K; else goto c2w4p;
       u2w4K: // global
           call _c2w4o(R1) args: 0, res: 0, upd: 0;
       c2w4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w4o() //  [R1]
         { info_tbl: [(c2w4o,
                       label: block_c2w4o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w4y; else goto c2w4x;
       c2w4y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w4x: // global
           _s2uQP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uQP::I64, 0)) goto c2w4C; else goto c2w4J;
       c2w4C: // global
           Hp = Hp - 16;
           R2 = _s2uQP::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2w4J: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.135171277 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { info_tbl: [(c2w4S,
                       label: GHC.Word.gtWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w4W; else goto c2w4X;
       c2w4W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w4X: // global
           I64[Sp - 16] = block_c2w4P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w56; else goto c2w4Q;
       u2w56: // global
           call _c2w4P(R1) args: 0, res: 0, upd: 0;
       c2w4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w4P() //  [R1]
         { info_tbl: [(c2w4P,
                       label: block_c2w4P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4P: // global
           I64[Sp] = block_c2w4V_info;
           _s2uQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQV::I64;
           if (R1 & 7 != 0) goto u2w55; else goto c2w4Z;
       u2w55: // global
           call _c2w4V(R1) args: 0, res: 0, upd: 0;
       c2w4Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w4V() //  [R1]
         { info_tbl: [(c2w4V,
                       label: block_c2w4V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w4V: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.136682664 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { info_tbl: [(c2w5e,
                       label: GHC.Word.geWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w5i; else goto c2w5j;
       c2w5i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w5j: // global
           I64[Sp - 16] = block_c2w5b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w5s; else goto c2w5c;
       u2w5s: // global
           call _c2w5b(R1) args: 0, res: 0, upd: 0;
       c2w5c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5b() //  [R1]
         { info_tbl: [(c2w5b,
                       label: block_c2w5b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5b: // global
           I64[Sp] = block_c2w5h_info;
           _s2uR2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR2::I64;
           if (R1 & 7 != 0) goto u2w5r; else goto c2w5l;
       u2w5r: // global
           call _c2w5h(R1) args: 0, res: 0, upd: 0;
       c2w5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5h() //  [R1]
         { info_tbl: [(c2w5h,
                       label: block_c2w5h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5h: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.138296056 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { info_tbl: [(c2w5A,
                       label: GHC.Word.ltWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w5E; else goto c2w5F;
       c2w5E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w5F: // global
           I64[Sp - 16] = block_c2w5x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w5O; else goto c2w5y;
       u2w5O: // global
           call _c2w5x(R1) args: 0, res: 0, upd: 0;
       c2w5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5x() //  [R1]
         { info_tbl: [(c2w5x,
                       label: block_c2w5x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5x: // global
           I64[Sp] = block_c2w5D_info;
           _s2uR9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR9::I64;
           if (R1 & 7 != 0) goto u2w5N; else goto c2w5H;
       u2w5N: // global
           call _c2w5D(R1) args: 0, res: 0, upd: 0;
       c2w5H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5D() //  [R1]
         { info_tbl: [(c2w5D,
                       label: block_c2w5D_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5D: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.139705067 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { info_tbl: [(c2w5W,
                       label: GHC.Word.leWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w60; else goto c2w61;
       c2w60: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w61: // global
           I64[Sp - 16] = block_c2w5T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w6a; else goto c2w5U;
       u2w6a: // global
           call _c2w5T(R1) args: 0, res: 0, upd: 0;
       c2w5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5T() //  [R1]
         { info_tbl: [(c2w5T,
                       label: block_c2w5T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5T: // global
           I64[Sp] = block_c2w5Z_info;
           _s2uRg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRg::I64;
           if (R1 & 7 != 0) goto u2w69; else goto c2w63;
       u2w69: // global
           call _c2w5Z(R1) args: 0, res: 0, upd: 0;
       c2w63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w5Z() //  [R1]
         { info_tbl: [(c2w5Z,
                       label: block_c2w5Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w5Z: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.141528132 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2w6i,
                       label: GHC.Word.$fOrdWord64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2w6m; else goto c2w6n;
       c2w6m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w6n: // global
           I64[Sp - 16] = block_c2w6f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w6A; else goto c2w6g;
       u2w6A: // global
           call _c2w6f(R1) args: 0, res: 0, upd: 0;
       c2w6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w6f() //  [R1]
         { info_tbl: [(c2w6f,
                       label: block_c2w6f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6f: // global
           I64[Sp - 8] = block_c2w6l_info;
           _s2uRm::P64 = R1;
           _s2uRn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRn::I64;
           P64[Sp + 8] = _s2uRm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w6z; else goto c2w6p;
       u2w6z: // global
           call _c2w6l(R1) args: 0, res: 0, upd: 0;
       c2w6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w6l() //  [R1]
         { info_tbl: [(c2w6l,
                       label: block_c2w6l_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6l: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2w6x; else goto c2w6y;
       c2w6x: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2w6y: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.143253685 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2w6I,
                       label: GHC.Word.$fOrdWord64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2w6M; else goto c2w6N;
       c2w6M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w6N: // global
           I64[Sp - 16] = block_c2w6F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w70; else goto c2w6G;
       u2w70: // global
           call _c2w6F(R1) args: 0, res: 0, upd: 0;
       c2w6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w6F() //  [R1]
         { info_tbl: [(c2w6F,
                       label: block_c2w6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6F: // global
           I64[Sp - 8] = block_c2w6L_info;
           _s2uRt::P64 = R1;
           _s2uRu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRu::I64;
           P64[Sp + 8] = _s2uRt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w6Z; else goto c2w6P;
       u2w6Z: // global
           call _c2w6L(R1) args: 0, res: 0, upd: 0;
       c2w6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w6L() //  [R1]
         { info_tbl: [(c2w6L,
                       label: block_c2w6L_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w6L: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2w6X; else goto c2w6Y;
       c2w6X: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2w6Y: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.14495306 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2w78,
                       label: GHC.Word.$fOrdWord64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w78: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w7c; else goto c2w7d;
       c2w7c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w7d: // global
           I64[Sp - 16] = block_c2w75_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w7w; else goto c2w76;
       u2w7w: // global
           call _c2w75(R1) args: 0, res: 0, upd: 0;
       c2w76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w75() //  [R1]
         { info_tbl: [(c2w75,
                       label: block_c2w75_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w75: // global
           I64[Sp] = block_c2w7b_info;
           _s2uRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRB::I64;
           if (R1 & 7 != 0) goto u2w7v; else goto c2w7f;
       u2w7v: // global
           call _c2w7b(R1) args: 0, res: 0, upd: 0;
       c2w7f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w7b() //  [R1]
         { info_tbl: [(c2w7b,
                       label: block_c2w7b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w7b: // global
           _s2uRB::I64 = I64[Sp + 8];
           _s2uRD::I64 = I64[R1 + 7];
           if (_s2uRB::I64 == _s2uRD::I64) goto c2w7u; else goto c2w7t;
       c2w7u: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w7t: // global
           if (_s2uRB::I64 > _s2uRD::I64) goto c2w7q; else goto c2w7r;
       c2w7q: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2w7r: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.146408624 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.147093714 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.149019103 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2w7E,
                       label: GHC.Word.$fEnumWord64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w7E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w7F; else goto c2w7G;
       c2w7F: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w7G: // global
           I64[Sp - 8] = block_c2w7B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w7X; else goto c2w7C;
       u2w7X: // global
           call _c2w7B(R1) args: 0, res: 0, upd: 0;
       c2w7C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w7B() //  [R1]
         { info_tbl: [(c2w7B,
                       label: block_c2w7B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w7B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w7L; else goto c2w7K;
       c2w7L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w7K: // global
           _s2uRI::I64 = I64[R1 + 7];
           if (_s2uRI::I64 > 9223372036854775807) goto c2w7P; else goto c2w7W;
       c2w7P: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2w7W: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uRI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.150728381 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2w82,
                       label: GHC.Word.$fEnumWord64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w82: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2w89,
                       label: GHC.Word.$fEnumWord64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w89: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2w8g,
                       label: GHC.Word.$fEnumWord64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8g: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2w8n,
                       label: GHC.Word.$fEnumWord64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8n: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.152577746 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2w8w,
                       label: GHC.Word.$fNumWord8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w8D; else goto c2w8E;
       c2w8D: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w8E: // global
           I64[Sp - 8] = block_c2w8u_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2w8u() //  [R1]
         { info_tbl: [(c2w8u,
                       label: block_c2w8u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w8H; else goto c2w8G;
       c2w8H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2w8G: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.154258015 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { info_tbl: [(c2w8M,
                       label: GHC.Word.$fNumWord8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8M: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.155319957 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { info_tbl: [(c2w8W,
                       label: GHC.Word.$fNumWord8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2w9c; else goto c2w9d;
       c2w9c: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2w9d: // global
           I64[Sp - 8] = block_c2w8T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2w9h; else goto c2w8U;
       u2w9h: // global
           call _c2w8T(R1) args: 0, res: 0, upd: 0;
       c2w8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w8T() //  [R1]
         { info_tbl: [(c2w8T,
                       label: block_c2w8T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w8T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w9g; else goto c2w9f;
       c2w9g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w9f: // global
           _s2uRV::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uRV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.15681039 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2w9p,
                       label: GHC.Word.$fNumWord8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2w9E; else goto c2w9F;
       c2w9E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2w9F: // global
           I64[Sp - 16] = block_c2w9m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2w9L; else goto c2w9n;
       u2w9L: // global
           call _c2w9m(R1) args: 0, res: 0, upd: 0;
       c2w9n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w9m() //  [R1]
         { info_tbl: [(c2w9m,
                       label: block_c2w9m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9m: // global
           I64[Sp] = block_c2w9s_info;
           _s2uRZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRZ::I64;
           if (R1 & 7 != 0) goto u2w9K; else goto c2w9t;
       u2w9K: // global
           call _c2w9s(R1) args: 0, res: 0, upd: 0;
       c2w9t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w9s() //  [R1]
         { info_tbl: [(c2w9s,
                       label: block_c2w9s_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2w9J; else goto c2w9I;
       c2w9J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2w9I: // global
           _s2uS3::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.158616011 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2w9T,
                       label: GHC.Word.$fNumWord8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wa8; else goto c2wa9;
       c2wa8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wa9: // global
           I64[Sp - 16] = block_c2w9Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2waf; else goto c2w9R;
       u2waf: // global
           call _c2w9Q(R1) args: 0, res: 0, upd: 0;
       c2w9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w9Q() //  [R1]
         { info_tbl: [(c2w9Q,
                       label: block_c2w9Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9Q: // global
           I64[Sp] = block_c2w9W_info;
           _s2uS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uS7::I64;
           if (R1 & 7 != 0) goto u2wae; else goto c2w9X;
       u2wae: // global
           call _c2w9W(R1) args: 0, res: 0, upd: 0;
       c2w9X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2w9W() //  [R1]
         { info_tbl: [(c2w9W,
                       label: block_c2w9W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2w9W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wad; else goto c2wac;
       c2wad: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wac: // global
           _s2uSb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.160380138 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2wan,
                       label: GHC.Word.$fNumWord8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wan: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2waC; else goto c2waD;
       c2waC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2waD: // global
           I64[Sp - 16] = block_c2wak_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2waJ; else goto c2wal;
       u2waJ: // global
           call _c2wak(R1) args: 0, res: 0, upd: 0;
       c2wal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wak() //  [R1]
         { info_tbl: [(c2wak,
                       label: block_c2wak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wak: // global
           I64[Sp] = block_c2waq_info;
           _s2uSf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSf::I64;
           if (R1 & 7 != 0) goto u2waI; else goto c2war;
       u2waI: // global
           call _c2waq(R1) args: 0, res: 0, upd: 0;
       c2war: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2waq() //  [R1]
         { info_tbl: [(c2waq,
                       label: block_c2waq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2waq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2waH; else goto c2waG;
       c2waH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2waG: // global
           _s2uSj::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.161959659 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2waR,
                       label: GHC.Word.$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2waR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2waS; else goto c2waT;
       c2waS: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2waT: // global
           I64[Sp - 8] = block_c2waO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2waY; else goto c2waP;
       u2waY: // global
           call _c2waO(R1) args: 0, res: 0, upd: 0;
       c2waP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2waO() //  [R1]
         { info_tbl: [(c2waO,
                       label: block_c2waO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2waO: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.163224348 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2wb6,
                       label: GHC.Word.$fBitsWord8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wb6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wbh; else goto c2wbi;
       c2wbh: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wbi: // global
           I64[Sp - 8] = block_c2wb3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wbm; else goto c2wb4;
       u2wbm: // global
           call _c2wb3(R1) args: 0, res: 0, upd: 0;
       c2wb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wb3() //  [R1]
         { info_tbl: [(c2wb3,
                       label: block_c2wb3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wb3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wbl; else goto c2wbk;
       c2wbl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wbk: // global
           (_c2wb9::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wb9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.164724647 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wbu,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wbG; else goto c2wbH;
       c2wbG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wbH: // global
           I64[Sp - 16] = block_c2wbr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wbN; else goto c2wbs;
       u2wbN: // global
           call _c2wbr(R1) args: 0, res: 0, upd: 0;
       c2wbs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wbr() //  [R1]
         { info_tbl: [(c2wbr,
                       label: block_c2wbr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbr: // global
           I64[Sp] = block_c2wbx_info;
           _s2uSw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSw::I64;
           if (R1 & 7 != 0) goto u2wbM; else goto c2wby;
       u2wbM: // global
           call _c2wbx(R1) args: 0, res: 0, upd: 0;
       c2wby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wbx() //  [R1]
         { info_tbl: [(c2wbx,
                       label: block_c2wbx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wbL; else goto c2wbK;
       c2wbL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wbK: // global
           _s2uSz::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.166571013 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wbV,
                       label: GHC.Word.$fBitsWord8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wbZ; else goto c2wc0;
       c2wbZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wc0: // global
           I64[Sp - 16] = block_c2wbS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wck; else goto c2wbT;
       u2wck: // global
           call _c2wbS(R1) args: 0, res: 0, upd: 0;
       c2wbT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wbS() //  [R1]
         { info_tbl: [(c2wbS,
                       label: block_c2wbS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbS: // global
           I64[Sp] = block_c2wbY_info;
           _s2uSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSD::I64;
           if (R1 & 7 != 0) goto u2wcj; else goto c2wc2;
       u2wcj: // global
           call _c2wbY(R1) args: 0, res: 0, upd: 0;
       c2wc2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wbY() //  [R1]
         { info_tbl: [(c2wbY,
                       label: block_c2wbY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wbY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wc8; else goto c2wc7;
       c2wc8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wc7: // global
           _s2uSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSF::I64, 64)) goto c2wch; else goto c2wci;
       c2wch: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uSF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wci: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.169188116 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wcs,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wcH; else goto c2wcI;
       c2wcH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wcI: // global
           I64[Sp - 16] = block_c2wcp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wcO; else goto c2wcq;
       u2wcO: // global
           call _c2wcp(R1) args: 0, res: 0, upd: 0;
       c2wcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wcp() //  [R1]
         { info_tbl: [(c2wcp,
                       label: block_c2wcp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcp: // global
           I64[Sp] = block_c2wcv_info;
           _s2uSL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSL::I64;
           if (R1 & 7 != 0) goto u2wcN; else goto c2wcw;
       u2wcN: // global
           call _c2wcv(R1) args: 0, res: 0, upd: 0;
       c2wcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wcv() //  [R1]
         { info_tbl: [(c2wcv,
                       label: block_c2wcv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wcM; else goto c2wcL;
       c2wcM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wcL: // global
           _s2uSP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.170961062 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wcW,
                       label: GHC.Word.$fBitsWord8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wd0; else goto c2wd1;
       c2wd0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wd1: // global
           I64[Sp - 16] = block_c2wcT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wdo; else goto c2wcU;
       u2wdo: // global
           call _c2wcT(R1) args: 0, res: 0, upd: 0;
       c2wcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wcT() //  [R1]
         { info_tbl: [(c2wcT,
                       label: block_c2wcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcT: // global
           I64[Sp] = block_c2wcZ_info;
           _s2uST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uST::I64;
           if (R1 & 7 != 0) goto u2wdn; else goto c2wd3;
       u2wdn: // global
           call _c2wcZ(R1) args: 0, res: 0, upd: 0;
       c2wd3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wcZ() //  [R1]
         { info_tbl: [(c2wcZ,
                       label: block_c2wcZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wcZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wd9; else goto c2wd8;
       c2wd9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wd8: // global
           _s2uSV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSV::I64, 64)) goto c2wdl; else goto c2wdm;
       c2wdl: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2uSV::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wdm: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.172522783 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { info_tbl: [(c2wdt,
                       label: GHC.Word.$fBitsWord8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdt: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.173946303 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2wdD,
                       label: GHC.Word.$fBitsWord8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wdH; else goto c2wdI;
       c2wdH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wdI: // global
           I64[Sp - 16] = block_c2wdA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wev; else goto c2wdB;
       u2wev: // global
           call _c2wdA(R1) args: 0, res: 0, upd: 0;
       c2wdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wdA() //  [R1]
         { info_tbl: [(c2wdA,
                       label: block_c2wdA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdA: // global
           I64[Sp - 8] = block_c2wdG_info;
           _s2uT2::P64 = R1;
           _s2uT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uT3::I64;
           P64[Sp + 8] = _s2uT2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2weu; else goto c2wdK;
       u2weu: // global
           call _c2wdG(R1) args: 0, res: 0, upd: 0;
       c2wdK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wdG() //  [R1]
         { info_tbl: [(c2wdG,
                       label: block_c2wdG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdG: // global
           _s2uT8::I64 = I64[R1 + 7] & 7;
           if (_s2uT8::I64 != 0) goto u2wes; else goto c2weo;
       u2wes: // global
           I64[Sp + 16] = _s2uT8::I64;
           Sp = Sp + 8;
           call _c2wdZ() args: 0, res: 0, upd: 0;
       c2weo: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wdZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdZ: // global
           Hp = Hp + 16;
           _s2uT8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wel; else goto c2wek;
       c2wel: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wdY_info;
           R1 = _s2uT8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wek: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2uT3::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2uT3::I64 << _s2uT8::I64) | (_s2uT3::I64 >> 8 - _s2uT8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wdY() //  [R1]
         { info_tbl: [(c2wdY,
                       label: block_c2wdY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wdY: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wdZ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.176215188 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2weF,
                       label: GHC.Word.$fBitsWord8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2weF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2weJ; else goto c2weK;
       c2weJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2weK: // global
           I64[Sp - 16] = block_c2weC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wfr; else goto c2weD;
       u2wfr: // global
           call _c2weC(R1) args: 0, res: 0, upd: 0;
       c2weD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2weC() //  [R1]
         { info_tbl: [(c2weC,
                       label: block_c2weC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2weC: // global
           I64[Sp] = block_c2weI_info;
           _s2uTh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTh::I64;
           if (R1 & 7 != 0) goto u2wfq; else goto c2weM;
       u2wfq: // global
           call _c2weI(R1) args: 0, res: 0, upd: 0;
       c2weM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2weI() //  [R1]
         { info_tbl: [(c2weI,
                       label: block_c2weI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2weI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2weS; else goto c2weR;
       c2weS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2weR: // global
           _s2uTh::I64 = I64[Sp + 8];
           _s2uTj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uTj::I64, 0)) goto c2wfa; else goto c2wfp;
       c2wfa: // global
           _s2uTl::I64 = -_s2uTj::I64;
           if (%MO_S_Ge_W64(_s2uTl::I64, 64)) goto c2wfo; else goto c2wf7;
       c2wf7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTh::I64 >> _s2uTl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wfp: // global
           if (%MO_S_Ge_W64(_s2uTj::I64, 64)) goto c2wfo; else goto c2wfn;
       c2wfo: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wfn: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uTh::I64 << _s2uTj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.178260706 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2wfz,
                       label: GHC.Word.$fBitsWord8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wfz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wfL; else goto c2wfM;
       c2wfL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wfM: // global
           I64[Sp - 16] = block_c2wfw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wfS; else goto c2wfx;
       u2wfS: // global
           call _c2wfw(R1) args: 0, res: 0, upd: 0;
       c2wfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wfw() //  [R1]
         { info_tbl: [(c2wfw,
                       label: block_c2wfw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wfw: // global
           I64[Sp] = block_c2wfC_info;
           _s2uTu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTu::I64;
           if (R1 & 7 != 0) goto u2wfR; else goto c2wfD;
       u2wfR: // global
           call _c2wfC(R1) args: 0, res: 0, upd: 0;
       c2wfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wfC() //  [R1]
         { info_tbl: [(c2wfC,
                       label: block_c2wfC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wfC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wfQ; else goto c2wfP;
       c2wfQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wfP: // global
           _s2uTx::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.17994185 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2wg0,
                       label: GHC.Word.$fBitsWord8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wg0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wgc; else goto c2wgd;
       c2wgc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wgd: // global
           I64[Sp - 16] = block_c2wfX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wgj; else goto c2wfY;
       u2wgj: // global
           call _c2wfX(R1) args: 0, res: 0, upd: 0;
       c2wfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wfX() //  [R1]
         { info_tbl: [(c2wfX,
                       label: block_c2wfX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wfX: // global
           I64[Sp] = block_c2wg3_info;
           _s2uTB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTB::I64;
           if (R1 & 7 != 0) goto u2wgi; else goto c2wg4;
       u2wgi: // global
           call _c2wg3(R1) args: 0, res: 0, upd: 0;
       c2wg4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wg3() //  [R1]
         { info_tbl: [(c2wg3,
                       label: block_c2wg3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wg3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wgh; else goto c2wgg;
       c2wgh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wgg: // global
           _s2uTE::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.181646955 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2wgr,
                       label: GHC.Word.$fBitsWord8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wgr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wgD; else goto c2wgE;
       c2wgD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wgE: // global
           I64[Sp - 16] = block_c2wgo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wgK; else goto c2wgp;
       u2wgK: // global
           call _c2wgo(R1) args: 0, res: 0, upd: 0;
       c2wgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wgo() //  [R1]
         { info_tbl: [(c2wgo,
                       label: block_c2wgo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wgo: // global
           I64[Sp] = block_c2wgu_info;
           _s2uTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTI::I64;
           if (R1 & 7 != 0) goto u2wgJ; else goto c2wgv;
       u2wgJ: // global
           call _c2wgu(R1) args: 0, res: 0, upd: 0;
       c2wgv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wgu() //  [R1]
         { info_tbl: [(c2wgu,
                       label: block_c2wgu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wgu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wgI; else goto c2wgH;
       c2wgI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wgH: // global
           _s2uTL::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.183345935 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2wgS,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wgS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wh3; else goto c2wh4;
       c2wh3: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wh4: // global
           I64[Sp - 8] = block_c2wgP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wh8; else goto c2wgQ;
       u2wh8: // global
           call _c2wgP(R1) args: 0, res: 0, upd: 0;
       c2wgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wgP() //  [R1]
         { info_tbl: [(c2wgP,
                       label: block_c2wgP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wgP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wh7; else goto c2wh6;
       c2wh7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wh6: // global
           (_c2wgV::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wgV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.184754759 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2whg,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2whg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2whr; else goto c2whs;
       c2whr: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2whs: // global
           I64[Sp - 8] = block_c2whd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2whw; else goto c2whe;
       u2whw: // global
           call _c2whd(R1) args: 0, res: 0, upd: 0;
       c2whe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2whd() //  [R1]
         { info_tbl: [(c2whd,
                       label: block_c2whd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2whd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2whv; else goto c2whu;
       c2whv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2whu: // global
           (_c2whj::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2whj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.186082207 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.186787788 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2whB,
                       label: GHC.Word.$fBitsWord8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2whB: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.188612969 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2whK,
                       label: GHC.Word.$fNumWord16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2whK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2whR; else goto c2whS;
       c2whR: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2whS: // global
           I64[Sp - 8] = block_c2whI_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2whI() //  [R1]
         { info_tbl: [(c2whI,
                       label: block_c2whI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2whI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2whV; else goto c2whU;
       c2whV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2whU: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.189795894 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { info_tbl: [(c2wi0,
                       label: GHC.Word.$fNumWord16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wi0: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.19078127 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { info_tbl: [(c2wia,
                       label: GHC.Word.$fNumWord16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wia: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wiq; else goto c2wir;
       c2wiq: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wir: // global
           I64[Sp - 8] = block_c2wi7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wiv; else goto c2wi8;
       u2wiv: // global
           call _c2wi7(R1) args: 0, res: 0, upd: 0;
       c2wi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wi7() //  [R1]
         { info_tbl: [(c2wi7,
                       label: block_c2wi7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wi7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wiu; else goto c2wit;
       c2wiu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wit: // global
           _s2uU7::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uU7::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.192243391 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2wiD,
                       label: GHC.Word.$fNumWord16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wiD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wiS; else goto c2wiT;
       c2wiS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wiT: // global
           I64[Sp - 16] = block_c2wiA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wiZ; else goto c2wiB;
       u2wiZ: // global
           call _c2wiA(R1) args: 0, res: 0, upd: 0;
       c2wiB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wiA() //  [R1]
         { info_tbl: [(c2wiA,
                       label: block_c2wiA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wiA: // global
           I64[Sp] = block_c2wiG_info;
           _s2uUb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUb::I64;
           if (R1 & 7 != 0) goto u2wiY; else goto c2wiH;
       u2wiY: // global
           call _c2wiG(R1) args: 0, res: 0, upd: 0;
       c2wiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wiG() //  [R1]
         { info_tbl: [(c2wiG,
                       label: block_c2wiG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wiG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wiX; else goto c2wiW;
       c2wiX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wiW: // global
           _s2uUf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.194001011 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2wj7,
                       label: GHC.Word.$fNumWord16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wj7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wjm; else goto c2wjn;
       c2wjm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wjn: // global
           I64[Sp - 16] = block_c2wj4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wjt; else goto c2wj5;
       u2wjt: // global
           call _c2wj4(R1) args: 0, res: 0, upd: 0;
       c2wj5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wj4() //  [R1]
         { info_tbl: [(c2wj4,
                       label: block_c2wj4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wj4: // global
           I64[Sp] = block_c2wja_info;
           _s2uUj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUj::I64;
           if (R1 & 7 != 0) goto u2wjs; else goto c2wjb;
       u2wjs: // global
           call _c2wja(R1) args: 0, res: 0, upd: 0;
       c2wjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wja() //  [R1]
         { info_tbl: [(c2wja,
                       label: block_c2wja_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wja: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wjr; else goto c2wjq;
       c2wjr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wjq: // global
           _s2uUn::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.195696208 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2wjB,
                       label: GHC.Word.$fNumWord16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wjB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wjQ; else goto c2wjR;
       c2wjQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wjR: // global
           I64[Sp - 16] = block_c2wjy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wjX; else goto c2wjz;
       u2wjX: // global
           call _c2wjy(R1) args: 0, res: 0, upd: 0;
       c2wjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wjy() //  [R1]
         { info_tbl: [(c2wjy,
                       label: block_c2wjy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wjy: // global
           I64[Sp] = block_c2wjE_info;
           _s2uUr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUr::I64;
           if (R1 & 7 != 0) goto u2wjW; else goto c2wjF;
       u2wjW: // global
           call _c2wjE(R1) args: 0, res: 0, upd: 0;
       c2wjF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wjE() //  [R1]
         { info_tbl: [(c2wjE,
                       label: block_c2wjE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wjE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wjV; else goto c2wjU;
       c2wjV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wjU: // global
           _s2uUv::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.197575619 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { info_tbl: [(c2wk5,
                       label: GHC.Word.$ctoInteger1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wk5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wk6; else goto c2wk7;
       c2wk6: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wk7: // global
           I64[Sp - 8] = block_c2wk2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wkc; else goto c2wk3;
       u2wkc: // global
           call _c2wk2(R1) args: 0, res: 0, upd: 0;
       c2wk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wk2() //  [R1]
         { info_tbl: [(c2wk2,
                       label: block_c2wk2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wk2: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.198809063 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2wkk,
                       label: GHC.Word.$fBitsWord16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wkk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wkv; else goto c2wkw;
       c2wkv: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wkw: // global
           I64[Sp - 8] = block_c2wkh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wkA; else goto c2wki;
       u2wkA: // global
           call _c2wkh(R1) args: 0, res: 0, upd: 0;
       c2wki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wkh() //  [R1]
         { info_tbl: [(c2wkh,
                       label: block_c2wkh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wkh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wkz; else goto c2wky;
       c2wkz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wky: // global
           (_c2wkn::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wkn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.200284015 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wkI,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wkU; else goto c2wkV;
       c2wkU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wkV: // global
           I64[Sp - 16] = block_c2wkF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wl1; else goto c2wkG;
       u2wl1: // global
           call _c2wkF(R1) args: 0, res: 0, upd: 0;
       c2wkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wkF() //  [R1]
         { info_tbl: [(c2wkF,
                       label: block_c2wkF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wkF: // global
           I64[Sp] = block_c2wkL_info;
           _s2uUI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUI::I64;
           if (R1 & 7 != 0) goto u2wl0; else goto c2wkM;
       u2wl0: // global
           call _c2wkL(R1) args: 0, res: 0, upd: 0;
       c2wkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wkL() //  [R1]
         { info_tbl: [(c2wkL,
                       label: block_c2wkL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wkL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wkZ; else goto c2wkY;
       c2wkZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wkY: // global
           _s2uUL::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.202056633 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wl9,
                       label: GHC.Word.$fBitsWord16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wl9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wld; else goto c2wle;
       c2wld: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wle: // global
           I64[Sp - 16] = block_c2wl6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wly; else goto c2wl7;
       u2wly: // global
           call _c2wl6(R1) args: 0, res: 0, upd: 0;
       c2wl7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wl6() //  [R1]
         { info_tbl: [(c2wl6,
                       label: block_c2wl6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wl6: // global
           I64[Sp] = block_c2wlc_info;
           _s2uUP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUP::I64;
           if (R1 & 7 != 0) goto u2wlx; else goto c2wlg;
       u2wlx: // global
           call _c2wlc(R1) args: 0, res: 0, upd: 0;
       c2wlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wlc() //  [R1]
         { info_tbl: [(c2wlc,
                       label: block_c2wlc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wlc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wlm; else goto c2wll;
       c2wlm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wll: // global
           _s2uUR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uUR::I64, 64)) goto c2wlv; else goto c2wlw;
       c2wlv: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uUR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wlw: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.203926795 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wlG,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wlG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wlV; else goto c2wlW;
       c2wlV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wlW: // global
           I64[Sp - 16] = block_c2wlD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wm2; else goto c2wlE;
       u2wm2: // global
           call _c2wlD(R1) args: 0, res: 0, upd: 0;
       c2wlE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wlD() //  [R1]
         { info_tbl: [(c2wlD,
                       label: block_c2wlD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wlD: // global
           I64[Sp] = block_c2wlJ_info;
           _s2uUX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUX::I64;
           if (R1 & 7 != 0) goto u2wm1; else goto c2wlK;
       u2wm1: // global
           call _c2wlJ(R1) args: 0, res: 0, upd: 0;
       c2wlK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wlJ() //  [R1]
         { info_tbl: [(c2wlJ,
                       label: block_c2wlJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wlJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wm0; else goto c2wlZ;
       c2wm0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wlZ: // global
           _s2uV1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uV1::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.205880384 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wma,
                       label: GHC.Word.$fBitsWord16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wme; else goto c2wmf;
       c2wme: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wmf: // global
           I64[Sp - 16] = block_c2wm7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wmC; else goto c2wm8;
       u2wmC: // global
           call _c2wm7(R1) args: 0, res: 0, upd: 0;
       c2wm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wm7() //  [R1]
         { info_tbl: [(c2wm7,
                       label: block_c2wm7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wm7: // global
           I64[Sp] = block_c2wmd_info;
           _s2uV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uV5::I64;
           if (R1 & 7 != 0) goto u2wmB; else goto c2wmh;
       u2wmB: // global
           call _c2wmd(R1) args: 0, res: 0, upd: 0;
       c2wmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wmd() //  [R1]
         { info_tbl: [(c2wmd,
                       label: block_c2wmd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wmd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wmn; else goto c2wmm;
       c2wmn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wmm: // global
           _s2uV7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uV7::I64, 64)) goto c2wmz; else goto c2wmA;
       c2wmz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2uV7::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wmA: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.208275361 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { info_tbl: [(c2wmH,
                       label: GHC.Word.$fBitsWord16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wmH: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.209904412 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2wmR,
                       label: GHC.Word.$fBitsWord16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wmR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wmV; else goto c2wmW;
       c2wmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wmW: // global
           I64[Sp - 16] = block_c2wmO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wnJ; else goto c2wmP;
       u2wnJ: // global
           call _c2wmO(R1) args: 0, res: 0, upd: 0;
       c2wmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wmO() //  [R1]
         { info_tbl: [(c2wmO,
                       label: block_c2wmO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wmO: // global
           I64[Sp - 8] = block_c2wmU_info;
           _s2uVe::P64 = R1;
           _s2uVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uVf::I64;
           P64[Sp + 8] = _s2uVe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wnI; else goto c2wmY;
       u2wnI: // global
           call _c2wmU(R1) args: 0, res: 0, upd: 0;
       c2wmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wmU() //  [R1]
         { info_tbl: [(c2wmU,
                       label: block_c2wmU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wmU: // global
           _s2uVk::I64 = I64[R1 + 7] & 15;
           if (_s2uVk::I64 != 0) goto u2wnG; else goto c2wnC;
       u2wnG: // global
           I64[Sp + 16] = _s2uVk::I64;
           Sp = Sp + 8;
           call _c2wnd() args: 0, res: 0, upd: 0;
       c2wnC: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wnd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wnd: // global
           Hp = Hp + 16;
           _s2uVk::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wnz; else goto c2wny;
       c2wnz: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wnc_info;
           R1 = _s2uVk::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wny: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2uVf::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2uVf::I64 << _s2uVk::I64) | (_s2uVf::I64 >> 16 - _s2uVk::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wnc() //  [R1]
         { info_tbl: [(c2wnc,
                       label: block_c2wnc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wnc: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wnd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.212231873 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2wnT,
                       label: GHC.Word.$fBitsWord16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wnT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wnX; else goto c2wnY;
       c2wnX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wnY: // global
           I64[Sp - 16] = block_c2wnQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2woF; else goto c2wnR;
       u2woF: // global
           call _c2wnQ(R1) args: 0, res: 0, upd: 0;
       c2wnR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wnQ() //  [R1]
         { info_tbl: [(c2wnQ,
                       label: block_c2wnQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wnQ: // global
           I64[Sp] = block_c2wnW_info;
           _s2uVt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVt::I64;
           if (R1 & 7 != 0) goto u2woE; else goto c2wo0;
       u2woE: // global
           call _c2wnW(R1) args: 0, res: 0, upd: 0;
       c2wo0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wnW() //  [R1]
         { info_tbl: [(c2wnW,
                       label: block_c2wnW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wnW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wo6; else goto c2wo5;
       c2wo6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wo5: // global
           _s2uVt::I64 = I64[Sp + 8];
           _s2uVv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uVv::I64, 0)) goto c2woo; else goto c2woD;
       c2woo: // global
           _s2uVx::I64 = -_s2uVv::I64;
           if (%MO_S_Ge_W64(_s2uVx::I64, 64)) goto c2woC; else goto c2wol;
       c2wol: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVt::I64 >> _s2uVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2woD: // global
           if (%MO_S_Ge_W64(_s2uVv::I64, 64)) goto c2woC; else goto c2woB;
       c2woC: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2woB: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uVt::I64 << _s2uVv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.21435466 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2woN,
                       label: GHC.Word.$fBitsWord16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2woN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2woZ; else goto c2wp0;
       c2woZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wp0: // global
           I64[Sp - 16] = block_c2woK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wp6; else goto c2woL;
       u2wp6: // global
           call _c2woK(R1) args: 0, res: 0, upd: 0;
       c2woL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2woK() //  [R1]
         { info_tbl: [(c2woK,
                       label: block_c2woK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2woK: // global
           I64[Sp] = block_c2woQ_info;
           _s2uVG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVG::I64;
           if (R1 & 7 != 0) goto u2wp5; else goto c2woR;
       u2wp5: // global
           call _c2woQ(R1) args: 0, res: 0, upd: 0;
       c2woR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2woQ() //  [R1]
         { info_tbl: [(c2woQ,
                       label: block_c2woQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2woQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wp4; else goto c2wp3;
       c2wp4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wp3: // global
           _s2uVJ::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.216017972 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2wpe,
                       label: GHC.Word.$fBitsWord16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wpe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wpq; else goto c2wpr;
       c2wpq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wpr: // global
           I64[Sp - 16] = block_c2wpb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wpx; else goto c2wpc;
       u2wpx: // global
           call _c2wpb(R1) args: 0, res: 0, upd: 0;
       c2wpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wpb() //  [R1]
         { info_tbl: [(c2wpb,
                       label: block_c2wpb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wpb: // global
           I64[Sp] = block_c2wph_info;
           _s2uVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVN::I64;
           if (R1 & 7 != 0) goto u2wpw; else goto c2wpi;
       u2wpw: // global
           call _c2wph(R1) args: 0, res: 0, upd: 0;
       c2wpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wph() //  [R1]
         { info_tbl: [(c2wph,
                       label: block_c2wph_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wph: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wpv; else goto c2wpu;
       c2wpv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wpu: // global
           _s2uVQ::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.217700044 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2wpF,
                       label: GHC.Word.$fBitsWord16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wpF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wpR; else goto c2wpS;
       c2wpR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wpS: // global
           I64[Sp - 16] = block_c2wpC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wpY; else goto c2wpD;
       u2wpY: // global
           call _c2wpC(R1) args: 0, res: 0, upd: 0;
       c2wpD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wpC() //  [R1]
         { info_tbl: [(c2wpC,
                       label: block_c2wpC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wpC: // global
           I64[Sp] = block_c2wpI_info;
           _s2uVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVU::I64;
           if (R1 & 7 != 0) goto u2wpX; else goto c2wpJ;
       u2wpX: // global
           call _c2wpI(R1) args: 0, res: 0, upd: 0;
       c2wpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wpI() //  [R1]
         { info_tbl: [(c2wpI,
                       label: block_c2wpI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wpI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wpW; else goto c2wpV;
       c2wpW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wpV: // global
           _s2uVX::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.22003764 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2wq6,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wq6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wqh; else goto c2wqi;
       c2wqh: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wqi: // global
           I64[Sp - 8] = block_c2wq3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wqm; else goto c2wq4;
       u2wqm: // global
           call _c2wq3(R1) args: 0, res: 0, upd: 0;
       c2wq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wq3() //  [R1]
         { info_tbl: [(c2wq3,
                       label: block_c2wq3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wq3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wql; else goto c2wqk;
       c2wql: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wqk: // global
           (_c2wq9::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wq9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.222107906 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2wqu,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wqu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wqF; else goto c2wqG;
       c2wqF: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wqG: // global
           I64[Sp - 8] = block_c2wqr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wqK; else goto c2wqs;
       u2wqK: // global
           call _c2wqr(R1) args: 0, res: 0, upd: 0;
       c2wqs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wqr() //  [R1]
         { info_tbl: [(c2wqr,
                       label: block_c2wqr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wqr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wqJ; else goto c2wqI;
       c2wqJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wqI: // global
           (_c2wqx::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wqx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.223218091 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.22387401 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2wqP,
                       label: GHC.Word.$fBitsWord16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wqP: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.224885105 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2wqY,
                       label: GHC.Word.$fNumWord32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wqY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wr5; else goto c2wr6;
       c2wr5: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wr6: // global
           I64[Sp - 8] = block_c2wqW_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2wqW() //  [R1]
         { info_tbl: [(c2wqW,
                       label: block_c2wqW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wqW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wr9; else goto c2wr8;
       c2wr9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wr8: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.226191217 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { info_tbl: [(c2wre,
                       label: GHC.Word.$fNumWord32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wre: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.227314053 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { info_tbl: [(c2wro,
                       label: GHC.Word.$fNumWord32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wro: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wrE; else goto c2wrF;
       c2wrE: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wrF: // global
           I64[Sp - 8] = block_c2wrl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wrJ; else goto c2wrm;
       u2wrJ: // global
           call _c2wrl(R1) args: 0, res: 0, upd: 0;
       c2wrm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wrl() //  [R1]
         { info_tbl: [(c2wrl,
                       label: block_c2wrl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wrl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wrI; else goto c2wrH;
       c2wrI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wrH: // global
           _s2uWj::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.2299037 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2wrR,
                       label: GHC.Word.$fNumWord32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wrR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ws6; else goto c2ws7;
       c2ws6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ws7: // global
           I64[Sp - 16] = block_c2wrO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wsd; else goto c2wrP;
       u2wsd: // global
           call _c2wrO(R1) args: 0, res: 0, upd: 0;
       c2wrP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wrO() //  [R1]
         { info_tbl: [(c2wrO,
                       label: block_c2wrO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wrO: // global
           I64[Sp] = block_c2wrU_info;
           _s2uWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWn::I64;
           if (R1 & 7 != 0) goto u2wsc; else goto c2wrV;
       u2wsc: // global
           call _c2wrU(R1) args: 0, res: 0, upd: 0;
       c2wrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wrU() //  [R1]
         { info_tbl: [(c2wrU,
                       label: block_c2wrU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wrU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wsb; else goto c2wsa;
       c2wsb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wsa: // global
           _s2uWr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.231567798 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2wsl,
                       label: GHC.Word.$fNumWord32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wsl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wsA; else goto c2wsB;
       c2wsA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wsB: // global
           I64[Sp - 16] = block_c2wsi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wsH; else goto c2wsj;
       u2wsH: // global
           call _c2wsi(R1) args: 0, res: 0, upd: 0;
       c2wsj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wsi() //  [R1]
         { info_tbl: [(c2wsi,
                       label: block_c2wsi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wsi: // global
           I64[Sp] = block_c2wso_info;
           _s2uWv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWv::I64;
           if (R1 & 7 != 0) goto u2wsG; else goto c2wsp;
       u2wsG: // global
           call _c2wso(R1) args: 0, res: 0, upd: 0;
       c2wsp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wso() //  [R1]
         { info_tbl: [(c2wso,
                       label: block_c2wso_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wso: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wsF; else goto c2wsE;
       c2wsF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wsE: // global
           _s2uWz::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.23332235 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2wsP,
                       label: GHC.Word.$fNumWord32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wsP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wt4; else goto c2wt5;
       c2wt4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wt5: // global
           I64[Sp - 16] = block_c2wsM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wtb; else goto c2wsN;
       u2wtb: // global
           call _c2wsM(R1) args: 0, res: 0, upd: 0;
       c2wsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wsM() //  [R1]
         { info_tbl: [(c2wsM,
                       label: block_c2wsM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wsM: // global
           I64[Sp] = block_c2wsS_info;
           _s2uWD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWD::I64;
           if (R1 & 7 != 0) goto u2wta; else goto c2wsT;
       u2wta: // global
           call _c2wsS(R1) args: 0, res: 0, upd: 0;
       c2wsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wsS() //  [R1]
         { info_tbl: [(c2wsS,
                       label: block_c2wsS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wsS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wt9; else goto c2wt8;
       c2wt9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wt8: // global
           _s2uWH::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.234819197 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { info_tbl: [(c2wtj,
                       label: GHC.Word.$ctoInteger2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wtk; else goto c2wtl;
       c2wtk: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wtl: // global
           I64[Sp - 8] = block_c2wtg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wtq; else goto c2wth;
       u2wtq: // global
           call _c2wtg(R1) args: 0, res: 0, upd: 0;
       c2wth: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wtg() //  [R1]
         { info_tbl: [(c2wtg,
                       label: block_c2wtg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtg: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.236106627 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2wty,
                       label: GHC.Word.$fBitsWord32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wty: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wtJ; else goto c2wtK;
       c2wtJ: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wtK: // global
           I64[Sp - 8] = block_c2wtv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wtO; else goto c2wtw;
       u2wtO: // global
           call _c2wtv(R1) args: 0, res: 0, upd: 0;
       c2wtw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wtv() //  [R1]
         { info_tbl: [(c2wtv,
                       label: block_c2wtv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wtN; else goto c2wtM;
       c2wtN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wtM: // global
           (_c2wtB::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wtB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.237656235 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wtW,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wu8; else goto c2wu9;
       c2wu8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wu9: // global
           I64[Sp - 16] = block_c2wtT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wuf; else goto c2wtU;
       u2wuf: // global
           call _c2wtT(R1) args: 0, res: 0, upd: 0;
       c2wtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wtT() //  [R1]
         { info_tbl: [(c2wtT,
                       label: block_c2wtT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtT: // global
           I64[Sp] = block_c2wtZ_info;
           _s2uWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWU::I64;
           if (R1 & 7 != 0) goto u2wue; else goto c2wu0;
       u2wue: // global
           call _c2wtZ(R1) args: 0, res: 0, upd: 0;
       c2wu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wtZ() //  [R1]
         { info_tbl: [(c2wtZ,
                       label: block_c2wtZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wtZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wud; else goto c2wuc;
       c2wud: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wuc: // global
           _s2uWX::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.239550185 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wun,
                       label: GHC.Word.$fBitsWord32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wun: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wur; else goto c2wus;
       c2wur: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wus: // global
           I64[Sp - 16] = block_c2wuk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wuM; else goto c2wul;
       u2wuM: // global
           call _c2wuk(R1) args: 0, res: 0, upd: 0;
       c2wul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wuk() //  [R1]
         { info_tbl: [(c2wuk,
                       label: block_c2wuk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wuk: // global
           I64[Sp] = block_c2wuq_info;
           _s2uX1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX1::I64;
           if (R1 & 7 != 0) goto u2wuL; else goto c2wuu;
       u2wuL: // global
           call _c2wuq(R1) args: 0, res: 0, upd: 0;
       c2wuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wuq() //  [R1]
         { info_tbl: [(c2wuq,
                       label: block_c2wuq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wuq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wuA; else goto c2wuz;
       c2wuA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wuz: // global
           _s2uX3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uX3::I64, 64)) goto c2wuJ; else goto c2wuK;
       c2wuJ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uX3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wuK: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.241445375 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wuU,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wuU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wv9; else goto c2wva;
       c2wv9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wva: // global
           I64[Sp - 16] = block_c2wuR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wvg; else goto c2wuS;
       u2wvg: // global
           call _c2wuR(R1) args: 0, res: 0, upd: 0;
       c2wuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wuR() //  [R1]
         { info_tbl: [(c2wuR,
                       label: block_c2wuR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wuR: // global
           I64[Sp] = block_c2wuX_info;
           _s2uX9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX9::I64;
           if (R1 & 7 != 0) goto u2wvf; else goto c2wuY;
       u2wvf: // global
           call _c2wuX(R1) args: 0, res: 0, upd: 0;
       c2wuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wuX() //  [R1]
         { info_tbl: [(c2wuX,
                       label: block_c2wuX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wuX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wve; else goto c2wvd;
       c2wve: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wvd: // global
           _s2uXd::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.24316534 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wvo,
                       label: GHC.Word.$fBitsWord32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wvo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wvs; else goto c2wvt;
       c2wvs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wvt: // global
           I64[Sp - 16] = block_c2wvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wvQ; else goto c2wvm;
       u2wvQ: // global
           call _c2wvl(R1) args: 0, res: 0, upd: 0;
       c2wvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wvl() //  [R1]
         { info_tbl: [(c2wvl,
                       label: block_c2wvl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wvl: // global
           I64[Sp] = block_c2wvr_info;
           _s2uXh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXh::I64;
           if (R1 & 7 != 0) goto u2wvP; else goto c2wvv;
       u2wvP: // global
           call _c2wvr(R1) args: 0, res: 0, upd: 0;
       c2wvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wvr() //  [R1]
         { info_tbl: [(c2wvr,
                       label: block_c2wvr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wvr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wvB; else goto c2wvA;
       c2wvB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wvA: // global
           _s2uXj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXj::I64, 64)) goto c2wvN; else goto c2wvO;
       c2wvN: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2uXj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wvO: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.244693578 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { info_tbl: [(c2wvV,
                       label: GHC.Word.$fBitsWord32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wvV: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.246447356 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2ww5,
                       label: GHC.Word.$fBitsWord32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ww5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ww9; else goto c2wwa;
       c2ww9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wwa: // global
           I64[Sp - 16] = block_c2ww2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wwX; else goto c2ww3;
       u2wwX: // global
           call _c2ww2(R1) args: 0, res: 0, upd: 0;
       c2ww3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ww2() //  [R1]
         { info_tbl: [(c2ww2,
                       label: block_c2ww2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ww2: // global
           I64[Sp - 8] = block_c2ww8_info;
           _s2uXq::P64 = R1;
           _s2uXr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uXr::I64;
           P64[Sp + 8] = _s2uXq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wwW; else goto c2wwc;
       u2wwW: // global
           call _c2ww8(R1) args: 0, res: 0, upd: 0;
       c2wwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ww8() //  [R1]
         { info_tbl: [(c2ww8,
                       label: block_c2ww8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ww8: // global
           _s2uXw::I64 = I64[R1 + 7] & 31;
           if (_s2uXw::I64 != 0) goto u2wwU; else goto c2wwQ;
       u2wwU: // global
           I64[Sp + 16] = _s2uXw::I64;
           Sp = Sp + 8;
           call _c2wwr() args: 0, res: 0, upd: 0;
       c2wwQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wwr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wwr: // global
           Hp = Hp + 16;
           _s2uXw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wwN; else goto c2wwM;
       c2wwN: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wwq_info;
           R1 = _s2uXw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wwM: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2uXr::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2uXr::I64 << _s2uXw::I64) | (_s2uXr::I64 >> 32 - _s2uXw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wwq() //  [R1]
         { info_tbl: [(c2wwq,
                       label: block_c2wwq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wwq: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wwr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.249692853 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2wx7,
                       label: GHC.Word.$fBitsWord32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wxb; else goto c2wxc;
       c2wxb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wxc: // global
           I64[Sp - 16] = block_c2wx4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wxT; else goto c2wx5;
       u2wxT: // global
           call _c2wx4(R1) args: 0, res: 0, upd: 0;
       c2wx5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wx4() //  [R1]
         { info_tbl: [(c2wx4,
                       label: block_c2wx4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wx4: // global
           I64[Sp] = block_c2wxa_info;
           _s2uXF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXF::I64;
           if (R1 & 7 != 0) goto u2wxS; else goto c2wxe;
       u2wxS: // global
           call _c2wxa(R1) args: 0, res: 0, upd: 0;
       c2wxe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wxa() //  [R1]
         { info_tbl: [(c2wxa,
                       label: block_c2wxa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wxa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wxk; else goto c2wxj;
       c2wxk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wxj: // global
           _s2uXF::I64 = I64[Sp + 8];
           _s2uXH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXH::I64, 0)) goto c2wxC; else goto c2wxR;
       c2wxC: // global
           _s2uXJ::I64 = -_s2uXH::I64;
           if (%MO_S_Ge_W64(_s2uXJ::I64, 64)) goto c2wxQ; else goto c2wxz;
       c2wxz: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXF::I64 >> _s2uXJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wxR: // global
           if (%MO_S_Ge_W64(_s2uXH::I64, 64)) goto c2wxQ; else goto c2wxP;
       c2wxQ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wxP: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uXF::I64 << _s2uXH::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.251617138 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2wy1,
                       label: GHC.Word.$fBitsWord32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wy1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wyd; else goto c2wye;
       c2wyd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wye: // global
           I64[Sp - 16] = block_c2wxY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wyk; else goto c2wxZ;
       u2wyk: // global
           call _c2wxY(R1) args: 0, res: 0, upd: 0;
       c2wxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wxY() //  [R1]
         { info_tbl: [(c2wxY,
                       label: block_c2wxY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wxY: // global
           I64[Sp] = block_c2wy4_info;
           _s2uXS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXS::I64;
           if (R1 & 7 != 0) goto u2wyj; else goto c2wy5;
       u2wyj: // global
           call _c2wy4(R1) args: 0, res: 0, upd: 0;
       c2wy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wy4() //  [R1]
         { info_tbl: [(c2wy4,
                       label: block_c2wy4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wy4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wyi; else goto c2wyh;
       c2wyi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wyh: // global
           _s2uXV::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.253317761 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2wys,
                       label: GHC.Word.$fBitsWord32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wys: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wyE; else goto c2wyF;
       c2wyE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wyF: // global
           I64[Sp - 16] = block_c2wyp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wyL; else goto c2wyq;
       u2wyL: // global
           call _c2wyp(R1) args: 0, res: 0, upd: 0;
       c2wyq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wyp() //  [R1]
         { info_tbl: [(c2wyp,
                       label: block_c2wyp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wyp: // global
           I64[Sp] = block_c2wyv_info;
           _s2uXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXZ::I64;
           if (R1 & 7 != 0) goto u2wyK; else goto c2wyw;
       u2wyK: // global
           call _c2wyv(R1) args: 0, res: 0, upd: 0;
       c2wyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wyv() //  [R1]
         { info_tbl: [(c2wyv,
                       label: block_c2wyv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wyv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wyJ; else goto c2wyI;
       c2wyJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wyI: // global
           _s2uY2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.254954391 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2wyT,
                       label: GHC.Word.$fBitsWord32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wyT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wz5; else goto c2wz6;
       c2wz5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wz6: // global
           I64[Sp - 16] = block_c2wyQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wzc; else goto c2wyR;
       u2wzc: // global
           call _c2wyQ(R1) args: 0, res: 0, upd: 0;
       c2wyR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wyQ() //  [R1]
         { info_tbl: [(c2wyQ,
                       label: block_c2wyQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wyQ: // global
           I64[Sp] = block_c2wyW_info;
           _s2uY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uY6::I64;
           if (R1 & 7 != 0) goto u2wzb; else goto c2wyX;
       u2wzb: // global
           call _c2wyW(R1) args: 0, res: 0, upd: 0;
       c2wyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wyW() //  [R1]
         { info_tbl: [(c2wyW,
                       label: block_c2wyW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wyW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wza; else goto c2wz9;
       c2wza: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wz9: // global
           _s2uY9::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.256557008 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2wzk,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wzk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wzv; else goto c2wzw;
       c2wzv: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wzw: // global
           I64[Sp - 8] = block_c2wzh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wzA; else goto c2wzi;
       u2wzA: // global
           call _c2wzh(R1) args: 0, res: 0, upd: 0;
       c2wzi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wzh() //  [R1]
         { info_tbl: [(c2wzh,
                       label: block_c2wzh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wzh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wzz; else goto c2wzy;
       c2wzz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wzy: // global
           (_c2wzn::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wzn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.257963807 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2wzI,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wzI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wzT; else goto c2wzU;
       c2wzT: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wzU: // global
           I64[Sp - 8] = block_c2wzF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wzY; else goto c2wzG;
       u2wzY: // global
           call _c2wzF(R1) args: 0, res: 0, upd: 0;
       c2wzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wzF() //  [R1]
         { info_tbl: [(c2wzF,
                       label: block_c2wzF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wzF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wzX; else goto c2wzW;
       c2wzX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wzW: // global
           (_c2wzL::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wzL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.259109053 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.259771881 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2wA3,
                       label: GHC.Word.$fBitsWord32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wA3: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.260785167 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2wAd,
                       label: GHC.Word.$fBitsWord64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wAo; else goto c2wAp;
       c2wAo: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wAp: // global
           I64[Sp - 8] = block_c2wAa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wAt; else goto c2wAb;
       u2wAt: // global
           call _c2wAa(R1) args: 0, res: 0, upd: 0;
       c2wAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wAa() //  [R1]
         { info_tbl: [(c2wAa,
                       label: block_c2wAa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wAs; else goto c2wAr;
       c2wAs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wAr: // global
           (_c2wAg::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wAg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.262316379 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wAB,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wAN; else goto c2wAO;
       c2wAN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wAO: // global
           I64[Sp - 16] = block_c2wAy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wAU; else goto c2wAz;
       u2wAU: // global
           call _c2wAy(R1) args: 0, res: 0, upd: 0;
       c2wAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wAy() //  [R1]
         { info_tbl: [(c2wAy,
                       label: block_c2wAy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAy: // global
           I64[Sp] = block_c2wAE_info;
           _s2uYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYt::I64;
           if (R1 & 7 != 0) goto u2wAT; else goto c2wAF;
       u2wAT: // global
           call _c2wAE(R1) args: 0, res: 0, upd: 0;
       c2wAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wAE() //  [R1]
         { info_tbl: [(c2wAE,
                       label: block_c2wAE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wAS; else goto c2wAR;
       c2wAS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wAR: // global
           _s2uYw::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.264093644 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2wB2,
                       label: GHC.Word.$fBitsWord64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wB2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wB6; else goto c2wB7;
       c2wB6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wB7: // global
           I64[Sp - 16] = block_c2wAZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wBr; else goto c2wB0;
       u2wBr: // global
           call _c2wAZ(R1) args: 0, res: 0, upd: 0;
       c2wB0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wAZ() //  [R1]
         { info_tbl: [(c2wAZ,
                       label: block_c2wAZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wAZ: // global
           I64[Sp] = block_c2wB5_info;
           _s2uYA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYA::I64;
           if (R1 & 7 != 0) goto u2wBq; else goto c2wB9;
       u2wBq: // global
           call _c2wB5(R1) args: 0, res: 0, upd: 0;
       c2wB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wB5() //  [R1]
         { info_tbl: [(c2wB5,
                       label: block_c2wB5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wB5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wBf; else goto c2wBe;
       c2wBf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wBe: // global
           _s2uYC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYC::I64, 64)) goto c2wBo; else goto c2wBp;
       c2wBo: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uYC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wBp: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.265983924 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wBz,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wBz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wBL; else goto c2wBM;
       c2wBL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wBM: // global
           I64[Sp - 16] = block_c2wBw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wBS; else goto c2wBx;
       u2wBS: // global
           call _c2wBw(R1) args: 0, res: 0, upd: 0;
       c2wBx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wBw() //  [R1]
         { info_tbl: [(c2wBw,
                       label: block_c2wBw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wBw: // global
           I64[Sp] = block_c2wBC_info;
           _s2uYI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYI::I64;
           if (R1 & 7 != 0) goto u2wBR; else goto c2wBD;
       u2wBR: // global
           call _c2wBC(R1) args: 0, res: 0, upd: 0;
       c2wBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wBC() //  [R1]
         { info_tbl: [(c2wBC,
                       label: block_c2wBC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wBC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wBQ; else goto c2wBP;
       c2wBQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wBP: // global
           _s2uYL::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.268583624 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2wC0,
                       label: GHC.Word.$fBitsWord64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wC4; else goto c2wC5;
       c2wC4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wC5: // global
           I64[Sp - 16] = block_c2wBX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wCp; else goto c2wBY;
       u2wCp: // global
           call _c2wBX(R1) args: 0, res: 0, upd: 0;
       c2wBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wBX() //  [R1]
         { info_tbl: [(c2wBX,
                       label: block_c2wBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wBX: // global
           I64[Sp] = block_c2wC3_info;
           _s2uYP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYP::I64;
           if (R1 & 7 != 0) goto u2wCo; else goto c2wC7;
       u2wCo: // global
           call _c2wC3(R1) args: 0, res: 0, upd: 0;
       c2wC7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wC3() //  [R1]
         { info_tbl: [(c2wC3,
                       label: block_c2wC3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wC3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wCd; else goto c2wCc;
       c2wCd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wCc: // global
           _s2uYR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYR::I64, 64)) goto c2wCm; else goto c2wCn;
       c2wCm: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2uYR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wCn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.270358067 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { info_tbl: [(c2wCu,
                       label: GHC.Word.$fBitsWord64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wCu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.271625119 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2wCE,
                       label: GHC.Word.$fBitsWord64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wCE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wCI; else goto c2wCJ;
       c2wCI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wCJ: // global
           I64[Sp - 16] = block_c2wCB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wDt; else goto c2wCC;
       u2wDt: // global
           call _c2wCB(R1) args: 0, res: 0, upd: 0;
       c2wCC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wCB() //  [R1]
         { info_tbl: [(c2wCB,
                       label: block_c2wCB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wCB: // global
           I64[Sp - 8] = block_c2wCH_info;
           _s2uYX::P64 = R1;
           _s2uYY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uYY::I64;
           P64[Sp + 8] = _s2uYX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wDs; else goto c2wCL;
       u2wDs: // global
           call _c2wCH(R1) args: 0, res: 0, upd: 0;
       c2wCL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wCH() //  [R1]
         { info_tbl: [(c2wCH,
                       label: block_c2wCH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wCH: // global
           _s2uZ3::I64 = I64[R1 + 7] & 63;
           if (_s2uZ3::I64 != 0) goto u2wDq; else goto c2wDm;
       u2wDq: // global
           I64[Sp + 16] = _s2uZ3::I64;
           Sp = Sp + 8;
           call _c2wD0() args: 0, res: 0, upd: 0;
       c2wDm: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wD0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wD0: // global
           Hp = Hp + 16;
           _s2uZ3::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wDj; else goto c2wDi;
       c2wDj: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wCZ_info;
           R1 = _s2uZ3::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wDi: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2uYY::I64 = I64[Sp];
           I64[Hp] = (_s2uYY::I64 << _s2uZ3::I64) | (_s2uYY::I64 >> 64 - _s2uZ3::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wCZ() //  [R1]
         { info_tbl: [(c2wCZ,
                       label: block_c2wCZ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wCZ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wD0() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.273902675 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2wDD,
                       label: GHC.Word.$fBitsWord64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wDD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wDH; else goto c2wDI;
       c2wDH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wDI: // global
           I64[Sp - 16] = block_c2wDA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wEm; else goto c2wDB;
       u2wEm: // global
           call _c2wDA(R1) args: 0, res: 0, upd: 0;
       c2wDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wDA() //  [R1]
         { info_tbl: [(c2wDA,
                       label: block_c2wDA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wDA: // global
           I64[Sp] = block_c2wDG_info;
           _s2uZb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZb::I64;
           if (R1 & 7 != 0) goto u2wEl; else goto c2wDK;
       u2wEl: // global
           call _c2wDG(R1) args: 0, res: 0, upd: 0;
       c2wDK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wDG() //  [R1]
         { info_tbl: [(c2wDG,
                       label: block_c2wDG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wDG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wDQ; else goto c2wDP;
       c2wDQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wDP: // global
           _s2uZb::I64 = I64[Sp + 8];
           _s2uZd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uZd::I64, 0)) goto c2wE8; else goto c2wEk;
       c2wE8: // global
           _s2uZf::I64 = -_s2uZd::I64;
           if (%MO_S_Ge_W64(_s2uZf::I64, 64)) goto c2wEj; else goto c2wE5;
       c2wE5: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 >> _s2uZf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wEk: // global
           if (%MO_S_Ge_W64(_s2uZd::I64, 64)) goto c2wEj; else goto c2wEi;
       c2wEj: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wEi: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 << _s2uZd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.275923961 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2wEu,
                       label: GHC.Word.$fBitsWord64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wEu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wEG; else goto c2wEH;
       c2wEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wEH: // global
           I64[Sp - 16] = block_c2wEr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wEN; else goto c2wEs;
       u2wEN: // global
           call _c2wEr(R1) args: 0, res: 0, upd: 0;
       c2wEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wEr() //  [R1]
         { info_tbl: [(c2wEr,
                       label: block_c2wEr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wEr: // global
           I64[Sp] = block_c2wEx_info;
           _s2uZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZn::I64;
           if (R1 & 7 != 0) goto u2wEM; else goto c2wEy;
       u2wEM: // global
           call _c2wEx(R1) args: 0, res: 0, upd: 0;
       c2wEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wEx() //  [R1]
         { info_tbl: [(c2wEx,
                       label: block_c2wEx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wEx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wEL; else goto c2wEK;
       c2wEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wEK: // global
           _s2uZq::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.277727291 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2wEV,
                       label: GHC.Word.$fBitsWord64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wEV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wF7; else goto c2wF8;
       c2wF7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wF8: // global
           I64[Sp - 16] = block_c2wES_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wFe; else goto c2wET;
       u2wFe: // global
           call _c2wES(R1) args: 0, res: 0, upd: 0;
       c2wET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wES() //  [R1]
         { info_tbl: [(c2wES,
                       label: block_c2wES_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wES: // global
           I64[Sp] = block_c2wEY_info;
           _s2uZu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZu::I64;
           if (R1 & 7 != 0) goto u2wFd; else goto c2wEZ;
       u2wFd: // global
           call _c2wEY(R1) args: 0, res: 0, upd: 0;
       c2wEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wEY() //  [R1]
         { info_tbl: [(c2wEY,
                       label: block_c2wEY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wEY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wFc; else goto c2wFb;
       c2wFc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wFb: // global
           _s2uZx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.27940075 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2wFm,
                       label: GHC.Word.$fBitsWord64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wFy; else goto c2wFz;
       c2wFy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wFz: // global
           I64[Sp - 16] = block_c2wFj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wFF; else goto c2wFk;
       u2wFF: // global
           call _c2wFj(R1) args: 0, res: 0, upd: 0;
       c2wFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wFj() //  [R1]
         { info_tbl: [(c2wFj,
                       label: block_c2wFj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wFj: // global
           I64[Sp] = block_c2wFp_info;
           _s2uZB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZB::I64;
           if (R1 & 7 != 0) goto u2wFE; else goto c2wFq;
       u2wFE: // global
           call _c2wFp(R1) args: 0, res: 0, upd: 0;
       c2wFq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wFp() //  [R1]
         { info_tbl: [(c2wFp,
                       label: block_c2wFp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wFp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wFD; else goto c2wFC;
       c2wFD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wFC: // global
           _s2uZE::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.280961866 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2wFN,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wFN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wFY; else goto c2wFZ;
       c2wFY: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wFZ: // global
           I64[Sp - 8] = block_c2wFK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wG3; else goto c2wFL;
       u2wG3: // global
           call _c2wFK(R1) args: 0, res: 0, upd: 0;
       c2wFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wFK() //  [R1]
         { info_tbl: [(c2wFK,
                       label: block_c2wFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wFK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wG2; else goto c2wG1;
       c2wG2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wG1: // global
           (_c2wFQ::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wFQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.282748664 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2wGb,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wGm; else goto c2wGn;
       c2wGm: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wGn: // global
           I64[Sp - 8] = block_c2wG8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wGr; else goto c2wG9;
       u2wGr: // global
           call _c2wG8(R1) args: 0, res: 0, upd: 0;
       c2wG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wG8() //  [R1]
         { info_tbl: [(c2wG8,
                       label: block_c2wG8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wG8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wGq; else goto c2wGp;
       c2wGq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wGp: // global
           (_c2wGe::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2wGe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.283901171 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.284637355 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2wGw,
                       label: GHC.Word.$fBitsWord64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGw: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.285935328 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { info_tbl: [(c2wGG,
                       label: GHC.Word.eqWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wGK; else goto c2wGL;
       c2wGK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wGL: // global
           I64[Sp - 16] = block_c2wGD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wGU; else goto c2wGE;
       u2wGU: // global
           call _c2wGD(R1) args: 0, res: 0, upd: 0;
       c2wGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wGD() //  [R1]
         { info_tbl: [(c2wGD,
                       label: block_c2wGD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGD: // global
           I64[Sp] = block_c2wGJ_info;
           _s2uZT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZT::I64;
           if (R1 & 7 != 0) goto u2wGT; else goto c2wGN;
       u2wGT: // global
           call _c2wGJ(R1) args: 0, res: 0, upd: 0;
       c2wGN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wGJ() //  [R1]
         { info_tbl: [(c2wGJ,
                       label: block_c2wGJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGJ: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.288186662 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.288760093 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.289801804 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { info_tbl: [(c2wH2,
                       label: GHC.Word.$fNumWord8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wH2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wH3; else goto c2wH4;
       c2wH3: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wH4: // global
           I64[Sp - 8] = block_c2wGZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wHc; else goto c2wH0;
       u2wHc: // global
           call _c2wGZ(R1) args: 0, res: 0, upd: 0;
       c2wH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wGZ() //  [R1]
         { info_tbl: [(c2wGZ,
                       label: block_c2wGZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wGZ: // global
           if (I64[R1 + 7] == 0) goto c2wHb; else goto c2wHa;
       c2wHb: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wHa: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.29092742 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.291885724 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2wHk,
                       label: GHC.Word.$fBitsWord8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wHk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wHr; else goto c2wHs;
       c2wHr: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wHs: // global
           I64[Sp - 8] = block_c2wHh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wHw; else goto c2wHi;
       u2wHw: // global
           call _c2wHh(R1) args: 0, res: 0, upd: 0;
       c2wHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wHh() //  [R1]
         { info_tbl: [(c2wHh,
                       label: block_c2wHh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wHh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wHv; else goto c2wHu;
       c2wHv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wHu: // global
           _s2v04::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v04::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.293064321 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.293847222 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2wHB,
                       label: GHC.Word.$fBitsWord8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wHB: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.295007689 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { info_tbl: [(c2wHL,
                       label: GHC.Word.$fBitsWord8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wHL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wHM; else goto c2wHN;
       c2wHM: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wHN: // global
           I64[Sp - 8] = block_c2wHI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wI6; else goto c2wHJ;
       u2wI6: // global
           call _c2wHI(R1) args: 0, res: 0, upd: 0;
       c2wHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wHI() //  [R1]
         { info_tbl: [(c2wHI,
                       label: block_c2wHI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wHI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wHS; else goto c2wHR;
       c2wHS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wHR: // global
           _s2v08::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v08::I64, 64)) goto c2wI4; else goto c2wI5;
       c2wI4: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v08::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wI5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.296770625 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2wIe,
                       label: GHC.Word.$fBitsWord8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wIe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wIi; else goto c2wIj;
       c2wIi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wIj: // global
           I64[Sp - 16] = block_c2wIb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wIS; else goto c2wIc;
       u2wIS: // global
           call _c2wIb(R1) args: 0, res: 0, upd: 0;
       c2wIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wIb() //  [R1]
         { info_tbl: [(c2wIb,
                       label: block_c2wIb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wIb: // global
           I64[Sp] = block_c2wIh_info;
           _s2v0f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0f::I64;
           if (R1 & 7 != 0) goto u2wIR; else goto c2wIl;
       u2wIR: // global
           call _c2wIh(R1) args: 0, res: 0, upd: 0;
       c2wIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wIh() //  [R1]
         { info_tbl: [(c2wIh,
                       label: block_c2wIh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wIh: // global
           _s2v0h::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v0h::I64, 64)) goto c2wIQ; else goto c2wIP;
       c2wIP: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0h::I64)) == 0) goto c2wIQ; else goto c2wIE;
       c2wIQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wIE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.298828537 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2wJ0,
                       label: GHC.Word.$fBitsWord8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wJ0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wJ4; else goto c2wJ5;
       c2wJ4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wJ5: // global
           I64[Sp - 16] = block_c2wIX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wJV; else goto c2wIY;
       u2wJV: // global
           call _c2wIX(R1) args: 0, res: 0, upd: 0;
       c2wIY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wIX() //  [R1]
         { info_tbl: [(c2wIX,
                       label: block_c2wIX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wIX: // global
           I64[Sp - 8] = block_c2wJ3_info;
           _s2v0o::P64 = R1;
           _s2v0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0p::I64;
           P64[Sp + 8] = _s2v0o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wJU; else goto c2wJ7;
       u2wJU: // global
           call _c2wJ3(R1) args: 0, res: 0, upd: 0;
       c2wJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wJ3() //  [R1]
         { info_tbl: [(c2wJ3,
                       label: block_c2wJ3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wJ3: // global
           _s2v0v::I64 = -I64[R1 + 7] & 7;
           if (_s2v0v::I64 != 0) goto u2wJS; else goto c2wJO;
       u2wJS: // global
           I64[Sp + 16] = _s2v0v::I64;
           Sp = Sp + 8;
           call _c2wJp() args: 0, res: 0, upd: 0;
       c2wJO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wJp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wJp: // global
           Hp = Hp + 16;
           _s2v0v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wJL; else goto c2wJK;
       c2wJL: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wJo_info;
           R1 = _s2v0v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wJK: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2v0p::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2v0p::I64 << _s2v0v::I64) | (_s2v0p::I64 >> 8 - _s2v0v::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wJo() //  [R1]
         { info_tbl: [(c2wJo,
                       label: block_c2wJo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wJo: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wJp() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.300650099 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2wK2,
                       label: GHC.Word.$fBitsWord8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wK2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.30193431 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2wKc,
                       label: GHC.Word.$fBitsWord8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wKc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wKg; else goto c2wKh;
       c2wKg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wKh: // global
           I64[Sp - 16] = block_c2wK9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wKH; else goto c2wKa;
       u2wKH: // global
           call _c2wK9(R1) args: 0, res: 0, upd: 0;
       c2wKa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wK9() //  [R1]
         { info_tbl: [(c2wK9,
                       label: block_c2wK9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wK9: // global
           I64[Sp - 8] = block_c2wKf_info;
           _s2v0D::P64 = R1;
           _s2v0E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0E::I64;
           P64[Sp + 8] = _s2v0D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wKG; else goto c2wKj;
       u2wKG: // global
           call _c2wKf(R1) args: 0, res: 0, upd: 0;
       c2wKj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wKf() //  [R1]
         { info_tbl: [(c2wKf,
                       label: block_c2wKf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wKf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wKp; else goto c2wKo;
       c2wKp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wKo: // global
           _s2v0G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0G::I64, 64)) goto c2wKE; else goto c2wKF;
       c2wKE: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0G::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wKF: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.303980167 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2wKP,
                       label: GHC.Word.$fBitsWord8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wKP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wKT; else goto c2wKU;
       c2wKT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wKU: // global
           I64[Sp - 16] = block_c2wKM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wLs; else goto c2wKN;
       u2wLs: // global
           call _c2wKM(R1) args: 0, res: 0, upd: 0;
       c2wKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wKM() //  [R1]
         { info_tbl: [(c2wKM,
                       label: block_c2wKM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wKM: // global
           I64[Sp] = block_c2wKS_info;
           _s2v0O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0O::I64;
           if (R1 & 7 != 0) goto u2wLr; else goto c2wKW;
       u2wLr: // global
           call _c2wKS(R1) args: 0, res: 0, upd: 0;
       c2wKW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wKS() //  [R1]
         { info_tbl: [(c2wKS,
                       label: block_c2wKS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wKS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wL2; else goto c2wL1;
       c2wL2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wL1: // global
           _s2v0O::I64 = I64[Sp + 8];
           _s2v0Q::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0Q::I64, 64)) goto c2wLk; else goto c2wLq;
       c2wLk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0Q::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wLq: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.306331304 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2wLA,
                       label: GHC.Word.$fBitsWord8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wLA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wLE; else goto c2wLF;
       c2wLE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wLF: // global
           I64[Sp - 16] = block_c2wLx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wM5; else goto c2wLy;
       u2wM5: // global
           call _c2wLx(R1) args: 0, res: 0, upd: 0;
       c2wLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wLx() //  [R1]
         { info_tbl: [(c2wLx,
                       label: block_c2wLx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wLx: // global
           I64[Sp - 8] = block_c2wLD_info;
           _s2v0Z::P64 = R1;
           _s2v10::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v10::I64;
           P64[Sp + 8] = _s2v0Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wM4; else goto c2wLH;
       u2wM4: // global
           call _c2wLD(R1) args: 0, res: 0, upd: 0;
       c2wLH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wLD() //  [R1]
         { info_tbl: [(c2wLD,
                       label: block_c2wLD_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wLD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wLN; else goto c2wLM;
       c2wLN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wLM: // global
           _s2v12::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v12::I64, 64)) goto c2wM2; else goto c2wM3;
       c2wM2: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v12::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wM3: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.308759375 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.309506125 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.310628418 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2wMd,
                       label: GHC.Word.$fIntegralWord8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wMh; else goto c2wMi;
       c2wMh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wMi: // global
           I64[Sp - 16] = block_c2wMa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wMB; else goto c2wMb;
       u2wMB: // global
           call _c2wMa(R1) args: 0, res: 0, upd: 0;
       c2wMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wMa() //  [R1]
         { info_tbl: [(c2wMa,
                       label: block_c2wMa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMa: // global
           I64[Sp] = block_c2wMg_info;
           _s2v1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1a::I64;
           if (R1 & 7 != 0) goto u2wMA; else goto c2wMk;
       u2wMA: // global
           call _c2wMg(R1) args: 0, res: 0, upd: 0;
       c2wMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wMg() //  [R1]
         { info_tbl: [(c2wMg,
                       label: block_c2wMg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wMq; else goto c2wMp;
       c2wMq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wMp: // global
           _s2v1d::I64 = I64[R1 + 7];
           if (_s2v1d::I64 != 0) goto c2wMy; else goto c2wMz;
       c2wMy: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v1d::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wMz: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.312561193 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2wMJ,
                       label: GHC.Word.$fIntegralWord8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wMN; else goto c2wMO;
       c2wMN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wMO: // global
           I64[Sp - 16] = block_c2wMG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wN7; else goto c2wMH;
       u2wN7: // global
           call _c2wMG(R1) args: 0, res: 0, upd: 0;
       c2wMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wMG() //  [R1]
         { info_tbl: [(c2wMG,
                       label: block_c2wMG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMG: // global
           I64[Sp] = block_c2wMM_info;
           _s2v1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1i::I64;
           if (R1 & 7 != 0) goto u2wN6; else goto c2wMQ;
       u2wN6: // global
           call _c2wMM(R1) args: 0, res: 0, upd: 0;
       c2wMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wMM() //  [R1]
         { info_tbl: [(c2wMM,
                       label: block_c2wMM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wMM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wMW; else goto c2wMV;
       c2wMW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wMV: // global
           _s2v1l::I64 = I64[R1 + 7];
           if (_s2v1l::I64 != 0) goto c2wN4; else goto c2wN5;
       c2wN4: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v1l::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wN5: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.314522938 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2wNf,
                       label: GHC.Word.$fIntegralWord8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wNj; else goto c2wNk;
       c2wNj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wNk: // global
           I64[Sp - 16] = block_c2wNc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wNC; else goto c2wNd;
       u2wNC: // global
           call _c2wNc(R1) args: 0, res: 0, upd: 0;
       c2wNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wNc() //  [R1]
         { info_tbl: [(c2wNc,
                       label: block_c2wNc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNc: // global
           I64[Sp] = block_c2wNi_info;
           _s2v1q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1q::I64;
           if (R1 & 7 != 0) goto u2wNB; else goto c2wNm;
       u2wNB: // global
           call _c2wNi(R1) args: 0, res: 0, upd: 0;
       c2wNm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wNi() //  [R1]
         { info_tbl: [(c2wNi,
                       label: block_c2wNi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2wNs; else goto c2wNr;
       c2wNs: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wNr: // global
           _s2v1t::I64 = I64[R1 + 7];
           if (_s2v1t::I64 != 0) goto c2wNz; else goto c2wNA;
       c2wNz: // global
           (_s2v1v::I64, _s2v1w::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v1t::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2v1w::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2v1v::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wNA: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.316798899 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2v1J_entry() //  [R1]
         { info_tbl: [(c2wNZ,
                       label: sat_s2v1J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNZ: // global
           _s2v1J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2wO2; else goto c2wO3;
       c2wO3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wO5; else goto c2wO4;
       c2wO5: // global
           HpAlloc = 16;
           goto c2wO2;
       c2wO2: // global
           R1 = _s2v1J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2wO4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1J::P64;
           _s2v1I::I64 = I64[_s2v1J::P64 + 16] % I64[_s2v1J::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1I::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v1H_entry() //  [R1]
         { info_tbl: [(c2wOc,
                       label: sat_s2v1H_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOc: // global
           _s2v1H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2wOf; else goto c2wOg;
       c2wOg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wOi; else goto c2wOh;
       c2wOi: // global
           HpAlloc = 16;
           goto c2wOf;
       c2wOf: // global
           R1 = _s2v1H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2wOh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1H::P64;
           _s2v1G::I64 = I64[_s2v1H::P64 + 16] / I64[_s2v1H::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1G::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2wOj,
                       label: GHC.Word.$fIntegralWord8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wOk; else goto c2wOl;
       c2wOk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wOl: // global
           I64[Sp - 16] = block_c2wNH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wOv; else goto c2wNI;
       u2wOv: // global
           call _c2wNH(R1) args: 0, res: 0, upd: 0;
       c2wNI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wNH() //  [R1]
         { info_tbl: [(c2wNH,
                       label: block_c2wNH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNH: // global
           I64[Sp] = block_c2wNM_info;
           _s2v1C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1C::I64;
           if (R1 & 7 != 0) goto u2wOu; else goto c2wNN;
       u2wOu: // global
           call _c2wNM(R1) args: 0, res: 0, upd: 0;
       c2wNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wNM() //  [R1]
         { info_tbl: [(c2wNM,
                       label: block_c2wNM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wNM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2wOp; else goto c2wOo;
       c2wOp: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wOo: // global
           _s2v1F::I64 = I64[R1 + 7];
           if (_s2v1F::I64 != 0) goto c2wOs; else goto c2wOt;
       c2wOs: // global
           I64[Hp - 80] = sat_s2v1J_info;
           _s2v1C::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v1C::I64;
           I64[Hp - 56] = _s2v1F::I64;
           I64[Hp - 48] = sat_s2v1H_info;
           I64[Hp - 32] = _s2v1C::I64;
           I64[Hp - 24] = _s2v1F::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wOt: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.31936251 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { info_tbl: [(c2wOD,
                       label: GHC.Word.gtWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wOH; else goto c2wOI;
       c2wOH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wOI: // global
           I64[Sp - 16] = block_c2wOA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wOR; else goto c2wOB;
       u2wOR: // global
           call _c2wOA(R1) args: 0, res: 0, upd: 0;
       c2wOB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wOA() //  [R1]
         { info_tbl: [(c2wOA,
                       label: block_c2wOA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOA: // global
           I64[Sp] = block_c2wOG_info;
           _s2v1N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1N::I64;
           if (R1 & 7 != 0) goto u2wOQ; else goto c2wOK;
       u2wOQ: // global
           call _c2wOG(R1) args: 0, res: 0, upd: 0;
       c2wOK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wOG() //  [R1]
         { info_tbl: [(c2wOG,
                       label: block_c2wOG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOG: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.320923175 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { info_tbl: [(c2wOZ,
                       label: GHC.Word.geWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wP3; else goto c2wP4;
       c2wP3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wP4: // global
           I64[Sp - 16] = block_c2wOW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wPd; else goto c2wOX;
       u2wPd: // global
           call _c2wOW(R1) args: 0, res: 0, upd: 0;
       c2wOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wOW() //  [R1]
         { info_tbl: [(c2wOW,
                       label: block_c2wOW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wOW: // global
           I64[Sp] = block_c2wP2_info;
           _s2v1U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1U::I64;
           if (R1 & 7 != 0) goto u2wPc; else goto c2wP6;
       u2wPc: // global
           call _c2wP2(R1) args: 0, res: 0, upd: 0;
       c2wP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wP2() //  [R1]
         { info_tbl: [(c2wP2,
                       label: block_c2wP2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wP2: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.323170656 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { info_tbl: [(c2wPl,
                       label: GHC.Word.ltWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wPp; else goto c2wPq;
       c2wPp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wPq: // global
           I64[Sp - 16] = block_c2wPi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wPz; else goto c2wPj;
       u2wPz: // global
           call _c2wPi(R1) args: 0, res: 0, upd: 0;
       c2wPj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wPi() //  [R1]
         { info_tbl: [(c2wPi,
                       label: block_c2wPi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPi: // global
           I64[Sp] = block_c2wPo_info;
           _s2v21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v21::I64;
           if (R1 & 7 != 0) goto u2wPy; else goto c2wPs;
       u2wPy: // global
           call _c2wPo(R1) args: 0, res: 0, upd: 0;
       c2wPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wPo() //  [R1]
         { info_tbl: [(c2wPo,
                       label: block_c2wPo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPo: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.324810857 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { info_tbl: [(c2wPH,
                       label: GHC.Word.leWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wPL; else goto c2wPM;
       c2wPL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wPM: // global
           I64[Sp - 16] = block_c2wPE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wPV; else goto c2wPF;
       u2wPV: // global
           call _c2wPE(R1) args: 0, res: 0, upd: 0;
       c2wPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wPE() //  [R1]
         { info_tbl: [(c2wPE,
                       label: block_c2wPE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPE: // global
           I64[Sp] = block_c2wPK_info;
           _s2v28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v28::I64;
           if (R1 & 7 != 0) goto u2wPU; else goto c2wPO;
       u2wPU: // global
           call _c2wPK(R1) args: 0, res: 0, upd: 0;
       c2wPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wPK() //  [R1]
         { info_tbl: [(c2wPK,
                       label: block_c2wPK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wPK: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.326712865 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2wQ3,
                       label: GHC.Word.$fOrdWord8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wQ7; else goto c2wQ8;
       c2wQ7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wQ8: // global
           I64[Sp - 16] = block_c2wQ0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wQr; else goto c2wQ1;
       u2wQr: // global
           call _c2wQ0(R1) args: 0, res: 0, upd: 0;
       c2wQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wQ0() //  [R1]
         { info_tbl: [(c2wQ0,
                       label: block_c2wQ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQ0: // global
           I64[Sp] = block_c2wQ6_info;
           _s2v2f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v2f::I64;
           if (R1 & 7 != 0) goto u2wQq; else goto c2wQa;
       u2wQq: // global
           call _c2wQ6(R1) args: 0, res: 0, upd: 0;
       c2wQa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wQ6() //  [R1]
         { info_tbl: [(c2wQ6,
                       label: block_c2wQ6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQ6: // global
           _s2v2f::I64 = I64[Sp + 8];
           _s2v2h::I64 = I64[R1 + 7];
           if (_s2v2f::I64 == _s2v2h::I64) goto c2wQp; else goto c2wQo;
       c2wQp: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wQo: // global
           if (_s2v2f::I64 > _s2v2h::I64) goto c2wQl; else goto c2wQm;
       c2wQl: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wQm: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.329614241 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2wQz,
                       label: GHC.Word.$fOrdWord8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wQD; else goto c2wQE;
       c2wQD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wQE: // global
           I64[Sp - 16] = block_c2wQw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wQR; else goto c2wQx;
       u2wQR: // global
           call _c2wQw(R1) args: 0, res: 0, upd: 0;
       c2wQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wQw() //  [R1]
         { info_tbl: [(c2wQw,
                       label: block_c2wQw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQw: // global
           I64[Sp - 8] = block_c2wQC_info;
           _s2v2m::P64 = R1;
           _s2v2n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2n::I64;
           P64[Sp + 8] = _s2v2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wQQ; else goto c2wQG;
       u2wQQ: // global
           call _c2wQC(R1) args: 0, res: 0, upd: 0;
       c2wQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wQC() //  [R1]
         { info_tbl: [(c2wQC,
                       label: block_c2wQC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQC: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2wQO; else goto c2wQP;
       c2wQO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2wQP: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.331345805 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2wQZ,
                       label: GHC.Word.$fOrdWord8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wR3; else goto c2wR4;
       c2wR3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wR4: // global
           I64[Sp - 16] = block_c2wQW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wRh; else goto c2wQX;
       u2wRh: // global
           call _c2wQW(R1) args: 0, res: 0, upd: 0;
       c2wQX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wQW() //  [R1]
         { info_tbl: [(c2wQW,
                       label: block_c2wQW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wQW: // global
           I64[Sp - 8] = block_c2wR2_info;
           _s2v2t::P64 = R1;
           _s2v2u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2u::I64;
           P64[Sp + 8] = _s2v2t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wRg; else goto c2wR6;
       u2wRg: // global
           call _c2wR2(R1) args: 0, res: 0, upd: 0;
       c2wR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wR2() //  [R1]
         { info_tbl: [(c2wR2,
                       label: block_c2wR2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wR2: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2wRe; else goto c2wRf;
       c2wRe: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2wRf: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.332701073 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.333928145 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2wRp,
                       label: GHC.Word.$fIxWord8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wRp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wRy; else goto c2wRz;
       c2wRy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wRz: // global
           I64[Sp - 16] = block_c2wRm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wRW; else goto c2wRn;
       u2wRW: // global
           call _c2wRm(R1) args: 0, res: 0, upd: 0;
       c2wRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wRm() //  [R1]
         { info_tbl: [(c2wRm,
                       label: block_c2wRm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wRm: // global
           I64[Sp - 8] = block_c2wRs_info;
           _s2v2C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wRV; else goto c2wRt;
       u2wRV: // global
           call _c2wRs(R1) args: 0, res: 0, upd: 0;
       c2wRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wRs() //  [R1]
         { info_tbl: [(c2wRs,
                       label: block_c2wRs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wRs: // global
           I64[Sp] = block_c2wRx_info;
           _s2v2E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v2E::I64;
           if (R1 & 7 != 0) goto u2wRX; else goto c2wRC;
       u2wRX: // global
           call _c2wRx(R1) args: 0, res: 0, upd: 0;
       c2wRC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wRx() //  [R1]
         { info_tbl: [(c2wRx,
                       label: block_c2wRx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wRx: // global
           _s2v2G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v2G::I64) goto c2wRK; else goto c2wRO;
       c2wRK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wRO: // global
           _s2v2C::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2wRN_info;
           R1 = _s2v2C::P64;
           I64[Sp + 16] = _s2v2G::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2wRY; else goto c2wRP;
       u2wRY: // global
           call _c2wRN(R1) args: 0, res: 0, upd: 0;
       c2wRP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wRN() //  [R1]
         { info_tbl: [(c2wRN,
                       label: block_c2wRN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wRN: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.336112116 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2wS6,
                       label: GHC.Word.$fRealWord8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wS6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wSn; else goto c2wSo;
       c2wSn: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wSo: // global
           I64[Sp - 8] = block_c2wS3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wSv; else goto c2wS4;
       u2wSv: // global
           call _c2wS3(R1) args: 0, res: 0, upd: 0;
       c2wS4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wS3() //  [R1]
         { info_tbl: [(c2wS3,
                       label: block_c2wS3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wS3: // global
           I64[Sp] = block_c2wSc_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSc() //  [R1]
         { info_tbl: [(c2wSc,
                       label: block_c2wSc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSc: // global
           I64[Sp] = block_c2wSg_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSg() //  [R1]
         { info_tbl: [(c2wSg,
                       label: block_c2wSg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSg: // global
           I64[Sp] = block_c2wSk_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSk() //  [R1, R2]
         { info_tbl: [(c2wSk,
                       label: block_c2wSk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2wSu; else goto c2wSt;
       c2wSu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2wSt: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.337801145 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.338431823 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.339557523 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2wSD,
                       label: GHC.Word.$fIxWord8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wT0; else goto c2wT1;
       c2wT0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wT1: // global
           I64[Sp - 16] = block_c2wSA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wT8; else goto c2wSB;
       u2wT8: // global
           call _c2wSA(R1) args: 0, res: 0, upd: 0;
       c2wSB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSA() //  [R1]
         { info_tbl: [(c2wSA,
                       label: block_c2wSA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSA: // global
           I64[Sp] = block_c2wSG_info;
           _s2v2X::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v2X::P64;
           if (R1 & 7 != 0) goto u2wT7; else goto c2wSH;
       u2wT7: // global
           call _c2wSG(R1) args: 0, res: 0, upd: 0;
       c2wSH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSG() //  [R1]
         { info_tbl: [(c2wSG,
                       label: block_c2wSG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSG: // global
           I64[Sp] = block_c2wSL_info;
           _s2v30::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v30::I64;
           if (R1 & 7 != 0) goto u2wT9; else goto c2wSM;
       u2wT9: // global
           call _c2wSL(R1) args: 0, res: 0, upd: 0;
       c2wSM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wSL() //  [R1]
         { info_tbl: [(c2wSL,
                       label: block_c2wSL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wSL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wT6; else goto c2wT5;
       c2wT6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wT5: // global
           _s2v35::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v35::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.341414961 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { info_tbl: [(c2wTh,
                       label: GHC.Word.$fIxWord8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wTi; else goto c2wTj;
       c2wTi: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wTj: // global
           I64[Sp - 8] = block_c2wTe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wTn; else goto c2wTf;
       u2wTn: // global
           call _c2wTe(R1) args: 0, res: 0, upd: 0;
       c2wTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wTe() //  [R1]
         { info_tbl: [(c2wTe,
                       label: block_c2wTe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTe: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.342552378 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.343742126 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2wTv,
                       label: GHC.Word.$fIxWord8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wTE; else goto c2wTF;
       c2wTE: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wTF: // global
           I64[Sp - 8] = block_c2wTs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wUa; else goto c2wTt;
       u2wUa: // global
           call _c2wTs(R1) args: 0, res: 0, upd: 0;
       c2wTt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wTs() //  [R1]
         { info_tbl: [(c2wTs,
                       label: block_c2wTs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTs: // global
           I64[Sp - 8] = block_c2wTy_info;
           _s2v3d::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wU9; else goto c2wTz;
       u2wU9: // global
           call _c2wTy(R1) args: 0, res: 0, upd: 0;
       c2wTz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wTy() //  [R1]
         { info_tbl: [(c2wTy,
                       label: block_c2wTy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTy: // global
           I64[Sp] = block_c2wTD_info;
           _s2v3f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3f::I64;
           if (R1 & 7 != 0) goto u2wUb; else goto c2wTI;
       u2wUb: // global
           call _c2wTD(R1) args: 0, res: 0, upd: 0;
       c2wTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wTD() //  [R1]
         { info_tbl: [(c2wTD,
                       label: block_c2wTD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wTD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wTO; else goto c2wTN;
       c2wTO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wTN: // global
           _s2v3f::I64 = I64[Sp + 8];
           _s2v3h::I64 = I64[R1 + 7];
           if (_s2v3f::I64 > _s2v3h::I64) goto c2wTS; else goto c2wU8;
       c2wTS: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wU8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3h::I64 - _s2v3f::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.346000602 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2wUj,
                       label: GHC.Word.$fIxWord8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wUj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wUJ; else goto c2wUK;
       c2wUJ: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wUK: // global
           I64[Sp - 8] = block_c2wUg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wUR; else goto c2wUh;
       u2wUR: // global
           call _c2wUg(R1) args: 0, res: 0, upd: 0;
       c2wUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wUg() //  [R1]
         { info_tbl: [(c2wUg,
                       label: block_c2wUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wUg: // global
           I64[Sp - 8] = block_c2wUm_info;
           _s2v3p::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v3p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wUQ; else goto c2wUn;
       u2wUQ: // global
           call _c2wUm(R1) args: 0, res: 0, upd: 0;
       c2wUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wUm() //  [R1]
         { info_tbl: [(c2wUm,
                       label: block_c2wUm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wUm: // global
           I64[Sp] = block_c2wUr_info;
           _s2v3s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3s::I64;
           if (R1 & 7 != 0) goto u2wUS; else goto c2wUs;
       u2wUS: // global
           call _c2wUr(R1) args: 0, res: 0, upd: 0;
       c2wUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wUr() //  [R1]
         { info_tbl: [(c2wUr,
                       label: block_c2wUr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wUr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wUP; else goto c2wUO;
       c2wUP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wUO: // global
           _s2v3y::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v3y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.349213533 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2wV0,
                       label: GHC.Word.$fIxWord8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wV0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wV9; else goto c2wVa;
       c2wV9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wVa: // global
           I64[Sp - 16] = block_c2wUX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wVP; else goto c2wUY;
       u2wVP: // global
           call _c2wUX(R1) args: 0, res: 0, upd: 0;
       c2wUY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wUX() //  [R1]
         { info_tbl: [(c2wUX,
                       label: block_c2wUX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wUX: // global
           I64[Sp - 8] = block_c2wV3_info;
           _s2v3D::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wVO; else goto c2wV4;
       u2wVO: // global
           call _c2wV3(R1) args: 0, res: 0, upd: 0;
       c2wV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wV3() //  [R1]
         { info_tbl: [(c2wV3,
                       label: block_c2wV3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wV3: // global
           I64[Sp] = block_c2wV8_info;
           _s2v3F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v3F::I64;
           if (R1 & 7 != 0) goto u2wVQ; else goto c2wVd;
       u2wVQ: // global
           call _c2wV8(R1) args: 0, res: 0, upd: 0;
       c2wVd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wV8() //  [R1]
         { info_tbl: [(c2wV8,
                       label: block_c2wV8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wV8: // global
           _s2v3H::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v3H::I64) goto c2wVl; else goto c2wVp;
       c2wVl: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2wVp: // global
           I64[Sp] = block_c2wVo_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3H::I64;
           if (R1 & 7 != 0) goto u2wVR; else goto c2wVq;
       u2wVR: // global
           call _c2wVo(R1) args: 0, res: 0, upd: 0;
       c2wVq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wVo() //  [R1]
         { info_tbl: [(c2wVo,
                       label: block_c2wVo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wVo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wVw; else goto c2wVv;
       c2wVw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wVv: // global
           _s2v3H::I64 = I64[Sp + 8];
           if (_s2v3H::I64 > I64[R1 + 7]) goto c2wVA; else goto c2wVN;
       c2wVA: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2wVN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3H::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.351453025 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.352614119 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { info_tbl: [(c2wVZ,
                       label: GHC.Word.eqWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wVZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wW3; else goto c2wW4;
       c2wW3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wW4: // global
           I64[Sp - 16] = block_c2wVW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wWd; else goto c2wVX;
       u2wWd: // global
           call _c2wVW(R1) args: 0, res: 0, upd: 0;
       c2wVX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wVW() //  [R1]
         { info_tbl: [(c2wVW,
                       label: block_c2wVW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wVW: // global
           I64[Sp] = block_c2wW2_info;
           _s2v3S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3S::I64;
           if (R1 & 7 != 0) goto u2wWc; else goto c2wW6;
       u2wWc: // global
           call _c2wW2(R1) args: 0, res: 0, upd: 0;
       c2wW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wW2() //  [R1]
         { info_tbl: [(c2wW2,
                       label: block_c2wW2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wW2: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.353955035 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.354543976 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.355395136 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { info_tbl: [(c2wWl,
                       label: GHC.Word.$fNumWord16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wWl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wWm; else goto c2wWn;
       c2wWm: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wWn: // global
           I64[Sp - 8] = block_c2wWi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wWv; else goto c2wWj;
       u2wWv: // global
           call _c2wWi(R1) args: 0, res: 0, upd: 0;
       c2wWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wWi() //  [R1]
         { info_tbl: [(c2wWi,
                       label: block_c2wWi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wWi: // global
           if (I64[R1 + 7] == 0) goto c2wWu; else goto c2wWt;
       c2wWu: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wWt: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.356445821 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.357387074 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2wWD,
                       label: GHC.Word.$fBitsWord16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wWD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wWK; else goto c2wWL;
       c2wWK: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wWL: // global
           I64[Sp - 8] = block_c2wWA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wWP; else goto c2wWB;
       u2wWP: // global
           call _c2wWA(R1) args: 0, res: 0, upd: 0;
       c2wWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wWA() //  [R1]
         { info_tbl: [(c2wWA,
                       label: block_c2wWA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wWA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wWO; else goto c2wWN;
       c2wWO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wWN: // global
           _s2v43::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v43::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.358504915 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.359181096 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2wWU,
                       label: GHC.Word.$fBitsWord16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wWU: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.360289884 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { info_tbl: [(c2wX4,
                       label: GHC.Word.$fBitsWord16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wX4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2wX5; else goto c2wX6;
       c2wX5: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2wX6: // global
           I64[Sp - 8] = block_c2wX1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wXp; else goto c2wX2;
       u2wXp: // global
           call _c2wX1(R1) args: 0, res: 0, upd: 0;
       c2wX2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wX1() //  [R1]
         { info_tbl: [(c2wX1,
                       label: block_c2wX1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wX1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wXb; else goto c2wXa;
       c2wXb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wXa: // global
           _s2v47::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v47::I64, 64)) goto c2wXn; else goto c2wXo;
       c2wXn: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v47::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wXo: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.362023112 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2wXx,
                       label: GHC.Word.$fBitsWord16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wXx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2wXB; else goto c2wXC;
       c2wXB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wXC: // global
           I64[Sp - 16] = block_c2wXu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wYb; else goto c2wXv;
       u2wYb: // global
           call _c2wXu(R1) args: 0, res: 0, upd: 0;
       c2wXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wXu() //  [R1]
         { info_tbl: [(c2wXu,
                       label: block_c2wXu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wXu: // global
           I64[Sp] = block_c2wXA_info;
           _s2v4e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4e::I64;
           if (R1 & 7 != 0) goto u2wYa; else goto c2wXE;
       u2wYa: // global
           call _c2wXA(R1) args: 0, res: 0, upd: 0;
       c2wXE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wXA() //  [R1]
         { info_tbl: [(c2wXA,
                       label: block_c2wXA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wXA: // global
           _s2v4g::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v4g::I64, 64)) goto c2wY9; else goto c2wY8;
       c2wY8: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4g::I64)) == 0) goto c2wY9; else goto c2wXX;
       c2wY9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wXX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.363990479 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2wYj,
                       label: GHC.Word.$fBitsWord16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wYj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wYn; else goto c2wYo;
       c2wYn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wYo: // global
           I64[Sp - 16] = block_c2wYg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2wZe; else goto c2wYh;
       u2wZe: // global
           call _c2wYg(R1) args: 0, res: 0, upd: 0;
       c2wYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wYg() //  [R1]
         { info_tbl: [(c2wYg,
                       label: block_c2wYg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wYg: // global
           I64[Sp - 8] = block_c2wYm_info;
           _s2v4n::P64 = R1;
           _s2v4o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4o::I64;
           P64[Sp + 8] = _s2v4n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wZd; else goto c2wYq;
       u2wZd: // global
           call _c2wYm(R1) args: 0, res: 0, upd: 0;
       c2wYq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wYm() //  [R1]
         { info_tbl: [(c2wYm,
                       label: block_c2wYm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wYm: // global
           _s2v4u::I64 = -I64[R1 + 7] & 15;
           if (_s2v4u::I64 != 0) goto u2wZb; else goto c2wZ7;
       u2wZb: // global
           I64[Sp + 16] = _s2v4u::I64;
           Sp = Sp + 8;
           call _c2wYI() args: 0, res: 0, upd: 0;
       c2wZ7: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wYI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wYI: // global
           Hp = Hp + 16;
           _s2v4u::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2wZ4; else goto c2wZ3;
       c2wZ4: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2wYH_info;
           R1 = _s2v4u::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2wZ3: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2v4o::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2v4o::I64 << _s2v4u::I64) | (_s2v4o::I64 >> 16 - _s2v4u::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2wYH() //  [R1]
         { info_tbl: [(c2wYH,
                       label: block_c2wYH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wYH: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2wYI() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.366841489 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2wZl,
                       label: GHC.Word.$fBitsWord16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wZl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.368174743 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2wZv,
                       label: GHC.Word.$fBitsWord16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wZv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2wZz; else goto c2wZA;
       c2wZz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2wZA: // global
           I64[Sp - 16] = block_c2wZs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x00; else goto c2wZt;
       u2x00: // global
           call _c2wZs(R1) args: 0, res: 0, upd: 0;
       c2wZt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wZs() //  [R1]
         { info_tbl: [(c2wZs,
                       label: block_c2wZs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wZs: // global
           I64[Sp - 8] = block_c2wZy_info;
           _s2v4C::P64 = R1;
           _s2v4D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4D::I64;
           P64[Sp + 8] = _s2v4C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2wZZ; else goto c2wZC;
       u2wZZ: // global
           call _c2wZy(R1) args: 0, res: 0, upd: 0;
       c2wZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2wZy() //  [R1]
         { info_tbl: [(c2wZy,
                       label: block_c2wZy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2wZy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2wZI; else goto c2wZH;
       c2wZI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2wZH: // global
           _s2v4F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4F::I64, 64)) goto c2wZX; else goto c2wZY;
       c2wZX: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2wZY: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.370166473 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2x08,
                       label: GHC.Word.$fBitsWord16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x08: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x0c; else goto c2x0d;
       c2x0c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x0d: // global
           I64[Sp - 16] = block_c2x05_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x0L; else goto c2x06;
       u2x0L: // global
           call _c2x05(R1) args: 0, res: 0, upd: 0;
       c2x06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x05() //  [R1]
         { info_tbl: [(c2x05,
                       label: block_c2x05_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x05: // global
           I64[Sp] = block_c2x0b_info;
           _s2v4N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4N::I64;
           if (R1 & 7 != 0) goto u2x0K; else goto c2x0f;
       u2x0K: // global
           call _c2x0b(R1) args: 0, res: 0, upd: 0;
       c2x0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x0b() //  [R1]
         { info_tbl: [(c2x0b,
                       label: block_c2x0b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x0b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x0l; else goto c2x0k;
       c2x0l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x0k: // global
           _s2v4N::I64 = I64[Sp + 8];
           _s2v4P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4P::I64, 64)) goto c2x0D; else goto c2x0J;
       c2x0D: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4P::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x0J: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.372146501 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2x0T,
                       label: GHC.Word.$fBitsWord16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x0T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2x0X; else goto c2x0Y;
       c2x0X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x0Y: // global
           I64[Sp - 16] = block_c2x0Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x1o; else goto c2x0R;
       u2x1o: // global
           call _c2x0Q(R1) args: 0, res: 0, upd: 0;
       c2x0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x0Q() //  [R1]
         { info_tbl: [(c2x0Q,
                       label: block_c2x0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x0Q: // global
           I64[Sp - 8] = block_c2x0W_info;
           _s2v4Y::P64 = R1;
           _s2v4Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4Z::I64;
           P64[Sp + 8] = _s2v4Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x1n; else goto c2x10;
       u2x1n: // global
           call _c2x0W(R1) args: 0, res: 0, upd: 0;
       c2x10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x0W() //  [R1]
         { info_tbl: [(c2x0W,
                       label: block_c2x0W_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x0W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x16; else goto c2x15;
       c2x16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x15: // global
           _s2v51::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v51::I64, 64)) goto c2x1l; else goto c2x1m;
       c2x1l: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v51::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x1m: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.373734354 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.374476904 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.375562383 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2x1w,
                       label: GHC.Word.$fIntegralWord16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x1A; else goto c2x1B;
       c2x1A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x1B: // global
           I64[Sp - 16] = block_c2x1t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x1U; else goto c2x1u;
       u2x1U: // global
           call _c2x1t(R1) args: 0, res: 0, upd: 0;
       c2x1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x1t() //  [R1]
         { info_tbl: [(c2x1t,
                       label: block_c2x1t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x1t: // global
           I64[Sp] = block_c2x1z_info;
           _s2v59::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v59::I64;
           if (R1 & 7 != 0) goto u2x1T; else goto c2x1D;
       u2x1T: // global
           call _c2x1z(R1) args: 0, res: 0, upd: 0;
       c2x1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x1z() //  [R1]
         { info_tbl: [(c2x1z,
                       label: block_c2x1z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x1z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x1J; else goto c2x1I;
       c2x1J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x1I: // global
           _s2v5c::I64 = I64[R1 + 7];
           if (_s2v5c::I64 != 0) goto c2x1R; else goto c2x1S;
       c2x1R: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v5c::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x1S: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.377523697 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2x22,
                       label: GHC.Word.$fIntegralWord16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x22: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x26; else goto c2x27;
       c2x26: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x27: // global
           I64[Sp - 16] = block_c2x1Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x2q; else goto c2x20;
       u2x2q: // global
           call _c2x1Z(R1) args: 0, res: 0, upd: 0;
       c2x20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x1Z() //  [R1]
         { info_tbl: [(c2x1Z,
                       label: block_c2x1Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x1Z: // global
           I64[Sp] = block_c2x25_info;
           _s2v5h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5h::I64;
           if (R1 & 7 != 0) goto u2x2p; else goto c2x29;
       u2x2p: // global
           call _c2x25(R1) args: 0, res: 0, upd: 0;
       c2x29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x25() //  [R1]
         { info_tbl: [(c2x25,
                       label: block_c2x25_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x25: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x2f; else goto c2x2e;
       c2x2f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x2e: // global
           _s2v5k::I64 = I64[R1 + 7];
           if (_s2v5k::I64 != 0) goto c2x2n; else goto c2x2o;
       c2x2n: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v5k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x2o: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.379471133 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2x2y,
                       label: GHC.Word.$fIntegralWord16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x2y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x2C; else goto c2x2D;
       c2x2C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x2D: // global
           I64[Sp - 16] = block_c2x2v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x2V; else goto c2x2w;
       u2x2V: // global
           call _c2x2v(R1) args: 0, res: 0, upd: 0;
       c2x2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x2v() //  [R1]
         { info_tbl: [(c2x2v,
                       label: block_c2x2v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x2v: // global
           I64[Sp] = block_c2x2B_info;
           _s2v5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5p::I64;
           if (R1 & 7 != 0) goto u2x2U; else goto c2x2F;
       u2x2U: // global
           call _c2x2B(R1) args: 0, res: 0, upd: 0;
       c2x2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x2B() //  [R1]
         { info_tbl: [(c2x2B,
                       label: block_c2x2B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x2B: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2x2L; else goto c2x2K;
       c2x2L: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x2K: // global
           _s2v5s::I64 = I64[R1 + 7];
           if (_s2v5s::I64 != 0) goto c2x2S; else goto c2x2T;
       c2x2S: // global
           (_s2v5u::I64, _s2v5v::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v5s::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2v5v::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2v5u::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x2T: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.381831944 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2v5I_entry() //  [R1]
         { info_tbl: [(c2x3i,
                       label: sat_s2v5I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3i: // global
           _s2v5I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2x3l; else goto c2x3m;
       c2x3m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x3o; else goto c2x3n;
       c2x3o: // global
           HpAlloc = 16;
           goto c2x3l;
       c2x3l: // global
           R1 = _s2v5I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2x3n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5I::P64;
           _s2v5H::I64 = I64[_s2v5I::P64 + 16] % I64[_s2v5I::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5H::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v5G_entry() //  [R1]
         { info_tbl: [(c2x3v,
                       label: sat_s2v5G_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3v: // global
           _s2v5G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2x3y; else goto c2x3z;
       c2x3z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x3B; else goto c2x3A;
       c2x3B: // global
           HpAlloc = 16;
           goto c2x3y;
       c2x3y: // global
           R1 = _s2v5G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2x3A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5G::P64;
           _s2v5F::I64 = I64[_s2v5G::P64 + 16] / I64[_s2v5G::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5F::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2x3C,
                       label: GHC.Word.$fIntegralWord16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x3D; else goto c2x3E;
       c2x3D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x3E: // global
           I64[Sp - 16] = block_c2x30_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x3O; else goto c2x31;
       u2x3O: // global
           call _c2x30(R1) args: 0, res: 0, upd: 0;
       c2x31: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x30() //  [R1]
         { info_tbl: [(c2x30,
                       label: block_c2x30_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x30: // global
           I64[Sp] = block_c2x35_info;
           _s2v5B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5B::I64;
           if (R1 & 7 != 0) goto u2x3N; else goto c2x36;
       u2x3N: // global
           call _c2x35(R1) args: 0, res: 0, upd: 0;
       c2x36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x35() //  [R1]
         { info_tbl: [(c2x35,
                       label: block_c2x35_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x35: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2x3I; else goto c2x3H;
       c2x3I: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x3H: // global
           _s2v5E::I64 = I64[R1 + 7];
           if (_s2v5E::I64 != 0) goto c2x3L; else goto c2x3M;
       c2x3L: // global
           I64[Hp - 80] = sat_s2v5I_info;
           _s2v5B::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v5B::I64;
           I64[Hp - 56] = _s2v5E::I64;
           I64[Hp - 48] = sat_s2v5G_info;
           I64[Hp - 32] = _s2v5B::I64;
           I64[Hp - 24] = _s2v5E::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x3M: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.384505586 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { info_tbl: [(c2x3W,
                       label: GHC.Word.gtWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x40; else goto c2x41;
       c2x40: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x41: // global
           I64[Sp - 16] = block_c2x3T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x4a; else goto c2x3U;
       u2x4a: // global
           call _c2x3T(R1) args: 0, res: 0, upd: 0;
       c2x3U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x3T() //  [R1]
         { info_tbl: [(c2x3T,
                       label: block_c2x3T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3T: // global
           I64[Sp] = block_c2x3Z_info;
           _s2v5M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5M::I64;
           if (R1 & 7 != 0) goto u2x49; else goto c2x43;
       u2x49: // global
           call _c2x3Z(R1) args: 0, res: 0, upd: 0;
       c2x43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x3Z() //  [R1]
         { info_tbl: [(c2x3Z,
                       label: block_c2x3Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x3Z: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.387120037 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { info_tbl: [(c2x4i,
                       label: GHC.Word.geWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x4m; else goto c2x4n;
       c2x4m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x4n: // global
           I64[Sp - 16] = block_c2x4f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x4w; else goto c2x4g;
       u2x4w: // global
           call _c2x4f(R1) args: 0, res: 0, upd: 0;
       c2x4g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x4f() //  [R1]
         { info_tbl: [(c2x4f,
                       label: block_c2x4f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4f: // global
           I64[Sp] = block_c2x4l_info;
           _s2v5T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5T::I64;
           if (R1 & 7 != 0) goto u2x4v; else goto c2x4p;
       u2x4v: // global
           call _c2x4l(R1) args: 0, res: 0, upd: 0;
       c2x4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x4l() //  [R1]
         { info_tbl: [(c2x4l,
                       label: block_c2x4l_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4l: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.388639237 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { info_tbl: [(c2x4E,
                       label: GHC.Word.ltWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x4I; else goto c2x4J;
       c2x4I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x4J: // global
           I64[Sp - 16] = block_c2x4B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x4S; else goto c2x4C;
       u2x4S: // global
           call _c2x4B(R1) args: 0, res: 0, upd: 0;
       c2x4C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x4B() //  [R1]
         { info_tbl: [(c2x4B,
                       label: block_c2x4B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4B: // global
           I64[Sp] = block_c2x4H_info;
           _s2v60::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v60::I64;
           if (R1 & 7 != 0) goto u2x4R; else goto c2x4L;
       u2x4R: // global
           call _c2x4H(R1) args: 0, res: 0, upd: 0;
       c2x4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x4H() //  [R1]
         { info_tbl: [(c2x4H,
                       label: block_c2x4H_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4H: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.390235549 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { info_tbl: [(c2x50,
                       label: GHC.Word.leWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x54; else goto c2x55;
       c2x54: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x55: // global
           I64[Sp - 16] = block_c2x4X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x5e; else goto c2x4Y;
       u2x5e: // global
           call _c2x4X(R1) args: 0, res: 0, upd: 0;
       c2x4Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x4X() //  [R1]
         { info_tbl: [(c2x4X,
                       label: block_c2x4X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x4X: // global
           I64[Sp] = block_c2x53_info;
           _s2v67::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v67::I64;
           if (R1 & 7 != 0) goto u2x5d; else goto c2x57;
       u2x5d: // global
           call _c2x53(R1) args: 0, res: 0, upd: 0;
       c2x57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x53() //  [R1]
         { info_tbl: [(c2x53,
                       label: block_c2x53_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x53: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.391824462 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2x5m,
                       label: GHC.Word.$fOrdWord16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x5q; else goto c2x5r;
       c2x5q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x5r: // global
           I64[Sp - 16] = block_c2x5j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x5K; else goto c2x5k;
       u2x5K: // global
           call _c2x5j(R1) args: 0, res: 0, upd: 0;
       c2x5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x5j() //  [R1]
         { info_tbl: [(c2x5j,
                       label: block_c2x5j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5j: // global
           I64[Sp] = block_c2x5p_info;
           _s2v6e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6e::I64;
           if (R1 & 7 != 0) goto u2x5J; else goto c2x5t;
       u2x5J: // global
           call _c2x5p(R1) args: 0, res: 0, upd: 0;
       c2x5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x5p() //  [R1]
         { info_tbl: [(c2x5p,
                       label: block_c2x5p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5p: // global
           _s2v6e::I64 = I64[Sp + 8];
           _s2v6g::I64 = I64[R1 + 7];
           if (_s2v6e::I64 == _s2v6g::I64) goto c2x5I; else goto c2x5H;
       c2x5I: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x5H: // global
           if (_s2v6e::I64 > _s2v6g::I64) goto c2x5E; else goto c2x5F;
       c2x5E: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x5F: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.393627014 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2x5S,
                       label: GHC.Word.$fOrdWord16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2x5W; else goto c2x5X;
       c2x5W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x5X: // global
           I64[Sp - 16] = block_c2x5P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x6a; else goto c2x5Q;
       u2x6a: // global
           call _c2x5P(R1) args: 0, res: 0, upd: 0;
       c2x5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x5P() //  [R1]
         { info_tbl: [(c2x5P,
                       label: block_c2x5P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5P: // global
           I64[Sp - 8] = block_c2x5V_info;
           _s2v6l::P64 = R1;
           _s2v6m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6m::I64;
           P64[Sp + 8] = _s2v6l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x69; else goto c2x5Z;
       u2x69: // global
           call _c2x5V(R1) args: 0, res: 0, upd: 0;
       c2x5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x5V() //  [R1]
         { info_tbl: [(c2x5V,
                       label: block_c2x5V_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x5V: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2x67; else goto c2x68;
       c2x67: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2x68: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.395281061 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2x6i,
                       label: GHC.Word.$fOrdWord16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2x6m; else goto c2x6n;
       c2x6m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x6n: // global
           I64[Sp - 16] = block_c2x6f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x6A; else goto c2x6g;
       u2x6A: // global
           call _c2x6f(R1) args: 0, res: 0, upd: 0;
       c2x6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x6f() //  [R1]
         { info_tbl: [(c2x6f,
                       label: block_c2x6f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6f: // global
           I64[Sp - 8] = block_c2x6l_info;
           _s2v6s::P64 = R1;
           _s2v6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6t::I64;
           P64[Sp + 8] = _s2v6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x6z; else goto c2x6p;
       u2x6z: // global
           call _c2x6l(R1) args: 0, res: 0, upd: 0;
       c2x6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x6l() //  [R1]
         { info_tbl: [(c2x6l,
                       label: block_c2x6l_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6l: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2x6x; else goto c2x6y;
       c2x6x: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2x6y: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.3966138 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.397920621 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2x6I,
                       label: GHC.Word.$fIxWord16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2x6R; else goto c2x6S;
       c2x6R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x6S: // global
           I64[Sp - 16] = block_c2x6F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x7f; else goto c2x6G;
       u2x7f: // global
           call _c2x6F(R1) args: 0, res: 0, upd: 0;
       c2x6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x6F() //  [R1]
         { info_tbl: [(c2x6F,
                       label: block_c2x6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6F: // global
           I64[Sp - 8] = block_c2x6L_info;
           _s2v6B::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v6B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x7e; else goto c2x6M;
       u2x7e: // global
           call _c2x6L(R1) args: 0, res: 0, upd: 0;
       c2x6M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x6L() //  [R1]
         { info_tbl: [(c2x6L,
                       label: block_c2x6L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6L: // global
           I64[Sp] = block_c2x6Q_info;
           _s2v6D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v6D::I64;
           if (R1 & 7 != 0) goto u2x7g; else goto c2x6V;
       u2x7g: // global
           call _c2x6Q(R1) args: 0, res: 0, upd: 0;
       c2x6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x6Q() //  [R1]
         { info_tbl: [(c2x6Q,
                       label: block_c2x6Q_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x6Q: // global
           _s2v6F::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v6F::I64) goto c2x73; else goto c2x77;
       c2x73: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x77: // global
           _s2v6B::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2x76_info;
           R1 = _s2v6B::P64;
           I64[Sp + 16] = _s2v6F::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2x7h; else goto c2x78;
       u2x7h: // global
           call _c2x76(R1) args: 0, res: 0, upd: 0;
       c2x78: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x76() //  [R1]
         { info_tbl: [(c2x76,
                       label: block_c2x76_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x76: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.400222196 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2x7p,
                       label: GHC.Word.$fRealWord16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2x7G; else goto c2x7H;
       c2x7G: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2x7H: // global
           I64[Sp - 8] = block_c2x7m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x7O; else goto c2x7n;
       u2x7O: // global
           call _c2x7m(R1) args: 0, res: 0, upd: 0;
       c2x7n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7m() //  [R1]
         { info_tbl: [(c2x7m,
                       label: block_c2x7m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7m: // global
           I64[Sp] = block_c2x7v_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7v() //  [R1]
         { info_tbl: [(c2x7v,
                       label: block_c2x7v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7v: // global
           I64[Sp] = block_c2x7z_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7z() //  [R1]
         { info_tbl: [(c2x7z,
                       label: block_c2x7z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7z: // global
           I64[Sp] = block_c2x7D_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7D() //  [R1, R2]
         { info_tbl: [(c2x7D,
                       label: block_c2x7D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2x7N; else goto c2x7M;
       c2x7N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2x7M: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.401777368 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.402386736 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.404521222 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2x7W,
                       label: GHC.Word.$fIxWord16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x8j; else goto c2x8k;
       c2x8j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2x8k: // global
           I64[Sp - 16] = block_c2x7T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2x8r; else goto c2x7U;
       u2x8r: // global
           call _c2x7T(R1) args: 0, res: 0, upd: 0;
       c2x7U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7T() //  [R1]
         { info_tbl: [(c2x7T,
                       label: block_c2x7T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7T: // global
           I64[Sp] = block_c2x7Z_info;
           _s2v6W::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v6W::P64;
           if (R1 & 7 != 0) goto u2x8q; else goto c2x80;
       u2x8q: // global
           call _c2x7Z(R1) args: 0, res: 0, upd: 0;
       c2x80: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x7Z() //  [R1]
         { info_tbl: [(c2x7Z,
                       label: block_c2x7Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x7Z: // global
           I64[Sp] = block_c2x84_info;
           _s2v6Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6Z::I64;
           if (R1 & 7 != 0) goto u2x8s; else goto c2x85;
       u2x8s: // global
           call _c2x84(R1) args: 0, res: 0, upd: 0;
       c2x85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x84() //  [R1]
         { info_tbl: [(c2x84,
                       label: block_c2x84_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x8p; else goto c2x8o;
       c2x8p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x8o: // global
           _s2v74::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v74::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.406425612 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { info_tbl: [(c2x8A,
                       label: GHC.Word.$fIxWord16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2x8B; else goto c2x8C;
       c2x8B: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2x8C: // global
           I64[Sp - 8] = block_c2x8x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x8G; else goto c2x8y;
       u2x8G: // global
           call _c2x8x(R1) args: 0, res: 0, upd: 0;
       c2x8y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x8x() //  [R1]
         { info_tbl: [(c2x8x,
                       label: block_c2x8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8x: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.407948191 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2x8O,
                       label: GHC.Word.$fIxWord16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2x8X; else goto c2x8Y;
       c2x8X: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2x8Y: // global
           I64[Sp - 8] = block_c2x8L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x9t; else goto c2x8M;
       u2x9t: // global
           call _c2x8L(R1) args: 0, res: 0, upd: 0;
       c2x8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x8L() //  [R1]
         { info_tbl: [(c2x8L,
                       label: block_c2x8L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8L: // global
           I64[Sp - 8] = block_c2x8R_info;
           _s2v7c::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7c::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2x9s; else goto c2x8S;
       u2x9s: // global
           call _c2x8R(R1) args: 0, res: 0, upd: 0;
       c2x8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x8R() //  [R1]
         { info_tbl: [(c2x8R,
                       label: block_c2x8R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8R: // global
           I64[Sp] = block_c2x8W_info;
           _s2v7e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7e::I64;
           if (R1 & 7 != 0) goto u2x9u; else goto c2x91;
       u2x9u: // global
           call _c2x8W(R1) args: 0, res: 0, upd: 0;
       c2x91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x8W() //  [R1]
         { info_tbl: [(c2x8W,
                       label: block_c2x8W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x8W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2x97; else goto c2x96;
       c2x97: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2x96: // global
           _s2v7e::I64 = I64[Sp + 8];
           _s2v7g::I64 = I64[R1 + 7];
           if (_s2v7e::I64 > _s2v7g::I64) goto c2x9b; else goto c2x9r;
       c2x9b: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2x9r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7g::I64 - _s2v7e::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.410185813 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2x9C,
                       label: GHC.Word.$fIxWord16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x9C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xa2; else goto c2xa3;
       c2xa2: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xa3: // global
           I64[Sp - 8] = block_c2x9z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xaa; else goto c2x9A;
       u2xaa: // global
           call _c2x9z(R1) args: 0, res: 0, upd: 0;
       c2x9A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x9z() //  [R1]
         { info_tbl: [(c2x9z,
                       label: block_c2x9z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x9z: // global
           I64[Sp - 8] = block_c2x9F_info;
           _s2v7o::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v7o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xa9; else goto c2x9G;
       u2xa9: // global
           call _c2x9F(R1) args: 0, res: 0, upd: 0;
       c2x9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x9F() //  [R1]
         { info_tbl: [(c2x9F,
                       label: block_c2x9F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x9F: // global
           I64[Sp] = block_c2x9K_info;
           _s2v7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7r::I64;
           if (R1 & 7 != 0) goto u2xab; else goto c2x9L;
       u2xab: // global
           call _c2x9K(R1) args: 0, res: 0, upd: 0;
       c2x9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2x9K() //  [R1]
         { info_tbl: [(c2x9K,
                       label: block_c2x9K_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2x9K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xa8; else goto c2xa7;
       c2xa8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xa7: // global
           _s2v7x::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v7x::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.412650544 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2xaj,
                       label: GHC.Word.$fIxWord16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xaj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xas; else goto c2xat;
       c2xas: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xat: // global
           I64[Sp - 16] = block_c2xag_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xb8; else goto c2xah;
       u2xb8: // global
           call _c2xag(R1) args: 0, res: 0, upd: 0;
       c2xah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xag() //  [R1]
         { info_tbl: [(c2xag,
                       label: block_c2xag_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xag: // global
           I64[Sp - 8] = block_c2xam_info;
           _s2v7C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xb7; else goto c2xan;
       u2xb7: // global
           call _c2xam(R1) args: 0, res: 0, upd: 0;
       c2xan: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xam() //  [R1]
         { info_tbl: [(c2xam,
                       label: block_c2xam_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xam: // global
           I64[Sp] = block_c2xar_info;
           _s2v7E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v7E::I64;
           if (R1 & 7 != 0) goto u2xb9; else goto c2xaw;
       u2xb9: // global
           call _c2xar(R1) args: 0, res: 0, upd: 0;
       c2xaw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xar() //  [R1]
         { info_tbl: [(c2xar,
                       label: block_c2xar_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xar: // global
           _s2v7G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v7G::I64) goto c2xaE; else goto c2xaI;
       c2xaE: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xaI: // global
           I64[Sp] = block_c2xaH_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7G::I64;
           if (R1 & 7 != 0) goto u2xba; else goto c2xaJ;
       u2xba: // global
           call _c2xaH(R1) args: 0, res: 0, upd: 0;
       c2xaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xaH() //  [R1]
         { info_tbl: [(c2xaH,
                       label: block_c2xaH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xaH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xaP; else goto c2xaO;
       c2xaP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xaO: // global
           _s2v7G::I64 = I64[Sp + 8];
           if (_s2v7G::I64 > I64[R1 + 7]) goto c2xaT; else goto c2xb6;
       c2xaT: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xb6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7G::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.41519853 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.416264599 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { info_tbl: [(c2xbi,
                       label: GHC.Word.byteSwap16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xbt; else goto c2xbu;
       c2xbt: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xbu: // global
           I64[Sp - 8] = block_c2xbf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xby; else goto c2xbg;
       u2xby: // global
           call _c2xbf(R1) args: 0, res: 0, upd: 0;
       c2xbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xbf() //  [R1]
         { info_tbl: [(c2xbf,
                       label: block_c2xbf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xbx; else goto c2xbw;
       c2xbx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xbw: // global
           (_c2xbl::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2xbl::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.417831971 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { info_tbl: [(c2xbG,
                       label: GHC.Word.eqWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xbK; else goto c2xbL;
       c2xbK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xbL: // global
           I64[Sp - 16] = block_c2xbD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xbU; else goto c2xbE;
       u2xbU: // global
           call _c2xbD(R1) args: 0, res: 0, upd: 0;
       c2xbE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xbD() //  [R1]
         { info_tbl: [(c2xbD,
                       label: block_c2xbD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbD: // global
           I64[Sp] = block_c2xbJ_info;
           _s2v7W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7W::I64;
           if (R1 & 7 != 0) goto u2xbT; else goto c2xbN;
       u2xbT: // global
           call _c2xbJ(R1) args: 0, res: 0, upd: 0;
       c2xbN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xbJ() //  [R1]
         { info_tbl: [(c2xbJ,
                       label: block_c2xbJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbJ: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.419137414 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.41975065 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.420647248 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { info_tbl: [(c2xc2,
                       label: GHC.Word.$fNumWord32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xc2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xc3; else goto c2xc4;
       c2xc3: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xc4: // global
           I64[Sp - 8] = block_c2xbZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xcc; else goto c2xc0;
       u2xcc: // global
           call _c2xbZ(R1) args: 0, res: 0, upd: 0;
       c2xc0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xbZ() //  [R1]
         { info_tbl: [(c2xbZ,
                       label: block_c2xbZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xbZ: // global
           if (I64[R1 + 7] == 0) goto c2xcb; else goto c2xca;
       c2xcb: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xca: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.421867883 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.42280515 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2xck,
                       label: GHC.Word.$fBitsWord32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xck: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xcr; else goto c2xcs;
       c2xcr: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xcs: // global
           I64[Sp - 8] = block_c2xch_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xcw; else goto c2xci;
       u2xcw: // global
           call _c2xch(R1) args: 0, res: 0, upd: 0;
       c2xci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xch() //  [R1]
         { info_tbl: [(c2xch,
                       label: block_c2xch_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xch: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xcv; else goto c2xcu;
       c2xcv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xcu: // global
           _s2v87::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v87::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.424781954 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.425573324 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2xcB,
                       label: GHC.Word.$fBitsWord32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xcB: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.426692478 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { info_tbl: [(c2xcL,
                       label: GHC.Word.$fBitsWord32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xcL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xcM; else goto c2xcN;
       c2xcM: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xcN: // global
           I64[Sp - 8] = block_c2xcI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xd6; else goto c2xcJ;
       u2xd6: // global
           call _c2xcI(R1) args: 0, res: 0, upd: 0;
       c2xcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xcI() //  [R1]
         { info_tbl: [(c2xcI,
                       label: block_c2xcI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xcI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xcS; else goto c2xcR;
       c2xcS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xcR: // global
           _s2v8b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8b::I64, 64)) goto c2xd4; else goto c2xd5;
       c2xd4: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8b::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xd5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.428455162 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2xde,
                       label: GHC.Word.$fBitsWord32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xde: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xdi; else goto c2xdj;
       c2xdi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xdj: // global
           I64[Sp - 16] = block_c2xdb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xdS; else goto c2xdc;
       u2xdS: // global
           call _c2xdb(R1) args: 0, res: 0, upd: 0;
       c2xdc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xdb() //  [R1]
         { info_tbl: [(c2xdb,
                       label: block_c2xdb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xdb: // global
           I64[Sp] = block_c2xdh_info;
           _s2v8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8i::I64;
           if (R1 & 7 != 0) goto u2xdR; else goto c2xdl;
       u2xdR: // global
           call _c2xdh(R1) args: 0, res: 0, upd: 0;
       c2xdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xdh() //  [R1]
         { info_tbl: [(c2xdh,
                       label: block_c2xdh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xdh: // global
           _s2v8k::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v8k::I64, 64)) goto c2xdQ; else goto c2xdP;
       c2xdP: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8k::I64)) == 0) goto c2xdQ; else goto c2xdE;
       c2xdQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xdE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.43066532 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2xe0,
                       label: GHC.Word.$fBitsWord32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xe0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xe4; else goto c2xe5;
       c2xe4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xe5: // global
           I64[Sp - 16] = block_c2xdX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xeV; else goto c2xdY;
       u2xeV: // global
           call _c2xdX(R1) args: 0, res: 0, upd: 0;
       c2xdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xdX() //  [R1]
         { info_tbl: [(c2xdX,
                       label: block_c2xdX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xdX: // global
           I64[Sp - 8] = block_c2xe3_info;
           _s2v8r::P64 = R1;
           _s2v8s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8s::I64;
           P64[Sp + 8] = _s2v8r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xeU; else goto c2xe7;
       u2xeU: // global
           call _c2xe3(R1) args: 0, res: 0, upd: 0;
       c2xe7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xe3() //  [R1]
         { info_tbl: [(c2xe3,
                       label: block_c2xe3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xe3: // global
           _s2v8y::I64 = -I64[R1 + 7] & 31;
           if (_s2v8y::I64 != 0) goto u2xeS; else goto c2xeO;
       u2xeS: // global
           I64[Sp + 16] = _s2v8y::I64;
           Sp = Sp + 8;
           call _c2xep() args: 0, res: 0, upd: 0;
       c2xeO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2xep() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xep: // global
           Hp = Hp + 16;
           _s2v8y::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2xeL; else goto c2xeK;
       c2xeL: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2xeo_info;
           R1 = _s2v8y::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2xeK: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2v8s::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2v8s::I64 << _s2v8y::I64) | (_s2v8s::I64 >> 32 - _s2v8y::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2xeo() //  [R1]
         { info_tbl: [(c2xeo,
                       label: block_c2xeo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xeo: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2xep() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.433018269 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2xf5,
                       label: GHC.Word.$fBitsWord32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xf5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xf9; else goto c2xfa;
       c2xf9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xfa: // global
           I64[Sp - 16] = block_c2xf2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xfA; else goto c2xf3;
       u2xfA: // global
           call _c2xf2(R1) args: 0, res: 0, upd: 0;
       c2xf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xf2() //  [R1]
         { info_tbl: [(c2xf2,
                       label: block_c2xf2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xf2: // global
           I64[Sp - 8] = block_c2xf8_info;
           _s2v8G::P64 = R1;
           _s2v8H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8H::I64;
           P64[Sp + 8] = _s2v8G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xfz; else goto c2xfc;
       u2xfz: // global
           call _c2xf8(R1) args: 0, res: 0, upd: 0;
       c2xfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xf8() //  [R1]
         { info_tbl: [(c2xf8,
                       label: block_c2xf8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xf8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xfi; else goto c2xfh;
       c2xfi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xfh: // global
           _s2v8J::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8J::I64, 64)) goto c2xfx; else goto c2xfy;
       c2xfx: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8J::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xfy: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.435094745 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2xfI,
                       label: GHC.Word.$fBitsWord32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xfI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xfM; else goto c2xfN;
       c2xfM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xfN: // global
           I64[Sp - 16] = block_c2xfF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xgl; else goto c2xfG;
       u2xgl: // global
           call _c2xfF(R1) args: 0, res: 0, upd: 0;
       c2xfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xfF() //  [R1]
         { info_tbl: [(c2xfF,
                       label: block_c2xfF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xfF: // global
           I64[Sp] = block_c2xfL_info;
           _s2v8R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8R::I64;
           if (R1 & 7 != 0) goto u2xgk; else goto c2xfP;
       u2xgk: // global
           call _c2xfL(R1) args: 0, res: 0, upd: 0;
       c2xfP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xfL() //  [R1]
         { info_tbl: [(c2xfL,
                       label: block_c2xfL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xfL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xfV; else goto c2xfU;
       c2xfV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xfU: // global
           _s2v8R::I64 = I64[Sp + 8];
           _s2v8T::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8T::I64, 64)) goto c2xgd; else goto c2xgj;
       c2xgd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8T::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xgj: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.437105197 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2xgt,
                       label: GHC.Word.$fBitsWord32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xgt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xgx; else goto c2xgy;
       c2xgx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xgy: // global
           I64[Sp - 16] = block_c2xgq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xgY; else goto c2xgr;
       u2xgY: // global
           call _c2xgq(R1) args: 0, res: 0, upd: 0;
       c2xgr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xgq() //  [R1]
         { info_tbl: [(c2xgq,
                       label: block_c2xgq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xgq: // global
           I64[Sp - 8] = block_c2xgw_info;
           _s2v92::P64 = R1;
           _s2v93::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v93::I64;
           P64[Sp + 8] = _s2v92::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xgX; else goto c2xgA;
       u2xgX: // global
           call _c2xgw(R1) args: 0, res: 0, upd: 0;
       c2xgA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xgw() //  [R1]
         { info_tbl: [(c2xgw,
                       label: block_c2xgw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xgw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xgG; else goto c2xgF;
       c2xgG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xgF: // global
           _s2v95::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v95::I64, 64)) goto c2xgV; else goto c2xgW;
       c2xgV: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v95::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xgW: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.438803483 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2xh3,
                       label: GHC.Word.$fBitsWord32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xh3: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.439602263 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.440376035 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.441566219 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2xhd,
                       label: GHC.Word.$fIntegralWord32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xhh; else goto c2xhi;
       c2xhh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xhi: // global
           I64[Sp - 16] = block_c2xha_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xhB; else goto c2xhb;
       u2xhB: // global
           call _c2xha(R1) args: 0, res: 0, upd: 0;
       c2xhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xha() //  [R1]
         { info_tbl: [(c2xha,
                       label: block_c2xha_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xha: // global
           I64[Sp] = block_c2xhg_info;
           _s2v9d::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9d::I64;
           if (R1 & 7 != 0) goto u2xhA; else goto c2xhk;
       u2xhA: // global
           call _c2xhg(R1) args: 0, res: 0, upd: 0;
       c2xhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xhg() //  [R1]
         { info_tbl: [(c2xhg,
                       label: block_c2xhg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xhg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xhq; else goto c2xhp;
       c2xhq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xhp: // global
           _s2v9g::I64 = I64[R1 + 7];
           if (_s2v9g::I64 != 0) goto c2xhy; else goto c2xhz;
       c2xhy: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v9g::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xhz: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.444442394 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2xhJ,
                       label: GHC.Word.$fIntegralWord32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xhJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xhN; else goto c2xhO;
       c2xhN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xhO: // global
           I64[Sp - 16] = block_c2xhG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xi7; else goto c2xhH;
       u2xi7: // global
           call _c2xhG(R1) args: 0, res: 0, upd: 0;
       c2xhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xhG() //  [R1]
         { info_tbl: [(c2xhG,
                       label: block_c2xhG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xhG: // global
           I64[Sp] = block_c2xhM_info;
           _s2v9l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9l::I64;
           if (R1 & 7 != 0) goto u2xi6; else goto c2xhQ;
       u2xi6: // global
           call _c2xhM(R1) args: 0, res: 0, upd: 0;
       c2xhQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xhM() //  [R1]
         { info_tbl: [(c2xhM,
                       label: block_c2xhM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xhW; else goto c2xhV;
       c2xhW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xhV: // global
           _s2v9o::I64 = I64[R1 + 7];
           if (_s2v9o::I64 != 0) goto c2xi4; else goto c2xi5;
       c2xi4: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v9o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xi5: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.446386737 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2xif,
                       label: GHC.Word.$fIntegralWord32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xij; else goto c2xik;
       c2xij: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xik: // global
           I64[Sp - 16] = block_c2xic_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xiC; else goto c2xid;
       u2xiC: // global
           call _c2xic(R1) args: 0, res: 0, upd: 0;
       c2xid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xic() //  [R1]
         { info_tbl: [(c2xic,
                       label: block_c2xic_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xic: // global
           I64[Sp] = block_c2xii_info;
           _s2v9t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9t::I64;
           if (R1 & 7 != 0) goto u2xiB; else goto c2xim;
       u2xiB: // global
           call _c2xii(R1) args: 0, res: 0, upd: 0;
       c2xim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xii() //  [R1]
         { info_tbl: [(c2xii,
                       label: block_c2xii_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xii: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2xis; else goto c2xir;
       c2xis: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xir: // global
           _s2v9w::I64 = I64[R1 + 7];
           if (_s2v9w::I64 != 0) goto c2xiz; else goto c2xiA;
       c2xiz: // global
           (_s2v9y::I64, _s2v9z::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v9w::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2v9z::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2v9y::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xiA: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.448656523 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2v9M_entry() //  [R1]
         { info_tbl: [(c2xiZ,
                       label: sat_s2v9M_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xiZ: // global
           _s2v9M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xj2; else goto c2xj3;
       c2xj3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xj5; else goto c2xj4;
       c2xj5: // global
           HpAlloc = 16;
           goto c2xj2;
       c2xj2: // global
           R1 = _s2v9M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xj4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9M::P64;
           _s2v9L::I64 = I64[_s2v9M::P64 + 16] % I64[_s2v9M::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9L::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v9K_entry() //  [R1]
         { info_tbl: [(c2xjc,
                       label: sat_s2v9K_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjc: // global
           _s2v9K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xjf; else goto c2xjg;
       c2xjg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xji; else goto c2xjh;
       c2xji: // global
           HpAlloc = 16;
           goto c2xjf;
       c2xjf: // global
           R1 = _s2v9K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9K::P64;
           _s2v9J::I64 = I64[_s2v9K::P64 + 16] / I64[_s2v9K::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9J::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2xjj,
                       label: GHC.Word.$fIntegralWord32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xjk; else goto c2xjl;
       c2xjk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xjl: // global
           I64[Sp - 16] = block_c2xiH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xjv; else goto c2xiI;
       u2xjv: // global
           call _c2xiH(R1) args: 0, res: 0, upd: 0;
       c2xiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xiH() //  [R1]
         { info_tbl: [(c2xiH,
                       label: block_c2xiH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xiH: // global
           I64[Sp] = block_c2xiM_info;
           _s2v9F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9F::I64;
           if (R1 & 7 != 0) goto u2xju; else goto c2xiN;
       u2xju: // global
           call _c2xiM(R1) args: 0, res: 0, upd: 0;
       c2xiN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xiM() //  [R1]
         { info_tbl: [(c2xiM,
                       label: block_c2xiM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xiM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2xjp; else goto c2xjo;
       c2xjp: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xjo: // global
           _s2v9I::I64 = I64[R1 + 7];
           if (_s2v9I::I64 != 0) goto c2xjs; else goto c2xjt;
       c2xjs: // global
           I64[Hp - 80] = sat_s2v9M_info;
           _s2v9F::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v9F::I64;
           I64[Hp - 56] = _s2v9I::I64;
           I64[Hp - 48] = sat_s2v9K_info;
           I64[Hp - 32] = _s2v9F::I64;
           I64[Hp - 24] = _s2v9I::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xjt: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.451261976 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { info_tbl: [(c2xjD,
                       label: GHC.Word.gtWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xjH; else goto c2xjI;
       c2xjH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xjI: // global
           I64[Sp - 16] = block_c2xjA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xjR; else goto c2xjB;
       u2xjR: // global
           call _c2xjA(R1) args: 0, res: 0, upd: 0;
       c2xjB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xjA() //  [R1]
         { info_tbl: [(c2xjA,
                       label: block_c2xjA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjA: // global
           I64[Sp] = block_c2xjG_info;
           _s2v9Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9Q::I64;
           if (R1 & 7 != 0) goto u2xjQ; else goto c2xjK;
       u2xjQ: // global
           call _c2xjG(R1) args: 0, res: 0, upd: 0;
       c2xjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xjG() //  [R1]
         { info_tbl: [(c2xjG,
                       label: block_c2xjG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjG: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.452750213 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { info_tbl: [(c2xjZ,
                       label: GHC.Word.geWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xk3; else goto c2xk4;
       c2xk3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xk4: // global
           I64[Sp - 16] = block_c2xjW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xkd; else goto c2xjX;
       u2xkd: // global
           call _c2xjW(R1) args: 0, res: 0, upd: 0;
       c2xjX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xjW() //  [R1]
         { info_tbl: [(c2xjW,
                       label: block_c2xjW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xjW: // global
           I64[Sp] = block_c2xk2_info;
           _s2v9X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9X::I64;
           if (R1 & 7 != 0) goto u2xkc; else goto c2xk6;
       u2xkc: // global
           call _c2xk2(R1) args: 0, res: 0, upd: 0;
       c2xk6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xk2() //  [R1]
         { info_tbl: [(c2xk2,
                       label: block_c2xk2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xk2: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.454866053 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { info_tbl: [(c2xkl,
                       label: GHC.Word.ltWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xkl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xkp; else goto c2xkq;
       c2xkp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xkq: // global
           I64[Sp - 16] = block_c2xki_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xkz; else goto c2xkj;
       u2xkz: // global
           call _c2xki(R1) args: 0, res: 0, upd: 0;
       c2xkj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xki() //  [R1]
         { info_tbl: [(c2xki,
                       label: block_c2xki_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xki: // global
           I64[Sp] = block_c2xko_info;
           _s2va4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2va4::I64;
           if (R1 & 7 != 0) goto u2xky; else goto c2xks;
       u2xky: // global
           call _c2xko(R1) args: 0, res: 0, upd: 0;
       c2xks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xko() //  [R1]
         { info_tbl: [(c2xko,
                       label: block_c2xko_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xko: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.456540547 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { info_tbl: [(c2xkH,
                       label: GHC.Word.leWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xkH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xkL; else goto c2xkM;
       c2xkL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xkM: // global
           I64[Sp - 16] = block_c2xkE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xkV; else goto c2xkF;
       u2xkV: // global
           call _c2xkE(R1) args: 0, res: 0, upd: 0;
       c2xkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xkE() //  [R1]
         { info_tbl: [(c2xkE,
                       label: block_c2xkE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xkE: // global
           I64[Sp] = block_c2xkK_info;
           _s2vab::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vab::I64;
           if (R1 & 7 != 0) goto u2xkU; else goto c2xkO;
       u2xkU: // global
           call _c2xkK(R1) args: 0, res: 0, upd: 0;
       c2xkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xkK() //  [R1]
         { info_tbl: [(c2xkK,
                       label: block_c2xkK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xkK: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.458344881 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2xl3,
                       label: GHC.Word.$fOrdWord32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xl3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xl7; else goto c2xl8;
       c2xl7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xl8: // global
           I64[Sp - 16] = block_c2xl0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xlr; else goto c2xl1;
       u2xlr: // global
           call _c2xl0(R1) args: 0, res: 0, upd: 0;
       c2xl1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xl0() //  [R1]
         { info_tbl: [(c2xl0,
                       label: block_c2xl0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xl0: // global
           I64[Sp] = block_c2xl6_info;
           _s2vai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vai::I64;
           if (R1 & 7 != 0) goto u2xlq; else goto c2xla;
       u2xlq: // global
           call _c2xl6(R1) args: 0, res: 0, upd: 0;
       c2xla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xl6() //  [R1]
         { info_tbl: [(c2xl6,
                       label: block_c2xl6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xl6: // global
           _s2vai::I64 = I64[Sp + 8];
           _s2vak::I64 = I64[R1 + 7];
           if (_s2vai::I64 == _s2vak::I64) goto c2xlp; else goto c2xlo;
       c2xlp: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xlo: // global
           if (_s2vai::I64 > _s2vak::I64) goto c2xll; else goto c2xlm;
       c2xll: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xlm: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.46024509 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2xlz,
                       label: GHC.Word.$fOrdWord32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xlz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xlD; else goto c2xlE;
       c2xlD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xlE: // global
           I64[Sp - 16] = block_c2xlw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xlR; else goto c2xlx;
       u2xlR: // global
           call _c2xlw(R1) args: 0, res: 0, upd: 0;
       c2xlx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xlw() //  [R1]
         { info_tbl: [(c2xlw,
                       label: block_c2xlw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xlw: // global
           I64[Sp - 8] = block_c2xlC_info;
           _s2vap::P64 = R1;
           _s2vaq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vaq::I64;
           P64[Sp + 8] = _s2vap::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xlQ; else goto c2xlG;
       u2xlQ: // global
           call _c2xlC(R1) args: 0, res: 0, upd: 0;
       c2xlG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xlC() //  [R1]
         { info_tbl: [(c2xlC,
                       label: block_c2xlC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xlC: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2xlO; else goto c2xlP;
       c2xlO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xlP: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.462145891 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2xlZ,
                       label: GHC.Word.$fOrdWord32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xlZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xm3; else goto c2xm4;
       c2xm3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xm4: // global
           I64[Sp - 16] = block_c2xlW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xmh; else goto c2xlX;
       u2xmh: // global
           call _c2xlW(R1) args: 0, res: 0, upd: 0;
       c2xlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xlW() //  [R1]
         { info_tbl: [(c2xlW,
                       label: block_c2xlW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xlW: // global
           I64[Sp - 8] = block_c2xm2_info;
           _s2vaw::P64 = R1;
           _s2vax::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vax::I64;
           P64[Sp + 8] = _s2vaw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xmg; else goto c2xm6;
       u2xmg: // global
           call _c2xm2(R1) args: 0, res: 0, upd: 0;
       c2xm6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xm2() //  [R1]
         { info_tbl: [(c2xm2,
                       label: block_c2xm2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xm2: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2xme; else goto c2xmf;
       c2xme: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xmf: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.464612701 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.465805226 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2xmp,
                       label: GHC.Word.$fIxWord32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xmp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xmy; else goto c2xmz;
       c2xmy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xmz: // global
           I64[Sp - 16] = block_c2xmm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xmW; else goto c2xmn;
       u2xmW: // global
           call _c2xmm(R1) args: 0, res: 0, upd: 0;
       c2xmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xmm() //  [R1]
         { info_tbl: [(c2xmm,
                       label: block_c2xmm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xmm: // global
           I64[Sp - 8] = block_c2xms_info;
           _s2vaF::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vaF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xmV; else goto c2xmt;
       u2xmV: // global
           call _c2xms(R1) args: 0, res: 0, upd: 0;
       c2xmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xms() //  [R1]
         { info_tbl: [(c2xms,
                       label: block_c2xms_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xms: // global
           I64[Sp] = block_c2xmx_info;
           _s2vaH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vaH::I64;
           if (R1 & 7 != 0) goto u2xmX; else goto c2xmC;
       u2xmX: // global
           call _c2xmx(R1) args: 0, res: 0, upd: 0;
       c2xmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xmx() //  [R1]
         { info_tbl: [(c2xmx,
                       label: block_c2xmx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xmx: // global
           _s2vaJ::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vaJ::I64) goto c2xmK; else goto c2xmO;
       c2xmK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xmO: // global
           _s2vaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2xmN_info;
           R1 = _s2vaF::P64;
           I64[Sp + 16] = _s2vaJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2xmY; else goto c2xmP;
       u2xmY: // global
           call _c2xmN(R1) args: 0, res: 0, upd: 0;
       c2xmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xmN() //  [R1]
         { info_tbl: [(c2xmN,
                       label: block_c2xmN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xmN: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.468014967 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2xn6,
                       label: GHC.Word.$fRealWord32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xn6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xnn; else goto c2xno;
       c2xnn: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xno: // global
           I64[Sp - 8] = block_c2xn3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xnv; else goto c2xn4;
       u2xnv: // global
           call _c2xn3(R1) args: 0, res: 0, upd: 0;
       c2xn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xn3() //  [R1]
         { info_tbl: [(c2xn3,
                       label: block_c2xn3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xn3: // global
           I64[Sp] = block_c2xnc_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xnc() //  [R1]
         { info_tbl: [(c2xnc,
                       label: block_c2xnc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnc: // global
           I64[Sp] = block_c2xng_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xng() //  [R1]
         { info_tbl: [(c2xng,
                       label: block_c2xng_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xng: // global
           I64[Sp] = block_c2xnk_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xnk() //  [R1, R2]
         { info_tbl: [(c2xnk,
                       label: block_c2xnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xnu; else goto c2xnt;
       c2xnu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xnt: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.469639794 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.470266959 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.471434124 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2xnD,
                       label: GHC.Word.$fIxWord32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xo0; else goto c2xo1;
       c2xo0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xo1: // global
           I64[Sp - 16] = block_c2xnA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xo8; else goto c2xnB;
       u2xo8: // global
           call _c2xnA(R1) args: 0, res: 0, upd: 0;
       c2xnB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xnA() //  [R1]
         { info_tbl: [(c2xnA,
                       label: block_c2xnA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnA: // global
           I64[Sp] = block_c2xnG_info;
           _s2vb0::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vb0::P64;
           if (R1 & 7 != 0) goto u2xo7; else goto c2xnH;
       u2xo7: // global
           call _c2xnG(R1) args: 0, res: 0, upd: 0;
       c2xnH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xnG() //  [R1]
         { info_tbl: [(c2xnG,
                       label: block_c2xnG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnG: // global
           I64[Sp] = block_c2xnL_info;
           _s2vb3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vb3::I64;
           if (R1 & 7 != 0) goto u2xo9; else goto c2xnM;
       u2xo9: // global
           call _c2xnL(R1) args: 0, res: 0, upd: 0;
       c2xnM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xnL() //  [R1]
         { info_tbl: [(c2xnL,
                       label: block_c2xnL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xnL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xo6; else goto c2xo5;
       c2xo6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xo5: // global
           _s2vb8::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vb8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.473295515 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { info_tbl: [(c2xoh,
                       label: GHC.Word.$fIxWord32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xoh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xoi; else goto c2xoj;
       c2xoi: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xoj: // global
           I64[Sp - 8] = block_c2xoe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xon; else goto c2xof;
       u2xon: // global
           call _c2xoe(R1) args: 0, res: 0, upd: 0;
       c2xof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xoe() //  [R1]
         { info_tbl: [(c2xoe,
                       label: block_c2xoe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xoe: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.474874483 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2xov,
                       label: GHC.Word.$fIxWord32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xoE; else goto c2xoF;
       c2xoE: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xoF: // global
           I64[Sp - 8] = block_c2xos_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xpa; else goto c2xot;
       u2xpa: // global
           call _c2xos(R1) args: 0, res: 0, upd: 0;
       c2xot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xos() //  [R1]
         { info_tbl: [(c2xos,
                       label: block_c2xos_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xos: // global
           I64[Sp - 8] = block_c2xoy_info;
           _s2vbg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xp9; else goto c2xoz;
       u2xp9: // global
           call _c2xoy(R1) args: 0, res: 0, upd: 0;
       c2xoz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xoy() //  [R1]
         { info_tbl: [(c2xoy,
                       label: block_c2xoy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xoy: // global
           I64[Sp] = block_c2xoD_info;
           _s2vbi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbi::I64;
           if (R1 & 7 != 0) goto u2xpb; else goto c2xoI;
       u2xpb: // global
           call _c2xoD(R1) args: 0, res: 0, upd: 0;
       c2xoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xoD() //  [R1]
         { info_tbl: [(c2xoD,
                       label: block_c2xoD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xoD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xoO; else goto c2xoN;
       c2xoO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xoN: // global
           _s2vbi::I64 = I64[Sp + 8];
           _s2vbk::I64 = I64[R1 + 7];
           if (_s2vbi::I64 > _s2vbk::I64) goto c2xoS; else goto c2xp8;
       c2xoS: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xp8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbk::I64 - _s2vbi::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.477068263 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2xpj,
                       label: GHC.Word.$fIxWord32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xpj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xpJ; else goto c2xpK;
       c2xpJ: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xpK: // global
           I64[Sp - 8] = block_c2xpg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xpR; else goto c2xph;
       u2xpR: // global
           call _c2xpg(R1) args: 0, res: 0, upd: 0;
       c2xph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xpg() //  [R1]
         { info_tbl: [(c2xpg,
                       label: block_c2xpg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xpg: // global
           I64[Sp - 8] = block_c2xpm_info;
           _s2vbs::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vbs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xpQ; else goto c2xpn;
       u2xpQ: // global
           call _c2xpm(R1) args: 0, res: 0, upd: 0;
       c2xpn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xpm() //  [R1]
         { info_tbl: [(c2xpm,
                       label: block_c2xpm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xpm: // global
           I64[Sp] = block_c2xpr_info;
           _s2vbv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbv::I64;
           if (R1 & 7 != 0) goto u2xpS; else goto c2xps;
       u2xpS: // global
           call _c2xpr(R1) args: 0, res: 0, upd: 0;
       c2xps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xpr() //  [R1]
         { info_tbl: [(c2xpr,
                       label: block_c2xpr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xpr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xpP; else goto c2xpO;
       c2xpP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xpO: // global
           _s2vbB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vbB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.479510893 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2xq0,
                       label: GHC.Word.$fIxWord32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xq0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xq9; else goto c2xqa;
       c2xq9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xqa: // global
           I64[Sp - 16] = block_c2xpX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xqP; else goto c2xpY;
       u2xqP: // global
           call _c2xpX(R1) args: 0, res: 0, upd: 0;
       c2xpY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xpX() //  [R1]
         { info_tbl: [(c2xpX,
                       label: block_c2xpX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xpX: // global
           I64[Sp - 8] = block_c2xq3_info;
           _s2vbG::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xqO; else goto c2xq4;
       u2xqO: // global
           call _c2xq3(R1) args: 0, res: 0, upd: 0;
       c2xq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xq3() //  [R1]
         { info_tbl: [(c2xq3,
                       label: block_c2xq3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xq3: // global
           I64[Sp] = block_c2xq8_info;
           _s2vbI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vbI::I64;
           if (R1 & 7 != 0) goto u2xqQ; else goto c2xqd;
       u2xqQ: // global
           call _c2xq8(R1) args: 0, res: 0, upd: 0;
       c2xqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xq8() //  [R1]
         { info_tbl: [(c2xq8,
                       label: block_c2xq8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xq8: // global
           _s2vbK::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vbK::I64) goto c2xql; else goto c2xqp;
       c2xql: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xqp: // global
           I64[Sp] = block_c2xqo_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbK::I64;
           if (R1 & 7 != 0) goto u2xqR; else goto c2xqq;
       u2xqR: // global
           call _c2xqo(R1) args: 0, res: 0, upd: 0;
       c2xqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xqo() //  [R1]
         { info_tbl: [(c2xqo,
                       label: block_c2xqo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xqo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xqw; else goto c2xqv;
       c2xqw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xqv: // global
           _s2vbK::I64 = I64[Sp + 8];
           if (_s2vbK::I64 > I64[R1 + 7]) goto c2xqA; else goto c2xqN;
       c2xqA: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xqN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbK::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.481793913 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.483737215 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { info_tbl: [(c2xqZ,
                       label: GHC.Word.byteSwap32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xqZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xra; else goto c2xrb;
       c2xra: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xrb: // global
           I64[Sp - 8] = block_c2xqW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xrf; else goto c2xqX;
       u2xrf: // global
           call _c2xqW(R1) args: 0, res: 0, upd: 0;
       c2xqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xqW() //  [R1]
         { info_tbl: [(c2xqW,
                       label: block_c2xqW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xqW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xre; else goto c2xrd;
       c2xre: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xrd: // global
           (_c2xr2::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2xr2::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.485287883 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2xrn,
                       label: GHC.Word.$fBitsWord64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xrn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xru; else goto c2xrv;
       c2xru: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xrv: // global
           I64[Sp - 8] = block_c2xrk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xrz; else goto c2xrl;
       u2xrz: // global
           call _c2xrk(R1) args: 0, res: 0, upd: 0;
       c2xrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xrk() //  [R1]
         { info_tbl: [(c2xrk,
                       label: block_c2xrk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xrk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xry; else goto c2xrx;
       c2xry: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xrx: // global
           _s2vc0::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vc0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.486447297 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.487196784 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2xrE,
                       label: GHC.Word.$fBitsWord64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xrE: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.488282886 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { info_tbl: [(c2xrO,
                       label: GHC.Word.$fBitsWord64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xrO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xrP; else goto c2xrQ;
       c2xrP: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xrQ: // global
           I64[Sp - 8] = block_c2xrL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xs6; else goto c2xrM;
       u2xs6: // global
           call _c2xrL(R1) args: 0, res: 0, upd: 0;
       c2xrM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xrL() //  [R1]
         { info_tbl: [(c2xrL,
                       label: block_c2xrL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xrL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xrV; else goto c2xrU;
       c2xrV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xrU: // global
           _s2vc4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vc4::I64, 64)) goto c2xs4; else goto c2xs5;
       c2xs4: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2vc4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xs5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.490266136 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2xse,
                       label: GHC.Word.$fBitsWord64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xse: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xsi; else goto c2xsj;
       c2xsi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xsj: // global
           I64[Sp - 16] = block_c2xsb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xsP; else goto c2xsc;
       u2xsP: // global
           call _c2xsb(R1) args: 0, res: 0, upd: 0;
       c2xsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xsb() //  [R1]
         { info_tbl: [(c2xsb,
                       label: block_c2xsb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xsb: // global
           I64[Sp] = block_c2xsh_info;
           _s2vca::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vca::I64;
           if (R1 & 7 != 0) goto u2xsO; else goto c2xsl;
       u2xsO: // global
           call _c2xsh(R1) args: 0, res: 0, upd: 0;
       c2xsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xsh() //  [R1]
         { info_tbl: [(c2xsh,
                       label: block_c2xsh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xsh: // global
           _s2vcc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2vcc::I64, 64)) goto c2xsN; else goto c2xsM;
       c2xsM: // global
           if (I64[Sp + 8] & (1 << _s2vcc::I64) == 0) goto c2xsN; else goto c2xsB;
       c2xsN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xsB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.492334549 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2xsX,
                       label: GHC.Word.$fBitsWord64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xsX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xt1; else goto c2xt2;
       c2xt1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xt2: // global
           I64[Sp - 16] = block_c2xsU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xtP; else goto c2xsV;
       u2xtP: // global
           call _c2xsU(R1) args: 0, res: 0, upd: 0;
       c2xsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xsU() //  [R1]
         { info_tbl: [(c2xsU,
                       label: block_c2xsU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xsU: // global
           I64[Sp - 8] = block_c2xt0_info;
           _s2vci::P64 = R1;
           _s2vcj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcj::I64;
           P64[Sp + 8] = _s2vci::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xtO; else goto c2xt4;
       u2xtO: // global
           call _c2xt0(R1) args: 0, res: 0, upd: 0;
       c2xt4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xt0() //  [R1]
         { info_tbl: [(c2xt0,
                       label: block_c2xt0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xt0: // global
           _s2vcp::I64 = -I64[R1 + 7] & 63;
           if (_s2vcp::I64 != 0) goto u2xtM; else goto c2xtI;
       u2xtM: // global
           I64[Sp + 16] = _s2vcp::I64;
           Sp = Sp + 8;
           call _c2xtm() args: 0, res: 0, upd: 0;
       c2xtI: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2xtm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xtm: // global
           Hp = Hp + 16;
           _s2vcp::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2xtF; else goto c2xtE;
       c2xtF: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2xtl_info;
           R1 = _s2vcp::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2xtE: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2vcj::I64 = I64[Sp];
           I64[Hp] = (_s2vcj::I64 << _s2vcp::I64) | (_s2vcj::I64 >> 64 - _s2vcp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2xtl() //  [R1]
         { info_tbl: [(c2xtl,
                       label: block_c2xtl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xtl: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2xtm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.494757451 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2xtZ,
                       label: GHC.Word.$fBitsWord64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xtZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xu3; else goto c2xu4;
       c2xu3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xu4: // global
           I64[Sp - 16] = block_c2xtW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xur; else goto c2xtX;
       u2xur: // global
           call _c2xtW(R1) args: 0, res: 0, upd: 0;
       c2xtX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xtW() //  [R1]
         { info_tbl: [(c2xtW,
                       label: block_c2xtW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xtW: // global
           I64[Sp - 8] = block_c2xu2_info;
           _s2vcw::P64 = R1;
           _s2vcx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcx::I64;
           P64[Sp + 8] = _s2vcw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xuq; else goto c2xu6;
       u2xuq: // global
           call _c2xu2(R1) args: 0, res: 0, upd: 0;
       c2xu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xu2() //  [R1]
         { info_tbl: [(c2xu2,
                       label: block_c2xu2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xu2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xuc; else goto c2xub;
       c2xuc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xub: // global
           _s2vcz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcz::I64, 64)) goto c2xuo; else goto c2xup;
       c2xuo: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2vcz::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xup: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.496813458 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2xuz,
                       label: GHC.Word.$fBitsWord64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xuz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xuD; else goto c2xuE;
       c2xuD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xuE: // global
           I64[Sp - 16] = block_c2xuw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xv9; else goto c2xux;
       u2xv9: // global
           call _c2xuw(R1) args: 0, res: 0, upd: 0;
       c2xux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xuw() //  [R1]
         { info_tbl: [(c2xuw,
                       label: block_c2xuw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xuw: // global
           I64[Sp] = block_c2xuC_info;
           _s2vcG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vcG::I64;
           if (R1 & 7 != 0) goto u2xv8; else goto c2xuG;
       u2xv8: // global
           call _c2xuC(R1) args: 0, res: 0, upd: 0;
       c2xuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xuC() //  [R1]
         { info_tbl: [(c2xuC,
                       label: block_c2xuC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xuC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xuM; else goto c2xuL;
       c2xuM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xuL: // global
           _s2vcG::I64 = I64[Sp + 8];
           _s2vcI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcI::I64, 64)) goto c2xv1; else goto c2xv7;
       c2xv1: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & (1 << _s2vcI::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xv7: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.498965553 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2xvh,
                       label: GHC.Word.$fBitsWord64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xvh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xvl; else goto c2xvm;
       c2xvl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xvm: // global
           I64[Sp - 16] = block_c2xve_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xvJ; else goto c2xvf;
       u2xvJ: // global
           call _c2xve(R1) args: 0, res: 0, upd: 0;
       c2xvf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xve() //  [R1]
         { info_tbl: [(c2xve,
                       label: block_c2xve_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xve: // global
           I64[Sp - 8] = block_c2xvk_info;
           _s2vcQ::P64 = R1;
           _s2vcR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcR::I64;
           P64[Sp + 8] = _s2vcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xvI; else goto c2xvo;
       u2xvI: // global
           call _c2xvk(R1) args: 0, res: 0, upd: 0;
       c2xvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xvk() //  [R1]
         { info_tbl: [(c2xvk,
                       label: block_c2xvk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xvk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xvu; else goto c2xvt;
       c2xvu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xvt: // global
           _s2vcT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcT::I64, 64)) goto c2xvG; else goto c2xvH;
       c2xvG: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2vcT::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xvH: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.500664609 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2xvO,
                       label: GHC.Word.$fBitsWord64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xvO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.501582947 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.503387188 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.50464118 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2xvY,
                       label: GHC.Word.$fIxWord64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xvY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xw7; else goto c2xw8;
       c2xw7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xw8: // global
           I64[Sp - 16] = block_c2xvV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xwv; else goto c2xvW;
       u2xwv: // global
           call _c2xvV(R1) args: 0, res: 0, upd: 0;
       c2xvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xvV() //  [R1]
         { info_tbl: [(c2xvV,
                       label: block_c2xvV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xvV: // global
           I64[Sp - 8] = block_c2xw1_info;
           _s2vd1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vd1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xwu; else goto c2xw2;
       u2xwu: // global
           call _c2xw1(R1) args: 0, res: 0, upd: 0;
       c2xw2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xw1() //  [R1]
         { info_tbl: [(c2xw1,
                       label: block_c2xw1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xw1: // global
           I64[Sp] = block_c2xw6_info;
           _s2vd3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vd3::I64;
           if (R1 & 7 != 0) goto u2xww; else goto c2xwb;
       u2xww: // global
           call _c2xw6(R1) args: 0, res: 0, upd: 0;
       c2xwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xw6() //  [R1]
         { info_tbl: [(c2xw6,
                       label: block_c2xw6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xw6: // global
           _s2vd5::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vd5::I64) goto c2xwj; else goto c2xwn;
       c2xwj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xwn: // global
           _s2vd1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2xwm_info;
           R1 = _s2vd1::P64;
           I64[Sp + 16] = _s2vd5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2xwx; else goto c2xwo;
       u2xwx: // global
           call _c2xwm(R1) args: 0, res: 0, upd: 0;
       c2xwo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xwm() //  [R1]
         { info_tbl: [(c2xwm,
                       label: block_c2xwm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwm: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.50674545 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { info_tbl: [(c2xwF,
                       label: GHC.Word.$fIxWord64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xwG; else goto c2xwH;
       c2xwG: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xwH: // global
           I64[Sp - 8] = block_c2xwC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xwL; else goto c2xwD;
       u2xwL: // global
           call _c2xwC(R1) args: 0, res: 0, upd: 0;
       c2xwD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xwC() //  [R1]
         { info_tbl: [(c2xwC,
                       label: block_c2xwC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwC: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.508314005 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2xwT,
                       label: GHC.Word.$fIxWord64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xxd; else goto c2xxe;
       c2xxd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xxe: // global
           I64[Sp - 16] = block_c2xwQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xxl; else goto c2xwR;
       u2xxl: // global
           call _c2xwQ(R1) args: 0, res: 0, upd: 0;
       c2xwR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xwQ() //  [R1]
         { info_tbl: [(c2xwQ,
                       label: block_c2xwQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwQ: // global
           I64[Sp] = block_c2xwW_info;
           _s2vdh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vdh::P64;
           if (R1 & 7 != 0) goto u2xxk; else goto c2xwX;
       u2xxk: // global
           call _c2xwW(R1) args: 0, res: 0, upd: 0;
       c2xwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xwW() //  [R1]
         { info_tbl: [(c2xwW,
                       label: block_c2xwW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xwW: // global
           I64[Sp] = block_c2xx1_info;
           _s2vdk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdk::I64;
           if (R1 & 7 != 0) goto u2xxm; else goto c2xx2;
       u2xxm: // global
           call _c2xx1(R1) args: 0, res: 0, upd: 0;
       c2xx2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xx1() //  [R1]
         { info_tbl: [(c2xx1,
                       label: block_c2xx1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xx1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xxj; else goto c2xxi;
       c2xxj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xxi: // global
           _s2vdo::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.510804123 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2xxu,
                       label: GHC.Word.$fIxWord64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xxu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xxD; else goto c2xxE;
       c2xxD: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xxE: // global
           I64[Sp - 8] = block_c2xxr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xy6; else goto c2xxs;
       u2xy6: // global
           call _c2xxr(R1) args: 0, res: 0, upd: 0;
       c2xxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xxr() //  [R1]
         { info_tbl: [(c2xxr,
                       label: block_c2xxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xxr: // global
           I64[Sp - 8] = block_c2xxx_info;
           _s2vds::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vds::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xy5; else goto c2xxy;
       u2xy5: // global
           call _c2xxx(R1) args: 0, res: 0, upd: 0;
       c2xxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xxx() //  [R1]
         { info_tbl: [(c2xxx,
                       label: block_c2xxx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xxx: // global
           I64[Sp] = block_c2xxC_info;
           _s2vdu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdu::I64;
           if (R1 & 7 != 0) goto u2xy7; else goto c2xxH;
       u2xy7: // global
           call _c2xxC(R1) args: 0, res: 0, upd: 0;
       c2xxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xxC() //  [R1]
         { info_tbl: [(c2xxC,
                       label: block_c2xxC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xxC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xxN; else goto c2xxM;
       c2xxN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xxM: // global
           _s2vdu::I64 = I64[Sp + 8];
           _s2vdw::I64 = I64[R1 + 7];
           if (_s2vdu::I64 > _s2vdw::I64) goto c2xxR; else goto c2xy4;
       c2xxR: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xy4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdw::I64 - _s2vdu::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.512968259 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2xyf,
                       label: GHC.Word.$fIxWord64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xyC; else goto c2xyD;
       c2xyC: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xyD: // global
           I64[Sp - 8] = block_c2xyc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xyK; else goto c2xyd;
       u2xyK: // global
           call _c2xyc(R1) args: 0, res: 0, upd: 0;
       c2xyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xyc() //  [R1]
         { info_tbl: [(c2xyc,
                       label: block_c2xyc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyc: // global
           I64[Sp - 8] = block_c2xyi_info;
           _s2vdD::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vdD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xyJ; else goto c2xyj;
       u2xyJ: // global
           call _c2xyi(R1) args: 0, res: 0, upd: 0;
       c2xyj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xyi() //  [R1]
         { info_tbl: [(c2xyi,
                       label: block_c2xyi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyi: // global
           I64[Sp] = block_c2xyn_info;
           _s2vdG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdG::I64;
           if (R1 & 7 != 0) goto u2xyL; else goto c2xyo;
       u2xyL: // global
           call _c2xyn(R1) args: 0, res: 0, upd: 0;
       c2xyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xyn() //  [R1]
         { info_tbl: [(c2xyn,
                       label: block_c2xyn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xyI; else goto c2xyH;
       c2xyI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xyH: // global
           _s2vdL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.515347589 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2xyT,
                       label: GHC.Word.$fIxWord64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xz2; else goto c2xz3;
       c2xz2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xz3: // global
           I64[Sp - 16] = block_c2xyQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xzF; else goto c2xyR;
       u2xzF: // global
           call _c2xyQ(R1) args: 0, res: 0, upd: 0;
       c2xyR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xyQ() //  [R1]
         { info_tbl: [(c2xyQ,
                       label: block_c2xyQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyQ: // global
           I64[Sp - 8] = block_c2xyW_info;
           _s2vdQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vdQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xzE; else goto c2xyX;
       u2xzE: // global
           call _c2xyW(R1) args: 0, res: 0, upd: 0;
       c2xyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xyW() //  [R1]
         { info_tbl: [(c2xyW,
                       label: block_c2xyW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xyW: // global
           I64[Sp] = block_c2xz1_info;
           _s2vdS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vdS::I64;
           if (R1 & 7 != 0) goto u2xzG; else goto c2xz6;
       u2xzG: // global
           call _c2xz1(R1) args: 0, res: 0, upd: 0;
       c2xz6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xz1() //  [R1]
         { info_tbl: [(c2xz1,
                       label: block_c2xz1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xz1: // global
           _s2vdU::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vdU::I64) goto c2xze; else goto c2xzi;
       c2xze: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xzi: // global
           I64[Sp] = block_c2xzh_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdU::I64;
           if (R1 & 7 != 0) goto u2xzH; else goto c2xzj;
       u2xzH: // global
           call _c2xzh(R1) args: 0, res: 0, upd: 0;
       c2xzj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xzh() //  [R1]
         { info_tbl: [(c2xzh,
                       label: block_c2xzh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xzh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xzp; else goto c2xzo;
       c2xzp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xzo: // global
           _s2vdU::I64 = I64[Sp + 8];
           if (_s2vdU::I64 > I64[R1 + 7]) goto c2xzt; else goto c2xzD;
       c2xzt: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2xzD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.51754341 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.51834879 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c2xzN,
                       label: GHC.Word.uncheckedShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xzN: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.519298497 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { info_tbl: [(c2xzV,
                       label: GHC.Word.uncheckedShiftRL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xzV: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.520426408 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { info_tbl: [(c2xA5,
                       label: GHC.Word.byteSwap64_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xA5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xAd; else goto c2xAe;
       c2xAd: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xAe: // global
           I64[Sp - 8] = block_c2xA2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xAi; else goto c2xA3;
       u2xAi: // global
           call _c2xA2(R1) args: 0, res: 0, upd: 0;
       c2xA3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xA2() //  [R1]
         { info_tbl: [(c2xA2,
                       label: block_c2xA2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xA2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xAh; else goto c2xAg;
       c2xAh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xAg: // global
           (_c2xA8::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2xA8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.521917485 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.52351252 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.524129488 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.524693139 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.52551785 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.526164843 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.52679817 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.527397291 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.528019346 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.528659013 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.529328961 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.529956312 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.530551054 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.531204896 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.531809653 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.532506202 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.533154813 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.533842541 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.534499522 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.535102729 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.535818701 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.536446626 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.53719991 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.538156367 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.539585347 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.540214383 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.540895472 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.541612823 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.542208921 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.542895134 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.543521918 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.54414424 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.54469372 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.545373811 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.546400894 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { info_tbl: [(c2xAo,
                       label: GHC.Word.W8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xAs; else goto c2xAr;
       c2xAs: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xAr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.547559662 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { info_tbl: [(c2xAy,
                       label: GHC.Word.W16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xAC; else goto c2xAB;
       c2xAC: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xAB: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.548608224 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { info_tbl: [(c2xAI,
                       label: GHC.Word.W32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xAM; else goto c2xAL;
       c2xAM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xAL: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.54967277 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { info_tbl: [(c2xAS,
                       label: GHC.Word.W64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xAW; else goto c2xAV;
       c2xAW: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xAV: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.550572724 UTC

[GHC.Word.W8#_con_entry() //  [R1]
         { info_tbl: [(c2xAX,
                       label: GHC.Word.W8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.551409283 UTC

[GHC.Word.W16#_con_entry() //  [R1]
         { info_tbl: [(c2xAY,
                       label: GHC.Word.W16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.552187807 UTC

[GHC.Word.W32#_con_entry() //  [R1]
         { info_tbl: [(c2xAZ,
                       label: GHC.Word.W32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xAZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.552997948 UTC

[GHC.Word.W64#_con_entry() //  [R1]
         { info_tbl: [(c2xB0,
                       label: GHC.Word.W64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xB0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.553774034 UTC

[section ""relreadonly" . S2vim_srt" {
     S2vim_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2uHi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.555311577 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:10.556903638 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2xB8,
                       label: GHC.Word.$fEnumWord8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xB8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xBf; else goto c2xBg;
       c2xBf: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xBg: // global
           I64[Sp - 8] = block_c2xB5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xBk; else goto c2xB6;
       u2xBk: // global
           call _c2xB5(R1) args: 0, res: 0, upd: 0;
       c2xB6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xB5() //  [R1]
         { info_tbl: [(c2xB5,
                       label: block_c2xB5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xB5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xBj; else goto c2xBi;
       c2xBj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xBi: // global
           _s2uFW::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.558446939 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2xBs,
                       label: GHC.Word.$fEnumWord16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xBs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xBz; else goto c2xBA;
       c2xBz: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xBA: // global
           I64[Sp - 8] = block_c2xBp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xBE; else goto c2xBq;
       u2xBE: // global
           call _c2xBp(R1) args: 0, res: 0, upd: 0;
       c2xBq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xBp() //  [R1]
         { info_tbl: [(c2xBp,
                       label: block_c2xBp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xBp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xBD; else goto c2xBC;
       c2xBD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xBC: // global
           _s2uG0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.559899664 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2xBM,
                       label: GHC.Word.$fEnumWord32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xBM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xBT; else goto c2xBU;
       c2xBT: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xBU: // global
           I64[Sp - 8] = block_c2xBJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xBY; else goto c2xBK;
       u2xBY: // global
           call _c2xBJ(R1) args: 0, res: 0, upd: 0;
       c2xBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xBJ() //  [R1]
         { info_tbl: [(c2xBJ,
                       label: block_c2xBJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xBX; else goto c2xBW;
       c2xBX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xBW: // global
           _s2uG4::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.561546885 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2xC5,
                       label: GHC.Word.$fNumWord64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xC5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xC9; else goto c2xCa;
       c2xC9: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xCa: // global
           I64[Sp - 8] = block_c2xC3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xC3() //  [R1]
         { info_tbl: [(c2xC3,
                       label: block_c2xC3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xC3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xCd; else goto c2xCc;
       c2xCd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2xCc: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.562732802 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { info_tbl: [(c2xCi,
                       label: GHC.Word.$fNumWord64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.563760528 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { info_tbl: [(c2xCs,
                       label: GHC.Word.$fNumWord64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xCF; else goto c2xCG;
       c2xCF: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xCG: // global
           I64[Sp - 8] = block_c2xCp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xCK; else goto c2xCq;
       u2xCK: // global
           call _c2xCp(R1) args: 0, res: 0, upd: 0;
       c2xCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xCp() //  [R1]
         { info_tbl: [(c2xCp,
                       label: block_c2xCp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xCJ; else goto c2xCI;
       c2xCJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xCI: // global
           _s2uGd::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.565331966 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2xCS,
                       label: GHC.Word.$fNumWord64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xD4; else goto c2xD5;
       c2xD4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xD5: // global
           I64[Sp - 16] = block_c2xCP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xDb; else goto c2xCQ;
       u2xDb: // global
           call _c2xCP(R1) args: 0, res: 0, upd: 0;
       c2xCQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xCP() //  [R1]
         { info_tbl: [(c2xCP,
                       label: block_c2xCP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCP: // global
           I64[Sp] = block_c2xCV_info;
           _s2uGh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGh::I64;
           if (R1 & 7 != 0) goto u2xDa; else goto c2xCW;
       u2xDa: // global
           call _c2xCV(R1) args: 0, res: 0, upd: 0;
       c2xCW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xCV() //  [R1]
         { info_tbl: [(c2xCV,
                       label: block_c2xCV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xCV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xD9; else goto c2xD8;
       c2xD9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xD8: // global
           _s2uGk::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.567092869 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2xDj,
                       label: GHC.Word.$fNumWord64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xDv; else goto c2xDw;
       c2xDv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xDw: // global
           I64[Sp - 16] = block_c2xDg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xDC; else goto c2xDh;
       u2xDC: // global
           call _c2xDg(R1) args: 0, res: 0, upd: 0;
       c2xDh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xDg() //  [R1]
         { info_tbl: [(c2xDg,
                       label: block_c2xDg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDg: // global
           I64[Sp] = block_c2xDm_info;
           _s2uGo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGo::I64;
           if (R1 & 7 != 0) goto u2xDB; else goto c2xDn;
       u2xDB: // global
           call _c2xDm(R1) args: 0, res: 0, upd: 0;
       c2xDn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xDm() //  [R1]
         { info_tbl: [(c2xDm,
                       label: block_c2xDm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xDA; else goto c2xDz;
       c2xDA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xDz: // global
           _s2uGr::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.568884369 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2xDK,
                       label: GHC.Word.$fNumWord64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xDW; else goto c2xDX;
       c2xDW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xDX: // global
           I64[Sp - 16] = block_c2xDH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xE3; else goto c2xDI;
       u2xE3: // global
           call _c2xDH(R1) args: 0, res: 0, upd: 0;
       c2xDI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xDH() //  [R1]
         { info_tbl: [(c2xDH,
                       label: block_c2xDH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDH: // global
           I64[Sp] = block_c2xDN_info;
           _s2uGv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGv::I64;
           if (R1 & 7 != 0) goto u2xE2; else goto c2xDO;
       u2xE2: // global
           call _c2xDN(R1) args: 0, res: 0, upd: 0;
       c2xDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xDN() //  [R1]
         { info_tbl: [(c2xDN,
                       label: block_c2xDN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xDN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xE1; else goto c2xE0;
       c2xE1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xE0: // global
           _s2uGy::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.570354118 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.571165977 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { info_tbl: [(c2xEa,
                       label: lvl_r2uFF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xEb; else goto c2xEc;
       c2xEb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xEc: // global
           (_c2xE7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xE7::I64 == 0) goto c2xE9; else goto c2xE8;
       c2xE9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xE8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xE7::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.572500807 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2xEk,
                       label: GHC.Word.$fIntegralWord64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xEk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xEl; else goto c2xEm;
       c2xEl: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xEm: // global
           I64[Sp - 8] = block_c2xEh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xEy; else goto c2xEi;
       u2xEy: // global
           call _c2xEh(R1) args: 0, res: 0, upd: 0;
       c2xEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xEh() //  [R1]
         { info_tbl: [(c2xEh,
                       label: block_c2xEh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xEh: // global
           _s2uGB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGB::I64, 0)) goto c2xEw; else goto c2xEx;
       c2xEw: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2xEx: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.574492495 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2uGF_entry() //  [R1]
         { info_tbl: [(c2xEK,
                       label: w1_s2uGF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xEK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xEL; else goto c2xEM;
       c2xEL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xEM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2xEH_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xEY; else goto c2xEI;
       u2xEY: // global
           call _c2xEH(R1) args: 0, res: 0, upd: 0;
       c2xEI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2xEH() //  [R1]
         { info_tbl: [(c2xEH,
                       label: block_c2xEH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xEH: // global
           _s2uGH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGH::I64, 0)) goto c2xEW; else goto c2xEX;
       c2xEW: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2xEX: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uGO_entry() //  [R1, R2]
         { info_tbl: [(c2xF7,
                       label: sat_s2uGO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xF7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xF8; else goto c2xF9;
       c2xF8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xF9: // global
           I64[Sp - 8] = block_c2xF4_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xF4() //  [R1, R2]
         { info_tbl: [(c2xF4,
                       label: block_c2xF4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xF4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xFc; else goto c2xFb;
       c2xFc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xFb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { info_tbl: [(c2xFd,
                       label: GHC.Word.$fShowWord3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2xFh; else goto c2xFg;
       c2xFh: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xFg: // global
           I64[Hp - 32] = w1_s2uGF_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2uGO_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.578193066 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2xFm,
                       label: GHC.Word.$fShowWord64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFm: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.579402932 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { info_tbl: [(c2xFv,
                       label: GHC.Word.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xFw; else goto c2xFx;
       c2xFw: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xFx: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2xFE; else goto c2xFL;
       c2xFE: // global
           I64[Sp - 8] = block_c2xFC_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2xFL: // global
           I64[Sp - 8] = block_c2xFK_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xFC() //  [R1]
         { info_tbl: [(c2xFC,
                       label: block_c2xFC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFC: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2xFK() //  [R1]
         { info_tbl: [(c2xFK,
                       label: block_c2xFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFK: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.580912265 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { info_tbl: [(c2xFX,
                       label: GHC.Word.$fShowWord64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xG3; else goto c2xG4;
       c2xG3: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xG4: // global
           I64[Sp - 8] = block_c2xFU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xG9; else goto c2xFV;
       u2xG9: // global
           call _c2xFU(R1) args: 0, res: 0, upd: 0;
       c2xFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xFU() //  [R1]
         { info_tbl: [(c2xFU,
                       label: block_c2xFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xFU: // global
           I64[Sp] = block_c2xG0_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xG0() //  [R1, R2]
         { info_tbl: [(c2xG0,
                       label: block_c2xG0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xG0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xG8; else goto c2xG7;
       c2xG8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xG7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.582942869 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2uH4_entry() //  [R1]
         { info_tbl: [(c2xGl,
                       label: w1_s2uH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xGm; else goto c2xGn;
       c2xGm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2xGi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xGz; else goto c2xGj;
       u2xGz: // global
           call _c2xGi(R1) args: 0, res: 0, upd: 0;
       c2xGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2xGi() //  [R1]
         { info_tbl: [(c2xGi,
                       label: block_c2xGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGi: // global
           _s2uH6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uH6::I64, 0)) goto c2xGx; else goto c2xGy;
       c2xGx: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2xGy: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uHf_entry() //  [R1, R2]
         { info_tbl: [(c2xGI,
                       label: sat_s2uHf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xGO; else goto c2xGP;
       c2xGO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xGP: // global
           I64[Sp - 24] = block_c2xGF_info;
           _s2uH4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2uH4::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xGU; else goto c2xGG;
       u2xGU: // global
           call _c2xGF(R1) args: 0, res: 0, upd: 0;
       c2xGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xGF() //  [R1]
         { info_tbl: [(c2xGF,
                       label: block_c2xGF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGF: // global
           _s2uH9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2xGL_info;
           R4 = _s2uH9::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xGL() //  [R1, R2]
         { info_tbl: [(c2xGL,
                       label: block_c2xGL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xGT; else goto c2xGS;
       c2xGT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xGS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c2xGV,
                       label: GHC.Word.$fShowWord64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xGV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2xGZ; else goto c2xGY;
       c2xGZ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xGY: // global
           I64[Hp - 40] = w1_s2uH4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2uHf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.585036588 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.585815432 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { info_tbl: [(c2xH4,
                       label: GHC.Word.$fEnumWord5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xH4: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.586575968 UTC

[section ""data" . sat_s2uHh_closure" {
     sat_s2uHh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.587120571 UTC

[section ""data" . sat_s2uHi_closure" {
     sat_s2uHi_closure:
         const :_con_info;
         const sat_s2uHh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.58787414 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { info_tbl: [(c2xHd,
                       label: GHC.Word.$fRealWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xHe; else goto c2xHf;
       c2xHe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xHf: // global
           (_c2xHa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xHa::I64 == 0) goto c2xHc; else goto c2xHb;
       c2xHc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xHb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xHa::I64;
           R3 = sat_s2uHi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.589091219 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { info_tbl: [(c2xHm,
                       label: GHC.Word.$w$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xHn; else goto c2xHo;
       c2xHn: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xHo: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2xHz; else goto c2xHL;
       c2xHz: // global
           I64[Sp - 8] = block_c2xHt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2xHL: // global
           I64[Sp - 8] = block_c2xHG_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xHt() //  [R1]
         { info_tbl: [(c2xHt,
                       label: block_c2xHt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHt: // global
           I64[Sp] = block_c2xHx_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xHx() //  [R1]
         { info_tbl: [(c2xHx,
                       label: block_c2xHx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHx: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2xHG() //  [R1]
         { info_tbl: [(c2xHG,
                       label: block_c2xHG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHG: // global
           I64[Sp] = block_c2xHK_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xHK() //  [R1]
         { info_tbl: [(c2xHK,
                       label: block_c2xHK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHK: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.590869059 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2xHY,
                       label: GHC.Word.$fRealWord64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xI4; else goto c2xI5;
       c2xI4: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xI5: // global
           I64[Sp - 8] = block_c2xHV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xIa; else goto c2xHW;
       u2xIa: // global
           call _c2xHV(R1) args: 0, res: 0, upd: 0;
       c2xHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xHV() //  [R1]
         { info_tbl: [(c2xHV,
                       label: block_c2xHV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xHV: // global
           I64[Sp] = block_c2xI1_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xI1() //  [R1, R2]
         { info_tbl: [(c2xI1,
                       label: block_c2xI1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xI1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xI9; else goto c2xI8;
       c2xI9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xI8: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.592120808 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.592957329 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { info_tbl: [(c2xIj,
                       label: GHC.Word.$fEnumWord10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xIk; else goto c2xIl;
       c2xIk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xIl: // global
           (_c2xIe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xIe::I64 == 0) goto c2xIg; else goto c2xIf;
       c2xIg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xIf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xIe::I64;
           I64[Sp - 24] = block_c2xIh_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2xIh() //  [R1]
         { info_tbl: [(c2xIh,
                       label: block_c2xIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.594428036 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { info_tbl: [(c2xIx,
                       label: GHC.Word.$fEnumWord11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xIy; else goto c2xIz;
       c2xIy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xIz: // global
           (_c2xIs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xIs::I64 == 0) goto c2xIu; else goto c2xIt;
       c2xIu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xIt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xIs::I64;
           I64[Sp - 24] = block_c2xIv_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2xIv() //  [R1]
         { info_tbl: [(c2xIv,
                       label: block_c2xIv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.596705858 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { info_tbl: [(c2xIK,
                       label: GHC.Word.neWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xIO; else goto c2xIP;
       c2xIO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xIP: // global
           I64[Sp - 16] = block_c2xIH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xIY; else goto c2xII;
       u2xIY: // global
           call _c2xIH(R1) args: 0, res: 0, upd: 0;
       c2xII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xIH() //  [R1]
         { info_tbl: [(c2xIH,
                       label: block_c2xIH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIH: // global
           I64[Sp] = block_c2xIN_info;
           _s2uHB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHB::I64;
           if (R1 & 7 != 0) goto u2xIX; else goto c2xIR;
       u2xIX: // global
           call _c2xIN(R1) args: 0, res: 0, upd: 0;
       c2xIR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xIN() //  [R1]
         { info_tbl: [(c2xIN,
                       label: block_c2xIN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xIN: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.598299819 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { info_tbl: [(c2xJ5,
                       label: lvl2_r2uFH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xJ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xJ6; else goto c2xJ7;
       c2xJ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xJ7: // global
           (_c2xJ2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xJ2::I64 == 0) goto c2xJ4; else goto c2xJ3;
       c2xJ4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xJ3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xJ2::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.599175868 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.600117596 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { info_tbl: [(c2xJf,
                       label: GHC.Word.$fEnumWord8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xJf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xJg; else goto c2xJh;
       c2xJg: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xJh: // global
           I64[Sp - 8] = block_c2xJc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xJz; else goto c2xJd;
       u2xJz: // global
           call _c2xJc(R1) args: 0, res: 0, upd: 0;
       c2xJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xJc() //  [R1]
         { info_tbl: [(c2xJc,
                       label: block_c2xJc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xJm; else goto c2xJl;
       c2xJm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xJl: // global
           _s2uHI::I64 = I64[R1 + 7];
           if (_s2uHI::I64 != 0) goto c2xJx; else goto c2xJy;
       c2xJx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHI::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xJy: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.601387692 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.601965819 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.602903016 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { info_tbl: [(c2xJH,
                       label: GHC.Word.$fEnumWord8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xJH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xJI; else goto c2xJJ;
       c2xJI: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xJJ: // global
           I64[Sp - 8] = block_c2xJE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xK1; else goto c2xJF;
       u2xK1: // global
           call _c2xJE(R1) args: 0, res: 0, upd: 0;
       c2xJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xJE() //  [R1]
         { info_tbl: [(c2xJE,
                       label: block_c2xJE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xJE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xJO; else goto c2xJN;
       c2xJO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xJN: // global
           _s2uHO::I64 = I64[R1 + 7];
           if (_s2uHO::I64 != 255) goto c2xJZ; else goto c2xK0;
       c2xJZ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHO::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xK0: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.604619424 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2xK9,
                       label: GHC.Word.$fShowWord8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xK9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xKn; else goto c2xKo;
       c2xKn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xKo: // global
           I64[Sp - 24] = block_c2xK6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xKv; else goto c2xK7;
       u2xKv: // global
           call _c2xK6(R1) args: 0, res: 0, upd: 0;
       c2xK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xK6() //  [R1]
         { info_tbl: [(c2xK6,
                       label: block_c2xK6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xK6: // global
           I64[Sp] = block_c2xKc_info;
           _s2uHV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHV::I64;
           if (R1 & 7 != 0) goto u2xKu; else goto c2xKd;
       u2xKu: // global
           call _c2xKc(R1) args: 0, res: 0, upd: 0;
       c2xKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xKc() //  [R1]
         { info_tbl: [(c2xKc,
                       label: block_c2xKc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKc: // global
           _s2uHT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2xKk_info;
           R4 = _s2uHT::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xKk() //  [R1, R2]
         { info_tbl: [(c2xKk,
                       label: block_c2xKk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xKt; else goto c2xKs;
       c2xKt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xKs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.606479601 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { info_tbl: [(c2xKD,
                       label: GHC.Word.$fShowWord8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xKM; else goto c2xKN;
       c2xKM: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xKN: // global
           I64[Sp - 8] = block_c2xKA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xKS; else goto c2xKB;
       u2xKS: // global
           call _c2xKA(R1) args: 0, res: 0, upd: 0;
       c2xKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xKA() //  [R1]
         { info_tbl: [(c2xKA,
                       label: block_c2xKA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKA: // global
           I64[Sp] = block_c2xKJ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xKJ() //  [R1, R2]
         { info_tbl: [(c2xKJ,
                       label: block_c2xKJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xKR; else goto c2xKQ;
       c2xKR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xKQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.608081414 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { info_tbl: [(c2xL0,
                       label: GHC.Word.$fShowWord4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xL0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xL9; else goto c2xLa;
       c2xL9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xLa: // global
           I64[Sp - 16] = block_c2xKX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xLf; else goto c2xKY;
       u2xLf: // global
           call _c2xKX(R1) args: 0, res: 0, upd: 0;
       c2xKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xKX() //  [R1]
         { info_tbl: [(c2xKX,
                       label: block_c2xKX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xKX: // global
           _s2uIa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2xL6_info;
           R4 = _s2uIa::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xL6() //  [R1, R2]
         { info_tbl: [(c2xL6,
                       label: block_c2xL6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xL6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xLe; else goto c2xLd;
       c2xLe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xLd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.609817804 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2xLk,
                       label: GHC.Word.$fShowWord8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xLk: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.61057761 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.611311891 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { info_tbl: [(c2xLr,
                       label: GHC.Word.$wlvl3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xLr: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.61250241 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c2xLD,
                       label: GHC.Word.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xLD: // global
           _s2uIk::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2xLL; else goto c2xLC;
       c2xLC: // global
           if (%MO_S_Gt_W64(_s2uIk::I64, 255)) goto c2xLL; else goto c2xLP;
       c2xLL: // global
           R2 = _s2uIk::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2xLP: // global
           R1 = _s2uIk::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.614555226 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2xLX,
                       label: GHC.Word.$fEnumWord8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xLX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xM5; else goto c2xM6;
       c2xM5: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xM6: // global
           I64[Sp - 8] = block_c2xLU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xMb; else goto c2xLV;
       u2xMb: // global
           call _c2xLU(R1) args: 0, res: 0, upd: 0;
       c2xLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xLU() //  [R1]
         { info_tbl: [(c2xLU,
                       label: block_c2xLU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xLU: // global
           I64[Sp] = block_c2xM0_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xM0() //  [R1]
         { info_tbl: [(c2xM0,
                       label: block_c2xM0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xM0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xMa; else goto c2xM9;
       c2xMa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2xM9: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.619637656 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2uIP_entry() //  [R1]
         { info_tbl: [(c2xMT,
                       label: sat_s2uIP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xMU; else goto c2xMV;
       c2xMU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xMV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIN_entry() //  [R1]
         { info_tbl: [(c2xN5,
                       label: sat_s2uIN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xN5: // global
           _s2uIN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xN6; else goto c2xN7;
       c2xN7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xN9; else goto c2xN8;
       c2xN9: // global
           HpAlloc = 16;
           goto c2xN6;
       c2xN6: // global
           R1 = _s2uIN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xN8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIN::P64;
           _s2uII::I64 = I64[_s2uIN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2xNf; else goto c2xN4;
       c2xN4: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2xNf; else goto c2xNm;
       c2xNf: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xNm: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIT_entry() //  [R1]
         { info_tbl: [(c2xNx,
                       label: sat_s2uIT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xNx: // global
           _s2uIT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xNy; else goto c2xNz;
       c2xNz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xNB; else goto c2xNA;
       c2xNB: // global
           HpAlloc = 16;
           goto c2xNy;
       c2xNy: // global
           R1 = _s2uIT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xNA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIT::P64;
           _s2uII::I64 = I64[_s2uIT::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2xNH; else goto c2xNw;
       c2xNw: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2xNH; else goto c2xNO;
       c2xNH: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xNO: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uIH_entry() //  [R1, R2]
         { info_tbl: [(c2xNS,
                       label: go_dn_s2uIH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xNS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2xNW; else goto c2xNV;
       c2xNW: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xNV: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2xNQ; else goto c2xNR;
       c2xNQ: // global
           _s2uIF::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uIP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uIF::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uIN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xNR: // global
           I64[Hp - 80] = sat_s2uIT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2xNY::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2xNY::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uIU_entry() //  [R1]
         { info_tbl: [(c2xNZ,
                       label: sat_s2uIU_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xNZ: // global
           _s2uIU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xO0; else goto c2xO1;
       c2xO1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xO3; else goto c2xO2;
       c2xO3: // global
           HpAlloc = 24;
           goto c2xO0;
       c2xO0: // global
           R1 = _s2uIU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xO2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIU::P64;
           _s2uIx::I64 = I64[_s2uIU::P64 + 24];
           _s2uIF::I64 = _s2uIx::I64 - I64[_s2uIU::P64 + 16];
           _s2uIG::I64 = I64[_s2uIU::P64 + 32] - _s2uIF::I64;
           I64[Hp - 16] = go_dn_s2uIH_info;
           I64[Hp - 8] = _s2uIF::I64;
           I64[Hp] = _s2uIG::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIE_entry() //  [R1]
         { info_tbl: [(c2xOd,
                       label: sat_s2uIE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xOd: // global
           _s2uIE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xOe; else goto c2xOf;
       c2xOf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xOh; else goto c2xOg;
       c2xOh: // global
           HpAlloc = 16;
           goto c2xOe;
       c2xOe: // global
           R1 = _s2uIE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xOg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIE::P64;
           _s2uIw::I64 = I64[_s2uIE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2xOn; else goto c2xOc;
       c2xOc: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2xOn; else goto c2xOu;
       c2xOn: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xOu: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIZ_entry() //  [R1]
         { info_tbl: [(c2xOI,
                       label: sat_s2uIZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xOI: // global
           _s2uIZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xOJ; else goto c2xOK;
       c2xOK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xOM; else goto c2xOL;
       c2xOM: // global
           HpAlloc = 16;
           goto c2xOJ;
       c2xOJ: // global
           R1 = _s2uIZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIZ::P64;
           _s2uIw::I64 = I64[_s2uIZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2xOS; else goto c2xOH;
       c2xOH: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2xOS; else goto c2xOZ;
       c2xOS: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xOZ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJg_entry() //  [R1]
         { info_tbl: [(c2xPv,
                       label: sat_s2uJg_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xPv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xPw; else goto c2xPx;
       c2xPw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xPx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJe_entry() //  [R1]
         { info_tbl: [(c2xPH,
                       label: sat_s2uJe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xPH: // global
           _s2uJe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xPI; else goto c2xPJ;
       c2xPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xPL; else goto c2xPK;
       c2xPL: // global
           HpAlloc = 16;
           goto c2xPI;
       c2xPI: // global
           R1 = _s2uJe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xPK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJe::P64;
           _s2uJ9::I64 = I64[_s2uJe::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2xPR; else goto c2xPG;
       c2xPG: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2xPR; else goto c2xPY;
       c2xPR: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xPY: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJk_entry() //  [R1]
         { info_tbl: [(c2xQ9,
                       label: sat_s2uJk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xQ9: // global
           _s2uJk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xQa; else goto c2xQb;
       c2xQb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xQd; else goto c2xQc;
       c2xQd: // global
           HpAlloc = 16;
           goto c2xQa;
       c2xQa: // global
           R1 = _s2uJk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xQc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJk::P64;
           _s2uJ9::I64 = I64[_s2uJk::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2xQj; else goto c2xQ8;
       c2xQ8: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2xQj; else goto c2xQq;
       c2xQj: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xQq: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uJ8_entry() //  [R1, R2]
         { info_tbl: [(c2xQu,
                       label: go_up_s2uJ8_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xQu: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2xQy; else goto c2xQx;
       c2xQy: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xQx: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2xQs; else goto c2xQt;
       c2xQs: // global
           _s2uJ6::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJg_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJ6::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xQt: // global
           I64[Hp - 80] = sat_s2uJk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2xQA::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2xQA::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uJl_entry() //  [R1]
         { info_tbl: [(c2xQB,
                       label: sat_s2uJl_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xQB: // global
           _s2uJl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xQC; else goto c2xQD;
       c2xQD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xQF; else goto c2xQE;
       c2xQF: // global
           HpAlloc = 24;
           goto c2xQC;
       c2xQC: // global
           R1 = _s2uJl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xQE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJl::P64;
           _s2uIx::I64 = I64[_s2uJl::P64 + 24];
           _s2uJ6::I64 = _s2uIx::I64 - I64[_s2uJl::P64 + 16];
           _s2uJ7::I64 = I64[_s2uJl::P64 + 32] - _s2uJ6::I64;
           I64[Hp - 16] = go_up_s2uJ8_info;
           I64[Hp - 8] = _s2uJ6::I64;
           I64[Hp] = _s2uJ7::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJ5_entry() //  [R1]
         { info_tbl: [(c2xQP,
                       label: sat_s2uJ5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xQP: // global
           _s2uJ5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xQQ; else goto c2xQR;
       c2xQR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xQT; else goto c2xQS;
       c2xQT: // global
           HpAlloc = 16;
           goto c2xQQ;
       c2xQQ: // global
           R1 = _s2uJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xQS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJ5::P64;
           _s2uIw::I64 = I64[_s2uJ5::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2xQZ; else goto c2xQO;
       c2xQO: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2xQZ; else goto c2xR6;
       c2xQZ: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xR6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJq_entry() //  [R1]
         { info_tbl: [(c2xRk,
                       label: sat_s2uJq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xRk: // global
           _s2uJq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xRl; else goto c2xRm;
       c2xRm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xRo; else goto c2xRn;
       c2xRo: // global
           HpAlloc = 16;
           goto c2xRl;
       c2xRl: // global
           R1 = _s2uJq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xRn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJq::P64;
           _s2uIw::I64 = I64[_s2uJq::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2xRu; else goto c2xRj;
       c2xRj: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2xRu; else goto c2xRB;
       c2xRu: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xRB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c2xRC,
                       label: GHC.Word.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xRC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2xRG; else goto c2xRF;
       c2xRG: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xRF: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2xRQ; else goto c2xRZ;
       c2xRQ: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2xRJ; else goto c2xRO;
       c2xRJ: // global
           I64[Hp - 80] = sat_s2uIU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uIE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xRO: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2xRX; else goto c2xRM;
       c2xRM: // global
           I64[Hp - 80] = sat_s2uIZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2xRK::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2xRK::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xRZ: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2xRT; else goto c2xRY;
       c2xRT: // global
           I64[Hp - 80] = sat_s2uJl_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uJ5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xRY: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2xRX; else goto c2xRW;
       c2xRX: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xRW: // global
           I64[Hp - 80] = sat_s2uJq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2xRU::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2xRU::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.627655625 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2xS7,
                       label: GHC.Word.$fEnumWord8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xS7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xSg; else goto c2xSh;
       c2xSg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xSh: // global
           I64[Sp - 24] = block_c2xS4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xSq; else goto c2xS5;
       u2xSq: // global
           call _c2xS4(R1) args: 0, res: 0, upd: 0;
       c2xS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xS4() //  [R1]
         { info_tbl: [(c2xS4,
                       label: block_c2xS4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xS4: // global
           I64[Sp] = block_c2xSa_info;
           _s2uJv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJv::I64;
           if (R1 & 7 != 0) goto u2xSp; else goto c2xSb;
       u2xSp: // global
           call _c2xSa(R1) args: 0, res: 0, upd: 0;
       c2xSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xSa() //  [R1]
         { info_tbl: [(c2xSa,
                       label: block_c2xSa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xSa: // global
           I64[Sp] = block_c2xSf_info;
           _s2uJx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uJx::I64;
           if (R1 & 7 != 0) goto u2xSr; else goto c2xSk;
       u2xSr: // global
           call _c2xSf(R1) args: 0, res: 0, upd: 0;
       c2xSk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xSf() //  [R1]
         { info_tbl: [(c2xSf,
                       label: block_c2xSf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xSf: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.630171588 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2uJN_entry() //  [R1]
         { info_tbl: [(c2xST,
                       label: sat_s2uJN_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xSU; else goto c2xSV;
       c2xSU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJG::I64 = I64[R1 + 32];
           if (_s2uJG::I64 == I64[R1 + 24]) goto c2xSS; else goto c2xSR;
       c2xSS: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2xSR: // global
           R2 = _s2uJG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uJF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJK_entry() //  [R1]
         { info_tbl: [(c2xT7,
                       label: sat_s2uJK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xT7: // global
           _s2uJK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xT8; else goto c2xT9;
       c2xT9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xTb; else goto c2xTa;
       c2xTb: // global
           HpAlloc = 16;
           goto c2xT8;
       c2xT8: // global
           R1 = _s2uJK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xTa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJK::P64;
           _s2uJG::I64 = I64[_s2uJK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJG::I64, 0)) goto c2xTh; else goto c2xT6;
       c2xT6: // global
           if (%MO_S_Gt_W64(_s2uJG::I64, 255)) goto c2xTh; else goto c2xTo;
       c2xTh: // global
           Hp = Hp - 16;
           R2 = _s2uJG::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xTo: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uJF_entry() //  [R1, R2]
         { info_tbl: [(c2xTq,
                       label: go_s2uJF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xTq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2xTu; else goto c2xTt;
       c2xTu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xTt: // global
           _s2uJD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c2xTv,
                       label: GHC.Word.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xTv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xTz; else goto c2xTy;
       c2xTz: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xTy: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2xTB; else goto c2xTC;
       c2xTB: // global
           I64[Hp - 8] = go_s2uJF_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uJF_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2xTC: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.633571577 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2xTK,
                       label: GHC.Word.$fEnumWord8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xTO; else goto c2xTP;
       c2xTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xTP: // global
           I64[Sp - 16] = block_c2xTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xTX; else goto c2xTI;
       u2xTX: // global
           call _c2xTH(R1) args: 0, res: 0, upd: 0;
       c2xTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xTH() //  [R1]
         { info_tbl: [(c2xTH,
                       label: block_c2xTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xTH: // global
           I64[Sp] = block_c2xTN_info;
           _s2uJR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJR::I64;
           if (R1 & 7 != 0) goto u2xTW; else goto c2xTR;
       u2xTW: // global
           call _c2xTN(R1) args: 0, res: 0, upd: 0;
       c2xTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xTN() //  [R1]
         { info_tbl: [(c2xTN,
                       label: block_c2xTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xTN: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.635560488 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2uK4_entry() //  [R1]
         { info_tbl: [(c2xUa,
                       label: sat_s2uK4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xUa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xUb; else goto c2xUm;
       c2xUb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xUm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJZ::I64 = I64[R1 + 16];
           if (_s2uJZ::I64 != 255) goto c2xU8; else goto c2xU9;
       c2xU8: // global
           I64[Sp - 24] = block_c2xUg_info;
           R2 = _s2uJZ::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2xU9: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2xUg() //  [R1, R2]
         { info_tbl: [(c2xUg,
                       label: block_c2xUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xUg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xUl; else goto c2xUk;
       c2xUl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2xUk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJY_entry() //  [R1]
         { info_tbl: [(c2xUw,
                       label: sat_s2uJY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xUw: // global
           _s2uJY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2xUx; else goto c2xUy;
       c2xUy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xUA; else goto c2xUz;
       c2xUA: // global
           HpAlloc = 16;
           goto c2xUx;
       c2xUx: // global
           R1 = _s2uJY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xUz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJY::P64;
           _s2uJU::I64 = I64[_s2uJY::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJU::I64, 0)) goto c2xUG; else goto c2xUv;
       c2xUv: // global
           if (%MO_S_Gt_W64(_s2uJU::I64, 255)) goto c2xUG; else goto c2xUN;
       c2xUG: // global
           Hp = Hp - 16;
           R2 = _s2uJU::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2xUN: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJU::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { info_tbl: [(c2xUO,
                       label: GHC.Word.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xUO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2xUS; else goto c2xUR;
       c2xUS: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xUR: // global
           I64[Hp - 40] = sat_s2uK4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uJY_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.63765817 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { info_tbl: [(c2xV0,
                       label: GHC.Word.$fEnumWord8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xV0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xV1; else goto c2xV2;
       c2xV1: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xV2: // global
           I64[Sp - 8] = block_c2xUX_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xUX() //  [R1, R2]
         { info_tbl: [(c2xUX,
                       label: block_c2xUX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xUX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xV5; else goto c2xV4;
       c2xV5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xV4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.638959976 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2xVd,
                       label: GHC.Word.$fEnumWord8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xVe; else goto c2xVf;
       c2xVe: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xVf: // global
           I64[Sp - 8] = block_c2xVa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xVr; else goto c2xVb;
       u2xVr: // global
           call _c2xVa(R1) args: 0, res: 0, upd: 0;
       c2xVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xVa() //  [R1]
         { info_tbl: [(c2xVa,
                       label: block_c2xVa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVa: // global
           _s2uKc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uKc::I64, 255)) goto c2xVp; else goto c2xVq;
       c2xVp: // global
           R2 = _s2uKc::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2xVq: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.640165961 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2xVw,
                       label: GHC.Word.$fEnumWord8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVw: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.641057156 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.641922788 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { info_tbl: [(c2xVH,
                       label: GHC.Word.$fEnumWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xVI; else goto c2xVJ;
       c2xVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xVJ: // global
           (_c2xVC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xVC::I64 == 0) goto c2xVE; else goto c2xVD;
       c2xVE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xVD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xVC::I64;
           I64[Sp - 24] = block_c2xVF_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2xVF() //  [R1]
         { info_tbl: [(c2xVF,
                       label: block_c2xVF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.643189973 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { info_tbl: [(c2xVV,
                       label: GHC.Word.$fEnumWord2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xVW; else goto c2xVX;
       c2xVW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xVX: // global
           (_c2xVQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xVQ::I64 == 0) goto c2xVS; else goto c2xVR;
       c2xVS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xVR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xVQ::I64;
           I64[Sp - 24] = block_c2xVT_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2xVT() //  [R1]
         { info_tbl: [(c2xVT,
                       label: block_c2xVT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xVT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.644578184 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { info_tbl: [(c2xW8,
                       label: GHC.Word.neWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xW8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xWc; else goto c2xWd;
       c2xWc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xWd: // global
           I64[Sp - 16] = block_c2xW5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xWm; else goto c2xW6;
       u2xWm: // global
           call _c2xW5(R1) args: 0, res: 0, upd: 0;
       c2xW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xW5() //  [R1]
         { info_tbl: [(c2xW5,
                       label: block_c2xW5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xW5: // global
           I64[Sp] = block_c2xWb_info;
           _s2uKj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKj::I64;
           if (R1 & 7 != 0) goto u2xWl; else goto c2xWf;
       u2xWl: // global
           call _c2xWb(R1) args: 0, res: 0, upd: 0;
       c2xWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xWb() //  [R1]
         { info_tbl: [(c2xWb,
                       label: block_c2xWb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xWb: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.645992639 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { info_tbl: [(c2xWt,
                       label: lvl4_r2uFJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xWt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xWu; else goto c2xWv;
       c2xWu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2xWv: // global
           (_c2xWq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2xWq::I64 == 0) goto c2xWs; else goto c2xWr;
       c2xWs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2xWr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2xWq::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.646936858 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.647906048 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { info_tbl: [(c2xWD,
                       label: GHC.Word.$fEnumWord16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xWD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xWE; else goto c2xWF;
       c2xWE: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xWF: // global
           I64[Sp - 8] = block_c2xWA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xWX; else goto c2xWB;
       u2xWX: // global
           call _c2xWA(R1) args: 0, res: 0, upd: 0;
       c2xWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xWA() //  [R1]
         { info_tbl: [(c2xWA,
                       label: block_c2xWA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xWA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xWK; else goto c2xWJ;
       c2xWK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xWJ: // global
           _s2uKq::I64 = I64[R1 + 7];
           if (_s2uKq::I64 != 0) goto c2xWV; else goto c2xWW;
       c2xWV: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xWW: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.649142025 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.649784671 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.651564107 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { info_tbl: [(c2xX5,
                       label: GHC.Word.$fEnumWord16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xX5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xX6; else goto c2xX7;
       c2xX6: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xX7: // global
           I64[Sp - 8] = block_c2xX2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xXp; else goto c2xX3;
       u2xXp: // global
           call _c2xX2(R1) args: 0, res: 0, upd: 0;
       c2xX3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xX2() //  [R1]
         { info_tbl: [(c2xX2,
                       label: block_c2xX2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xX2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xXc; else goto c2xXb;
       c2xXc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2xXb: // global
           _s2uKw::I64 = I64[R1 + 7];
           if (_s2uKw::I64 != 65535) goto c2xXn; else goto c2xXo;
       c2xXn: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2xXo: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.65327077 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2xXx,
                       label: GHC.Word.$fShowWord16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xXx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2xXL; else goto c2xXM;
       c2xXL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xXM: // global
           I64[Sp - 24] = block_c2xXu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2xXT; else goto c2xXv;
       u2xXT: // global
           call _c2xXu(R1) args: 0, res: 0, upd: 0;
       c2xXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xXu() //  [R1]
         { info_tbl: [(c2xXu,
                       label: block_c2xXu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xXu: // global
           I64[Sp] = block_c2xXA_info;
           _s2uKD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKD::I64;
           if (R1 & 7 != 0) goto u2xXS; else goto c2xXB;
       u2xXS: // global
           call _c2xXA(R1) args: 0, res: 0, upd: 0;
       c2xXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xXA() //  [R1]
         { info_tbl: [(c2xXA,
                       label: block_c2xXA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xXA: // global
           _s2uKB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2xXI_info;
           R4 = _s2uKB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xXI() //  [R1, R2]
         { info_tbl: [(c2xXI,
                       label: block_c2xXI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xXI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xXR; else goto c2xXQ;
       c2xXR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xXQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.655113106 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { info_tbl: [(c2xY1,
                       label: GHC.Word.$fShowWord16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xY1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xYa; else goto c2xYb;
       c2xYa: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xYb: // global
           I64[Sp - 8] = block_c2xXY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xYg; else goto c2xXZ;
       u2xYg: // global
           call _c2xXY(R1) args: 0, res: 0, upd: 0;
       c2xXZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xXY() //  [R1]
         { info_tbl: [(c2xXY,
                       label: block_c2xXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xXY: // global
           I64[Sp] = block_c2xY7_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xY7() //  [R1, R2]
         { info_tbl: [(c2xY7,
                       label: block_c2xY7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xY7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xYf; else goto c2xYe;
       c2xYf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xYe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.656759709 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { info_tbl: [(c2xYo,
                       label: GHC.Word.$fShowWord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2xYx; else goto c2xYy;
       c2xYx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2xYy: // global
           I64[Sp - 16] = block_c2xYl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2xYD; else goto c2xYm;
       u2xYD: // global
           call _c2xYl(R1) args: 0, res: 0, upd: 0;
       c2xYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xYl() //  [R1]
         { info_tbl: [(c2xYl,
                       label: block_c2xYl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xYl: // global
           _s2uKS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2xYu_info;
           R4 = _s2uKS::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xYu() //  [R1, R2]
         { info_tbl: [(c2xYu,
                       label: block_c2xYu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xYu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2xYC; else goto c2xYB;
       c2xYC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2xYB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.658427215 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2xYI,
                       label: GHC.Word.$fShowWord16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xYI: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.659240115 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.659985611 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { info_tbl: [(c2xYP,
                       label: GHC.Word.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xYP: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.661075124 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2xZ1,
                       label: GHC.Word.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xZ1: // global
           _s2uL2::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2xZ9; else goto c2xZ0;
       c2xZ0: // global
           if (%MO_S_Gt_W64(_s2uL2::I64, 65535)) goto c2xZ9; else goto c2xZd;
       c2xZ9: // global
           R2 = _s2uL2::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2xZd: // global
           R1 = _s2uL2::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.66233191 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2xZl,
                       label: GHC.Word.$fEnumWord16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xZl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2xZt; else goto c2xZu;
       c2xZt: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2xZu: // global
           I64[Sp - 8] = block_c2xZi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2xZz; else goto c2xZj;
       u2xZz: // global
           call _c2xZi(R1) args: 0, res: 0, upd: 0;
       c2xZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2xZi() //  [R1]
         { info_tbl: [(c2xZi,
                       label: block_c2xZi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xZi: // global
           I64[Sp] = block_c2xZo_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2xZo() //  [R1]
         { info_tbl: [(c2xZo,
                       label: block_c2xZo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2xZo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2xZy; else goto c2xZx;
       c2xZy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2xZx: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.667526659 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2uLx_entry() //  [R1]
         { info_tbl: [(c2y0h,
                       label: sat_s2uLx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y0h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y0i; else goto c2y0j;
       c2y0i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y0j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLv_entry() //  [R1]
         { info_tbl: [(c2y0t,
                       label: sat_s2uLv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y0t: // global
           _s2uLv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y0u; else goto c2y0v;
       c2y0v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y0x; else goto c2y0w;
       c2y0x: // global
           HpAlloc = 16;
           goto c2y0u;
       c2y0u: // global
           R1 = _s2uLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y0w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLv::P64;
           _s2uLq::I64 = I64[_s2uLv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2y0D; else goto c2y0s;
       c2y0s: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2y0D; else goto c2y0K;
       c2y0D: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y0K: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLB_entry() //  [R1]
         { info_tbl: [(c2y0V,
                       label: sat_s2uLB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y0V: // global
           _s2uLB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y0W; else goto c2y0X;
       c2y0X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y0Z; else goto c2y0Y;
       c2y0Z: // global
           HpAlloc = 16;
           goto c2y0W;
       c2y0W: // global
           R1 = _s2uLB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLB::P64;
           _s2uLq::I64 = I64[_s2uLB::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2y15; else goto c2y0U;
       c2y0U: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2y15; else goto c2y1c;
       c2y15: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y1c: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uLp_entry() //  [R1, R2]
         { info_tbl: [(c2y1g,
                       label: go_dn_s2uLp_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y1g: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2y1k; else goto c2y1j;
       c2y1k: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y1j: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2y1e; else goto c2y1f;
       c2y1e: // global
           _s2uLn::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLx_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLn::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y1f: // global
           I64[Hp - 80] = sat_s2uLB_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2y1m::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2y1m::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uLC_entry() //  [R1]
         { info_tbl: [(c2y1n,
                       label: sat_s2uLC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y1n: // global
           _s2uLC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y1o; else goto c2y1p;
       c2y1p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2y1r; else goto c2y1q;
       c2y1r: // global
           HpAlloc = 24;
           goto c2y1o;
       c2y1o: // global
           R1 = _s2uLC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLC::P64;
           _s2uLf::I64 = I64[_s2uLC::P64 + 24];
           _s2uLn::I64 = _s2uLf::I64 - I64[_s2uLC::P64 + 16];
           _s2uLo::I64 = I64[_s2uLC::P64 + 32] - _s2uLn::I64;
           I64[Hp - 16] = go_dn_s2uLp_info;
           I64[Hp - 8] = _s2uLn::I64;
           I64[Hp] = _s2uLo::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLm_entry() //  [R1]
         { info_tbl: [(c2y1B,
                       label: sat_s2uLm_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y1B: // global
           _s2uLm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y1C; else goto c2y1D;
       c2y1D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y1F; else goto c2y1E;
       c2y1F: // global
           HpAlloc = 16;
           goto c2y1C;
       c2y1C: // global
           R1 = _s2uLm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y1E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLm::P64;
           _s2uLe::I64 = I64[_s2uLm::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2y1L; else goto c2y1A;
       c2y1A: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2y1L; else goto c2y1S;
       c2y1L: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y1S: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLH_entry() //  [R1]
         { info_tbl: [(c2y26,
                       label: sat_s2uLH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y26: // global
           _s2uLH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y27; else goto c2y28;
       c2y28: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y2a; else goto c2y29;
       c2y2a: // global
           HpAlloc = 16;
           goto c2y27;
       c2y27: // global
           R1 = _s2uLH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y29: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLH::P64;
           _s2uLe::I64 = I64[_s2uLH::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2y2g; else goto c2y25;
       c2y25: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2y2g; else goto c2y2n;
       c2y2g: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y2n: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLY_entry() //  [R1]
         { info_tbl: [(c2y2T,
                       label: sat_s2uLY_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y2T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y2U; else goto c2y2V;
       c2y2U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y2V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLW_entry() //  [R1]
         { info_tbl: [(c2y35,
                       label: sat_s2uLW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y35: // global
           _s2uLW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y36; else goto c2y37;
       c2y37: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y39; else goto c2y38;
       c2y39: // global
           HpAlloc = 16;
           goto c2y36;
       c2y36: // global
           R1 = _s2uLW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y38: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLW::P64;
           _s2uLR::I64 = I64[_s2uLW::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2y3f; else goto c2y34;
       c2y34: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2y3f; else goto c2y3m;
       c2y3f: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y3m: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM2_entry() //  [R1]
         { info_tbl: [(c2y3x,
                       label: sat_s2uM2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y3x: // global
           _s2uM2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y3y; else goto c2y3z;
       c2y3z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y3B; else goto c2y3A;
       c2y3B: // global
           HpAlloc = 16;
           goto c2y3y;
       c2y3y: // global
           R1 = _s2uM2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y3A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM2::P64;
           _s2uLR::I64 = I64[_s2uM2::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2y3H; else goto c2y3w;
       c2y3w: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2y3H; else goto c2y3O;
       c2y3H: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y3O: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uLQ_entry() //  [R1, R2]
         { info_tbl: [(c2y3S,
                       label: go_up_s2uLQ_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y3S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2y3W; else goto c2y3V;
       c2y3W: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y3V: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2y3Q; else goto c2y3R;
       c2y3Q: // global
           _s2uLO::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLY_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLO::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y3R: // global
           I64[Hp - 80] = sat_s2uM2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2y3Y::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2y3Y::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uM3_entry() //  [R1]
         { info_tbl: [(c2y3Z,
                       label: sat_s2uM3_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y3Z: // global
           _s2uM3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y40; else goto c2y41;
       c2y41: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2y43; else goto c2y42;
       c2y43: // global
           HpAlloc = 24;
           goto c2y40;
       c2y40: // global
           R1 = _s2uM3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y42: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM3::P64;
           _s2uLf::I64 = I64[_s2uM3::P64 + 24];
           _s2uLO::I64 = _s2uLf::I64 - I64[_s2uM3::P64 + 16];
           _s2uLP::I64 = I64[_s2uM3::P64 + 32] - _s2uLO::I64;
           I64[Hp - 16] = go_up_s2uLQ_info;
           I64[Hp - 8] = _s2uLO::I64;
           I64[Hp] = _s2uLP::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLN_entry() //  [R1]
         { info_tbl: [(c2y4d,
                       label: sat_s2uLN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y4d: // global
           _s2uLN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y4e; else goto c2y4f;
       c2y4f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y4h; else goto c2y4g;
       c2y4h: // global
           HpAlloc = 16;
           goto c2y4e;
       c2y4e: // global
           R1 = _s2uLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y4g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLN::P64;
           _s2uLe::I64 = I64[_s2uLN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2y4n; else goto c2y4c;
       c2y4c: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2y4n; else goto c2y4u;
       c2y4n: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y4u: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM8_entry() //  [R1]
         { info_tbl: [(c2y4I,
                       label: sat_s2uM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y4I: // global
           _s2uM8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y4J; else goto c2y4K;
       c2y4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y4M; else goto c2y4L;
       c2y4M: // global
           HpAlloc = 16;
           goto c2y4J;
       c2y4J: // global
           R1 = _s2uM8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM8::P64;
           _s2uLe::I64 = I64[_s2uM8::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2y4S; else goto c2y4H;
       c2y4H: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2y4S; else goto c2y4Z;
       c2y4S: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y4Z: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2y50,
                       label: GHC.Word.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y50: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2y54; else goto c2y53;
       c2y54: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2y53: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2y5e; else goto c2y5n;
       c2y5e: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2y57; else goto c2y5c;
       c2y57: // global
           I64[Hp - 80] = sat_s2uLC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y5c: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2y5l; else goto c2y5a;
       c2y5a: // global
           I64[Hp - 80] = sat_s2uLH_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2y58::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2y58::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y5n: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2y5h; else goto c2y5m;
       c2y5h: // global
           I64[Hp - 80] = sat_s2uM3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y5m: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2y5l; else goto c2y5k;
       c2y5l: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2y5k: // global
           I64[Hp - 80] = sat_s2uM8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2y5i::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2y5i::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.676328906 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2y5v,
                       label: GHC.Word.$fEnumWord16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y5v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2y5E; else goto c2y5F;
       c2y5E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2y5F: // global
           I64[Sp - 24] = block_c2y5s_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2y5O; else goto c2y5t;
       u2y5O: // global
           call _c2y5s(R1) args: 0, res: 0, upd: 0;
       c2y5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y5s() //  [R1]
         { info_tbl: [(c2y5s,
                       label: block_c2y5s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y5s: // global
           I64[Sp] = block_c2y5y_info;
           _s2uMd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMd::I64;
           if (R1 & 7 != 0) goto u2y5N; else goto c2y5z;
       u2y5N: // global
           call _c2y5y(R1) args: 0, res: 0, upd: 0;
       c2y5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y5y() //  [R1]
         { info_tbl: [(c2y5y,
                       label: block_c2y5y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y5y: // global
           I64[Sp] = block_c2y5D_info;
           _s2uMf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uMf::I64;
           if (R1 & 7 != 0) goto u2y5P; else goto c2y5I;
       u2y5P: // global
           call _c2y5D(R1) args: 0, res: 0, upd: 0;
       c2y5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y5D() //  [R1]
         { info_tbl: [(c2y5D,
                       label: block_c2y5D_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y5D: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.678899508 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2uMv_entry() //  [R1]
         { info_tbl: [(c2y6h,
                       label: sat_s2uMv_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y6h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y6i; else goto c2y6j;
       c2y6i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y6j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMo::I64 = I64[R1 + 32];
           if (_s2uMo::I64 == I64[R1 + 24]) goto c2y6g; else goto c2y6f;
       c2y6g: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2y6f: // global
           R2 = _s2uMo::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uMn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMs_entry() //  [R1]
         { info_tbl: [(c2y6v,
                       label: sat_s2uMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y6v: // global
           _s2uMs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y6w; else goto c2y6x;
       c2y6x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y6z; else goto c2y6y;
       c2y6z: // global
           HpAlloc = 16;
           goto c2y6w;
       c2y6w: // global
           R1 = _s2uMs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y6y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMs::P64;
           _s2uMo::I64 = I64[_s2uMs::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMo::I64, 0)) goto c2y6F; else goto c2y6u;
       c2y6u: // global
           if (%MO_S_Gt_W64(_s2uMo::I64, 65535)) goto c2y6F; else goto c2y6M;
       c2y6F: // global
           Hp = Hp - 16;
           R2 = _s2uMo::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y6M: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMo::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uMn_entry() //  [R1, R2]
         { info_tbl: [(c2y6O,
                       label: go_s2uMn_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y6O: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2y6S; else goto c2y6R;
       c2y6S: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y6R: // global
           _s2uMl::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uMv_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uMl::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uMs_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2y6T,
                       label: GHC.Word.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y6T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y6X; else goto c2y6W;
       c2y6X: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2y6W: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2y6Z; else goto c2y70;
       c2y6Z: // global
           I64[Hp - 8] = go_s2uMn_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uMn_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2y70: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.681299782 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2y78,
                       label: GHC.Word.$fEnumWord16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y78: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y7c; else goto c2y7d;
       c2y7c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2y7d: // global
           I64[Sp - 16] = block_c2y75_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2y7l; else goto c2y76;
       u2y7l: // global
           call _c2y75(R1) args: 0, res: 0, upd: 0;
       c2y76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y75() //  [R1]
         { info_tbl: [(c2y75,
                       label: block_c2y75_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y75: // global
           I64[Sp] = block_c2y7b_info;
           _s2uMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMz::I64;
           if (R1 & 7 != 0) goto u2y7k; else goto c2y7f;
       u2y7k: // global
           call _c2y7b(R1) args: 0, res: 0, upd: 0;
       c2y7f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y7b() //  [R1]
         { info_tbl: [(c2y7b,
                       label: block_c2y7b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y7b: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.683421207 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2uMM_entry() //  [R1]
         { info_tbl: [(c2y7y,
                       label: sat_s2uMM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y7y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2y7z; else goto c2y7K;
       c2y7z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMH::I64 = I64[R1 + 16];
           if (_s2uMH::I64 != 65535) goto c2y7w; else goto c2y7x;
       c2y7w: // global
           I64[Sp - 24] = block_c2y7E_info;
           R2 = _s2uMH::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2y7x: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2y7E() //  [R1, R2]
         { info_tbl: [(c2y7E,
                       label: block_c2y7E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2y7J; else goto c2y7I;
       c2y7J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2y7I: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMG_entry() //  [R1]
         { info_tbl: [(c2y7U,
                       label: sat_s2uMG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y7U: // global
           _s2uMG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2y7V; else goto c2y7W;
       c2y7W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2y7Y; else goto c2y7X;
       c2y7Y: // global
           HpAlloc = 16;
           goto c2y7V;
       c2y7V: // global
           R1 = _s2uMG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y7X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMG::P64;
           _s2uMC::I64 = I64[_s2uMG::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMC::I64, 0)) goto c2y84; else goto c2y7T;
       c2y7T: // global
           if (%MO_S_Gt_W64(_s2uMC::I64, 65535)) goto c2y84; else goto c2y8b;
       c2y84: // global
           Hp = Hp - 16;
           R2 = _s2uMC::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2y8b: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo_entry() //  [R2]
         { info_tbl: [(c2y8c,
                       label: GHC.Word.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8c: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2y8g; else goto c2y8f;
       c2y8g: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y8f: // global
           I64[Hp - 40] = sat_s2uMM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uMG_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.685597978 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { info_tbl: [(c2y8o,
                       label: GHC.Word.$fEnumWord16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2y8p; else goto c2y8q;
       c2y8p: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y8q: // global
           I64[Sp - 8] = block_c2y8l_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2y8l() //  [R1, R2]
         { info_tbl: [(c2y8l,
                       label: block_c2y8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2y8t; else goto c2y8s;
       c2y8t: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2y8s: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.68698065 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2y8B,
                       label: GHC.Word.$fEnumWord16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2y8C; else goto c2y8D;
       c2y8C: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2y8D: // global
           I64[Sp - 8] = block_c2y8y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2y8P; else goto c2y8z;
       u2y8P: // global
           call _c2y8y(R1) args: 0, res: 0, upd: 0;
       c2y8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y8y() //  [R1]
         { info_tbl: [(c2y8y,
                       label: block_c2y8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8y: // global
           _s2uMU::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uMU::I64, 65535)) goto c2y8N; else goto c2y8O;
       c2y8N: // global
           R2 = _s2uMU::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2y8O: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.688973629 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2y8U,
                       label: GHC.Word.$fEnumWord16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y8U: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.689923338 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.690730538 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { info_tbl: [(c2y95,
                       label: GHC.Word.$fEnumWord3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y95: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2y96; else goto c2y97;
       c2y96: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y97: // global
           (_c2y90::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2y90::I64 == 0) goto c2y92; else goto c2y91;
       c2y92: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2y91: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2y90::I64;
           I64[Sp - 24] = block_c2y93_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2y93() //  [R1]
         { info_tbl: [(c2y93,
                       label: block_c2y93_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y93: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.691965531 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { info_tbl: [(c2y9j,
                       label: GHC.Word.$fEnumWord4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2y9k; else goto c2y9l;
       c2y9k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y9l: // global
           (_c2y9e::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2y9e::I64 == 0) goto c2y9g; else goto c2y9f;
       c2y9g: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2y9f: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2y9e::I64;
           I64[Sp - 24] = block_c2y9h_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2y9h() //  [R1]
         { info_tbl: [(c2y9h,
                       label: block_c2y9h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9h: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.693357293 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { info_tbl: [(c2y9w,
                       label: GHC.Word.neWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y9A; else goto c2y9B;
       c2y9A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2y9B: // global
           I64[Sp - 16] = block_c2y9t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2y9K; else goto c2y9u;
       u2y9K: // global
           call _c2y9t(R1) args: 0, res: 0, upd: 0;
       c2y9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y9t() //  [R1]
         { info_tbl: [(c2y9t,
                       label: block_c2y9t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9t: // global
           I64[Sp] = block_c2y9z_info;
           _s2uN1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uN1::I64;
           if (R1 & 7 != 0) goto u2y9J; else goto c2y9D;
       u2y9J: // global
           call _c2y9z(R1) args: 0, res: 0, upd: 0;
       c2y9D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y9z() //  [R1]
         { info_tbl: [(c2y9z,
                       label: block_c2y9z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9z: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.694723325 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { info_tbl: [(c2y9R,
                       label: lvl6_r2uFL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2y9S; else goto c2y9T;
       c2y9S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2y9T: // global
           (_c2y9O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2y9O::I64 == 0) goto c2y9Q; else goto c2y9P;
       c2y9Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2y9P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2y9O::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.695612225 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.69650121 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { info_tbl: [(c2ya1,
                       label: GHC.Word.$fEnumWord32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ya1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ya2; else goto c2ya3;
       c2ya2: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ya3: // global
           I64[Sp - 8] = block_c2y9Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yal; else goto c2y9Z;
       u2yal: // global
           call _c2y9Y(R1) args: 0, res: 0, upd: 0;
       c2y9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2y9Y() //  [R1]
         { info_tbl: [(c2y9Y,
                       label: block_c2y9Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2y9Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ya8; else goto c2ya7;
       c2ya8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ya7: // global
           _s2uN8::I64 = I64[R1 + 7];
           if (_s2uN8::I64 != 0) goto c2yaj; else goto c2yak;
       c2yaj: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uN8::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yak: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.697880334 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.69846185 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.699348781 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { info_tbl: [(c2yat,
                       label: GHC.Word.$fEnumWord32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yat: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yau; else goto c2yav;
       c2yau: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yav: // global
           I64[Sp - 8] = block_c2yaq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yaN; else goto c2yar;
       u2yaN: // global
           call _c2yaq(R1) args: 0, res: 0, upd: 0;
       c2yar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yaq() //  [R1]
         { info_tbl: [(c2yaq,
                       label: block_c2yaq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yaq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yaA; else goto c2yaz;
       c2yaA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yaz: // global
           _s2uNe::I64 = I64[R1 + 7];
           if (_s2uNe::I64 != 4294967295) goto c2yaL; else goto c2yaM;
       c2yaL: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uNe::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yaM: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.701566609 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2yaV,
                       label: GHC.Word.$fShowWord32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yaV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yb9; else goto c2yba;
       c2yb9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yba: // global
           I64[Sp - 24] = block_c2yaS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2ybh; else goto c2yaT;
       u2ybh: // global
           call _c2yaS(R1) args: 0, res: 0, upd: 0;
       c2yaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yaS() //  [R1]
         { info_tbl: [(c2yaS,
                       label: block_c2yaS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yaS: // global
           I64[Sp] = block_c2yaY_info;
           _s2uNl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uNl::I64;
           if (R1 & 7 != 0) goto u2ybg; else goto c2yaZ;
       u2ybg: // global
           call _c2yaY(R1) args: 0, res: 0, upd: 0;
       c2yaZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yaY() //  [R1]
         { info_tbl: [(c2yaY,
                       label: block_c2yaY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yaY: // global
           _s2uNj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2yb6_info;
           R4 = _s2uNj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2yb6() //  [R1, R2]
         { info_tbl: [(c2yb6,
                       label: block_c2yb6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yb6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ybf; else goto c2ybe;
       c2ybf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ybe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.70366796 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { info_tbl: [(c2ybp,
                       label: GHC.Word.$fShowWord32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yby; else goto c2ybz;
       c2yby: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ybz: // global
           I64[Sp - 8] = block_c2ybm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ybE; else goto c2ybn;
       u2ybE: // global
           call _c2ybm(R1) args: 0, res: 0, upd: 0;
       c2ybn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ybm() //  [R1]
         { info_tbl: [(c2ybm,
                       label: block_c2ybm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybm: // global
           I64[Sp] = block_c2ybv_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ybv() //  [R1, R2]
         { info_tbl: [(c2ybv,
                       label: block_c2ybv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ybD; else goto c2ybC;
       c2ybD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ybC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.70554545 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { info_tbl: [(c2ybM,
                       label: GHC.Word.$fShowWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ybV; else goto c2ybW;
       c2ybV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ybW: // global
           I64[Sp - 16] = block_c2ybJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yc1; else goto c2ybK;
       u2yc1: // global
           call _c2ybJ(R1) args: 0, res: 0, upd: 0;
       c2ybK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ybJ() //  [R1]
         { info_tbl: [(c2ybJ,
                       label: block_c2ybJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybJ: // global
           _s2uNA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2ybS_info;
           R4 = _s2uNA::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ybS() //  [R1, R2]
         { info_tbl: [(c2ybS,
                       label: block_c2ybS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ybS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2yc0; else goto c2ybZ;
       c2yc0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ybZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.707680431 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2yc6,
                       label: GHC.Word.$fShowWord32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yc6: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.708405907 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.709128572 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { info_tbl: [(c2ycd,
                       label: GHC.Word.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ycd: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.710213679 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c2ycp,
                       label: GHC.Word.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ycp: // global
           _s2uNK::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2ycx; else goto c2yco;
       c2yco: // global
           if (%MO_S_Gt_W64(_s2uNK::I64,
                            4294967295)) goto c2ycx; else goto c2ycB;
       c2ycx: // global
           R2 = _s2uNK::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2ycB: // global
           R1 = _s2uNK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.711339684 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2ycJ,
                       label: GHC.Word.$fEnumWord32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ycJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ycR; else goto c2ycS;
       c2ycR: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ycS: // global
           I64[Sp - 8] = block_c2ycG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ycX; else goto c2ycH;
       u2ycX: // global
           call _c2ycG(R1) args: 0, res: 0, upd: 0;
       c2ycH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ycG() //  [R1]
         { info_tbl: [(c2ycG,
                       label: block_c2ycG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ycG: // global
           I64[Sp] = block_c2ycM_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ycM() //  [R1]
         { info_tbl: [(c2ycM,
                       label: block_c2ycM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ycM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ycW; else goto c2ycV;
       c2ycW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2ycV: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.716412042 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2uOf_entry() //  [R1]
         { info_tbl: [(c2ydF,
                       label: sat_s2uOf_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ydF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ydG; else goto c2ydH;
       c2ydG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ydH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOd_entry() //  [R1]
         { info_tbl: [(c2ydR,
                       label: sat_s2uOd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ydR: // global
           _s2uOd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ydS; else goto c2ydT;
       c2ydT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ydV; else goto c2ydU;
       c2ydV: // global
           HpAlloc = 16;
           goto c2ydS;
       c2ydS: // global
           R1 = _s2uOd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ydU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOd::P64;
           _s2uO8::I64 = I64[_s2uOd::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2ye1; else goto c2ydQ;
       c2ydQ: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2ye1; else goto c2ye8;
       c2ye1: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ye8: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOj_entry() //  [R1]
         { info_tbl: [(c2yej,
                       label: sat_s2uOj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yej: // global
           _s2uOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yek; else goto c2yel;
       c2yel: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yen; else goto c2yem;
       c2yen: // global
           HpAlloc = 16;
           goto c2yek;
       c2yek: // global
           R1 = _s2uOj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOj::P64;
           _s2uO8::I64 = I64[_s2uOj::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2yet; else goto c2yei;
       c2yei: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2yet; else goto c2yeA;
       c2yet: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yeA: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uO7_entry() //  [R1, R2]
         { info_tbl: [(c2yeE,
                       label: go_dn_s2uO7_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yeE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2yeI; else goto c2yeH;
       c2yeI: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yeH: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2yeC; else goto c2yeD;
       c2yeC: // global
           _s2uO5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOf_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uO5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yeD: // global
           I64[Hp - 80] = sat_s2uOj_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2yeK::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2yeK::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOk_entry() //  [R1]
         { info_tbl: [(c2yeL,
                       label: sat_s2uOk_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yeL: // global
           _s2uOk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yeM; else goto c2yeN;
       c2yeN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2yeP; else goto c2yeO;
       c2yeP: // global
           HpAlloc = 24;
           goto c2yeM;
       c2yeM: // global
           R1 = _s2uOk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yeO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOk::P64;
           _s2uNX::I64 = I64[_s2uOk::P64 + 24];
           _s2uO5::I64 = _s2uNX::I64 - I64[_s2uOk::P64 + 16];
           _s2uO6::I64 = I64[_s2uOk::P64 + 32] - _s2uO5::I64;
           I64[Hp - 16] = go_dn_s2uO7_info;
           I64[Hp - 8] = _s2uO5::I64;
           I64[Hp] = _s2uO6::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uO4_entry() //  [R1]
         { info_tbl: [(c2yeZ,
                       label: sat_s2uO4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yeZ: // global
           _s2uO4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yf0; else goto c2yf1;
       c2yf1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yf3; else goto c2yf2;
       c2yf3: // global
           HpAlloc = 16;
           goto c2yf0;
       c2yf0: // global
           R1 = _s2uO4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yf2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uO4::P64;
           _s2uNW::I64 = I64[_s2uO4::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2yf9; else goto c2yeY;
       c2yeY: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2yf9; else goto c2yfg;
       c2yf9: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yfg: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOp_entry() //  [R1]
         { info_tbl: [(c2yfu,
                       label: sat_s2uOp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yfu: // global
           _s2uOp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yfv; else goto c2yfw;
       c2yfw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yfy; else goto c2yfx;
       c2yfy: // global
           HpAlloc = 16;
           goto c2yfv;
       c2yfv: // global
           R1 = _s2uOp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yfx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOp::P64;
           _s2uNW::I64 = I64[_s2uOp::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2yfE; else goto c2yft;
       c2yft: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2yfE; else goto c2yfL;
       c2yfE: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yfL: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOG_entry() //  [R1]
         { info_tbl: [(c2ygh,
                       label: sat_s2uOG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ygh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ygi; else goto c2ygj;
       c2ygi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ygj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOE_entry() //  [R1]
         { info_tbl: [(c2ygt,
                       label: sat_s2uOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ygt: // global
           _s2uOE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ygu; else goto c2ygv;
       c2ygv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ygx; else goto c2ygw;
       c2ygx: // global
           HpAlloc = 16;
           goto c2ygu;
       c2ygu: // global
           R1 = _s2uOE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ygw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOE::P64;
           _s2uOz::I64 = I64[_s2uOE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2ygD; else goto c2ygs;
       c2ygs: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2ygD; else goto c2ygK;
       c2ygD: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ygK: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOK_entry() //  [R1]
         { info_tbl: [(c2ygV,
                       label: sat_s2uOK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ygV: // global
           _s2uOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ygW; else goto c2ygX;
       c2ygX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ygZ; else goto c2ygY;
       c2ygZ: // global
           HpAlloc = 16;
           goto c2ygW;
       c2ygW: // global
           R1 = _s2uOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ygY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOK::P64;
           _s2uOz::I64 = I64[_s2uOK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2yh5; else goto c2ygU;
       c2ygU: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2yh5; else goto c2yhc;
       c2yh5: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yhc: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uOy_entry() //  [R1, R2]
         { info_tbl: [(c2yhg,
                       label: go_up_s2uOy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yhg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2yhk; else goto c2yhj;
       c2yhk: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yhj: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2yhe; else goto c2yhf;
       c2yhe: // global
           _s2uOw::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uOw::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yhf: // global
           I64[Hp - 80] = sat_s2uOK_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2yhm::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2yhm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOL_entry() //  [R1]
         { info_tbl: [(c2yhn,
                       label: sat_s2uOL_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yhn: // global
           _s2uOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yho; else goto c2yhp;
       c2yhp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2yhr; else goto c2yhq;
       c2yhr: // global
           HpAlloc = 24;
           goto c2yho;
       c2yho: // global
           R1 = _s2uOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yhq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOL::P64;
           _s2uNX::I64 = I64[_s2uOL::P64 + 24];
           _s2uOw::I64 = _s2uNX::I64 - I64[_s2uOL::P64 + 16];
           _s2uOx::I64 = I64[_s2uOL::P64 + 32] - _s2uOw::I64;
           I64[Hp - 16] = go_up_s2uOy_info;
           I64[Hp - 8] = _s2uOw::I64;
           I64[Hp] = _s2uOx::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOv_entry() //  [R1]
         { info_tbl: [(c2yhB,
                       label: sat_s2uOv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yhB: // global
           _s2uOv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yhC; else goto c2yhD;
       c2yhD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yhF; else goto c2yhE;
       c2yhF: // global
           HpAlloc = 16;
           goto c2yhC;
       c2yhC: // global
           R1 = _s2uOv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yhE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOv::P64;
           _s2uNW::I64 = I64[_s2uOv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2yhL; else goto c2yhA;
       c2yhA: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2yhL; else goto c2yhS;
       c2yhL: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yhS: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOQ_entry() //  [R1]
         { info_tbl: [(c2yi6,
                       label: sat_s2uOQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yi6: // global
           _s2uOQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yi7; else goto c2yi8;
       c2yi8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yia; else goto c2yi9;
       c2yia: // global
           HpAlloc = 16;
           goto c2yi7;
       c2yi7: // global
           R1 = _s2uOQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yi9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOQ::P64;
           _s2uNW::I64 = I64[_s2uOQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2yig; else goto c2yi5;
       c2yi5: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2yig; else goto c2yin;
       c2yig: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yin: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2yio,
                       label: GHC.Word.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yio: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2yis; else goto c2yir;
       c2yis: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yir: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2yiC; else goto c2yiL;
       c2yiC: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2yiv; else goto c2yiA;
       c2yiv: // global
           I64[Hp - 80] = sat_s2uOk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uO4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yiA: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2yiJ; else goto c2yiy;
       c2yiy: // global
           I64[Hp - 80] = sat_s2uOp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2yiw::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2yiw::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yiL: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2yiF; else goto c2yiK;
       c2yiF: // global
           I64[Hp - 80] = sat_s2uOL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uOv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yiK: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2yiJ; else goto c2yiI;
       c2yiJ: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yiI: // global
           I64[Hp - 80] = sat_s2uOQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2yiG::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2yiG::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.725156317 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2yiT,
                       label: GHC.Word.$fEnumWord32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yiT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yj2; else goto c2yj3;
       c2yj2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yj3: // global
           I64[Sp - 24] = block_c2yiQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2yjc; else goto c2yiR;
       u2yjc: // global
           call _c2yiQ(R1) args: 0, res: 0, upd: 0;
       c2yiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yiQ() //  [R1]
         { info_tbl: [(c2yiQ,
                       label: block_c2yiQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yiQ: // global
           I64[Sp] = block_c2yiW_info;
           _s2uOV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uOV::I64;
           if (R1 & 7 != 0) goto u2yjb; else goto c2yiX;
       u2yjb: // global
           call _c2yiW(R1) args: 0, res: 0, upd: 0;
       c2yiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yiW() //  [R1]
         { info_tbl: [(c2yiW,
                       label: block_c2yiW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yiW: // global
           I64[Sp] = block_c2yj1_info;
           _s2uOX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uOX::I64;
           if (R1 & 7 != 0) goto u2yjd; else goto c2yj6;
       u2yjd: // global
           call _c2yj1(R1) args: 0, res: 0, upd: 0;
       c2yj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yj1() //  [R1]
         { info_tbl: [(c2yj1,
                       label: block_c2yj1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yj1: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.727883169 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2uPd_entry() //  [R1]
         { info_tbl: [(c2yjF,
                       label: sat_s2uPd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yjG; else goto c2yjH;
       c2yjG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yjH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uP6::I64 = I64[R1 + 32];
           if (_s2uP6::I64 == I64[R1 + 24]) goto c2yjE; else goto c2yjD;
       c2yjE: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2yjD: // global
           R2 = _s2uP6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uP5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPa_entry() //  [R1]
         { info_tbl: [(c2yjT,
                       label: sat_s2uPa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yjT: // global
           _s2uPa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yjU; else goto c2yjV;
       c2yjV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yjX; else goto c2yjW;
       c2yjX: // global
           HpAlloc = 16;
           goto c2yjU;
       c2yjU: // global
           R1 = _s2uPa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yjW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPa::P64;
           _s2uP6::I64 = I64[_s2uPa::P64 + 16];
           if (%MO_S_Lt_W64(_s2uP6::I64, 0)) goto c2yk3; else goto c2yjS;
       c2yjS: // global
           if (%MO_S_Gt_W64(_s2uP6::I64,
                            4294967295)) goto c2yk3; else goto c2yka;
       c2yk3: // global
           Hp = Hp - 16;
           R2 = _s2uP6::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2yka: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uP6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uP5_entry() //  [R1, R2]
         { info_tbl: [(c2ykc,
                       label: go_s2uP5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykc: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ykg; else goto c2ykf;
       c2ykg: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ykf: // global
           _s2uP3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uPd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uP3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uPa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c2ykh,
                       label: GHC.Word.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ykl; else goto c2ykk;
       c2ykl: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ykk: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2ykn; else goto c2yko;
       c2ykn: // global
           I64[Hp - 8] = go_s2uP5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uP5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2yko: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.730283642 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2ykw,
                       label: GHC.Word.$fEnumWord32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ykA; else goto c2ykB;
       c2ykA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ykB: // global
           I64[Sp - 16] = block_c2ykt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ykJ; else goto c2yku;
       u2ykJ: // global
           call _c2ykt(R1) args: 0, res: 0, upd: 0;
       c2yku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ykt() //  [R1]
         { info_tbl: [(c2ykt,
                       label: block_c2ykt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykt: // global
           I64[Sp] = block_c2ykz_info;
           _s2uPh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPh::I64;
           if (R1 & 7 != 0) goto u2ykI; else goto c2ykD;
       u2ykI: // global
           call _c2ykz(R1) args: 0, res: 0, upd: 0;
       c2ykD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ykz() //  [R1]
         { info_tbl: [(c2ykz,
                       label: block_c2ykz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykz: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.732307738 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2uPu_entry() //  [R1]
         { info_tbl: [(c2ykW,
                       label: sat_s2uPu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ykW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ykX; else goto c2yl8;
       c2ykX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yl8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uPp::I64 = I64[R1 + 16];
           if (_s2uPp::I64 != 4294967295) goto c2ykU; else goto c2ykV;
       c2ykU: // global
           I64[Sp - 24] = block_c2yl2_info;
           R2 = _s2uPp::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2ykV: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2yl2() //  [R1, R2]
         { info_tbl: [(c2yl2,
                       label: block_c2yl2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yl2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2yl7; else goto c2yl6;
       c2yl7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2yl6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPo_entry() //  [R1]
         { info_tbl: [(c2yli,
                       label: sat_s2uPo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yli: // global
           _s2uPo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ylj; else goto c2ylk;
       c2ylk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ylm; else goto c2yll;
       c2ylm: // global
           HpAlloc = 16;
           goto c2ylj;
       c2ylj: // global
           R1 = _s2uPo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yll: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPo::P64;
           _s2uPk::I64 = I64[_s2uPo::P64 + 16];
           if (%MO_S_Lt_W64(_s2uPk::I64, 0)) goto c2yls; else goto c2ylh;
       c2ylh: // global
           if (%MO_S_Gt_W64(_s2uPk::I64,
                            4294967295)) goto c2yls; else goto c2ylz;
       c2yls: // global
           Hp = Hp - 16;
           R2 = _s2uPk::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ylz: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uPk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { info_tbl: [(c2ylA,
                       label: GHC.Word.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ylA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2ylE; else goto c2ylD;
       c2ylE: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ylD: // global
           I64[Hp - 40] = sat_s2uPu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uPo_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.73460168 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { info_tbl: [(c2ylM,
                       label: GHC.Word.$fEnumWord32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ylM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ylN; else goto c2ylO;
       c2ylN: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ylO: // global
           I64[Sp - 8] = block_c2ylJ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ylJ() //  [R1, R2]
         { info_tbl: [(c2ylJ,
                       label: block_c2ylJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ylJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ylR; else goto c2ylQ;
       c2ylR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ylQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.735916543 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2ylZ,
                       label: GHC.Word.$fEnumWord32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ylZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ym0; else goto c2ym1;
       c2ym0: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ym1: // global
           I64[Sp - 8] = block_c2ylW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ymd; else goto c2ylX;
       u2ymd: // global
           call _c2ylW(R1) args: 0, res: 0, upd: 0;
       c2ylX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ylW() //  [R1]
         { info_tbl: [(c2ylW,
                       label: block_c2ylW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ylW: // global
           _s2uPC::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uPC::I64,
                            4294967295)) goto c2ymb; else goto c2ymc;
       c2ymb: // global
           R2 = _s2uPC::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2ymc: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.737167409 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2ymi,
                       label: GHC.Word.$fEnumWord32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ymi: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.738146285 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.738760186 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.739695118 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { info_tbl: [(c2yms,
                       label: GHC.Word.eqWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yms: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ymw; else goto c2ymx;
       c2ymw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ymx: // global
           I64[Sp - 16] = block_c2ymp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ymG; else goto c2ymq;
       u2ymG: // global
           call _c2ymp(R1) args: 0, res: 0, upd: 0;
       c2ymq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ymp() //  [R1]
         { info_tbl: [(c2ymp,
                       label: block_c2ymp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ymp: // global
           I64[Sp] = block_c2ymv_info;
           _s2uPH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPH::I64;
           if (R1 & 7 != 0) goto u2ymF; else goto c2ymz;
       u2ymF: // global
           call _c2ymv(R1) args: 0, res: 0, upd: 0;
       c2ymz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ymv() //  [R1]
         { info_tbl: [(c2ymv,
                       label: block_c2ymv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ymv: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.741191232 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { info_tbl: [(c2ymO,
                       label: GHC.Word.$fNumWord64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ymO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ymP; else goto c2ymQ;
       c2ymP: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ymQ: // global
           I64[Sp - 8] = block_c2ymL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ymY; else goto c2ymM;
       u2ymY: // global
           call _c2ymL(R1) args: 0, res: 0, upd: 0;
       c2ymM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ymL() //  [R1]
         { info_tbl: [(c2ymL,
                       label: block_c2ymL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ymL: // global
           if (I64[R1 + 7] == 0) goto c2ymX; else goto c2ymW;
       c2ymX: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ymW: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.743135354 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.743963075 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2yn8_srtd" {
     u2yn8_srtd:
         const S2vim_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { info_tbl: [(c2yn5,
                       label: GHC.Word.$fEnumWord7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yn5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yn6; else goto c2yn7;
       c2yn6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yn7: // global
           (_c2yn2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2yn2::I64 == 0) goto c2yn4; else goto c2yn3;
       c2yn4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2yn3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2yn2::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.74507739 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2yni_srtd" {
     u2yni_srtd:
         const S2vim_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { info_tbl: [(c2ynf,
                       label: GHC.Word.$fEnumWord9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yng; else goto c2ynh;
       c2yng: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ynh: // global
           (_c2ync::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2ync::I64 == 0) goto c2yne; else goto c2ynd;
       c2yne: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2ynd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2ync::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.746394237 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { info_tbl: [(c2ynq,
                       label: GHC.Word.neWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ynu; else goto c2ynv;
       c2ynu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ynv: // global
           I64[Sp - 16] = block_c2ynn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ynE; else goto c2yno;
       u2ynE: // global
           call _c2ynn(R1) args: 0, res: 0, upd: 0;
       c2yno: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ynn() //  [R1]
         { info_tbl: [(c2ynn,
                       label: block_c2ynn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynn: // global
           I64[Sp] = block_c2ynt_info;
           _s2uPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPS::I64;
           if (R1 & 7 != 0) goto u2ynD; else goto c2ynx;
       u2ynD: // global
           call _c2ynt(R1) args: 0, res: 0, upd: 0;
       c2ynx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ynt() //  [R1]
         { info_tbl: [(c2ynt,
                       label: block_c2ynt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynt: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.748402592 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2uQ6_entry() //  [R1]
         { info_tbl: [(c2yo1,
                       label: sat_s2uQ6_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yo1: // global
           _s2uQ6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yo4; else goto c2yo5;
       c2yo5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yo7; else goto c2yo6;
       c2yo7: // global
           HpAlloc = 16;
           goto c2yo4;
       c2yo4: // global
           R1 = _s2uQ6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ6::P64;
           _s2uQ5::I64 = I64[_s2uQ6::P64 + 16] % I64[_s2uQ6::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uQ4_entry() //  [R1]
         { info_tbl: [(c2yoe,
                       label: sat_s2uQ4_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yoe: // global
           _s2uQ4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2yoh; else goto c2yoi;
       c2yoi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yok; else goto c2yoj;
       c2yok: // global
           HpAlloc = 16;
           goto c2yoh;
       c2yoh: // global
           R1 = _s2uQ4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2yoj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ4::P64;
           _s2uQ3::I64 = I64[_s2uQ4::P64 + 16] / I64[_s2uQ4::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2yol,
                       label: GHC.Word.$fIntegralWord64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yom; else goto c2yon;
       c2yom: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yon: // global
           I64[Sp - 16] = block_c2ynJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yox; else goto c2ynK;
       u2yox: // global
           call _c2ynJ(R1) args: 0, res: 0, upd: 0;
       c2ynK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ynJ() //  [R1]
         { info_tbl: [(c2ynJ,
                       label: block_c2ynJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynJ: // global
           I64[Sp] = block_c2ynO_info;
           _s2uPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPZ::I64;
           if (R1 & 7 != 0) goto u2yow; else goto c2ynP;
       u2yow: // global
           call _c2ynO(R1) args: 0, res: 0, upd: 0;
       c2ynP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ynO() //  [R1]
         { info_tbl: [(c2ynO,
                       label: block_c2ynO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ynO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2yor; else goto c2yoq;
       c2yor: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yoq: // global
           _s2uQ2::I64 = I64[R1 + 7];
           if (_s2uQ2::I64 != 0) goto c2you; else goto c2yov;
       c2you: // global
           I64[Hp - 80] = sat_s2uQ6_info;
           _s2uPZ::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2uPZ::I64;
           I64[Hp - 56] = _s2uQ2::I64;
           I64[Hp - 48] = sat_s2uQ4_info;
           I64[Hp - 32] = _s2uPZ::I64;
           I64[Hp - 24] = _s2uQ2::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yov: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.751025988 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2yoF,
                       label: GHC.Word.$fIntegralWord64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yoF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yoJ; else goto c2yoK;
       c2yoJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yoK: // global
           I64[Sp - 16] = block_c2yoC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yp2; else goto c2yoD;
       u2yp2: // global
           call _c2yoC(R1) args: 0, res: 0, upd: 0;
       c2yoD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yoC() //  [R1]
         { info_tbl: [(c2yoC,
                       label: block_c2yoC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yoC: // global
           I64[Sp] = block_c2yoI_info;
           _s2uQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQa::I64;
           if (R1 & 7 != 0) goto u2yp1; else goto c2yoM;
       u2yp1: // global
           call _c2yoI(R1) args: 0, res: 0, upd: 0;
       c2yoM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yoI() //  [R1]
         { info_tbl: [(c2yoI,
                       label: block_c2yoI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yoI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2yoS; else goto c2yoR;
       c2yoS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yoR: // global
           _s2uQd::I64 = I64[R1 + 7];
           if (_s2uQd::I64 != 0) goto c2yoZ; else goto c2yp0;
       c2yoZ: // global
           (_s2uQf::I64, _s2uQg::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2uQd::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2uQg::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2uQf::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yp0: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.75292418 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c2ypa,
                       label: GHC.Word.$fIntegralWord64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ypa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ype; else goto c2ypf;
       c2ype: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ypf: // global
           I64[Sp - 16] = block_c2yp7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ypy; else goto c2yp8;
       u2ypy: // global
           call _c2yp7(R1) args: 0, res: 0, upd: 0;
       c2yp8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yp7() //  [R1]
         { info_tbl: [(c2yp7,
                       label: block_c2yp7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yp7: // global
           I64[Sp] = block_c2ypd_info;
           _s2uQm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQm::I64;
           if (R1 & 7 != 0) goto u2ypx; else goto c2yph;
       u2ypx: // global
           call _c2ypd(R1) args: 0, res: 0, upd: 0;
       c2yph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ypd() //  [R1]
         { info_tbl: [(c2ypd,
                       label: block_c2ypd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ypd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ypn; else goto c2ypm;
       c2ypn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ypm: // global
           _s2uQp::I64 = I64[R1 + 7];
           if (_s2uQp::I64 != 0) goto c2ypv; else goto c2ypw;
       c2ypv: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2uQp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ypw: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.754930121 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c2ypG,
                       label: GHC.Word.$fIntegralWord64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ypG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ypK; else goto c2ypL;
       c2ypK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ypL: // global
           I64[Sp - 16] = block_c2ypD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yq4; else goto c2ypE;
       u2yq4: // global
           call _c2ypD(R1) args: 0, res: 0, upd: 0;
       c2ypE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ypD() //  [R1]
         { info_tbl: [(c2ypD,
                       label: block_c2ypD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ypD: // global
           I64[Sp] = block_c2ypJ_info;
           _s2uQu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQu::I64;
           if (R1 & 7 != 0) goto u2yq3; else goto c2ypN;
       u2yq3: // global
           call _c2ypJ(R1) args: 0, res: 0, upd: 0;
       c2ypN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ypJ() //  [R1]
         { info_tbl: [(c2ypJ,
                       label: block_c2ypJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ypJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ypT; else goto c2ypS;
       c2ypT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ypS: // global
           _s2uQx::I64 = I64[R1 + 7];
           if (_s2uQx::I64 != 0) goto c2yq1; else goto c2yq2;
       c2yq1: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2uQx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yq2: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.756347525 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.757288475 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { info_tbl: [(c2yqc,
                       label: GHC.Word.$fEnumWord64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yqc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yqd; else goto c2yqe;
       c2yqd: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yqe: // global
           I64[Sp - 8] = block_c2yq9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yqt; else goto c2yqa;
       u2yqt: // global
           call _c2yq9(R1) args: 0, res: 0, upd: 0;
       c2yqa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yq9() //  [R1]
         { info_tbl: [(c2yq9,
                       label: block_c2yq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yqj; else goto c2yqi;
       c2yqj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yqi: // global
           _s2uQC::I64 = I64[R1 + 7];
           if (_s2uQC::I64 != 0) goto c2yqr; else goto c2yqs;
       c2yqr: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQC::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yqs: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.758516224 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.759099554 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.76088311 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { info_tbl: [(c2yqB,
                       label: GHC.Word.$fEnumWord64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yqB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yqC; else goto c2yqD;
       c2yqC: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yqD: // global
           I64[Sp - 8] = block_c2yqy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yqS; else goto c2yqz;
       u2yqS: // global
           call _c2yqy(R1) args: 0, res: 0, upd: 0;
       c2yqz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yqy() //  [R1]
         { info_tbl: [(c2yqy,
                       label: block_c2yqy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yqy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yqI; else goto c2yqH;
       c2yqI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yqH: // global
           _s2uQH::I64 = I64[R1 + 7];
           if (_s2uQH::I64 != 18446744073709551615) goto c2yqQ; else goto c2yqR;
       c2yqQ: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQH::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yqR: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.762199691 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2yr0_srtd" {
     u2yr0_srtd:
         const S2vim_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { info_tbl: [(c2yqX,
                       label: GHC.Word.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yqX: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.763262087 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { info_tbl: [(c2yr8,
                       label: GHC.Word.$fEnumWord6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yr8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yr9; else goto c2yra;
       c2yr9: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yra: // global
           I64[Sp - 8] = block_c2yr5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yre; else goto c2yr6;
       u2yre: // global
           call _c2yr5(R1) args: 0, res: 0, upd: 0;
       c2yr6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yr5() //  [R1]
         { info_tbl: [(c2yr5,
                       label: block_c2yr5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yr5: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.764541816 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2yrm,
                       label: GHC.Word.$fEnumWord64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yrm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yrn; else goto c2yro;
       c2yrn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yro: // global
           I64[Sp - 8] = block_c2yrj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yrF; else goto c2yrk;
       u2yrF: // global
           call _c2yrj(R1) args: 0, res: 0, upd: 0;
       c2yrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yrj() //  [R1]
         { info_tbl: [(c2yrj,
                       label: block_c2yrj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yrj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yrt; else goto c2yrs;
       c2yrt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yrs: // global
           _s2uQP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uQP::I64, 0)) goto c2yrx; else goto c2yrE;
       c2yrx: // global
           Hp = Hp - 16;
           R2 = _s2uQP::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2yrE: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.76642797 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { info_tbl: [(c2yrN,
                       label: GHC.Word.gtWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yrN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yrR; else goto c2yrS;
       c2yrR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yrS: // global
           I64[Sp - 16] = block_c2yrK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ys1; else goto c2yrL;
       u2ys1: // global
           call _c2yrK(R1) args: 0, res: 0, upd: 0;
       c2yrL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yrK() //  [R1]
         { info_tbl: [(c2yrK,
                       label: block_c2yrK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yrK: // global
           I64[Sp] = block_c2yrQ_info;
           _s2uQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQV::I64;
           if (R1 & 7 != 0) goto u2ys0; else goto c2yrU;
       u2ys0: // global
           call _c2yrQ(R1) args: 0, res: 0, upd: 0;
       c2yrU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yrQ() //  [R1]
         { info_tbl: [(c2yrQ,
                       label: block_c2yrQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yrQ: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.767900376 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { info_tbl: [(c2ys9,
                       label: GHC.Word.geWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ys9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ysd; else goto c2yse;
       c2ysd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yse: // global
           I64[Sp - 16] = block_c2ys6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ysn; else goto c2ys7;
       u2ysn: // global
           call _c2ys6(R1) args: 0, res: 0, upd: 0;
       c2ys7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ys6() //  [R1]
         { info_tbl: [(c2ys6,
                       label: block_c2ys6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ys6: // global
           I64[Sp] = block_c2ysc_info;
           _s2uR2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR2::I64;
           if (R1 & 7 != 0) goto u2ysm; else goto c2ysg;
       u2ysm: // global
           call _c2ysc(R1) args: 0, res: 0, upd: 0;
       c2ysg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ysc() //  [R1]
         { info_tbl: [(c2ysc,
                       label: block_c2ysc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysc: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.769406672 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { info_tbl: [(c2ysv,
                       label: GHC.Word.ltWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ysz; else goto c2ysA;
       c2ysz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ysA: // global
           I64[Sp - 16] = block_c2yss_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ysJ; else goto c2yst;
       u2ysJ: // global
           call _c2yss(R1) args: 0, res: 0, upd: 0;
       c2yst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yss() //  [R1]
         { info_tbl: [(c2yss,
                       label: block_c2yss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yss: // global
           I64[Sp] = block_c2ysy_info;
           _s2uR9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR9::I64;
           if (R1 & 7 != 0) goto u2ysI; else goto c2ysC;
       u2ysI: // global
           call _c2ysy(R1) args: 0, res: 0, upd: 0;
       c2ysC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ysy() //  [R1]
         { info_tbl: [(c2ysy,
                       label: block_c2ysy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysy: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.770833841 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { info_tbl: [(c2ysR,
                       label: GHC.Word.leWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ysV; else goto c2ysW;
       c2ysV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ysW: // global
           I64[Sp - 16] = block_c2ysO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yt5; else goto c2ysP;
       u2yt5: // global
           call _c2ysO(R1) args: 0, res: 0, upd: 0;
       c2ysP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ysO() //  [R1]
         { info_tbl: [(c2ysO,
                       label: block_c2ysO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysO: // global
           I64[Sp] = block_c2ysU_info;
           _s2uRg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRg::I64;
           if (R1 & 7 != 0) goto u2yt4; else goto c2ysY;
       u2yt4: // global
           call _c2ysU(R1) args: 0, res: 0, upd: 0;
       c2ysY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ysU() //  [R1]
         { info_tbl: [(c2ysU,
                       label: block_c2ysU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ysU: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.772397699 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2ytd,
                       label: GHC.Word.$fOrdWord64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ytd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yth; else goto c2yti;
       c2yth: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yti: // global
           I64[Sp - 16] = block_c2yta_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ytv; else goto c2ytb;
       u2ytv: // global
           call _c2yta(R1) args: 0, res: 0, upd: 0;
       c2ytb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yta() //  [R1]
         { info_tbl: [(c2yta,
                       label: block_c2yta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yta: // global
           I64[Sp - 8] = block_c2ytg_info;
           _s2uRm::P64 = R1;
           _s2uRn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRn::I64;
           P64[Sp + 8] = _s2uRm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ytu; else goto c2ytk;
       u2ytu: // global
           call _c2ytg(R1) args: 0, res: 0, upd: 0;
       c2ytk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ytg() //  [R1]
         { info_tbl: [(c2ytg,
                       label: block_c2ytg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ytg: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2yts; else goto c2ytt;
       c2yts: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2ytt: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.774099916 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2ytD,
                       label: GHC.Word.$fOrdWord64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ytD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ytH; else goto c2ytI;
       c2ytH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ytI: // global
           I64[Sp - 16] = block_c2ytA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ytV; else goto c2ytB;
       u2ytV: // global
           call _c2ytA(R1) args: 0, res: 0, upd: 0;
       c2ytB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ytA() //  [R1]
         { info_tbl: [(c2ytA,
                       label: block_c2ytA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ytA: // global
           I64[Sp - 8] = block_c2ytG_info;
           _s2uRt::P64 = R1;
           _s2uRu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRu::I64;
           P64[Sp + 8] = _s2uRt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ytU; else goto c2ytK;
       u2ytU: // global
           call _c2ytG(R1) args: 0, res: 0, upd: 0;
       c2ytK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ytG() //  [R1]
         { info_tbl: [(c2ytG,
                       label: block_c2ytG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ytG: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2ytS; else goto c2ytT;
       c2ytS: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2ytT: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.775813805 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2yu3,
                       label: GHC.Word.$fOrdWord64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yu3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yu7; else goto c2yu8;
       c2yu7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yu8: // global
           I64[Sp - 16] = block_c2yu0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yur; else goto c2yu1;
       u2yur: // global
           call _c2yu0(R1) args: 0, res: 0, upd: 0;
       c2yu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yu0() //  [R1]
         { info_tbl: [(c2yu0,
                       label: block_c2yu0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yu0: // global
           I64[Sp] = block_c2yu6_info;
           _s2uRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRB::I64;
           if (R1 & 7 != 0) goto u2yuq; else goto c2yua;
       u2yuq: // global
           call _c2yu6(R1) args: 0, res: 0, upd: 0;
       c2yua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yu6() //  [R1]
         { info_tbl: [(c2yu6,
                       label: block_c2yu6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yu6: // global
           _s2uRB::I64 = I64[Sp + 8];
           _s2uRD::I64 = I64[R1 + 7];
           if (_s2uRB::I64 == _s2uRD::I64) goto c2yup; else goto c2yuo;
       c2yup: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yuo: // global
           if (_s2uRB::I64 > _s2uRD::I64) goto c2yul; else goto c2yum;
       c2yul: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yum: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.777471205 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.778871468 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.779842807 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2yuz,
                       label: GHC.Word.$fEnumWord64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yuz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yuA; else goto c2yuB;
       c2yuA: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yuB: // global
           I64[Sp - 8] = block_c2yuw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yuS; else goto c2yux;
       u2yuS: // global
           call _c2yuw(R1) args: 0, res: 0, upd: 0;
       c2yux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yuw() //  [R1]
         { info_tbl: [(c2yuw,
                       label: block_c2yuw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yuw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yuG; else goto c2yuF;
       c2yuG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yuF: // global
           _s2uRI::I64 = I64[R1 + 7];
           if (_s2uRI::I64 > 9223372036854775807) goto c2yuK; else goto c2yuR;
       c2yuK: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2yuR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uRI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.78152072 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2yuX,
                       label: GHC.Word.$fEnumWord64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yuX: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2yv4,
                       label: GHC.Word.$fEnumWord64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yv4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2yvb,
                       label: GHC.Word.$fEnumWord64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvb: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2yvi,
                       label: GHC.Word.$fEnumWord64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvi: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.783396293 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2yvr,
                       label: GHC.Word.$fNumWord8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yvy; else goto c2yvz;
       c2yvy: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yvz: // global
           I64[Sp - 8] = block_c2yvp_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2yvp() //  [R1]
         { info_tbl: [(c2yvp,
                       label: block_c2yvp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yvC; else goto c2yvB;
       c2yvC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yvB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.784616481 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { info_tbl: [(c2yvH,
                       label: GHC.Word.$fNumWord8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvH: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.785681042 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { info_tbl: [(c2yvR,
                       label: GHC.Word.$fNumWord8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yw7; else goto c2yw8;
       c2yw7: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yw8: // global
           I64[Sp - 8] = block_c2yvO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ywc; else goto c2yvP;
       u2ywc: // global
           call _c2yvO(R1) args: 0, res: 0, upd: 0;
       c2yvP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yvO() //  [R1]
         { info_tbl: [(c2yvO,
                       label: block_c2yvO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yvO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ywb; else goto c2ywa;
       c2ywb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ywa: // global
           _s2uRV::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uRV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.787168834 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2ywk,
                       label: GHC.Word.$fNumWord8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ywz; else goto c2ywA;
       c2ywz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ywA: // global
           I64[Sp - 16] = block_c2ywh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ywG; else goto c2ywi;
       u2ywG: // global
           call _c2ywh(R1) args: 0, res: 0, upd: 0;
       c2ywi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ywh() //  [R1]
         { info_tbl: [(c2ywh,
                       label: block_c2ywh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywh: // global
           I64[Sp] = block_c2ywn_info;
           _s2uRZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRZ::I64;
           if (R1 & 7 != 0) goto u2ywF; else goto c2ywo;
       u2ywF: // global
           call _c2ywn(R1) args: 0, res: 0, upd: 0;
       c2ywo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ywn() //  [R1]
         { info_tbl: [(c2ywn,
                       label: block_c2ywn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ywE; else goto c2ywD;
       c2ywE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ywD: // global
           _s2uS3::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.788815524 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2ywO,
                       label: GHC.Word.$fNumWord8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yx3; else goto c2yx4;
       c2yx3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yx4: // global
           I64[Sp - 16] = block_c2ywL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yxa; else goto c2ywM;
       u2yxa: // global
           call _c2ywL(R1) args: 0, res: 0, upd: 0;
       c2ywM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ywL() //  [R1]
         { info_tbl: [(c2ywL,
                       label: block_c2ywL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywL: // global
           I64[Sp] = block_c2ywR_info;
           _s2uS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uS7::I64;
           if (R1 & 7 != 0) goto u2yx9; else goto c2ywS;
       u2yx9: // global
           call _c2ywR(R1) args: 0, res: 0, upd: 0;
       c2ywS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ywR() //  [R1]
         { info_tbl: [(c2ywR,
                       label: block_c2ywR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ywR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yx8; else goto c2yx7;
       c2yx8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yx7: // global
           _s2uSb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.790537051 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2yxi,
                       label: GHC.Word.$fNumWord8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yxx; else goto c2yxy;
       c2yxx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yxy: // global
           I64[Sp - 16] = block_c2yxf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yxE; else goto c2yxg;
       u2yxE: // global
           call _c2yxf(R1) args: 0, res: 0, upd: 0;
       c2yxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yxf() //  [R1]
         { info_tbl: [(c2yxf,
                       label: block_c2yxf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxf: // global
           I64[Sp] = block_c2yxl_info;
           _s2uSf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSf::I64;
           if (R1 & 7 != 0) goto u2yxD; else goto c2yxm;
       u2yxD: // global
           call _c2yxl(R1) args: 0, res: 0, upd: 0;
       c2yxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yxl() //  [R1]
         { info_tbl: [(c2yxl,
                       label: block_c2yxl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yxC; else goto c2yxB;
       c2yxC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yxB: // global
           _s2uSj::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.792151376 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2yxM,
                       label: GHC.Word.$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yxN; else goto c2yxO;
       c2yxN: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yxO: // global
           I64[Sp - 8] = block_c2yxJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yxT; else goto c2yxK;
       u2yxT: // global
           call _c2yxJ(R1) args: 0, res: 0, upd: 0;
       c2yxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yxJ() //  [R1]
         { info_tbl: [(c2yxJ,
                       label: block_c2yxJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxJ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.793478969 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2yy1,
                       label: GHC.Word.$fBitsWord8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yy1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yyc; else goto c2yyd;
       c2yyc: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yyd: // global
           I64[Sp - 8] = block_c2yxY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yyh; else goto c2yxZ;
       u2yyh: // global
           call _c2yxY(R1) args: 0, res: 0, upd: 0;
       c2yxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yxY() //  [R1]
         { info_tbl: [(c2yxY,
                       label: block_c2yxY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yxY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yyg; else goto c2yyf;
       c2yyg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yyf: // global
           (_c2yy4::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yy4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.794992377 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yyp,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yyp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yyB; else goto c2yyC;
       c2yyB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yyC: // global
           I64[Sp - 16] = block_c2yym_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yyI; else goto c2yyn;
       u2yyI: // global
           call _c2yym(R1) args: 0, res: 0, upd: 0;
       c2yyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yym() //  [R1]
         { info_tbl: [(c2yym,
                       label: block_c2yym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yym: // global
           I64[Sp] = block_c2yys_info;
           _s2uSw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSw::I64;
           if (R1 & 7 != 0) goto u2yyH; else goto c2yyt;
       u2yyH: // global
           call _c2yys(R1) args: 0, res: 0, upd: 0;
       c2yyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yys() //  [R1]
         { info_tbl: [(c2yys,
                       label: block_c2yys_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yys: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yyG; else goto c2yyF;
       c2yyG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yyF: // global
           _s2uSz::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.7976748 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yyQ,
                       label: GHC.Word.$fBitsWord8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yyQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yyU; else goto c2yyV;
       c2yyU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yyV: // global
           I64[Sp - 16] = block_c2yyN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yzf; else goto c2yyO;
       u2yzf: // global
           call _c2yyN(R1) args: 0, res: 0, upd: 0;
       c2yyO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yyN() //  [R1]
         { info_tbl: [(c2yyN,
                       label: block_c2yyN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yyN: // global
           I64[Sp] = block_c2yyT_info;
           _s2uSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSD::I64;
           if (R1 & 7 != 0) goto u2yze; else goto c2yyX;
       u2yze: // global
           call _c2yyT(R1) args: 0, res: 0, upd: 0;
       c2yyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yyT() //  [R1]
         { info_tbl: [(c2yyT,
                       label: block_c2yyT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yyT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yz3; else goto c2yz2;
       c2yz3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yz2: // global
           _s2uSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSF::I64, 64)) goto c2yzc; else goto c2yzd;
       c2yzc: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uSF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yzd: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.799378988 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yzn,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yzC; else goto c2yzD;
       c2yzC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yzD: // global
           I64[Sp - 16] = block_c2yzk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yzJ; else goto c2yzl;
       u2yzJ: // global
           call _c2yzk(R1) args: 0, res: 0, upd: 0;
       c2yzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yzk() //  [R1]
         { info_tbl: [(c2yzk,
                       label: block_c2yzk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzk: // global
           I64[Sp] = block_c2yzq_info;
           _s2uSL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSL::I64;
           if (R1 & 7 != 0) goto u2yzI; else goto c2yzr;
       u2yzI: // global
           call _c2yzq(R1) args: 0, res: 0, upd: 0;
       c2yzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yzq() //  [R1]
         { info_tbl: [(c2yzq,
                       label: block_c2yzq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yzH; else goto c2yzG;
       c2yzH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yzG: // global
           _s2uSP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.801179992 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yzR,
                       label: GHC.Word.$fBitsWord8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yzV; else goto c2yzW;
       c2yzV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yzW: // global
           I64[Sp - 16] = block_c2yzO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yAj; else goto c2yzP;
       u2yAj: // global
           call _c2yzO(R1) args: 0, res: 0, upd: 0;
       c2yzP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yzO() //  [R1]
         { info_tbl: [(c2yzO,
                       label: block_c2yzO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzO: // global
           I64[Sp] = block_c2yzU_info;
           _s2uST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uST::I64;
           if (R1 & 7 != 0) goto u2yAi; else goto c2yzY;
       u2yAi: // global
           call _c2yzU(R1) args: 0, res: 0, upd: 0;
       c2yzY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yzU() //  [R1]
         { info_tbl: [(c2yzU,
                       label: block_c2yzU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yzU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yA4; else goto c2yA3;
       c2yA4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yA3: // global
           _s2uSV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSV::I64, 64)) goto c2yAg; else goto c2yAh;
       c2yAg: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2uSV::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yAh: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.802707391 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { info_tbl: [(c2yAo,
                       label: GHC.Word.$fBitsWord8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAo: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.804038824 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2yAy,
                       label: GHC.Word.$fBitsWord8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yAC; else goto c2yAD;
       c2yAC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yAD: // global
           I64[Sp - 16] = block_c2yAv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yBq; else goto c2yAw;
       u2yBq: // global
           call _c2yAv(R1) args: 0, res: 0, upd: 0;
       c2yAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yAv() //  [R1]
         { info_tbl: [(c2yAv,
                       label: block_c2yAv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAv: // global
           I64[Sp - 8] = block_c2yAB_info;
           _s2uT2::P64 = R1;
           _s2uT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uT3::I64;
           P64[Sp + 8] = _s2uT2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yBp; else goto c2yAF;
       u2yBp: // global
           call _c2yAB(R1) args: 0, res: 0, upd: 0;
       c2yAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yAB() //  [R1]
         { info_tbl: [(c2yAB,
                       label: block_c2yAB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAB: // global
           _s2uT8::I64 = I64[R1 + 7] & 7;
           if (_s2uT8::I64 != 0) goto u2yBn; else goto c2yBj;
       u2yBn: // global
           I64[Sp + 16] = _s2uT8::I64;
           Sp = Sp + 8;
           call _c2yAU() args: 0, res: 0, upd: 0;
       c2yBj: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yAU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAU: // global
           Hp = Hp + 16;
           _s2uT8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2yBg; else goto c2yBf;
       c2yBg: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2yAT_info;
           R1 = _s2uT8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yBf: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2uT3::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2uT3::I64 << _s2uT8::I64) | (_s2uT3::I64 >> 8 - _s2uT8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yAT() //  [R1]
         { info_tbl: [(c2yAT,
                       label: block_c2yAT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yAT: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2yAU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.806481187 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2yBA,
                       label: GHC.Word.$fBitsWord8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yBA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yBE; else goto c2yBF;
       c2yBE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yBF: // global
           I64[Sp - 16] = block_c2yBx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yCm; else goto c2yBy;
       u2yCm: // global
           call _c2yBx(R1) args: 0, res: 0, upd: 0;
       c2yBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yBx() //  [R1]
         { info_tbl: [(c2yBx,
                       label: block_c2yBx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yBx: // global
           I64[Sp] = block_c2yBD_info;
           _s2uTh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTh::I64;
           if (R1 & 7 != 0) goto u2yCl; else goto c2yBH;
       u2yCl: // global
           call _c2yBD(R1) args: 0, res: 0, upd: 0;
       c2yBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yBD() //  [R1]
         { info_tbl: [(c2yBD,
                       label: block_c2yBD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yBD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yBN; else goto c2yBM;
       c2yBN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yBM: // global
           _s2uTh::I64 = I64[Sp + 8];
           _s2uTj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uTj::I64, 0)) goto c2yC5; else goto c2yCk;
       c2yC5: // global
           _s2uTl::I64 = -_s2uTj::I64;
           if (%MO_S_Ge_W64(_s2uTl::I64, 64)) goto c2yCj; else goto c2yC2;
       c2yC2: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTh::I64 >> _s2uTl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yCk: // global
           if (%MO_S_Ge_W64(_s2uTj::I64, 64)) goto c2yCj; else goto c2yCi;
       c2yCj: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yCi: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uTh::I64 << _s2uTj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.808440979 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2yCu,
                       label: GHC.Word.$fBitsWord8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yCG; else goto c2yCH;
       c2yCG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yCH: // global
           I64[Sp - 16] = block_c2yCr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yCN; else goto c2yCs;
       u2yCN: // global
           call _c2yCr(R1) args: 0, res: 0, upd: 0;
       c2yCs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yCr() //  [R1]
         { info_tbl: [(c2yCr,
                       label: block_c2yCr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCr: // global
           I64[Sp] = block_c2yCx_info;
           _s2uTu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTu::I64;
           if (R1 & 7 != 0) goto u2yCM; else goto c2yCy;
       u2yCM: // global
           call _c2yCx(R1) args: 0, res: 0, upd: 0;
       c2yCy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yCx() //  [R1]
         { info_tbl: [(c2yCx,
                       label: block_c2yCx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yCL; else goto c2yCK;
       c2yCL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yCK: // global
           _s2uTx::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.810260827 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2yCV,
                       label: GHC.Word.$fBitsWord8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yD7; else goto c2yD8;
       c2yD7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yD8: // global
           I64[Sp - 16] = block_c2yCS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yDe; else goto c2yCT;
       u2yDe: // global
           call _c2yCS(R1) args: 0, res: 0, upd: 0;
       c2yCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yCS() //  [R1]
         { info_tbl: [(c2yCS,
                       label: block_c2yCS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCS: // global
           I64[Sp] = block_c2yCY_info;
           _s2uTB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTB::I64;
           if (R1 & 7 != 0) goto u2yDd; else goto c2yCZ;
       u2yDd: // global
           call _c2yCY(R1) args: 0, res: 0, upd: 0;
       c2yCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yCY() //  [R1]
         { info_tbl: [(c2yCY,
                       label: block_c2yCY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yCY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yDc; else goto c2yDb;
       c2yDc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yDb: // global
           _s2uTE::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.812062042 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2yDm,
                       label: GHC.Word.$fBitsWord8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yDm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yDy; else goto c2yDz;
       c2yDy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yDz: // global
           I64[Sp - 16] = block_c2yDj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yDF; else goto c2yDk;
       u2yDF: // global
           call _c2yDj(R1) args: 0, res: 0, upd: 0;
       c2yDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yDj() //  [R1]
         { info_tbl: [(c2yDj,
                       label: block_c2yDj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yDj: // global
           I64[Sp] = block_c2yDp_info;
           _s2uTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTI::I64;
           if (R1 & 7 != 0) goto u2yDE; else goto c2yDq;
       u2yDE: // global
           call _c2yDp(R1) args: 0, res: 0, upd: 0;
       c2yDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yDp() //  [R1]
         { info_tbl: [(c2yDp,
                       label: block_c2yDp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yDp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yDD; else goto c2yDC;
       c2yDD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yDC: // global
           _s2uTL::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.814808184 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2yDN,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yDN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yDY; else goto c2yDZ;
       c2yDY: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yDZ: // global
           I64[Sp - 8] = block_c2yDK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yE3; else goto c2yDL;
       u2yE3: // global
           call _c2yDK(R1) args: 0, res: 0, upd: 0;
       c2yDL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yDK() //  [R1]
         { info_tbl: [(c2yDK,
                       label: block_c2yDK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yDK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yE2; else goto c2yE1;
       c2yE2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yE1: // global
           (_c2yDQ::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yDQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.81619359 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2yEb,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yEb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yEm; else goto c2yEn;
       c2yEm: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yEn: // global
           I64[Sp - 8] = block_c2yE8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yEr; else goto c2yE9;
       u2yEr: // global
           call _c2yE8(R1) args: 0, res: 0, upd: 0;
       c2yE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yE8() //  [R1]
         { info_tbl: [(c2yE8,
                       label: block_c2yE8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yE8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yEq; else goto c2yEp;
       c2yEq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yEp: // global
           (_c2yEe::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yEe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.81734244 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.817998638 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2yEw,
                       label: GHC.Word.$fBitsWord8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yEw: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.818963903 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2yEF,
                       label: GHC.Word.$fNumWord16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yEF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yEM; else goto c2yEN;
       c2yEM: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yEN: // global
           I64[Sp - 8] = block_c2yED_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2yED() //  [R1]
         { info_tbl: [(c2yED,
                       label: block_c2yED_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yED: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yEQ; else goto c2yEP;
       c2yEQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yEP: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.820127083 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { info_tbl: [(c2yEV,
                       label: GHC.Word.$fNumWord16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yEV: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.821162267 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { info_tbl: [(c2yF5,
                       label: GHC.Word.$fNumWord16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yF5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yFl; else goto c2yFm;
       c2yFl: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yFm: // global
           I64[Sp - 8] = block_c2yF2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yFq; else goto c2yF3;
       u2yFq: // global
           call _c2yF2(R1) args: 0, res: 0, upd: 0;
       c2yF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yF2() //  [R1]
         { info_tbl: [(c2yF2,
                       label: block_c2yF2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yF2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yFp; else goto c2yFo;
       c2yFp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yFo: // global
           _s2uU7::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uU7::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.823072034 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2yFy,
                       label: GHC.Word.$fNumWord16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yFy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yFN; else goto c2yFO;
       c2yFN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yFO: // global
           I64[Sp - 16] = block_c2yFv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yFU; else goto c2yFw;
       u2yFU: // global
           call _c2yFv(R1) args: 0, res: 0, upd: 0;
       c2yFw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yFv() //  [R1]
         { info_tbl: [(c2yFv,
                       label: block_c2yFv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yFv: // global
           I64[Sp] = block_c2yFB_info;
           _s2uUb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUb::I64;
           if (R1 & 7 != 0) goto u2yFT; else goto c2yFC;
       u2yFT: // global
           call _c2yFB(R1) args: 0, res: 0, upd: 0;
       c2yFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yFB() //  [R1]
         { info_tbl: [(c2yFB,
                       label: block_c2yFB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yFB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yFS; else goto c2yFR;
       c2yFS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yFR: // global
           _s2uUf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.824857781 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2yG2,
                       label: GHC.Word.$fNumWord16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yGh; else goto c2yGi;
       c2yGh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yGi: // global
           I64[Sp - 16] = block_c2yFZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yGo; else goto c2yG0;
       u2yGo: // global
           call _c2yFZ(R1) args: 0, res: 0, upd: 0;
       c2yG0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yFZ() //  [R1]
         { info_tbl: [(c2yFZ,
                       label: block_c2yFZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yFZ: // global
           I64[Sp] = block_c2yG5_info;
           _s2uUj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUj::I64;
           if (R1 & 7 != 0) goto u2yGn; else goto c2yG6;
       u2yGn: // global
           call _c2yG5(R1) args: 0, res: 0, upd: 0;
       c2yG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yG5() //  [R1]
         { info_tbl: [(c2yG5,
                       label: block_c2yG5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yG5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yGm; else goto c2yGl;
       c2yGm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yGl: // global
           _s2uUn::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.826648174 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2yGw,
                       label: GHC.Word.$fNumWord16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yGL; else goto c2yGM;
       c2yGL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yGM: // global
           I64[Sp - 16] = block_c2yGt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yGS; else goto c2yGu;
       u2yGS: // global
           call _c2yGt(R1) args: 0, res: 0, upd: 0;
       c2yGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yGt() //  [R1]
         { info_tbl: [(c2yGt,
                       label: block_c2yGt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yGt: // global
           I64[Sp] = block_c2yGz_info;
           _s2uUr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUr::I64;
           if (R1 & 7 != 0) goto u2yGR; else goto c2yGA;
       u2yGR: // global
           call _c2yGz(R1) args: 0, res: 0, upd: 0;
       c2yGA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yGz() //  [R1]
         { info_tbl: [(c2yGz,
                       label: block_c2yGz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yGz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yGQ; else goto c2yGP;
       c2yGQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yGP: // global
           _s2uUv::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.828279171 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { info_tbl: [(c2yH0,
                       label: GHC.Word.$ctoInteger1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yH0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yH1; else goto c2yH2;
       c2yH1: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yH2: // global
           I64[Sp - 8] = block_c2yGX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yH7; else goto c2yGY;
       u2yH7: // global
           call _c2yGX(R1) args: 0, res: 0, upd: 0;
       c2yGY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yGX() //  [R1]
         { info_tbl: [(c2yGX,
                       label: block_c2yGX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yGX: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.829702183 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2yHf,
                       label: GHC.Word.$fBitsWord16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yHf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yHq; else goto c2yHr;
       c2yHq: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yHr: // global
           I64[Sp - 8] = block_c2yHc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yHv; else goto c2yHd;
       u2yHv: // global
           call _c2yHc(R1) args: 0, res: 0, upd: 0;
       c2yHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yHc() //  [R1]
         { info_tbl: [(c2yHc,
                       label: block_c2yHc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yHc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yHu; else goto c2yHt;
       c2yHu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yHt: // global
           (_c2yHi::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yHi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.831331701 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yHD,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yHD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yHP; else goto c2yHQ;
       c2yHP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yHQ: // global
           I64[Sp - 16] = block_c2yHA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yHW; else goto c2yHB;
       u2yHW: // global
           call _c2yHA(R1) args: 0, res: 0, upd: 0;
       c2yHB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yHA() //  [R1]
         { info_tbl: [(c2yHA,
                       label: block_c2yHA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yHA: // global
           I64[Sp] = block_c2yHG_info;
           _s2uUI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUI::I64;
           if (R1 & 7 != 0) goto u2yHV; else goto c2yHH;
       u2yHV: // global
           call _c2yHG(R1) args: 0, res: 0, upd: 0;
       c2yHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yHG() //  [R1]
         { info_tbl: [(c2yHG,
                       label: block_c2yHG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yHG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yHU; else goto c2yHT;
       c2yHU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yHT: // global
           _s2uUL::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.834186986 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yI4,
                       label: GHC.Word.$fBitsWord16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yI8; else goto c2yI9;
       c2yI8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yI9: // global
           I64[Sp - 16] = block_c2yI1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yIt; else goto c2yI2;
       u2yIt: // global
           call _c2yI1(R1) args: 0, res: 0, upd: 0;
       c2yI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yI1() //  [R1]
         { info_tbl: [(c2yI1,
                       label: block_c2yI1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yI1: // global
           I64[Sp] = block_c2yI7_info;
           _s2uUP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUP::I64;
           if (R1 & 7 != 0) goto u2yIs; else goto c2yIb;
       u2yIs: // global
           call _c2yI7(R1) args: 0, res: 0, upd: 0;
       c2yIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yI7() //  [R1]
         { info_tbl: [(c2yI7,
                       label: block_c2yI7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yI7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yIh; else goto c2yIg;
       c2yIh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yIg: // global
           _s2uUR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uUR::I64, 64)) goto c2yIq; else goto c2yIr;
       c2yIq: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uUR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yIr: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.836047502 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yIB,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yIQ; else goto c2yIR;
       c2yIQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yIR: // global
           I64[Sp - 16] = block_c2yIy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yIX; else goto c2yIz;
       u2yIX: // global
           call _c2yIy(R1) args: 0, res: 0, upd: 0;
       c2yIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yIy() //  [R1]
         { info_tbl: [(c2yIy,
                       label: block_c2yIy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yIy: // global
           I64[Sp] = block_c2yIE_info;
           _s2uUX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUX::I64;
           if (R1 & 7 != 0) goto u2yIW; else goto c2yIF;
       u2yIW: // global
           call _c2yIE(R1) args: 0, res: 0, upd: 0;
       c2yIF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yIE() //  [R1]
         { info_tbl: [(c2yIE,
                       label: block_c2yIE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yIE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yIV; else goto c2yIU;
       c2yIV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yIU: // global
           _s2uV1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uV1::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.83830465 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yJ5,
                       label: GHC.Word.$fBitsWord16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yJ9; else goto c2yJa;
       c2yJ9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yJa: // global
           I64[Sp - 16] = block_c2yJ2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yJx; else goto c2yJ3;
       u2yJx: // global
           call _c2yJ2(R1) args: 0, res: 0, upd: 0;
       c2yJ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yJ2() //  [R1]
         { info_tbl: [(c2yJ2,
                       label: block_c2yJ2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJ2: // global
           I64[Sp] = block_c2yJ8_info;
           _s2uV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uV5::I64;
           if (R1 & 7 != 0) goto u2yJw; else goto c2yJc;
       u2yJw: // global
           call _c2yJ8(R1) args: 0, res: 0, upd: 0;
       c2yJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yJ8() //  [R1]
         { info_tbl: [(c2yJ8,
                       label: block_c2yJ8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJ8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yJi; else goto c2yJh;
       c2yJi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yJh: // global
           _s2uV7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uV7::I64, 64)) goto c2yJu; else goto c2yJv;
       c2yJu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2uV7::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yJv: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.839804222 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { info_tbl: [(c2yJC,
                       label: GHC.Word.$fBitsWord16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.841134906 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2yJM,
                       label: GHC.Word.$fBitsWord16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yJQ; else goto c2yJR;
       c2yJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yJR: // global
           I64[Sp - 16] = block_c2yJJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yKE; else goto c2yJK;
       u2yKE: // global
           call _c2yJJ(R1) args: 0, res: 0, upd: 0;
       c2yJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yJJ() //  [R1]
         { info_tbl: [(c2yJJ,
                       label: block_c2yJJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJJ: // global
           I64[Sp - 8] = block_c2yJP_info;
           _s2uVe::P64 = R1;
           _s2uVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uVf::I64;
           P64[Sp + 8] = _s2uVe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yKD; else goto c2yJT;
       u2yKD: // global
           call _c2yJP(R1) args: 0, res: 0, upd: 0;
       c2yJT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yJP() //  [R1]
         { info_tbl: [(c2yJP,
                       label: block_c2yJP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yJP: // global
           _s2uVk::I64 = I64[R1 + 7] & 15;
           if (_s2uVk::I64 != 0) goto u2yKB; else goto c2yKx;
       u2yKB: // global
           I64[Sp + 16] = _s2uVk::I64;
           Sp = Sp + 8;
           call _c2yK8() args: 0, res: 0, upd: 0;
       c2yKx: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yK8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yK8: // global
           Hp = Hp + 16;
           _s2uVk::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2yKu; else goto c2yKt;
       c2yKu: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2yK7_info;
           R1 = _s2uVk::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yKt: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2uVf::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2uVf::I64 << _s2uVk::I64) | (_s2uVf::I64 >> 16 - _s2uVk::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yK7() //  [R1]
         { info_tbl: [(c2yK7,
                       label: block_c2yK7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yK7: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2yK8() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.843478553 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2yKO,
                       label: GHC.Word.$fBitsWord16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yKO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yKS; else goto c2yKT;
       c2yKS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yKT: // global
           I64[Sp - 16] = block_c2yKL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yLA; else goto c2yKM;
       u2yLA: // global
           call _c2yKL(R1) args: 0, res: 0, upd: 0;
       c2yKM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yKL() //  [R1]
         { info_tbl: [(c2yKL,
                       label: block_c2yKL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yKL: // global
           I64[Sp] = block_c2yKR_info;
           _s2uVt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVt::I64;
           if (R1 & 7 != 0) goto u2yLz; else goto c2yKV;
       u2yLz: // global
           call _c2yKR(R1) args: 0, res: 0, upd: 0;
       c2yKV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yKR() //  [R1]
         { info_tbl: [(c2yKR,
                       label: block_c2yKR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yKR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yL1; else goto c2yL0;
       c2yL1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yL0: // global
           _s2uVt::I64 = I64[Sp + 8];
           _s2uVv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uVv::I64, 0)) goto c2yLj; else goto c2yLy;
       c2yLj: // global
           _s2uVx::I64 = -_s2uVv::I64;
           if (%MO_S_Ge_W64(_s2uVx::I64, 64)) goto c2yLx; else goto c2yLg;
       c2yLg: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVt::I64 >> _s2uVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yLy: // global
           if (%MO_S_Ge_W64(_s2uVv::I64, 64)) goto c2yLx; else goto c2yLw;
       c2yLx: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yLw: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uVt::I64 << _s2uVv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.845523491 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2yLI,
                       label: GHC.Word.$fBitsWord16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yLU; else goto c2yLV;
       c2yLU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yLV: // global
           I64[Sp - 16] = block_c2yLF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yM1; else goto c2yLG;
       u2yM1: // global
           call _c2yLF(R1) args: 0, res: 0, upd: 0;
       c2yLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yLF() //  [R1]
         { info_tbl: [(c2yLF,
                       label: block_c2yLF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yLF: // global
           I64[Sp] = block_c2yLL_info;
           _s2uVG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVG::I64;
           if (R1 & 7 != 0) goto u2yM0; else goto c2yLM;
       u2yM0: // global
           call _c2yLL(R1) args: 0, res: 0, upd: 0;
       c2yLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yLL() //  [R1]
         { info_tbl: [(c2yLL,
                       label: block_c2yLL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yLL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yLZ; else goto c2yLY;
       c2yLZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yLY: // global
           _s2uVJ::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.847272995 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2yM9,
                       label: GHC.Word.$fBitsWord16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yM9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yMl; else goto c2yMm;
       c2yMl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yMm: // global
           I64[Sp - 16] = block_c2yM6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yMs; else goto c2yM7;
       u2yMs: // global
           call _c2yM6(R1) args: 0, res: 0, upd: 0;
       c2yM7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yM6() //  [R1]
         { info_tbl: [(c2yM6,
                       label: block_c2yM6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yM6: // global
           I64[Sp] = block_c2yMc_info;
           _s2uVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVN::I64;
           if (R1 & 7 != 0) goto u2yMr; else goto c2yMd;
       u2yMr: // global
           call _c2yMc(R1) args: 0, res: 0, upd: 0;
       c2yMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yMc() //  [R1]
         { info_tbl: [(c2yMc,
                       label: block_c2yMc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yMc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yMq; else goto c2yMp;
       c2yMq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yMp: // global
           _s2uVQ::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.848989954 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2yMA,
                       label: GHC.Word.$fBitsWord16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yMA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yMM; else goto c2yMN;
       c2yMM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yMN: // global
           I64[Sp - 16] = block_c2yMx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yMT; else goto c2yMy;
       u2yMT: // global
           call _c2yMx(R1) args: 0, res: 0, upd: 0;
       c2yMy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yMx() //  [R1]
         { info_tbl: [(c2yMx,
                       label: block_c2yMx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yMx: // global
           I64[Sp] = block_c2yMD_info;
           _s2uVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVU::I64;
           if (R1 & 7 != 0) goto u2yMS; else goto c2yME;
       u2yMS: // global
           call _c2yMD(R1) args: 0, res: 0, upd: 0;
       c2yME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yMD() //  [R1]
         { info_tbl: [(c2yMD,
                       label: block_c2yMD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yMD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yMR; else goto c2yMQ;
       c2yMR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yMQ: // global
           _s2uVX::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.851571258 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2yN1,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yN1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yNc; else goto c2yNd;
       c2yNc: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yNd: // global
           I64[Sp - 8] = block_c2yMY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yNh; else goto c2yMZ;
       u2yNh: // global
           call _c2yMY(R1) args: 0, res: 0, upd: 0;
       c2yMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yMY() //  [R1]
         { info_tbl: [(c2yMY,
                       label: block_c2yMY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yMY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yNg; else goto c2yNf;
       c2yNg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yNf: // global
           (_c2yN4::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yN4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.852970591 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2yNp,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yNp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yNA; else goto c2yNB;
       c2yNA: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yNB: // global
           I64[Sp - 8] = block_c2yNm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yNF; else goto c2yNn;
       u2yNF: // global
           call _c2yNm(R1) args: 0, res: 0, upd: 0;
       c2yNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yNm() //  [R1]
         { info_tbl: [(c2yNm,
                       label: block_c2yNm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yNm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yNE; else goto c2yND;
       c2yNE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yND: // global
           (_c2yNs::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yNs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.85406967 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.854739977 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2yNK,
                       label: GHC.Word.$fBitsWord16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yNK: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.855720495 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2yNT,
                       label: GHC.Word.$fNumWord32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yNT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yO0; else goto c2yO1;
       c2yO0: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yO1: // global
           I64[Sp - 8] = block_c2yNR_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2yNR() //  [R1]
         { info_tbl: [(c2yNR,
                       label: block_c2yNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yNR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yO4; else goto c2yO3;
       c2yO4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yO3: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.856863579 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { info_tbl: [(c2yO9,
                       label: GHC.Word.$fNumWord32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yO9: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.857938594 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { info_tbl: [(c2yOj,
                       label: GHC.Word.$fNumWord32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yOj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yOz; else goto c2yOA;
       c2yOz: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yOA: // global
           I64[Sp - 8] = block_c2yOg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yOE; else goto c2yOh;
       u2yOE: // global
           call _c2yOg(R1) args: 0, res: 0, upd: 0;
       c2yOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yOg() //  [R1]
         { info_tbl: [(c2yOg,
                       label: block_c2yOg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yOg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yOD; else goto c2yOC;
       c2yOD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yOC: // global
           _s2uWj::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.859410216 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2yOM,
                       label: GHC.Word.$fNumWord32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yOM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yP1; else goto c2yP2;
       c2yP1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yP2: // global
           I64[Sp - 16] = block_c2yOJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yP8; else goto c2yOK;
       u2yP8: // global
           call _c2yOJ(R1) args: 0, res: 0, upd: 0;
       c2yOK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yOJ() //  [R1]
         { info_tbl: [(c2yOJ,
                       label: block_c2yOJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yOJ: // global
           I64[Sp] = block_c2yOP_info;
           _s2uWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWn::I64;
           if (R1 & 7 != 0) goto u2yP7; else goto c2yOQ;
       u2yP7: // global
           call _c2yOP(R1) args: 0, res: 0, upd: 0;
       c2yOQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yOP() //  [R1]
         { info_tbl: [(c2yOP,
                       label: block_c2yOP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yOP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yP6; else goto c2yP5;
       c2yP6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yP5: // global
           _s2uWr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.861117416 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2yPg,
                       label: GHC.Word.$fNumWord32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yPv; else goto c2yPw;
       c2yPv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yPw: // global
           I64[Sp - 16] = block_c2yPd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yPC; else goto c2yPe;
       u2yPC: // global
           call _c2yPd(R1) args: 0, res: 0, upd: 0;
       c2yPe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yPd() //  [R1]
         { info_tbl: [(c2yPd,
                       label: block_c2yPd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPd: // global
           I64[Sp] = block_c2yPj_info;
           _s2uWv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWv::I64;
           if (R1 & 7 != 0) goto u2yPB; else goto c2yPk;
       u2yPB: // global
           call _c2yPj(R1) args: 0, res: 0, upd: 0;
       c2yPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yPj() //  [R1]
         { info_tbl: [(c2yPj,
                       label: block_c2yPj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yPA; else goto c2yPz;
       c2yPA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yPz: // global
           _s2uWz::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.863080947 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2yPK,
                       label: GHC.Word.$fNumWord32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yPZ; else goto c2yQ0;
       c2yPZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yQ0: // global
           I64[Sp - 16] = block_c2yPH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yQ6; else goto c2yPI;
       u2yQ6: // global
           call _c2yPH(R1) args: 0, res: 0, upd: 0;
       c2yPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yPH() //  [R1]
         { info_tbl: [(c2yPH,
                       label: block_c2yPH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPH: // global
           I64[Sp] = block_c2yPN_info;
           _s2uWD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWD::I64;
           if (R1 & 7 != 0) goto u2yQ5; else goto c2yPO;
       u2yQ5: // global
           call _c2yPN(R1) args: 0, res: 0, upd: 0;
       c2yPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yPN() //  [R1]
         { info_tbl: [(c2yPN,
                       label: block_c2yPN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yPN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yQ4; else goto c2yQ3;
       c2yQ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yQ3: // global
           _s2uWH::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.864678984 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { info_tbl: [(c2yQe,
                       label: GHC.Word.$ctoInteger2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yQf; else goto c2yQg;
       c2yQf: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yQg: // global
           I64[Sp - 8] = block_c2yQb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yQl; else goto c2yQc;
       u2yQl: // global
           call _c2yQb(R1) args: 0, res: 0, upd: 0;
       c2yQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yQb() //  [R1]
         { info_tbl: [(c2yQb,
                       label: block_c2yQb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQb: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.86601977 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2yQt,
                       label: GHC.Word.$fBitsWord32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yQE; else goto c2yQF;
       c2yQE: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yQF: // global
           I64[Sp - 8] = block_c2yQq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yQJ; else goto c2yQr;
       u2yQJ: // global
           call _c2yQq(R1) args: 0, res: 0, upd: 0;
       c2yQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yQq() //  [R1]
         { info_tbl: [(c2yQq,
                       label: block_c2yQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yQI; else goto c2yQH;
       c2yQI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yQH: // global
           (_c2yQw::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yQw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.867541198 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yQR,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yR3; else goto c2yR4;
       c2yR3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yR4: // global
           I64[Sp - 16] = block_c2yQO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yRa; else goto c2yQP;
       u2yRa: // global
           call _c2yQO(R1) args: 0, res: 0, upd: 0;
       c2yQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yQO() //  [R1]
         { info_tbl: [(c2yQO,
                       label: block_c2yQO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQO: // global
           I64[Sp] = block_c2yQU_info;
           _s2uWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWU::I64;
           if (R1 & 7 != 0) goto u2yR9; else goto c2yQV;
       u2yR9: // global
           call _c2yQU(R1) args: 0, res: 0, upd: 0;
       c2yQV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yQU() //  [R1]
         { info_tbl: [(c2yQU,
                       label: block_c2yQU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yQU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yR8; else goto c2yR7;
       c2yR8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yR7: // global
           _s2uWX::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.870151036 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yRi,
                       label: GHC.Word.$fBitsWord32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yRm; else goto c2yRn;
       c2yRm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yRn: // global
           I64[Sp - 16] = block_c2yRf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yRH; else goto c2yRg;
       u2yRH: // global
           call _c2yRf(R1) args: 0, res: 0, upd: 0;
       c2yRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yRf() //  [R1]
         { info_tbl: [(c2yRf,
                       label: block_c2yRf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRf: // global
           I64[Sp] = block_c2yRl_info;
           _s2uX1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX1::I64;
           if (R1 & 7 != 0) goto u2yRG; else goto c2yRp;
       u2yRG: // global
           call _c2yRl(R1) args: 0, res: 0, upd: 0;
       c2yRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yRl() //  [R1]
         { info_tbl: [(c2yRl,
                       label: block_c2yRl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yRv; else goto c2yRu;
       c2yRv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yRu: // global
           _s2uX3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uX3::I64, 64)) goto c2yRE; else goto c2yRF;
       c2yRE: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uX3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yRF: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.871954055 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yRP,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yS4; else goto c2yS5;
       c2yS4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yS5: // global
           I64[Sp - 16] = block_c2yRM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ySb; else goto c2yRN;
       u2ySb: // global
           call _c2yRM(R1) args: 0, res: 0, upd: 0;
       c2yRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yRM() //  [R1]
         { info_tbl: [(c2yRM,
                       label: block_c2yRM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRM: // global
           I64[Sp] = block_c2yRS_info;
           _s2uX9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX9::I64;
           if (R1 & 7 != 0) goto u2ySa; else goto c2yRT;
       u2ySa: // global
           call _c2yRS(R1) args: 0, res: 0, upd: 0;
       c2yRT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yRS() //  [R1]
         { info_tbl: [(c2yRS,
                       label: block_c2yRS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yRS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yS9; else goto c2yS8;
       c2yS9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yS8: // global
           _s2uXd::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.873730309 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2ySj,
                       label: GHC.Word.$fBitsWord32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ySj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ySn; else goto c2ySo;
       c2ySn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ySo: // global
           I64[Sp - 16] = block_c2ySg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ySL; else goto c2ySh;
       u2ySL: // global
           call _c2ySg(R1) args: 0, res: 0, upd: 0;
       c2ySh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ySg() //  [R1]
         { info_tbl: [(c2ySg,
                       label: block_c2ySg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ySg: // global
           I64[Sp] = block_c2ySm_info;
           _s2uXh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXh::I64;
           if (R1 & 7 != 0) goto u2ySK; else goto c2ySq;
       u2ySK: // global
           call _c2ySm(R1) args: 0, res: 0, upd: 0;
       c2ySq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ySm() //  [R1]
         { info_tbl: [(c2ySm,
                       label: block_c2ySm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ySm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ySw; else goto c2ySv;
       c2ySw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ySv: // global
           _s2uXj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXj::I64, 64)) goto c2ySI; else goto c2ySJ;
       c2ySI: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2uXj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ySJ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.87526582 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { info_tbl: [(c2ySQ,
                       label: GHC.Word.$fBitsWord32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ySQ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.876567101 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2yT0,
                       label: GHC.Word.$fBitsWord32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yT0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yT4; else goto c2yT5;
       c2yT4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yT5: // global
           I64[Sp - 16] = block_c2ySX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yTS; else goto c2ySY;
       u2yTS: // global
           call _c2ySX(R1) args: 0, res: 0, upd: 0;
       c2ySY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ySX() //  [R1]
         { info_tbl: [(c2ySX,
                       label: block_c2ySX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ySX: // global
           I64[Sp - 8] = block_c2yT3_info;
           _s2uXq::P64 = R1;
           _s2uXr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uXr::I64;
           P64[Sp + 8] = _s2uXq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yTR; else goto c2yT7;
       u2yTR: // global
           call _c2yT3(R1) args: 0, res: 0, upd: 0;
       c2yT7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yT3() //  [R1]
         { info_tbl: [(c2yT3,
                       label: block_c2yT3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yT3: // global
           _s2uXw::I64 = I64[R1 + 7] & 31;
           if (_s2uXw::I64 != 0) goto u2yTP; else goto c2yTL;
       u2yTP: // global
           I64[Sp + 16] = _s2uXw::I64;
           Sp = Sp + 8;
           call _c2yTm() args: 0, res: 0, upd: 0;
       c2yTL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yTm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yTm: // global
           Hp = Hp + 16;
           _s2uXw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2yTI; else goto c2yTH;
       c2yTI: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2yTl_info;
           R1 = _s2uXw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2yTH: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2uXr::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2uXr::I64 << _s2uXw::I64) | (_s2uXr::I64 >> 32 - _s2uXw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yTl() //  [R1]
         { info_tbl: [(c2yTl,
                       label: block_c2yTl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yTl: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2yTm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.878888896 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2yU2,
                       label: GHC.Word.$fBitsWord32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yU2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yU6; else goto c2yU7;
       c2yU6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yU7: // global
           I64[Sp - 16] = block_c2yTZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yUO; else goto c2yU0;
       u2yUO: // global
           call _c2yTZ(R1) args: 0, res: 0, upd: 0;
       c2yU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yTZ() //  [R1]
         { info_tbl: [(c2yTZ,
                       label: block_c2yTZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yTZ: // global
           I64[Sp] = block_c2yU5_info;
           _s2uXF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXF::I64;
           if (R1 & 7 != 0) goto u2yUN; else goto c2yU9;
       u2yUN: // global
           call _c2yU5(R1) args: 0, res: 0, upd: 0;
       c2yU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yU5() //  [R1]
         { info_tbl: [(c2yU5,
                       label: block_c2yU5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yU5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yUf; else goto c2yUe;
       c2yUf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yUe: // global
           _s2uXF::I64 = I64[Sp + 8];
           _s2uXH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXH::I64, 0)) goto c2yUx; else goto c2yUM;
       c2yUx: // global
           _s2uXJ::I64 = -_s2uXH::I64;
           if (%MO_S_Ge_W64(_s2uXJ::I64, 64)) goto c2yUL; else goto c2yUu;
       c2yUu: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXF::I64 >> _s2uXJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yUM: // global
           if (%MO_S_Ge_W64(_s2uXH::I64, 64)) goto c2yUL; else goto c2yUK;
       c2yUL: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yUK: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uXF::I64 << _s2uXH::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.880810448 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2yUW,
                       label: GHC.Word.$fBitsWord32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yUW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yV8; else goto c2yV9;
       c2yV8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yV9: // global
           I64[Sp - 16] = block_c2yUT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yVf; else goto c2yUU;
       u2yVf: // global
           call _c2yUT(R1) args: 0, res: 0, upd: 0;
       c2yUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yUT() //  [R1]
         { info_tbl: [(c2yUT,
                       label: block_c2yUT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yUT: // global
           I64[Sp] = block_c2yUZ_info;
           _s2uXS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXS::I64;
           if (R1 & 7 != 0) goto u2yVe; else goto c2yV0;
       u2yVe: // global
           call _c2yUZ(R1) args: 0, res: 0, upd: 0;
       c2yV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yUZ() //  [R1]
         { info_tbl: [(c2yUZ,
                       label: block_c2yUZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yUZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yVd; else goto c2yVc;
       c2yVd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yVc: // global
           _s2uXV::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.882566616 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2yVn,
                       label: GHC.Word.$fBitsWord32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yVz; else goto c2yVA;
       c2yVz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yVA: // global
           I64[Sp - 16] = block_c2yVk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yVG; else goto c2yVl;
       u2yVG: // global
           call _c2yVk(R1) args: 0, res: 0, upd: 0;
       c2yVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yVk() //  [R1]
         { info_tbl: [(c2yVk,
                       label: block_c2yVk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVk: // global
           I64[Sp] = block_c2yVq_info;
           _s2uXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXZ::I64;
           if (R1 & 7 != 0) goto u2yVF; else goto c2yVr;
       u2yVF: // global
           call _c2yVq(R1) args: 0, res: 0, upd: 0;
       c2yVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yVq() //  [R1]
         { info_tbl: [(c2yVq,
                       label: block_c2yVq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yVE; else goto c2yVD;
       c2yVE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yVD: // global
           _s2uY2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.884263587 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2yVO,
                       label: GHC.Word.$fBitsWord32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yW0; else goto c2yW1;
       c2yW0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yW1: // global
           I64[Sp - 16] = block_c2yVL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yW7; else goto c2yVM;
       u2yW7: // global
           call _c2yVL(R1) args: 0, res: 0, upd: 0;
       c2yVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yVL() //  [R1]
         { info_tbl: [(c2yVL,
                       label: block_c2yVL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVL: // global
           I64[Sp] = block_c2yVR_info;
           _s2uY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uY6::I64;
           if (R1 & 7 != 0) goto u2yW6; else goto c2yVS;
       u2yW6: // global
           call _c2yVR(R1) args: 0, res: 0, upd: 0;
       c2yVS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yVR() //  [R1]
         { info_tbl: [(c2yVR,
                       label: block_c2yVR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yVR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yW5; else goto c2yW4;
       c2yW5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yW4: // global
           _s2uY9::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.887223643 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2yWf,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yWf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yWq; else goto c2yWr;
       c2yWq: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yWr: // global
           I64[Sp - 8] = block_c2yWc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yWv; else goto c2yWd;
       u2yWv: // global
           call _c2yWc(R1) args: 0, res: 0, upd: 0;
       c2yWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yWc() //  [R1]
         { info_tbl: [(c2yWc,
                       label: block_c2yWc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yWc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yWu; else goto c2yWt;
       c2yWu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yWt: // global
           (_c2yWi::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yWi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.888657779 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2yWD,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yWD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yWO; else goto c2yWP;
       c2yWO: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yWP: // global
           I64[Sp - 8] = block_c2yWA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yWT; else goto c2yWB;
       u2yWT: // global
           call _c2yWA(R1) args: 0, res: 0, upd: 0;
       c2yWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yWA() //  [R1]
         { info_tbl: [(c2yWA,
                       label: block_c2yWA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yWA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yWS; else goto c2yWR;
       c2yWS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yWR: // global
           (_c2yWG::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yWG::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.889835932 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.890501897 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2yWY,
                       label: GHC.Word.$fBitsWord32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yWY: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.891524562 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2yX8,
                       label: GHC.Word.$fBitsWord64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yX8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2yXj; else goto c2yXk;
       c2yXj: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2yXk: // global
           I64[Sp - 8] = block_c2yX5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2yXo; else goto c2yX6;
       u2yXo: // global
           call _c2yX5(R1) args: 0, res: 0, upd: 0;
       c2yX6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yX5() //  [R1]
         { info_tbl: [(c2yX5,
                       label: block_c2yX5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yX5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yXn; else goto c2yXm;
       c2yXn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yXm: // global
           (_c2yXb::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2yXb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.893021106 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yXw,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yXw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yXI; else goto c2yXJ;
       c2yXI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yXJ: // global
           I64[Sp - 16] = block_c2yXt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yXP; else goto c2yXu;
       u2yXP: // global
           call _c2yXt(R1) args: 0, res: 0, upd: 0;
       c2yXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yXt() //  [R1]
         { info_tbl: [(c2yXt,
                       label: block_c2yXt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yXt: // global
           I64[Sp] = block_c2yXz_info;
           _s2uYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYt::I64;
           if (R1 & 7 != 0) goto u2yXO; else goto c2yXA;
       u2yXO: // global
           call _c2yXz(R1) args: 0, res: 0, upd: 0;
       c2yXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yXz() //  [R1]
         { info_tbl: [(c2yXz,
                       label: block_c2yXz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yXz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yXN; else goto c2yXM;
       c2yXN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yXM: // global
           _s2uYw::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.894812578 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2yXX,
                       label: GHC.Word.$fBitsWord64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yXX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yY1; else goto c2yY2;
       c2yY1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yY2: // global
           I64[Sp - 16] = block_c2yXU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yYm; else goto c2yXV;
       u2yYm: // global
           call _c2yXU(R1) args: 0, res: 0, upd: 0;
       c2yXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yXU() //  [R1]
         { info_tbl: [(c2yXU,
                       label: block_c2yXU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yXU: // global
           I64[Sp] = block_c2yY0_info;
           _s2uYA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYA::I64;
           if (R1 & 7 != 0) goto u2yYl; else goto c2yY4;
       u2yYl: // global
           call _c2yY0(R1) args: 0, res: 0, upd: 0;
       c2yY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yY0() //  [R1]
         { info_tbl: [(c2yY0,
                       label: block_c2yY0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yY0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yYa; else goto c2yY9;
       c2yYa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yY9: // global
           _s2uYC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYC::I64, 64)) goto c2yYj; else goto c2yYk;
       c2yYj: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uYC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yYk: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.896572912 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yYu,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yYG; else goto c2yYH;
       c2yYG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yYH: // global
           I64[Sp - 16] = block_c2yYr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yYN; else goto c2yYs;
       u2yYN: // global
           call _c2yYr(R1) args: 0, res: 0, upd: 0;
       c2yYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yYr() //  [R1]
         { info_tbl: [(c2yYr,
                       label: block_c2yYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYr: // global
           I64[Sp] = block_c2yYx_info;
           _s2uYI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYI::I64;
           if (R1 & 7 != 0) goto u2yYM; else goto c2yYy;
       u2yYM: // global
           call _c2yYx(R1) args: 0, res: 0, upd: 0;
       c2yYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yYx() //  [R1]
         { info_tbl: [(c2yYx,
                       label: block_c2yYx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yYL; else goto c2yYK;
       c2yYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yYK: // global
           _s2uYL::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.898306107 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2yYV,
                       label: GHC.Word.$fBitsWord64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2yYZ; else goto c2yZ0;
       c2yYZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yZ0: // global
           I64[Sp - 16] = block_c2yYS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2yZk; else goto c2yYT;
       u2yZk: // global
           call _c2yYS(R1) args: 0, res: 0, upd: 0;
       c2yYT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yYS() //  [R1]
         { info_tbl: [(c2yYS,
                       label: block_c2yYS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYS: // global
           I64[Sp] = block_c2yYY_info;
           _s2uYP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYP::I64;
           if (R1 & 7 != 0) goto u2yZj; else goto c2yZ2;
       u2yZj: // global
           call _c2yYY(R1) args: 0, res: 0, upd: 0;
       c2yZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yYY() //  [R1]
         { info_tbl: [(c2yYY,
                       label: block_c2yYY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yYY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2yZ8; else goto c2yZ7;
       c2yZ8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2yZ7: // global
           _s2uYR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYR::I64, 64)) goto c2yZh; else goto c2yZi;
       c2yZh: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2uYR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2yZi: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.899824745 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { info_tbl: [(c2yZp,
                       label: GHC.Word.$fBitsWord64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZp: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.901124974 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2yZz,
                       label: GHC.Word.$fBitsWord64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2yZD; else goto c2yZE;
       c2yZD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2yZE: // global
           I64[Sp - 16] = block_c2yZw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z0o; else goto c2yZx;
       u2z0o: // global
           call _c2yZw(R1) args: 0, res: 0, upd: 0;
       c2yZx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yZw() //  [R1]
         { info_tbl: [(c2yZw,
                       label: block_c2yZw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZw: // global
           I64[Sp - 8] = block_c2yZC_info;
           _s2uYX::P64 = R1;
           _s2uYY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uYY::I64;
           P64[Sp + 8] = _s2uYX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z0n; else goto c2yZG;
       u2z0n: // global
           call _c2yZC(R1) args: 0, res: 0, upd: 0;
       c2yZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2yZC() //  [R1]
         { info_tbl: [(c2yZC,
                       label: block_c2yZC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZC: // global
           _s2uZ3::I64 = I64[R1 + 7] & 63;
           if (_s2uZ3::I64 != 0) goto u2z0l; else goto c2z0h;
       u2z0l: // global
           I64[Sp + 16] = _s2uZ3::I64;
           Sp = Sp + 8;
           call _c2yZV() args: 0, res: 0, upd: 0;
       c2z0h: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yZV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZV: // global
           Hp = Hp + 16;
           _s2uZ3::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2z0e; else goto c2z0d;
       c2z0e: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2yZU_info;
           R1 = _s2uZ3::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2z0d: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2uYY::I64 = I64[Sp];
           I64[Hp] = (_s2uYY::I64 << _s2uZ3::I64) | (_s2uYY::I64 >> 64 - _s2uZ3::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2yZU() //  [R1]
         { info_tbl: [(c2yZU,
                       label: block_c2yZU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2yZU: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2yZV() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.904369585 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2z0y,
                       label: GHC.Word.$fBitsWord64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z0y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z0C; else goto c2z0D;
       c2z0C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z0D: // global
           I64[Sp - 16] = block_c2z0v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z1h; else goto c2z0w;
       u2z1h: // global
           call _c2z0v(R1) args: 0, res: 0, upd: 0;
       c2z0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z0v() //  [R1]
         { info_tbl: [(c2z0v,
                       label: block_c2z0v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z0v: // global
           I64[Sp] = block_c2z0B_info;
           _s2uZb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZb::I64;
           if (R1 & 7 != 0) goto u2z1g; else goto c2z0F;
       u2z1g: // global
           call _c2z0B(R1) args: 0, res: 0, upd: 0;
       c2z0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z0B() //  [R1]
         { info_tbl: [(c2z0B,
                       label: block_c2z0B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z0B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z0L; else goto c2z0K;
       c2z0L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z0K: // global
           _s2uZb::I64 = I64[Sp + 8];
           _s2uZd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uZd::I64, 0)) goto c2z13; else goto c2z1f;
       c2z13: // global
           _s2uZf::I64 = -_s2uZd::I64;
           if (%MO_S_Ge_W64(_s2uZf::I64, 64)) goto c2z1e; else goto c2z10;
       c2z10: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 >> _s2uZf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z1f: // global
           if (%MO_S_Ge_W64(_s2uZd::I64, 64)) goto c2z1e; else goto c2z1d;
       c2z1e: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z1d: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 << _s2uZd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.906788082 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2z1p,
                       label: GHC.Word.$fBitsWord64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z1B; else goto c2z1C;
       c2z1B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z1C: // global
           I64[Sp - 16] = block_c2z1m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z1I; else goto c2z1n;
       u2z1I: // global
           call _c2z1m(R1) args: 0, res: 0, upd: 0;
       c2z1n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z1m() //  [R1]
         { info_tbl: [(c2z1m,
                       label: block_c2z1m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1m: // global
           I64[Sp] = block_c2z1s_info;
           _s2uZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZn::I64;
           if (R1 & 7 != 0) goto u2z1H; else goto c2z1t;
       u2z1H: // global
           call _c2z1s(R1) args: 0, res: 0, upd: 0;
       c2z1t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z1s() //  [R1]
         { info_tbl: [(c2z1s,
                       label: block_c2z1s_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z1G; else goto c2z1F;
       c2z1G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z1F: // global
           _s2uZq::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.908481976 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2z1Q,
                       label: GHC.Word.$fBitsWord64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z22; else goto c2z23;
       c2z22: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z23: // global
           I64[Sp - 16] = block_c2z1N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z29; else goto c2z1O;
       u2z29: // global
           call _c2z1N(R1) args: 0, res: 0, upd: 0;
       c2z1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z1N() //  [R1]
         { info_tbl: [(c2z1N,
                       label: block_c2z1N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1N: // global
           I64[Sp] = block_c2z1T_info;
           _s2uZu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZu::I64;
           if (R1 & 7 != 0) goto u2z28; else goto c2z1U;
       u2z28: // global
           call _c2z1T(R1) args: 0, res: 0, upd: 0;
       c2z1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z1T() //  [R1]
         { info_tbl: [(c2z1T,
                       label: block_c2z1T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z1T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z27; else goto c2z26;
       c2z27: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z26: // global
           _s2uZx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.91023108 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2z2h,
                       label: GHC.Word.$fBitsWord64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z2t; else goto c2z2u;
       c2z2t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z2u: // global
           I64[Sp - 16] = block_c2z2e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z2A; else goto c2z2f;
       u2z2A: // global
           call _c2z2e(R1) args: 0, res: 0, upd: 0;
       c2z2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z2e() //  [R1]
         { info_tbl: [(c2z2e,
                       label: block_c2z2e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z2e: // global
           I64[Sp] = block_c2z2k_info;
           _s2uZB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZB::I64;
           if (R1 & 7 != 0) goto u2z2z; else goto c2z2l;
       u2z2z: // global
           call _c2z2k(R1) args: 0, res: 0, upd: 0;
       c2z2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z2k() //  [R1]
         { info_tbl: [(c2z2k,
                       label: block_c2z2k_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z2k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z2y; else goto c2z2x;
       c2z2y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z2x: // global
           _s2uZE::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.911793703 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2z2I,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z2I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2z2T; else goto c2z2U;
       c2z2T: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2z2U: // global
           I64[Sp - 8] = block_c2z2F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z2Y; else goto c2z2G;
       u2z2Y: // global
           call _c2z2F(R1) args: 0, res: 0, upd: 0;
       c2z2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z2F() //  [R1]
         { info_tbl: [(c2z2F,
                       label: block_c2z2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z2F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z2X; else goto c2z2W;
       c2z2X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z2W: // global
           (_c2z2L::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2z2L::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.913152968 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2z36,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z36: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2z3h; else goto c2z3i;
       c2z3h: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2z3i: // global
           I64[Sp - 8] = block_c2z33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z3m; else goto c2z34;
       u2z3m: // global
           call _c2z33(R1) args: 0, res: 0, upd: 0;
       c2z34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z33() //  [R1]
         { info_tbl: [(c2z33,
                       label: block_c2z33_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z33: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z3l; else goto c2z3k;
       c2z3l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z3k: // global
           (_c2z39::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2z39::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.914326945 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.914972116 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2z3r,
                       label: GHC.Word.$fBitsWord64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3r: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.915946454 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { info_tbl: [(c2z3B,
                       label: GHC.Word.eqWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z3F; else goto c2z3G;
       c2z3F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z3G: // global
           I64[Sp - 16] = block_c2z3y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z3P; else goto c2z3z;
       u2z3P: // global
           call _c2z3y(R1) args: 0, res: 0, upd: 0;
       c2z3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z3y() //  [R1]
         { info_tbl: [(c2z3y,
                       label: block_c2z3y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3y: // global
           I64[Sp] = block_c2z3E_info;
           _s2uZT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZT::I64;
           if (R1 & 7 != 0) goto u2z3O; else goto c2z3I;
       u2z3O: // global
           call _c2z3E(R1) args: 0, res: 0, upd: 0;
       c2z3I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z3E() //  [R1]
         { info_tbl: [(c2z3E,
                       label: block_c2z3E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3E: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.917198064 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.917810548 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.918666357 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { info_tbl: [(c2z3X,
                       label: GHC.Word.$fNumWord8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2z3Y; else goto c2z3Z;
       c2z3Y: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2z3Z: // global
           I64[Sp - 8] = block_c2z3U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z47; else goto c2z3V;
       u2z47: // global
           call _c2z3U(R1) args: 0, res: 0, upd: 0;
       c2z3V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z3U() //  [R1]
         { info_tbl: [(c2z3U,
                       label: block_c2z3U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z3U: // global
           if (I64[R1 + 7] == 0) goto c2z46; else goto c2z45;
       c2z46: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z45: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.919778123 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.920749818 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2z4f,
                       label: GHC.Word.$fBitsWord8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z4f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2z4m; else goto c2z4n;
       c2z4m: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2z4n: // global
           I64[Sp - 8] = block_c2z4c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z4r; else goto c2z4d;
       u2z4r: // global
           call _c2z4c(R1) args: 0, res: 0, upd: 0;
       c2z4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z4c() //  [R1]
         { info_tbl: [(c2z4c,
                       label: block_c2z4c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z4c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z4q; else goto c2z4p;
       c2z4q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z4p: // global
           _s2v04::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v04::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.922637188 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.923307086 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2z4w,
                       label: GHC.Word.$fBitsWord8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z4w: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.924338275 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { info_tbl: [(c2z4G,
                       label: GHC.Word.$fBitsWord8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z4G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2z4H; else goto c2z4I;
       c2z4H: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2z4I: // global
           I64[Sp - 8] = block_c2z4D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z51; else goto c2z4E;
       u2z51: // global
           call _c2z4D(R1) args: 0, res: 0, upd: 0;
       c2z4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z4D() //  [R1]
         { info_tbl: [(c2z4D,
                       label: block_c2z4D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z4D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z4N; else goto c2z4M;
       c2z4N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z4M: // global
           _s2v08::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v08::I64, 64)) goto c2z4Z; else goto c2z50;
       c2z4Z: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v08::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z50: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.926332843 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2z59,
                       label: GHC.Word.$fBitsWord8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z59: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z5d; else goto c2z5e;
       c2z5d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z5e: // global
           I64[Sp - 16] = block_c2z56_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z5N; else goto c2z57;
       u2z5N: // global
           call _c2z56(R1) args: 0, res: 0, upd: 0;
       c2z57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z56() //  [R1]
         { info_tbl: [(c2z56,
                       label: block_c2z56_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z56: // global
           I64[Sp] = block_c2z5c_info;
           _s2v0f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0f::I64;
           if (R1 & 7 != 0) goto u2z5M; else goto c2z5g;
       u2z5M: // global
           call _c2z5c(R1) args: 0, res: 0, upd: 0;
       c2z5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z5c() //  [R1]
         { info_tbl: [(c2z5c,
                       label: block_c2z5c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z5c: // global
           _s2v0h::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v0h::I64, 64)) goto c2z5L; else goto c2z5K;
       c2z5K: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0h::I64)) == 0) goto c2z5L; else goto c2z5z;
       c2z5L: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z5z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.928252079 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2z5V,
                       label: GHC.Word.$fBitsWord8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z5V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2z5Z; else goto c2z60;
       c2z5Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z60: // global
           I64[Sp - 16] = block_c2z5S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z6Q; else goto c2z5T;
       u2z6Q: // global
           call _c2z5S(R1) args: 0, res: 0, upd: 0;
       c2z5T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z5S() //  [R1]
         { info_tbl: [(c2z5S,
                       label: block_c2z5S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z5S: // global
           I64[Sp - 8] = block_c2z5Y_info;
           _s2v0o::P64 = R1;
           _s2v0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0p::I64;
           P64[Sp + 8] = _s2v0o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z6P; else goto c2z62;
       u2z6P: // global
           call _c2z5Y(R1) args: 0, res: 0, upd: 0;
       c2z62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z5Y() //  [R1]
         { info_tbl: [(c2z5Y,
                       label: block_c2z5Y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z5Y: // global
           _s2v0v::I64 = -I64[R1 + 7] & 7;
           if (_s2v0v::I64 != 0) goto u2z6N; else goto c2z6J;
       u2z6N: // global
           I64[Sp + 16] = _s2v0v::I64;
           Sp = Sp + 8;
           call _c2z6k() args: 0, res: 0, upd: 0;
       c2z6J: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2z6k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z6k: // global
           Hp = Hp + 16;
           _s2v0v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2z6G; else goto c2z6F;
       c2z6G: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2z6j_info;
           R1 = _s2v0v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2z6F: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2v0p::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2v0p::I64 << _s2v0v::I64) | (_s2v0p::I64 >> 8 - _s2v0v::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2z6j() //  [R1]
         { info_tbl: [(c2z6j,
                       label: block_c2z6j_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z6j: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2z6k() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.930079777 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2z6X,
                       label: GHC.Word.$fBitsWord8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z6X: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.931270126 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2z77,
                       label: GHC.Word.$fBitsWord8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z77: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2z7b; else goto c2z7c;
       c2z7b: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z7c: // global
           I64[Sp - 16] = block_c2z74_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z7C; else goto c2z75;
       u2z7C: // global
           call _c2z74(R1) args: 0, res: 0, upd: 0;
       c2z75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z74() //  [R1]
         { info_tbl: [(c2z74,
                       label: block_c2z74_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z74: // global
           I64[Sp - 8] = block_c2z7a_info;
           _s2v0D::P64 = R1;
           _s2v0E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0E::I64;
           P64[Sp + 8] = _s2v0D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z7B; else goto c2z7e;
       u2z7B: // global
           call _c2z7a(R1) args: 0, res: 0, upd: 0;
       c2z7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z7a() //  [R1]
         { info_tbl: [(c2z7a,
                       label: block_c2z7a_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z7a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z7k; else goto c2z7j;
       c2z7k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z7j: // global
           _s2v0G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0G::I64, 64)) goto c2z7z; else goto c2z7A;
       c2z7z: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0G::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z7A: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.93319324 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2z7K,
                       label: GHC.Word.$fBitsWord8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z7K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z7O; else goto c2z7P;
       c2z7O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z7P: // global
           I64[Sp - 16] = block_c2z7H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z8n; else goto c2z7I;
       u2z8n: // global
           call _c2z7H(R1) args: 0, res: 0, upd: 0;
       c2z7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z7H() //  [R1]
         { info_tbl: [(c2z7H,
                       label: block_c2z7H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z7H: // global
           I64[Sp] = block_c2z7N_info;
           _s2v0O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0O::I64;
           if (R1 & 7 != 0) goto u2z8m; else goto c2z7R;
       u2z8m: // global
           call _c2z7N(R1) args: 0, res: 0, upd: 0;
       c2z7R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z7N() //  [R1]
         { info_tbl: [(c2z7N,
                       label: block_c2z7N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z7N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z7X; else goto c2z7W;
       c2z7X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z7W: // global
           _s2v0O::I64 = I64[Sp + 8];
           _s2v0Q::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0Q::I64, 64)) goto c2z8f; else goto c2z8l;
       c2z8f: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0Q::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z8l: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.935174785 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2z8v,
                       label: GHC.Word.$fBitsWord8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z8v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2z8z; else goto c2z8A;
       c2z8z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z8A: // global
           I64[Sp - 16] = block_c2z8s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z90; else goto c2z8t;
       u2z90: // global
           call _c2z8s(R1) args: 0, res: 0, upd: 0;
       c2z8t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z8s() //  [R1]
         { info_tbl: [(c2z8s,
                       label: block_c2z8s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z8s: // global
           I64[Sp - 8] = block_c2z8y_info;
           _s2v0Z::P64 = R1;
           _s2v10::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v10::I64;
           P64[Sp + 8] = _s2v0Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2z8Z; else goto c2z8C;
       u2z8Z: // global
           call _c2z8y(R1) args: 0, res: 0, upd: 0;
       c2z8C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z8y() //  [R1]
         { info_tbl: [(c2z8y,
                       label: block_c2z8y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z8y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z8I; else goto c2z8H;
       c2z8I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z8H: // global
           _s2v12::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v12::I64, 64)) goto c2z8X; else goto c2z8Y;
       c2z8X: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v12::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z8Y: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.936704772 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.937509461 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.938562413 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2z98,
                       label: GHC.Word.$fIntegralWord8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z98: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z9c; else goto c2z9d;
       c2z9c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z9d: // global
           I64[Sp - 16] = block_c2z95_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2z9w; else goto c2z96;
       u2z9w: // global
           call _c2z95(R1) args: 0, res: 0, upd: 0;
       c2z96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z95() //  [R1]
         { info_tbl: [(c2z95,
                       label: block_c2z95_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z95: // global
           I64[Sp] = block_c2z9b_info;
           _s2v1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1a::I64;
           if (R1 & 7 != 0) goto u2z9v; else goto c2z9f;
       u2z9v: // global
           call _c2z9b(R1) args: 0, res: 0, upd: 0;
       c2z9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z9b() //  [R1]
         { info_tbl: [(c2z9b,
                       label: block_c2z9b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z9b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z9l; else goto c2z9k;
       c2z9l: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z9k: // global
           _s2v1d::I64 = I64[R1 + 7];
           if (_s2v1d::I64 != 0) goto c2z9t; else goto c2z9u;
       c2z9t: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v1d::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2z9u: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.941184156 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2z9E,
                       label: GHC.Word.$fIntegralWord8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z9E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2z9I; else goto c2z9J;
       c2z9I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2z9J: // global
           I64[Sp - 16] = block_c2z9B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2za2; else goto c2z9C;
       u2za2: // global
           call _c2z9B(R1) args: 0, res: 0, upd: 0;
       c2z9C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z9B() //  [R1]
         { info_tbl: [(c2z9B,
                       label: block_c2z9B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z9B: // global
           I64[Sp] = block_c2z9H_info;
           _s2v1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1i::I64;
           if (R1 & 7 != 0) goto u2za1; else goto c2z9L;
       u2za1: // global
           call _c2z9H(R1) args: 0, res: 0, upd: 0;
       c2z9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2z9H() //  [R1]
         { info_tbl: [(c2z9H,
                       label: block_c2z9H_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2z9H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2z9R; else goto c2z9Q;
       c2z9R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2z9Q: // global
           _s2v1l::I64 = I64[R1 + 7];
           if (_s2v1l::I64 != 0) goto c2z9Z; else goto c2za0;
       c2z9Z: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v1l::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2za0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.943054284 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2zaa,
                       label: GHC.Word.$fIntegralWord8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zaa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zae; else goto c2zaf;
       c2zae: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zaf: // global
           I64[Sp - 16] = block_c2za7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zax; else goto c2za8;
       u2zax: // global
           call _c2za7(R1) args: 0, res: 0, upd: 0;
       c2za8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2za7() //  [R1]
         { info_tbl: [(c2za7,
                       label: block_c2za7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2za7: // global
           I64[Sp] = block_c2zad_info;
           _s2v1q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1q::I64;
           if (R1 & 7 != 0) goto u2zaw; else goto c2zah;
       u2zaw: // global
           call _c2zad(R1) args: 0, res: 0, upd: 0;
       c2zah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zad() //  [R1]
         { info_tbl: [(c2zad,
                       label: block_c2zad_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zad: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2zan; else goto c2zam;
       c2zan: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zam: // global
           _s2v1t::I64 = I64[R1 + 7];
           if (_s2v1t::I64 != 0) goto c2zau; else goto c2zav;
       c2zau: // global
           (_s2v1v::I64, _s2v1w::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v1t::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2v1w::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2v1v::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zav: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.945349706 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2v1J_entry() //  [R1]
         { info_tbl: [(c2zaU,
                       label: sat_s2v1J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zaU: // global
           _s2v1J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zaX; else goto c2zaY;
       c2zaY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zb0; else goto c2zaZ;
       c2zb0: // global
           HpAlloc = 16;
           goto c2zaX;
       c2zaX: // global
           R1 = _s2v1J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zaZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1J::P64;
           _s2v1I::I64 = I64[_s2v1J::P64 + 16] % I64[_s2v1J::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1I::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v1H_entry() //  [R1]
         { info_tbl: [(c2zb7,
                       label: sat_s2v1H_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zb7: // global
           _s2v1H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zba; else goto c2zbb;
       c2zbb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zbd; else goto c2zbc;
       c2zbd: // global
           HpAlloc = 16;
           goto c2zba;
       c2zba: // global
           R1 = _s2v1H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zbc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1H::P64;
           _s2v1G::I64 = I64[_s2v1H::P64 + 16] / I64[_s2v1H::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1G::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2zbe,
                       label: GHC.Word.$fIntegralWord8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zbf; else goto c2zbg;
       c2zbf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zbg: // global
           I64[Sp - 16] = block_c2zaC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zbq; else goto c2zaD;
       u2zbq: // global
           call _c2zaC(R1) args: 0, res: 0, upd: 0;
       c2zaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zaC() //  [R1]
         { info_tbl: [(c2zaC,
                       label: block_c2zaC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zaC: // global
           I64[Sp] = block_c2zaH_info;
           _s2v1C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1C::I64;
           if (R1 & 7 != 0) goto u2zbp; else goto c2zaI;
       u2zbp: // global
           call _c2zaH(R1) args: 0, res: 0, upd: 0;
       c2zaI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zaH() //  [R1]
         { info_tbl: [(c2zaH,
                       label: block_c2zaH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zaH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2zbk; else goto c2zbj;
       c2zbk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zbj: // global
           _s2v1F::I64 = I64[R1 + 7];
           if (_s2v1F::I64 != 0) goto c2zbn; else goto c2zbo;
       c2zbn: // global
           I64[Hp - 80] = sat_s2v1J_info;
           _s2v1C::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v1C::I64;
           I64[Hp - 56] = _s2v1F::I64;
           I64[Hp - 48] = sat_s2v1H_info;
           I64[Hp - 32] = _s2v1C::I64;
           I64[Hp - 24] = _s2v1F::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zbo: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.947779267 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { info_tbl: [(c2zby,
                       label: GHC.Word.gtWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zby: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zbC; else goto c2zbD;
       c2zbC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zbD: // global
           I64[Sp - 16] = block_c2zbv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zbM; else goto c2zbw;
       u2zbM: // global
           call _c2zbv(R1) args: 0, res: 0, upd: 0;
       c2zbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zbv() //  [R1]
         { info_tbl: [(c2zbv,
                       label: block_c2zbv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbv: // global
           I64[Sp] = block_c2zbB_info;
           _s2v1N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1N::I64;
           if (R1 & 7 != 0) goto u2zbL; else goto c2zbF;
       u2zbL: // global
           call _c2zbB(R1) args: 0, res: 0, upd: 0;
       c2zbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zbB() //  [R1]
         { info_tbl: [(c2zbB,
                       label: block_c2zbB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbB: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.949643471 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { info_tbl: [(c2zbU,
                       label: GHC.Word.geWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zbY; else goto c2zbZ;
       c2zbY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zbZ: // global
           I64[Sp - 16] = block_c2zbR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zc8; else goto c2zbS;
       u2zc8: // global
           call _c2zbR(R1) args: 0, res: 0, upd: 0;
       c2zbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zbR() //  [R1]
         { info_tbl: [(c2zbR,
                       label: block_c2zbR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbR: // global
           I64[Sp] = block_c2zbX_info;
           _s2v1U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1U::I64;
           if (R1 & 7 != 0) goto u2zc7; else goto c2zc1;
       u2zc7: // global
           call _c2zbX(R1) args: 0, res: 0, upd: 0;
       c2zc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zbX() //  [R1]
         { info_tbl: [(c2zbX,
                       label: block_c2zbX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zbX: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.951135142 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { info_tbl: [(c2zcg,
                       label: GHC.Word.ltWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zck; else goto c2zcl;
       c2zck: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zcl: // global
           I64[Sp - 16] = block_c2zcd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zcu; else goto c2zce;
       u2zcu: // global
           call _c2zcd(R1) args: 0, res: 0, upd: 0;
       c2zce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zcd() //  [R1]
         { info_tbl: [(c2zcd,
                       label: block_c2zcd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcd: // global
           I64[Sp] = block_c2zcj_info;
           _s2v21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v21::I64;
           if (R1 & 7 != 0) goto u2zct; else goto c2zcn;
       u2zct: // global
           call _c2zcj(R1) args: 0, res: 0, upd: 0;
       c2zcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zcj() //  [R1]
         { info_tbl: [(c2zcj,
                       label: block_c2zcj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcj: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.952674392 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { info_tbl: [(c2zcC,
                       label: GHC.Word.leWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zcG; else goto c2zcH;
       c2zcG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zcH: // global
           I64[Sp - 16] = block_c2zcz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zcQ; else goto c2zcA;
       u2zcQ: // global
           call _c2zcz(R1) args: 0, res: 0, upd: 0;
       c2zcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zcz() //  [R1]
         { info_tbl: [(c2zcz,
                       label: block_c2zcz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcz: // global
           I64[Sp] = block_c2zcF_info;
           _s2v28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v28::I64;
           if (R1 & 7 != 0) goto u2zcP; else goto c2zcJ;
       u2zcP: // global
           call _c2zcF(R1) args: 0, res: 0, upd: 0;
       c2zcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zcF() //  [R1]
         { info_tbl: [(c2zcF,
                       label: block_c2zcF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcF: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.954309897 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2zcY,
                       label: GHC.Word.$fOrdWord8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zd2; else goto c2zd3;
       c2zd2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zd3: // global
           I64[Sp - 16] = block_c2zcV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zdm; else goto c2zcW;
       u2zdm: // global
           call _c2zcV(R1) args: 0, res: 0, upd: 0;
       c2zcW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zcV() //  [R1]
         { info_tbl: [(c2zcV,
                       label: block_c2zcV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zcV: // global
           I64[Sp] = block_c2zd1_info;
           _s2v2f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v2f::I64;
           if (R1 & 7 != 0) goto u2zdl; else goto c2zd5;
       u2zdl: // global
           call _c2zd1(R1) args: 0, res: 0, upd: 0;
       c2zd5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zd1() //  [R1]
         { info_tbl: [(c2zd1,
                       label: block_c2zd1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zd1: // global
           _s2v2f::I64 = I64[Sp + 8];
           _s2v2h::I64 = I64[R1 + 7];
           if (_s2v2f::I64 == _s2v2h::I64) goto c2zdk; else goto c2zdj;
       c2zdk: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zdj: // global
           if (_s2v2f::I64 > _s2v2h::I64) goto c2zdg; else goto c2zdh;
       c2zdg: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zdh: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.956094609 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2zdu,
                       label: GHC.Word.$fOrdWord8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zdy; else goto c2zdz;
       c2zdy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zdz: // global
           I64[Sp - 16] = block_c2zdr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zdM; else goto c2zds;
       u2zdM: // global
           call _c2zdr(R1) args: 0, res: 0, upd: 0;
       c2zds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zdr() //  [R1]
         { info_tbl: [(c2zdr,
                       label: block_c2zdr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdr: // global
           I64[Sp - 8] = block_c2zdx_info;
           _s2v2m::P64 = R1;
           _s2v2n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2n::I64;
           P64[Sp + 8] = _s2v2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zdL; else goto c2zdB;
       u2zdL: // global
           call _c2zdx(R1) args: 0, res: 0, upd: 0;
       c2zdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zdx() //  [R1]
         { info_tbl: [(c2zdx,
                       label: block_c2zdx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdx: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2zdJ; else goto c2zdK;
       c2zdJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zdK: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.958793657 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2zdU,
                       label: GHC.Word.$fOrdWord8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zdY; else goto c2zdZ;
       c2zdY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zdZ: // global
           I64[Sp - 16] = block_c2zdR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zec; else goto c2zdS;
       u2zec: // global
           call _c2zdR(R1) args: 0, res: 0, upd: 0;
       c2zdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zdR() //  [R1]
         { info_tbl: [(c2zdR,
                       label: block_c2zdR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdR: // global
           I64[Sp - 8] = block_c2zdX_info;
           _s2v2t::P64 = R1;
           _s2v2u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2u::I64;
           P64[Sp + 8] = _s2v2t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zeb; else goto c2ze1;
       u2zeb: // global
           call _c2zdX(R1) args: 0, res: 0, upd: 0;
       c2ze1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zdX() //  [R1]
         { info_tbl: [(c2zdX,
                       label: block_c2zdX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zdX: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2ze9; else goto c2zea;
       c2ze9: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zea: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.960091011 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.961220586 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2zek,
                       label: GHC.Word.$fIxWord8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zek: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zet; else goto c2zeu;
       c2zet: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zeu: // global
           I64[Sp - 16] = block_c2zeh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zeR; else goto c2zei;
       u2zeR: // global
           call _c2zeh(R1) args: 0, res: 0, upd: 0;
       c2zei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zeh() //  [R1]
         { info_tbl: [(c2zeh,
                       label: block_c2zeh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zeh: // global
           I64[Sp - 8] = block_c2zen_info;
           _s2v2C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zeQ; else goto c2zeo;
       u2zeQ: // global
           call _c2zen(R1) args: 0, res: 0, upd: 0;
       c2zeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zen() //  [R1]
         { info_tbl: [(c2zen,
                       label: block_c2zen_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zen: // global
           I64[Sp] = block_c2zes_info;
           _s2v2E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v2E::I64;
           if (R1 & 7 != 0) goto u2zeS; else goto c2zex;
       u2zeS: // global
           call _c2zes(R1) args: 0, res: 0, upd: 0;
       c2zex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zes() //  [R1]
         { info_tbl: [(c2zes,
                       label: block_c2zes_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zes: // global
           _s2v2G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v2G::I64) goto c2zeF; else goto c2zeJ;
       c2zeF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zeJ: // global
           _s2v2C::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2zeI_info;
           R1 = _s2v2C::P64;
           I64[Sp + 16] = _s2v2G::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2zeT; else goto c2zeK;
       u2zeT: // global
           call _c2zeI(R1) args: 0, res: 0, upd: 0;
       c2zeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zeI() //  [R1]
         { info_tbl: [(c2zeI,
                       label: block_c2zeI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zeI: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.963314068 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2zf1,
                       label: GHC.Word.$fRealWord8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zf1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zfi; else goto c2zfj;
       c2zfi: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zfj: // global
           I64[Sp - 8] = block_c2zeY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zfq; else goto c2zeZ;
       u2zfq: // global
           call _c2zeY(R1) args: 0, res: 0, upd: 0;
       c2zeZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zeY() //  [R1]
         { info_tbl: [(c2zeY,
                       label: block_c2zeY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zeY: // global
           I64[Sp] = block_c2zf7_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zf7() //  [R1]
         { info_tbl: [(c2zf7,
                       label: block_c2zf7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zf7: // global
           I64[Sp] = block_c2zfb_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zfb() //  [R1]
         { info_tbl: [(c2zfb,
                       label: block_c2zfb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zfb: // global
           I64[Sp] = block_c2zff_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zff() //  [R1, R2]
         { info_tbl: [(c2zff,
                       label: block_c2zff_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zff: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2zfp; else goto c2zfo;
       c2zfp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2zfo: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.964793769 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.965421961 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.966567767 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2zfy,
                       label: GHC.Word.$fIxWord8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zfy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zfV; else goto c2zfW;
       c2zfV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zfW: // global
           I64[Sp - 16] = block_c2zfv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zg3; else goto c2zfw;
       u2zg3: // global
           call _c2zfv(R1) args: 0, res: 0, upd: 0;
       c2zfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zfv() //  [R1]
         { info_tbl: [(c2zfv,
                       label: block_c2zfv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zfv: // global
           I64[Sp] = block_c2zfB_info;
           _s2v2X::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v2X::P64;
           if (R1 & 7 != 0) goto u2zg2; else goto c2zfC;
       u2zg2: // global
           call _c2zfB(R1) args: 0, res: 0, upd: 0;
       c2zfC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zfB() //  [R1]
         { info_tbl: [(c2zfB,
                       label: block_c2zfB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zfB: // global
           I64[Sp] = block_c2zfG_info;
           _s2v30::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v30::I64;
           if (R1 & 7 != 0) goto u2zg4; else goto c2zfH;
       u2zg4: // global
           call _c2zfG(R1) args: 0, res: 0, upd: 0;
       c2zfH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zfG() //  [R1]
         { info_tbl: [(c2zfG,
                       label: block_c2zfG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zfG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zg1; else goto c2zg0;
       c2zg1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zg0: // global
           _s2v35::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v35::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.96827083 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { info_tbl: [(c2zgc,
                       label: GHC.Word.$fIxWord8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zgc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zgd; else goto c2zge;
       c2zgd: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zge: // global
           I64[Sp - 8] = block_c2zg9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zgi; else goto c2zga;
       u2zgi: // global
           call _c2zg9(R1) args: 0, res: 0, upd: 0;
       c2zga: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zg9() //  [R1]
         { info_tbl: [(c2zg9,
                       label: block_c2zg9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zg9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.96935553 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.970503605 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2zgq,
                       label: GHC.Word.$fIxWord8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zgz; else goto c2zgA;
       c2zgz: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zgA: // global
           I64[Sp - 8] = block_c2zgn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zh5; else goto c2zgo;
       u2zh5: // global
           call _c2zgn(R1) args: 0, res: 0, upd: 0;
       c2zgo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zgn() //  [R1]
         { info_tbl: [(c2zgn,
                       label: block_c2zgn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zgn: // global
           I64[Sp - 8] = block_c2zgt_info;
           _s2v3d::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zh4; else goto c2zgu;
       u2zh4: // global
           call _c2zgt(R1) args: 0, res: 0, upd: 0;
       c2zgu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zgt() //  [R1]
         { info_tbl: [(c2zgt,
                       label: block_c2zgt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zgt: // global
           I64[Sp] = block_c2zgy_info;
           _s2v3f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3f::I64;
           if (R1 & 7 != 0) goto u2zh6; else goto c2zgD;
       u2zh6: // global
           call _c2zgy(R1) args: 0, res: 0, upd: 0;
       c2zgD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zgy() //  [R1]
         { info_tbl: [(c2zgy,
                       label: block_c2zgy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zgy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zgJ; else goto c2zgI;
       c2zgJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zgI: // global
           _s2v3f::I64 = I64[Sp + 8];
           _s2v3h::I64 = I64[R1 + 7];
           if (_s2v3f::I64 > _s2v3h::I64) goto c2zgN; else goto c2zh3;
       c2zgN: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zh3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3h::I64 - _s2v3f::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.972590694 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2zhe,
                       label: GHC.Word.$fIxWord8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zhE; else goto c2zhF;
       c2zhE: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zhF: // global
           I64[Sp - 8] = block_c2zhb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zhM; else goto c2zhc;
       u2zhM: // global
           call _c2zhb(R1) args: 0, res: 0, upd: 0;
       c2zhc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zhb() //  [R1]
         { info_tbl: [(c2zhb,
                       label: block_c2zhb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhb: // global
           I64[Sp - 8] = block_c2zhh_info;
           _s2v3p::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v3p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zhL; else goto c2zhi;
       u2zhL: // global
           call _c2zhh(R1) args: 0, res: 0, upd: 0;
       c2zhi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zhh() //  [R1]
         { info_tbl: [(c2zhh,
                       label: block_c2zhh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhh: // global
           I64[Sp] = block_c2zhm_info;
           _s2v3s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3s::I64;
           if (R1 & 7 != 0) goto u2zhN; else goto c2zhn;
       u2zhN: // global
           call _c2zhm(R1) args: 0, res: 0, upd: 0;
       c2zhn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zhm() //  [R1]
         { info_tbl: [(c2zhm,
                       label: block_c2zhm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zhK; else goto c2zhJ;
       c2zhK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zhJ: // global
           _s2v3y::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v3y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.975614695 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2zhV,
                       label: GHC.Word.$fIxWord8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zi4; else goto c2zi5;
       c2zi4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zi5: // global
           I64[Sp - 16] = block_c2zhS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ziK; else goto c2zhT;
       u2ziK: // global
           call _c2zhS(R1) args: 0, res: 0, upd: 0;
       c2zhT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zhS() //  [R1]
         { info_tbl: [(c2zhS,
                       label: block_c2zhS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhS: // global
           I64[Sp - 8] = block_c2zhY_info;
           _s2v3D::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ziJ; else goto c2zhZ;
       u2ziJ: // global
           call _c2zhY(R1) args: 0, res: 0, upd: 0;
       c2zhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zhY() //  [R1]
         { info_tbl: [(c2zhY,
                       label: block_c2zhY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zhY: // global
           I64[Sp] = block_c2zi3_info;
           _s2v3F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v3F::I64;
           if (R1 & 7 != 0) goto u2ziL; else goto c2zi8;
       u2ziL: // global
           call _c2zi3(R1) args: 0, res: 0, upd: 0;
       c2zi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zi3() //  [R1]
         { info_tbl: [(c2zi3,
                       label: block_c2zi3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zi3: // global
           _s2v3H::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v3H::I64) goto c2zig; else goto c2zik;
       c2zig: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zik: // global
           I64[Sp] = block_c2zij_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3H::I64;
           if (R1 & 7 != 0) goto u2ziM; else goto c2zil;
       u2ziM: // global
           call _c2zij(R1) args: 0, res: 0, upd: 0;
       c2zil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zij() //  [R1]
         { info_tbl: [(c2zij,
                       label: block_c2zij_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zij: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zir; else goto c2ziq;
       c2zir: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ziq: // global
           _s2v3H::I64 = I64[Sp + 8];
           if (_s2v3H::I64 > I64[R1 + 7]) goto c2ziv; else goto c2ziI;
       c2ziv: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2ziI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3H::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.977742688 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.978697566 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { info_tbl: [(c2ziU,
                       label: GHC.Word.eqWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ziU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ziY; else goto c2ziZ;
       c2ziY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ziZ: // global
           I64[Sp - 16] = block_c2ziR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zj8; else goto c2ziS;
       u2zj8: // global
           call _c2ziR(R1) args: 0, res: 0, upd: 0;
       c2ziS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ziR() //  [R1]
         { info_tbl: [(c2ziR,
                       label: block_c2ziR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ziR: // global
           I64[Sp] = block_c2ziX_info;
           _s2v3S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3S::I64;
           if (R1 & 7 != 0) goto u2zj7; else goto c2zj1;
       u2zj7: // global
           call _c2ziX(R1) args: 0, res: 0, upd: 0;
       c2zj1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ziX() //  [R1]
         { info_tbl: [(c2ziX,
                       label: block_c2ziX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ziX: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.979903078 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.980512758 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.981436036 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { info_tbl: [(c2zjg,
                       label: GHC.Word.$fNumWord16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zjh; else goto c2zji;
       c2zjh: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zji: // global
           I64[Sp - 8] = block_c2zjd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zjq; else goto c2zje;
       u2zjq: // global
           call _c2zjd(R1) args: 0, res: 0, upd: 0;
       c2zje: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zjd() //  [R1]
         { info_tbl: [(c2zjd,
                       label: block_c2zjd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjd: // global
           if (I64[R1 + 7] == 0) goto c2zjp; else goto c2zjo;
       c2zjp: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zjo: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.982606737 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.983522738 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2zjy,
                       label: GHC.Word.$fBitsWord16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zjF; else goto c2zjG;
       c2zjF: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zjG: // global
           I64[Sp - 8] = block_c2zjv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zjK; else goto c2zjw;
       u2zjK: // global
           call _c2zjv(R1) args: 0, res: 0, upd: 0;
       c2zjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zjv() //  [R1]
         { info_tbl: [(c2zjv,
                       label: block_c2zjv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zjJ; else goto c2zjI;
       c2zjJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zjI: // global
           _s2v43::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v43::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.984626817 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.985357872 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2zjP,
                       label: GHC.Word.$fBitsWord16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjP: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.986470552 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { info_tbl: [(c2zjZ,
                       label: GHC.Word.$fBitsWord16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zk0; else goto c2zk1;
       c2zk0: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zk1: // global
           I64[Sp - 8] = block_c2zjW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zkk; else goto c2zjX;
       u2zkk: // global
           call _c2zjW(R1) args: 0, res: 0, upd: 0;
       c2zjX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zjW() //  [R1]
         { info_tbl: [(c2zjW,
                       label: block_c2zjW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zjW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zk6; else goto c2zk5;
       c2zk6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zk5: // global
           _s2v47::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v47::I64, 64)) goto c2zki; else goto c2zkj;
       c2zki: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v47::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zkj: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.988127064 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2zks,
                       label: GHC.Word.$fBitsWord16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zks: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zkw; else goto c2zkx;
       c2zkw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zkx: // global
           I64[Sp - 16] = block_c2zkp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zl6; else goto c2zkq;
       u2zl6: // global
           call _c2zkp(R1) args: 0, res: 0, upd: 0;
       c2zkq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zkp() //  [R1]
         { info_tbl: [(c2zkp,
                       label: block_c2zkp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zkp: // global
           I64[Sp] = block_c2zkv_info;
           _s2v4e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4e::I64;
           if (R1 & 7 != 0) goto u2zl5; else goto c2zkz;
       u2zl5: // global
           call _c2zkv(R1) args: 0, res: 0, upd: 0;
       c2zkz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zkv() //  [R1]
         { info_tbl: [(c2zkv,
                       label: block_c2zkv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zkv: // global
           _s2v4g::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v4g::I64, 64)) goto c2zl4; else goto c2zl3;
       c2zl3: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4g::I64)) == 0) goto c2zl4; else goto c2zkS;
       c2zl4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zkS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.99018271 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2zle,
                       label: GHC.Word.$fBitsWord16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zle: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zli; else goto c2zlj;
       c2zli: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zlj: // global
           I64[Sp - 16] = block_c2zlb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zm9; else goto c2zlc;
       u2zm9: // global
           call _c2zlb(R1) args: 0, res: 0, upd: 0;
       c2zlc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zlb() //  [R1]
         { info_tbl: [(c2zlb,
                       label: block_c2zlb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zlb: // global
           I64[Sp - 8] = block_c2zlh_info;
           _s2v4n::P64 = R1;
           _s2v4o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4o::I64;
           P64[Sp + 8] = _s2v4n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zm8; else goto c2zll;
       u2zm8: // global
           call _c2zlh(R1) args: 0, res: 0, upd: 0;
       c2zll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zlh() //  [R1]
         { info_tbl: [(c2zlh,
                       label: block_c2zlh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zlh: // global
           _s2v4u::I64 = -I64[R1 + 7] & 15;
           if (_s2v4u::I64 != 0) goto u2zm6; else goto c2zm2;
       u2zm6: // global
           I64[Sp + 16] = _s2v4u::I64;
           Sp = Sp + 8;
           call _c2zlD() args: 0, res: 0, upd: 0;
       c2zm2: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zlD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zlD: // global
           Hp = Hp + 16;
           _s2v4u::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2zlZ; else goto c2zlY;
       c2zlZ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2zlC_info;
           R1 = _s2v4u::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2zlY: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2v4o::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2v4o::I64 << _s2v4u::I64) | (_s2v4o::I64 >> 16 - _s2v4u::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zlC() //  [R1]
         { info_tbl: [(c2zlC,
                       label: block_c2zlC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zlC: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2zlD() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.992763333 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2zmg,
                       label: GHC.Word.$fBitsWord16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zmg: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.994027006 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2zmq,
                       label: GHC.Word.$fBitsWord16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zmq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zmu; else goto c2zmv;
       c2zmu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zmv: // global
           I64[Sp - 16] = block_c2zmn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zmV; else goto c2zmo;
       u2zmV: // global
           call _c2zmn(R1) args: 0, res: 0, upd: 0;
       c2zmo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zmn() //  [R1]
         { info_tbl: [(c2zmn,
                       label: block_c2zmn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zmn: // global
           I64[Sp - 8] = block_c2zmt_info;
           _s2v4C::P64 = R1;
           _s2v4D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4D::I64;
           P64[Sp + 8] = _s2v4C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zmU; else goto c2zmx;
       u2zmU: // global
           call _c2zmt(R1) args: 0, res: 0, upd: 0;
       c2zmx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zmt() //  [R1]
         { info_tbl: [(c2zmt,
                       label: block_c2zmt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zmt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zmD; else goto c2zmC;
       c2zmD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zmC: // global
           _s2v4F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4F::I64, 64)) goto c2zmS; else goto c2zmT;
       c2zmS: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zmT: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.995939994 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2zn3,
                       label: GHC.Word.$fBitsWord16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zn7; else goto c2zn8;
       c2zn7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zn8: // global
           I64[Sp - 16] = block_c2zn0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2znG; else goto c2zn1;
       u2znG: // global
           call _c2zn0(R1) args: 0, res: 0, upd: 0;
       c2zn1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zn0() //  [R1]
         { info_tbl: [(c2zn0,
                       label: block_c2zn0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zn0: // global
           I64[Sp] = block_c2zn6_info;
           _s2v4N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4N::I64;
           if (R1 & 7 != 0) goto u2znF; else goto c2zna;
       u2znF: // global
           call _c2zn6(R1) args: 0, res: 0, upd: 0;
       c2zna: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zn6() //  [R1]
         { info_tbl: [(c2zn6,
                       label: block_c2zn6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zn6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zng; else goto c2znf;
       c2zng: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2znf: // global
           _s2v4N::I64 = I64[Sp + 8];
           _s2v4P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4P::I64, 64)) goto c2zny; else goto c2znE;
       c2zny: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4P::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2znE: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.997913607 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2znO,
                       label: GHC.Word.$fBitsWord16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2znO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2znS; else goto c2znT;
       c2znS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2znT: // global
           I64[Sp - 16] = block_c2znL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zoj; else goto c2znM;
       u2zoj: // global
           call _c2znL(R1) args: 0, res: 0, upd: 0;
       c2znM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2znL() //  [R1]
         { info_tbl: [(c2znL,
                       label: block_c2znL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2znL: // global
           I64[Sp - 8] = block_c2znR_info;
           _s2v4Y::P64 = R1;
           _s2v4Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4Z::I64;
           P64[Sp + 8] = _s2v4Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zoi; else goto c2znV;
       u2zoi: // global
           call _c2znR(R1) args: 0, res: 0, upd: 0;
       c2znV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2znR() //  [R1]
         { info_tbl: [(c2znR,
                       label: block_c2znR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2znR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zo1; else goto c2zo0;
       c2zo1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zo0: // global
           _s2v51::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v51::I64, 64)) goto c2zog; else goto c2zoh;
       c2zog: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v51::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zoh: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:10.999440233 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.000161535 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.001187559 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2zor,
                       label: GHC.Word.$fIntegralWord16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zor: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zov; else goto c2zow;
       c2zov: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zow: // global
           I64[Sp - 16] = block_c2zoo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zoP; else goto c2zop;
       u2zoP: // global
           call _c2zoo(R1) args: 0, res: 0, upd: 0;
       c2zop: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zoo() //  [R1]
         { info_tbl: [(c2zoo,
                       label: block_c2zoo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zoo: // global
           I64[Sp] = block_c2zou_info;
           _s2v59::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v59::I64;
           if (R1 & 7 != 0) goto u2zoO; else goto c2zoy;
       u2zoO: // global
           call _c2zou(R1) args: 0, res: 0, upd: 0;
       c2zoy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zou() //  [R1]
         { info_tbl: [(c2zou,
                       label: block_c2zou_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zoE; else goto c2zoD;
       c2zoE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zoD: // global
           _s2v5c::I64 = I64[R1 + 7];
           if (_s2v5c::I64 != 0) goto c2zoM; else goto c2zoN;
       c2zoM: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v5c::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zoN: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.003098134 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2zoX,
                       label: GHC.Word.$fIntegralWord16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zoX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zp1; else goto c2zp2;
       c2zp1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zp2: // global
           I64[Sp - 16] = block_c2zoU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zpl; else goto c2zoV;
       u2zpl: // global
           call _c2zoU(R1) args: 0, res: 0, upd: 0;
       c2zoV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zoU() //  [R1]
         { info_tbl: [(c2zoU,
                       label: block_c2zoU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zoU: // global
           I64[Sp] = block_c2zp0_info;
           _s2v5h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5h::I64;
           if (R1 & 7 != 0) goto u2zpk; else goto c2zp4;
       u2zpk: // global
           call _c2zp0(R1) args: 0, res: 0, upd: 0;
       c2zp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zp0() //  [R1]
         { info_tbl: [(c2zp0,
                       label: block_c2zp0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zp0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zpa; else goto c2zp9;
       c2zpa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zp9: // global
           _s2v5k::I64 = I64[R1 + 7];
           if (_s2v5k::I64 != 0) goto c2zpi; else goto c2zpj;
       c2zpi: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v5k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zpj: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.004988789 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2zpt,
                       label: GHC.Word.$fIntegralWord16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zpt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zpx; else goto c2zpy;
       c2zpx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zpy: // global
           I64[Sp - 16] = block_c2zpq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zpQ; else goto c2zpr;
       u2zpQ: // global
           call _c2zpq(R1) args: 0, res: 0, upd: 0;
       c2zpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zpq() //  [R1]
         { info_tbl: [(c2zpq,
                       label: block_c2zpq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zpq: // global
           I64[Sp] = block_c2zpw_info;
           _s2v5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5p::I64;
           if (R1 & 7 != 0) goto u2zpP; else goto c2zpA;
       u2zpP: // global
           call _c2zpw(R1) args: 0, res: 0, upd: 0;
       c2zpA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zpw() //  [R1]
         { info_tbl: [(c2zpw,
                       label: block_c2zpw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zpw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2zpG; else goto c2zpF;
       c2zpG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zpF: // global
           _s2v5s::I64 = I64[R1 + 7];
           if (_s2v5s::I64 != 0) goto c2zpN; else goto c2zpO;
       c2zpN: // global
           (_s2v5u::I64, _s2v5v::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v5s::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2v5v::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2v5u::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zpO: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.007934978 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2v5I_entry() //  [R1]
         { info_tbl: [(c2zqd,
                       label: sat_s2v5I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqd: // global
           _s2v5I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zqg; else goto c2zqh;
       c2zqh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zqj; else goto c2zqi;
       c2zqj: // global
           HpAlloc = 16;
           goto c2zqg;
       c2zqg: // global
           R1 = _s2v5I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zqi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5I::P64;
           _s2v5H::I64 = I64[_s2v5I::P64 + 16] % I64[_s2v5I::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5H::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v5G_entry() //  [R1]
         { info_tbl: [(c2zqq,
                       label: sat_s2v5G_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqq: // global
           _s2v5G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zqt; else goto c2zqu;
       c2zqu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zqw; else goto c2zqv;
       c2zqw: // global
           HpAlloc = 16;
           goto c2zqt;
       c2zqt: // global
           R1 = _s2v5G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5G::P64;
           _s2v5F::I64 = I64[_s2v5G::P64 + 16] / I64[_s2v5G::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5F::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2zqx,
                       label: GHC.Word.$fIntegralWord16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zqy; else goto c2zqz;
       c2zqy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zqz: // global
           I64[Sp - 16] = block_c2zpV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zqJ; else goto c2zpW;
       u2zqJ: // global
           call _c2zpV(R1) args: 0, res: 0, upd: 0;
       c2zpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zpV() //  [R1]
         { info_tbl: [(c2zpV,
                       label: block_c2zpV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zpV: // global
           I64[Sp] = block_c2zq0_info;
           _s2v5B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5B::I64;
           if (R1 & 7 != 0) goto u2zqI; else goto c2zq1;
       u2zqI: // global
           call _c2zq0(R1) args: 0, res: 0, upd: 0;
       c2zq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zq0() //  [R1]
         { info_tbl: [(c2zq0,
                       label: block_c2zq0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zq0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2zqD; else goto c2zqC;
       c2zqD: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zqC: // global
           _s2v5E::I64 = I64[R1 + 7];
           if (_s2v5E::I64 != 0) goto c2zqG; else goto c2zqH;
       c2zqG: // global
           I64[Hp - 80] = sat_s2v5I_info;
           _s2v5B::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v5B::I64;
           I64[Hp - 56] = _s2v5E::I64;
           I64[Hp - 48] = sat_s2v5G_info;
           I64[Hp - 32] = _s2v5B::I64;
           I64[Hp - 24] = _s2v5E::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zqH: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.011442778 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { info_tbl: [(c2zqR,
                       label: GHC.Word.gtWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zqV; else goto c2zqW;
       c2zqV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zqW: // global
           I64[Sp - 16] = block_c2zqO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zr5; else goto c2zqP;
       u2zr5: // global
           call _c2zqO(R1) args: 0, res: 0, upd: 0;
       c2zqP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zqO() //  [R1]
         { info_tbl: [(c2zqO,
                       label: block_c2zqO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqO: // global
           I64[Sp] = block_c2zqU_info;
           _s2v5M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5M::I64;
           if (R1 & 7 != 0) goto u2zr4; else goto c2zqY;
       u2zr4: // global
           call _c2zqU(R1) args: 0, res: 0, upd: 0;
       c2zqY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zqU() //  [R1]
         { info_tbl: [(c2zqU,
                       label: block_c2zqU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zqU: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.012978698 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { info_tbl: [(c2zrd,
                       label: GHC.Word.geWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zrh; else goto c2zri;
       c2zrh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zri: // global
           I64[Sp - 16] = block_c2zra_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zrr; else goto c2zrb;
       u2zrr: // global
           call _c2zra(R1) args: 0, res: 0, upd: 0;
       c2zrb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zra() //  [R1]
         { info_tbl: [(c2zra,
                       label: block_c2zra_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zra: // global
           I64[Sp] = block_c2zrg_info;
           _s2v5T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5T::I64;
           if (R1 & 7 != 0) goto u2zrq; else goto c2zrk;
       u2zrq: // global
           call _c2zrg(R1) args: 0, res: 0, upd: 0;
       c2zrk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zrg() //  [R1]
         { info_tbl: [(c2zrg,
                       label: block_c2zrg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrg: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.014503297 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { info_tbl: [(c2zrz,
                       label: GHC.Word.ltWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zrD; else goto c2zrE;
       c2zrD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zrE: // global
           I64[Sp - 16] = block_c2zrw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zrN; else goto c2zrx;
       u2zrN: // global
           call _c2zrw(R1) args: 0, res: 0, upd: 0;
       c2zrx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zrw() //  [R1]
         { info_tbl: [(c2zrw,
                       label: block_c2zrw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrw: // global
           I64[Sp] = block_c2zrC_info;
           _s2v60::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v60::I64;
           if (R1 & 7 != 0) goto u2zrM; else goto c2zrG;
       u2zrM: // global
           call _c2zrC(R1) args: 0, res: 0, upd: 0;
       c2zrG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zrC() //  [R1]
         { info_tbl: [(c2zrC,
                       label: block_c2zrC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrC: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.015977292 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { info_tbl: [(c2zrV,
                       label: GHC.Word.leWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zrZ; else goto c2zs0;
       c2zrZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zs0: // global
           I64[Sp - 16] = block_c2zrS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zs9; else goto c2zrT;
       u2zs9: // global
           call _c2zrS(R1) args: 0, res: 0, upd: 0;
       c2zrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zrS() //  [R1]
         { info_tbl: [(c2zrS,
                       label: block_c2zrS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrS: // global
           I64[Sp] = block_c2zrY_info;
           _s2v67::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v67::I64;
           if (R1 & 7 != 0) goto u2zs8; else goto c2zs2;
       u2zs8: // global
           call _c2zrY(R1) args: 0, res: 0, upd: 0;
       c2zs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zrY() //  [R1]
         { info_tbl: [(c2zrY,
                       label: block_c2zrY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zrY: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.017623515 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2zsh,
                       label: GHC.Word.$fOrdWord16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zsh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zsl; else goto c2zsm;
       c2zsl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zsm: // global
           I64[Sp - 16] = block_c2zse_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zsF; else goto c2zsf;
       u2zsF: // global
           call _c2zse(R1) args: 0, res: 0, upd: 0;
       c2zsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zse() //  [R1]
         { info_tbl: [(c2zse,
                       label: block_c2zse_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zse: // global
           I64[Sp] = block_c2zsk_info;
           _s2v6e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6e::I64;
           if (R1 & 7 != 0) goto u2zsE; else goto c2zso;
       u2zsE: // global
           call _c2zsk(R1) args: 0, res: 0, upd: 0;
       c2zso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zsk() //  [R1]
         { info_tbl: [(c2zsk,
                       label: block_c2zsk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zsk: // global
           _s2v6e::I64 = I64[Sp + 8];
           _s2v6g::I64 = I64[R1 + 7];
           if (_s2v6e::I64 == _s2v6g::I64) goto c2zsD; else goto c2zsC;
       c2zsD: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zsC: // global
           if (_s2v6e::I64 > _s2v6g::I64) goto c2zsz; else goto c2zsA;
       c2zsz: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zsA: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.019335851 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2zsN,
                       label: GHC.Word.$fOrdWord16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zsN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zsR; else goto c2zsS;
       c2zsR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zsS: // global
           I64[Sp - 16] = block_c2zsK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zt5; else goto c2zsL;
       u2zt5: // global
           call _c2zsK(R1) args: 0, res: 0, upd: 0;
       c2zsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zsK() //  [R1]
         { info_tbl: [(c2zsK,
                       label: block_c2zsK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zsK: // global
           I64[Sp - 8] = block_c2zsQ_info;
           _s2v6l::P64 = R1;
           _s2v6m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6m::I64;
           P64[Sp + 8] = _s2v6l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zt4; else goto c2zsU;
       u2zt4: // global
           call _c2zsQ(R1) args: 0, res: 0, upd: 0;
       c2zsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zsQ() //  [R1]
         { info_tbl: [(c2zsQ,
                       label: block_c2zsQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zsQ: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2zt2; else goto c2zt3;
       c2zt2: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zt3: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.021008006 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2ztd,
                       label: GHC.Word.$fOrdWord16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zth; else goto c2zti;
       c2zth: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zti: // global
           I64[Sp - 16] = block_c2zta_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ztv; else goto c2ztb;
       u2ztv: // global
           call _c2zta(R1) args: 0, res: 0, upd: 0;
       c2ztb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zta() //  [R1]
         { info_tbl: [(c2zta,
                       label: block_c2zta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zta: // global
           I64[Sp - 8] = block_c2ztg_info;
           _s2v6s::P64 = R1;
           _s2v6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6t::I64;
           P64[Sp + 8] = _s2v6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ztu; else goto c2ztk;
       u2ztu: // global
           call _c2ztg(R1) args: 0, res: 0, upd: 0;
       c2ztk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ztg() //  [R1]
         { info_tbl: [(c2ztg,
                       label: block_c2ztg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztg: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2zts; else goto c2ztt;
       c2zts: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2ztt: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.022677199 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.023882621 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2ztD,
                       label: GHC.Word.$fIxWord16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ztM; else goto c2ztN;
       c2ztM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ztN: // global
           I64[Sp - 16] = block_c2ztA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zua; else goto c2ztB;
       u2zua: // global
           call _c2ztA(R1) args: 0, res: 0, upd: 0;
       c2ztB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ztA() //  [R1]
         { info_tbl: [(c2ztA,
                       label: block_c2ztA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztA: // global
           I64[Sp - 8] = block_c2ztG_info;
           _s2v6B::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v6B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zu9; else goto c2ztH;
       u2zu9: // global
           call _c2ztG(R1) args: 0, res: 0, upd: 0;
       c2ztH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ztG() //  [R1]
         { info_tbl: [(c2ztG,
                       label: block_c2ztG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztG: // global
           I64[Sp] = block_c2ztL_info;
           _s2v6D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v6D::I64;
           if (R1 & 7 != 0) goto u2zub; else goto c2ztQ;
       u2zub: // global
           call _c2ztL(R1) args: 0, res: 0, upd: 0;
       c2ztQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ztL() //  [R1]
         { info_tbl: [(c2ztL,
                       label: block_c2ztL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ztL: // global
           _s2v6F::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v6F::I64) goto c2ztY; else goto c2zu2;
       c2ztY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zu2: // global
           _s2v6B::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2zu1_info;
           R1 = _s2v6B::P64;
           I64[Sp + 16] = _s2v6F::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2zuc; else goto c2zu3;
       u2zuc: // global
           call _c2zu1(R1) args: 0, res: 0, upd: 0;
       c2zu3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zu1() //  [R1]
         { info_tbl: [(c2zu1,
                       label: block_c2zu1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zu1: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.027142187 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2zuk,
                       label: GHC.Word.$fRealWord16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zuB; else goto c2zuC;
       c2zuB: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zuC: // global
           I64[Sp - 8] = block_c2zuh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zuJ; else goto c2zui;
       u2zuJ: // global
           call _c2zuh(R1) args: 0, res: 0, upd: 0;
       c2zui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuh() //  [R1]
         { info_tbl: [(c2zuh,
                       label: block_c2zuh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuh: // global
           I64[Sp] = block_c2zuq_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuq() //  [R1]
         { info_tbl: [(c2zuq,
                       label: block_c2zuq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuq: // global
           I64[Sp] = block_c2zuu_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuu() //  [R1]
         { info_tbl: [(c2zuu,
                       label: block_c2zuu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuu: // global
           I64[Sp] = block_c2zuy_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuy() //  [R1, R2]
         { info_tbl: [(c2zuy,
                       label: block_c2zuy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2zuI; else goto c2zuH;
       c2zuI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2zuH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.028634085 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.029201593 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.030356774 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2zuR,
                       label: GHC.Word.$fIxWord16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zve; else goto c2zvf;
       c2zve: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zvf: // global
           I64[Sp - 16] = block_c2zuO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zvm; else goto c2zuP;
       u2zvm: // global
           call _c2zuO(R1) args: 0, res: 0, upd: 0;
       c2zuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuO() //  [R1]
         { info_tbl: [(c2zuO,
                       label: block_c2zuO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuO: // global
           I64[Sp] = block_c2zuU_info;
           _s2v6W::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v6W::P64;
           if (R1 & 7 != 0) goto u2zvl; else goto c2zuV;
       u2zvl: // global
           call _c2zuU(R1) args: 0, res: 0, upd: 0;
       c2zuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuU() //  [R1]
         { info_tbl: [(c2zuU,
                       label: block_c2zuU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuU: // global
           I64[Sp] = block_c2zuZ_info;
           _s2v6Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6Z::I64;
           if (R1 & 7 != 0) goto u2zvn; else goto c2zv0;
       u2zvn: // global
           call _c2zuZ(R1) args: 0, res: 0, upd: 0;
       c2zv0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zuZ() //  [R1]
         { info_tbl: [(c2zuZ,
                       label: block_c2zuZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zuZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zvk; else goto c2zvj;
       c2zvk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zvj: // global
           _s2v74::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v74::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.032083197 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { info_tbl: [(c2zvv,
                       label: GHC.Word.$fIxWord16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zvw; else goto c2zvx;
       c2zvw: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zvx: // global
           I64[Sp - 8] = block_c2zvs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zvB; else goto c2zvt;
       u2zvB: // global
           call _c2zvs(R1) args: 0, res: 0, upd: 0;
       c2zvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zvs() //  [R1]
         { info_tbl: [(c2zvs,
                       label: block_c2zvs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvs: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.033644915 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2zvJ,
                       label: GHC.Word.$fIxWord16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zvS; else goto c2zvT;
       c2zvS: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zvT: // global
           I64[Sp - 8] = block_c2zvG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zwo; else goto c2zvH;
       u2zwo: // global
           call _c2zvG(R1) args: 0, res: 0, upd: 0;
       c2zvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zvG() //  [R1]
         { info_tbl: [(c2zvG,
                       label: block_c2zvG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvG: // global
           I64[Sp - 8] = block_c2zvM_info;
           _s2v7c::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7c::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zwn; else goto c2zvN;
       u2zwn: // global
           call _c2zvM(R1) args: 0, res: 0, upd: 0;
       c2zvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zvM() //  [R1]
         { info_tbl: [(c2zvM,
                       label: block_c2zvM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvM: // global
           I64[Sp] = block_c2zvR_info;
           _s2v7e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7e::I64;
           if (R1 & 7 != 0) goto u2zwp; else goto c2zvW;
       u2zwp: // global
           call _c2zvR(R1) args: 0, res: 0, upd: 0;
       c2zvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zvR() //  [R1]
         { info_tbl: [(c2zvR,
                       label: block_c2zvR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zvR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zw2; else goto c2zw1;
       c2zw2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zw1: // global
           _s2v7e::I64 = I64[Sp + 8];
           _s2v7g::I64 = I64[R1 + 7];
           if (_s2v7e::I64 > _s2v7g::I64) goto c2zw6; else goto c2zwm;
       c2zw6: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zwm: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7g::I64 - _s2v7e::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.035617864 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2zwx,
                       label: GHC.Word.$fIxWord16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zwX; else goto c2zwY;
       c2zwX: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zwY: // global
           I64[Sp - 8] = block_c2zwu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zx5; else goto c2zwv;
       u2zx5: // global
           call _c2zwu(R1) args: 0, res: 0, upd: 0;
       c2zwv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zwu() //  [R1]
         { info_tbl: [(c2zwu,
                       label: block_c2zwu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zwu: // global
           I64[Sp - 8] = block_c2zwA_info;
           _s2v7o::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v7o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zx4; else goto c2zwB;
       u2zx4: // global
           call _c2zwA(R1) args: 0, res: 0, upd: 0;
       c2zwB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zwA() //  [R1]
         { info_tbl: [(c2zwA,
                       label: block_c2zwA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zwA: // global
           I64[Sp] = block_c2zwF_info;
           _s2v7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7r::I64;
           if (R1 & 7 != 0) goto u2zx6; else goto c2zwG;
       u2zx6: // global
           call _c2zwF(R1) args: 0, res: 0, upd: 0;
       c2zwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zwF() //  [R1]
         { info_tbl: [(c2zwF,
                       label: block_c2zwF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zwF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zx3; else goto c2zx2;
       c2zx3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zx2: // global
           _s2v7x::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v7x::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.037734738 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2zxe,
                       label: GHC.Word.$fIxWord16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zxe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zxn; else goto c2zxo;
       c2zxn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zxo: // global
           I64[Sp - 16] = block_c2zxb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zy3; else goto c2zxc;
       u2zy3: // global
           call _c2zxb(R1) args: 0, res: 0, upd: 0;
       c2zxc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zxb() //  [R1]
         { info_tbl: [(c2zxb,
                       label: block_c2zxb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zxb: // global
           I64[Sp - 8] = block_c2zxh_info;
           _s2v7C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zy2; else goto c2zxi;
       u2zy2: // global
           call _c2zxh(R1) args: 0, res: 0, upd: 0;
       c2zxi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zxh() //  [R1]
         { info_tbl: [(c2zxh,
                       label: block_c2zxh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zxh: // global
           I64[Sp] = block_c2zxm_info;
           _s2v7E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v7E::I64;
           if (R1 & 7 != 0) goto u2zy4; else goto c2zxr;
       u2zy4: // global
           call _c2zxm(R1) args: 0, res: 0, upd: 0;
       c2zxr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zxm() //  [R1]
         { info_tbl: [(c2zxm,
                       label: block_c2zxm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zxm: // global
           _s2v7G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v7G::I64) goto c2zxz; else goto c2zxD;
       c2zxz: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zxD: // global
           I64[Sp] = block_c2zxC_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7G::I64;
           if (R1 & 7 != 0) goto u2zy5; else goto c2zxE;
       u2zy5: // global
           call _c2zxC(R1) args: 0, res: 0, upd: 0;
       c2zxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zxC() //  [R1]
         { info_tbl: [(c2zxC,
                       label: block_c2zxC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zxC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zxK; else goto c2zxJ;
       c2zxK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zxJ: // global
           _s2v7G::I64 = I64[Sp + 8];
           if (_s2v7G::I64 > I64[R1 + 7]) goto c2zxO; else goto c2zy1;
       c2zxO: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zy1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7G::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.039640209 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.040597733 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { info_tbl: [(c2zyd,
                       label: GHC.Word.byteSwap16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zyo; else goto c2zyp;
       c2zyo: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zyp: // global
           I64[Sp - 8] = block_c2zya_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zyt; else goto c2zyb;
       u2zyt: // global
           call _c2zya(R1) args: 0, res: 0, upd: 0;
       c2zyb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zya() //  [R1]
         { info_tbl: [(c2zya,
                       label: block_c2zya_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zya: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zys; else goto c2zyr;
       c2zys: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zyr: // global
           (_c2zyg::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2zyg::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.042135675 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { info_tbl: [(c2zyB,
                       label: GHC.Word.eqWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zyF; else goto c2zyG;
       c2zyF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zyG: // global
           I64[Sp - 16] = block_c2zyy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zyP; else goto c2zyz;
       u2zyP: // global
           call _c2zyy(R1) args: 0, res: 0, upd: 0;
       c2zyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zyy() //  [R1]
         { info_tbl: [(c2zyy,
                       label: block_c2zyy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyy: // global
           I64[Sp] = block_c2zyE_info;
           _s2v7W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7W::I64;
           if (R1 & 7 != 0) goto u2zyO; else goto c2zyI;
       u2zyO: // global
           call _c2zyE(R1) args: 0, res: 0, upd: 0;
       c2zyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zyE() //  [R1]
         { info_tbl: [(c2zyE,
                       label: block_c2zyE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyE: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.044265063 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.044869587 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.04573321 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { info_tbl: [(c2zyX,
                       label: GHC.Word.$fNumWord32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zyY; else goto c2zyZ;
       c2zyY: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zyZ: // global
           I64[Sp - 8] = block_c2zyU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zz7; else goto c2zyV;
       u2zz7: // global
           call _c2zyU(R1) args: 0, res: 0, upd: 0;
       c2zyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zyU() //  [R1]
         { info_tbl: [(c2zyU,
                       label: block_c2zyU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zyU: // global
           if (I64[R1 + 7] == 0) goto c2zz6; else goto c2zz5;
       c2zz6: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zz5: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.046787236 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.04771636 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2zzf,
                       label: GHC.Word.$fBitsWord32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zzf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zzm; else goto c2zzn;
       c2zzm: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zzn: // global
           I64[Sp - 8] = block_c2zzc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zzr; else goto c2zzd;
       u2zzr: // global
           call _c2zzc(R1) args: 0, res: 0, upd: 0;
       c2zzd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zzc() //  [R1]
         { info_tbl: [(c2zzc,
                       label: block_c2zzc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zzc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zzq; else goto c2zzp;
       c2zzq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zzp: // global
           _s2v87::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v87::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.048784295 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.049820756 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2zzw,
                       label: GHC.Word.$fBitsWord32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zzw: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.050889203 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { info_tbl: [(c2zzG,
                       label: GHC.Word.$fBitsWord32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zzG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zzH; else goto c2zzI;
       c2zzH: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zzI: // global
           I64[Sp - 8] = block_c2zzD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zA1; else goto c2zzE;
       u2zA1: // global
           call _c2zzD(R1) args: 0, res: 0, upd: 0;
       c2zzE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zzD() //  [R1]
         { info_tbl: [(c2zzD,
                       label: block_c2zzD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zzD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zzN; else goto c2zzM;
       c2zzN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zzM: // global
           _s2v8b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8b::I64, 64)) goto c2zzZ; else goto c2zA0;
       c2zzZ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8b::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zA0: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.052586655 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2zA9,
                       label: GHC.Word.$fBitsWord32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zA9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zAd; else goto c2zAe;
       c2zAd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zAe: // global
           I64[Sp - 16] = block_c2zA6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zAN; else goto c2zA7;
       u2zAN: // global
           call _c2zA6(R1) args: 0, res: 0, upd: 0;
       c2zA7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zA6() //  [R1]
         { info_tbl: [(c2zA6,
                       label: block_c2zA6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zA6: // global
           I64[Sp] = block_c2zAc_info;
           _s2v8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8i::I64;
           if (R1 & 7 != 0) goto u2zAM; else goto c2zAg;
       u2zAM: // global
           call _c2zAc(R1) args: 0, res: 0, upd: 0;
       c2zAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zAc() //  [R1]
         { info_tbl: [(c2zAc,
                       label: block_c2zAc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zAc: // global
           _s2v8k::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v8k::I64, 64)) goto c2zAL; else goto c2zAK;
       c2zAK: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8k::I64)) == 0) goto c2zAL; else goto c2zAz;
       c2zAL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zAz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.054608594 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2zAV,
                       label: GHC.Word.$fBitsWord32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zAV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zAZ; else goto c2zB0;
       c2zAZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zB0: // global
           I64[Sp - 16] = block_c2zAS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zBQ; else goto c2zAT;
       u2zBQ: // global
           call _c2zAS(R1) args: 0, res: 0, upd: 0;
       c2zAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zAS() //  [R1]
         { info_tbl: [(c2zAS,
                       label: block_c2zAS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zAS: // global
           I64[Sp - 8] = block_c2zAY_info;
           _s2v8r::P64 = R1;
           _s2v8s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8s::I64;
           P64[Sp + 8] = _s2v8r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zBP; else goto c2zB2;
       u2zBP: // global
           call _c2zAY(R1) args: 0, res: 0, upd: 0;
       c2zB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zAY() //  [R1]
         { info_tbl: [(c2zAY,
                       label: block_c2zAY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zAY: // global
           _s2v8y::I64 = -I64[R1 + 7] & 31;
           if (_s2v8y::I64 != 0) goto u2zBN; else goto c2zBJ;
       u2zBN: // global
           I64[Sp + 16] = _s2v8y::I64;
           Sp = Sp + 8;
           call _c2zBk() args: 0, res: 0, upd: 0;
       c2zBJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zBk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zBk: // global
           Hp = Hp + 16;
           _s2v8y::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2zBG; else goto c2zBF;
       c2zBG: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2zBj_info;
           R1 = _s2v8y::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2zBF: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2v8s::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2v8s::I64 << _s2v8y::I64) | (_s2v8s::I64 >> 32 - _s2v8y::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zBj() //  [R1]
         { info_tbl: [(c2zBj,
                       label: block_c2zBj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zBj: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2zBk() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.056787083 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2zC0,
                       label: GHC.Word.$fBitsWord32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zC0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zC4; else goto c2zC5;
       c2zC4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zC5: // global
           I64[Sp - 16] = block_c2zBX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zCv; else goto c2zBY;
       u2zCv: // global
           call _c2zBX(R1) args: 0, res: 0, upd: 0;
       c2zBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zBX() //  [R1]
         { info_tbl: [(c2zBX,
                       label: block_c2zBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zBX: // global
           I64[Sp - 8] = block_c2zC3_info;
           _s2v8G::P64 = R1;
           _s2v8H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8H::I64;
           P64[Sp + 8] = _s2v8G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zCu; else goto c2zC7;
       u2zCu: // global
           call _c2zC3(R1) args: 0, res: 0, upd: 0;
       c2zC7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zC3() //  [R1]
         { info_tbl: [(c2zC3,
                       label: block_c2zC3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zC3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zCd; else goto c2zCc;
       c2zCd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zCc: // global
           _s2v8J::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8J::I64, 64)) goto c2zCs; else goto c2zCt;
       c2zCs: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8J::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zCt: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.058821289 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2zCD,
                       label: GHC.Word.$fBitsWord32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zCD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zCH; else goto c2zCI;
       c2zCH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zCI: // global
           I64[Sp - 16] = block_c2zCA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zDg; else goto c2zCB;
       u2zDg: // global
           call _c2zCA(R1) args: 0, res: 0, upd: 0;
       c2zCB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zCA() //  [R1]
         { info_tbl: [(c2zCA,
                       label: block_c2zCA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zCA: // global
           I64[Sp] = block_c2zCG_info;
           _s2v8R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8R::I64;
           if (R1 & 7 != 0) goto u2zDf; else goto c2zCK;
       u2zDf: // global
           call _c2zCG(R1) args: 0, res: 0, upd: 0;
       c2zCK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zCG() //  [R1]
         { info_tbl: [(c2zCG,
                       label: block_c2zCG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zCG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zCQ; else goto c2zCP;
       c2zCQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zCP: // global
           _s2v8R::I64 = I64[Sp + 8];
           _s2v8T::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8T::I64, 64)) goto c2zD8; else goto c2zDe;
       c2zD8: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8T::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zDe: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.061643924 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2zDo,
                       label: GHC.Word.$fBitsWord32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zDo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zDs; else goto c2zDt;
       c2zDs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zDt: // global
           I64[Sp - 16] = block_c2zDl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zDT; else goto c2zDm;
       u2zDT: // global
           call _c2zDl(R1) args: 0, res: 0, upd: 0;
       c2zDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zDl() //  [R1]
         { info_tbl: [(c2zDl,
                       label: block_c2zDl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zDl: // global
           I64[Sp - 8] = block_c2zDr_info;
           _s2v92::P64 = R1;
           _s2v93::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v93::I64;
           P64[Sp + 8] = _s2v92::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zDS; else goto c2zDv;
       u2zDS: // global
           call _c2zDr(R1) args: 0, res: 0, upd: 0;
       c2zDv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zDr() //  [R1]
         { info_tbl: [(c2zDr,
                       label: block_c2zDr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zDr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zDB; else goto c2zDA;
       c2zDB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zDA: // global
           _s2v95::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v95::I64, 64)) goto c2zDQ; else goto c2zDR;
       c2zDQ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v95::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zDR: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.063158015 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2zDY,
                       label: GHC.Word.$fBitsWord32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zDY: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.063890007 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.064637878 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.066006009 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2zE8,
                       label: GHC.Word.$fIntegralWord32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zE8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zEc; else goto c2zEd;
       c2zEc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zEd: // global
           I64[Sp - 16] = block_c2zE5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zEw; else goto c2zE6;
       u2zEw: // global
           call _c2zE5(R1) args: 0, res: 0, upd: 0;
       c2zE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zE5() //  [R1]
         { info_tbl: [(c2zE5,
                       label: block_c2zE5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zE5: // global
           I64[Sp] = block_c2zEb_info;
           _s2v9d::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9d::I64;
           if (R1 & 7 != 0) goto u2zEv; else goto c2zEf;
       u2zEv: // global
           call _c2zEb(R1) args: 0, res: 0, upd: 0;
       c2zEf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zEb() //  [R1]
         { info_tbl: [(c2zEb,
                       label: block_c2zEb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zEl; else goto c2zEk;
       c2zEl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zEk: // global
           _s2v9g::I64 = I64[R1 + 7];
           if (_s2v9g::I64 != 0) goto c2zEt; else goto c2zEu;
       c2zEt: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v9g::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zEu: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.067816175 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2zEE,
                       label: GHC.Word.$fIntegralWord32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zEE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zEI; else goto c2zEJ;
       c2zEI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zEJ: // global
           I64[Sp - 16] = block_c2zEB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zF2; else goto c2zEC;
       u2zF2: // global
           call _c2zEB(R1) args: 0, res: 0, upd: 0;
       c2zEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zEB() //  [R1]
         { info_tbl: [(c2zEB,
                       label: block_c2zEB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zEB: // global
           I64[Sp] = block_c2zEH_info;
           _s2v9l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9l::I64;
           if (R1 & 7 != 0) goto u2zF1; else goto c2zEL;
       u2zF1: // global
           call _c2zEH(R1) args: 0, res: 0, upd: 0;
       c2zEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zEH() //  [R1]
         { info_tbl: [(c2zEH,
                       label: block_c2zEH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zEH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zER; else goto c2zEQ;
       c2zER: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zEQ: // global
           _s2v9o::I64 = I64[R1 + 7];
           if (_s2v9o::I64 != 0) goto c2zEZ; else goto c2zF0;
       c2zEZ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v9o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zF0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.069729501 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2zFa,
                       label: GHC.Word.$fIntegralWord32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zFe; else goto c2zFf;
       c2zFe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zFf: // global
           I64[Sp - 16] = block_c2zF7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zFx; else goto c2zF8;
       u2zFx: // global
           call _c2zF7(R1) args: 0, res: 0, upd: 0;
       c2zF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zF7() //  [R1]
         { info_tbl: [(c2zF7,
                       label: block_c2zF7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zF7: // global
           I64[Sp] = block_c2zFd_info;
           _s2v9t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9t::I64;
           if (R1 & 7 != 0) goto u2zFw; else goto c2zFh;
       u2zFw: // global
           call _c2zFd(R1) args: 0, res: 0, upd: 0;
       c2zFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zFd() //  [R1]
         { info_tbl: [(c2zFd,
                       label: block_c2zFd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zFd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2zFn; else goto c2zFm;
       c2zFn: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zFm: // global
           _s2v9w::I64 = I64[R1 + 7];
           if (_s2v9w::I64 != 0) goto c2zFu; else goto c2zFv;
       c2zFu: // global
           (_s2v9y::I64, _s2v9z::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v9w::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2v9z::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2v9y::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zFv: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.072078222 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2v9M_entry() //  [R1]
         { info_tbl: [(c2zFU,
                       label: sat_s2v9M_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zFU: // global
           _s2v9M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zFX; else goto c2zFY;
       c2zFY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zG0; else goto c2zFZ;
       c2zG0: // global
           HpAlloc = 16;
           goto c2zFX;
       c2zFX: // global
           R1 = _s2v9M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9M::P64;
           _s2v9L::I64 = I64[_s2v9M::P64 + 16] % I64[_s2v9M::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9L::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v9K_entry() //  [R1]
         { info_tbl: [(c2zG7,
                       label: sat_s2v9K_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zG7: // global
           _s2v9K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2zGa; else goto c2zGb;
       c2zGb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zGd; else goto c2zGc;
       c2zGd: // global
           HpAlloc = 16;
           goto c2zGa;
       c2zGa: // global
           R1 = _s2v9K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2zGc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9K::P64;
           _s2v9J::I64 = I64[_s2v9K::P64 + 16] / I64[_s2v9K::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9J::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2zGe,
                       label: GHC.Word.$fIntegralWord32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zGf; else goto c2zGg;
       c2zGf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zGg: // global
           I64[Sp - 16] = block_c2zFC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zGq; else goto c2zFD;
       u2zGq: // global
           call _c2zFC(R1) args: 0, res: 0, upd: 0;
       c2zFD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zFC() //  [R1]
         { info_tbl: [(c2zFC,
                       label: block_c2zFC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zFC: // global
           I64[Sp] = block_c2zFH_info;
           _s2v9F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9F::I64;
           if (R1 & 7 != 0) goto u2zGp; else goto c2zFI;
       u2zGp: // global
           call _c2zFH(R1) args: 0, res: 0, upd: 0;
       c2zFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zFH() //  [R1]
         { info_tbl: [(c2zFH,
                       label: block_c2zFH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zFH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2zGk; else goto c2zGj;
       c2zGk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zGj: // global
           _s2v9I::I64 = I64[R1 + 7];
           if (_s2v9I::I64 != 0) goto c2zGn; else goto c2zGo;
       c2zGn: // global
           I64[Hp - 80] = sat_s2v9M_info;
           _s2v9F::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v9F::I64;
           I64[Hp - 56] = _s2v9I::I64;
           I64[Hp - 48] = sat_s2v9K_info;
           I64[Hp - 32] = _s2v9F::I64;
           I64[Hp - 24] = _s2v9I::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zGo: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.074665191 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { info_tbl: [(c2zGy,
                       label: GHC.Word.gtWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zGC; else goto c2zGD;
       c2zGC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zGD: // global
           I64[Sp - 16] = block_c2zGv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zGM; else goto c2zGw;
       u2zGM: // global
           call _c2zGv(R1) args: 0, res: 0, upd: 0;
       c2zGw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zGv() //  [R1]
         { info_tbl: [(c2zGv,
                       label: block_c2zGv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGv: // global
           I64[Sp] = block_c2zGB_info;
           _s2v9Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9Q::I64;
           if (R1 & 7 != 0) goto u2zGL; else goto c2zGF;
       u2zGL: // global
           call _c2zGB(R1) args: 0, res: 0, upd: 0;
       c2zGF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zGB() //  [R1]
         { info_tbl: [(c2zGB,
                       label: block_c2zGB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGB: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.076243022 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { info_tbl: [(c2zGU,
                       label: GHC.Word.geWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zGY; else goto c2zGZ;
       c2zGY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zGZ: // global
           I64[Sp - 16] = block_c2zGR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zH8; else goto c2zGS;
       u2zH8: // global
           call _c2zGR(R1) args: 0, res: 0, upd: 0;
       c2zGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zGR() //  [R1]
         { info_tbl: [(c2zGR,
                       label: block_c2zGR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGR: // global
           I64[Sp] = block_c2zGX_info;
           _s2v9X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9X::I64;
           if (R1 & 7 != 0) goto u2zH7; else goto c2zH1;
       u2zH7: // global
           call _c2zGX(R1) args: 0, res: 0, upd: 0;
       c2zH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zGX() //  [R1]
         { info_tbl: [(c2zGX,
                       label: block_c2zGX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zGX: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.078648191 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { info_tbl: [(c2zHg,
                       label: GHC.Word.ltWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zHk; else goto c2zHl;
       c2zHk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zHl: // global
           I64[Sp - 16] = block_c2zHd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zHu; else goto c2zHe;
       u2zHu: // global
           call _c2zHd(R1) args: 0, res: 0, upd: 0;
       c2zHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zHd() //  [R1]
         { info_tbl: [(c2zHd,
                       label: block_c2zHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHd: // global
           I64[Sp] = block_c2zHj_info;
           _s2va4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2va4::I64;
           if (R1 & 7 != 0) goto u2zHt; else goto c2zHn;
       u2zHt: // global
           call _c2zHj(R1) args: 0, res: 0, upd: 0;
       c2zHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zHj() //  [R1]
         { info_tbl: [(c2zHj,
                       label: block_c2zHj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHj: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.080122075 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { info_tbl: [(c2zHC,
                       label: GHC.Word.leWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zHG; else goto c2zHH;
       c2zHG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zHH: // global
           I64[Sp - 16] = block_c2zHz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zHQ; else goto c2zHA;
       u2zHQ: // global
           call _c2zHz(R1) args: 0, res: 0, upd: 0;
       c2zHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zHz() //  [R1]
         { info_tbl: [(c2zHz,
                       label: block_c2zHz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHz: // global
           I64[Sp] = block_c2zHF_info;
           _s2vab::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vab::I64;
           if (R1 & 7 != 0) goto u2zHP; else goto c2zHJ;
       u2zHP: // global
           call _c2zHF(R1) args: 0, res: 0, upd: 0;
       c2zHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zHF() //  [R1]
         { info_tbl: [(c2zHF,
                       label: block_c2zHF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHF: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.081720727 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2zHY,
                       label: GHC.Word.$fOrdWord32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zI2; else goto c2zI3;
       c2zI2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zI3: // global
           I64[Sp - 16] = block_c2zHV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zIm; else goto c2zHW;
       u2zIm: // global
           call _c2zHV(R1) args: 0, res: 0, upd: 0;
       c2zHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zHV() //  [R1]
         { info_tbl: [(c2zHV,
                       label: block_c2zHV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zHV: // global
           I64[Sp] = block_c2zI1_info;
           _s2vai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vai::I64;
           if (R1 & 7 != 0) goto u2zIl; else goto c2zI5;
       u2zIl: // global
           call _c2zI1(R1) args: 0, res: 0, upd: 0;
       c2zI5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zI1() //  [R1]
         { info_tbl: [(c2zI1,
                       label: block_c2zI1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zI1: // global
           _s2vai::I64 = I64[Sp + 8];
           _s2vak::I64 = I64[R1 + 7];
           if (_s2vai::I64 == _s2vak::I64) goto c2zIk; else goto c2zIj;
       c2zIk: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zIj: // global
           if (_s2vai::I64 > _s2vak::I64) goto c2zIg; else goto c2zIh;
       c2zIg: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zIh: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.083521655 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2zIu,
                       label: GHC.Word.$fOrdWord32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zIy; else goto c2zIz;
       c2zIy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zIz: // global
           I64[Sp - 16] = block_c2zIr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zIM; else goto c2zIs;
       u2zIM: // global
           call _c2zIr(R1) args: 0, res: 0, upd: 0;
       c2zIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zIr() //  [R1]
         { info_tbl: [(c2zIr,
                       label: block_c2zIr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIr: // global
           I64[Sp - 8] = block_c2zIx_info;
           _s2vap::P64 = R1;
           _s2vaq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vaq::I64;
           P64[Sp + 8] = _s2vap::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zIL; else goto c2zIB;
       u2zIL: // global
           call _c2zIx(R1) args: 0, res: 0, upd: 0;
       c2zIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zIx() //  [R1]
         { info_tbl: [(c2zIx,
                       label: block_c2zIx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIx: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2zIJ; else goto c2zIK;
       c2zIJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zIK: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.085181353 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2zIU,
                       label: GHC.Word.$fOrdWord32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zIY; else goto c2zIZ;
       c2zIY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zIZ: // global
           I64[Sp - 16] = block_c2zIR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zJc; else goto c2zIS;
       u2zJc: // global
           call _c2zIR(R1) args: 0, res: 0, upd: 0;
       c2zIS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zIR() //  [R1]
         { info_tbl: [(c2zIR,
                       label: block_c2zIR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIR: // global
           I64[Sp - 8] = block_c2zIX_info;
           _s2vaw::P64 = R1;
           _s2vax::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vax::I64;
           P64[Sp + 8] = _s2vaw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zJb; else goto c2zJ1;
       u2zJb: // global
           call _c2zIX(R1) args: 0, res: 0, upd: 0;
       c2zJ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zIX() //  [R1]
         { info_tbl: [(c2zIX,
                       label: block_c2zIX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zIX: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2zJ9; else goto c2zJa;
       c2zJ9: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zJa: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.08653963 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.087648582 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2zJk,
                       label: GHC.Word.$fIxWord32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zJt; else goto c2zJu;
       c2zJt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zJu: // global
           I64[Sp - 16] = block_c2zJh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zJR; else goto c2zJi;
       u2zJR: // global
           call _c2zJh(R1) args: 0, res: 0, upd: 0;
       c2zJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zJh() //  [R1]
         { info_tbl: [(c2zJh,
                       label: block_c2zJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJh: // global
           I64[Sp - 8] = block_c2zJn_info;
           _s2vaF::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vaF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zJQ; else goto c2zJo;
       u2zJQ: // global
           call _c2zJn(R1) args: 0, res: 0, upd: 0;
       c2zJo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zJn() //  [R1]
         { info_tbl: [(c2zJn,
                       label: block_c2zJn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJn: // global
           I64[Sp] = block_c2zJs_info;
           _s2vaH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vaH::I64;
           if (R1 & 7 != 0) goto u2zJS; else goto c2zJx;
       u2zJS: // global
           call _c2zJs(R1) args: 0, res: 0, upd: 0;
       c2zJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zJs() //  [R1]
         { info_tbl: [(c2zJs,
                       label: block_c2zJs_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJs: // global
           _s2vaJ::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vaJ::I64) goto c2zJF; else goto c2zJJ;
       c2zJF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zJJ: // global
           _s2vaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2zJI_info;
           R1 = _s2vaF::P64;
           I64[Sp + 16] = _s2vaJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2zJT; else goto c2zJK;
       u2zJT: // global
           call _c2zJI(R1) args: 0, res: 0, upd: 0;
       c2zJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zJI() //  [R1]
         { info_tbl: [(c2zJI,
                       label: block_c2zJI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJI: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.090091277 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2zK1,
                       label: GHC.Word.$fRealWord32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zK1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zKi; else goto c2zKj;
       c2zKi: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zKj: // global
           I64[Sp - 8] = block_c2zJY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zKq; else goto c2zJZ;
       u2zKq: // global
           call _c2zJY(R1) args: 0, res: 0, upd: 0;
       c2zJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zJY() //  [R1]
         { info_tbl: [(c2zJY,
                       label: block_c2zJY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zJY: // global
           I64[Sp] = block_c2zK7_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zK7() //  [R1]
         { info_tbl: [(c2zK7,
                       label: block_c2zK7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zK7: // global
           I64[Sp] = block_c2zKb_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zKb() //  [R1]
         { info_tbl: [(c2zKb,
                       label: block_c2zKb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKb: // global
           I64[Sp] = block_c2zKf_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zKf() //  [R1, R2]
         { info_tbl: [(c2zKf,
                       label: block_c2zKf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2zKp; else goto c2zKo;
       c2zKp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2zKo: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.091604875 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.092176479 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.093410576 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2zKy,
                       label: GHC.Word.$fIxWord32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zKV; else goto c2zKW;
       c2zKV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zKW: // global
           I64[Sp - 16] = block_c2zKv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zL3; else goto c2zKw;
       u2zL3: // global
           call _c2zKv(R1) args: 0, res: 0, upd: 0;
       c2zKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zKv() //  [R1]
         { info_tbl: [(c2zKv,
                       label: block_c2zKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKv: // global
           I64[Sp] = block_c2zKB_info;
           _s2vb0::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vb0::P64;
           if (R1 & 7 != 0) goto u2zL2; else goto c2zKC;
       u2zL2: // global
           call _c2zKB(R1) args: 0, res: 0, upd: 0;
       c2zKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zKB() //  [R1]
         { info_tbl: [(c2zKB,
                       label: block_c2zKB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKB: // global
           I64[Sp] = block_c2zKG_info;
           _s2vb3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vb3::I64;
           if (R1 & 7 != 0) goto u2zL4; else goto c2zKH;
       u2zL4: // global
           call _c2zKG(R1) args: 0, res: 0, upd: 0;
       c2zKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zKG() //  [R1]
         { info_tbl: [(c2zKG,
                       label: block_c2zKG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zKG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zL1; else goto c2zL0;
       c2zL1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zL0: // global
           _s2vb8::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vb8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.096073873 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { info_tbl: [(c2zLc,
                       label: GHC.Word.$fIxWord32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zLc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zLd; else goto c2zLe;
       c2zLd: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zLe: // global
           I64[Sp - 8] = block_c2zL9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zLi; else goto c2zLa;
       u2zLi: // global
           call _c2zL9(R1) args: 0, res: 0, upd: 0;
       c2zLa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zL9() //  [R1]
         { info_tbl: [(c2zL9,
                       label: block_c2zL9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zL9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.09767305 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2zLq,
                       label: GHC.Word.$fIxWord32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zLq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zLz; else goto c2zLA;
       c2zLz: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zLA: // global
           I64[Sp - 8] = block_c2zLn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zM5; else goto c2zLo;
       u2zM5: // global
           call _c2zLn(R1) args: 0, res: 0, upd: 0;
       c2zLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zLn() //  [R1]
         { info_tbl: [(c2zLn,
                       label: block_c2zLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zLn: // global
           I64[Sp - 8] = block_c2zLt_info;
           _s2vbg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zM4; else goto c2zLu;
       u2zM4: // global
           call _c2zLt(R1) args: 0, res: 0, upd: 0;
       c2zLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zLt() //  [R1]
         { info_tbl: [(c2zLt,
                       label: block_c2zLt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zLt: // global
           I64[Sp] = block_c2zLy_info;
           _s2vbi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbi::I64;
           if (R1 & 7 != 0) goto u2zM6; else goto c2zLD;
       u2zM6: // global
           call _c2zLy(R1) args: 0, res: 0, upd: 0;
       c2zLD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zLy() //  [R1]
         { info_tbl: [(c2zLy,
                       label: block_c2zLy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zLy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zLJ; else goto c2zLI;
       c2zLJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zLI: // global
           _s2vbi::I64 = I64[Sp + 8];
           _s2vbk::I64 = I64[R1 + 7];
           if (_s2vbi::I64 > _s2vbk::I64) goto c2zLN; else goto c2zM3;
       c2zLN: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zM3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbk::I64 - _s2vbi::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.099662312 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2zMe,
                       label: GHC.Word.$fIxWord32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zME; else goto c2zMF;
       c2zME: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zMF: // global
           I64[Sp - 8] = block_c2zMb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zMM; else goto c2zMc;
       u2zMM: // global
           call _c2zMb(R1) args: 0, res: 0, upd: 0;
       c2zMc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zMb() //  [R1]
         { info_tbl: [(c2zMb,
                       label: block_c2zMb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMb: // global
           I64[Sp - 8] = block_c2zMh_info;
           _s2vbs::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vbs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zML; else goto c2zMi;
       u2zML: // global
           call _c2zMh(R1) args: 0, res: 0, upd: 0;
       c2zMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zMh() //  [R1]
         { info_tbl: [(c2zMh,
                       label: block_c2zMh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMh: // global
           I64[Sp] = block_c2zMm_info;
           _s2vbv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbv::I64;
           if (R1 & 7 != 0) goto u2zMN; else goto c2zMn;
       u2zMN: // global
           call _c2zMm(R1) args: 0, res: 0, upd: 0;
       c2zMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zMm() //  [R1]
         { info_tbl: [(c2zMm,
                       label: block_c2zMm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zMK; else goto c2zMJ;
       c2zMK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zMJ: // global
           _s2vbB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vbB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.102061115 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2zMV,
                       label: GHC.Word.$fIxWord32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zN4; else goto c2zN5;
       c2zN4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zN5: // global
           I64[Sp - 16] = block_c2zMS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zNK; else goto c2zMT;
       u2zNK: // global
           call _c2zMS(R1) args: 0, res: 0, upd: 0;
       c2zMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zMS() //  [R1]
         { info_tbl: [(c2zMS,
                       label: block_c2zMS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMS: // global
           I64[Sp - 8] = block_c2zMY_info;
           _s2vbG::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zNJ; else goto c2zMZ;
       u2zNJ: // global
           call _c2zMY(R1) args: 0, res: 0, upd: 0;
       c2zMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zMY() //  [R1]
         { info_tbl: [(c2zMY,
                       label: block_c2zMY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zMY: // global
           I64[Sp] = block_c2zN3_info;
           _s2vbI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vbI::I64;
           if (R1 & 7 != 0) goto u2zNL; else goto c2zN8;
       u2zNL: // global
           call _c2zN3(R1) args: 0, res: 0, upd: 0;
       c2zN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zN3() //  [R1]
         { info_tbl: [(c2zN3,
                       label: block_c2zN3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zN3: // global
           _s2vbK::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vbK::I64) goto c2zNg; else goto c2zNk;
       c2zNg: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zNk: // global
           I64[Sp] = block_c2zNj_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbK::I64;
           if (R1 & 7 != 0) goto u2zNM; else goto c2zNl;
       u2zNM: // global
           call _c2zNj(R1) args: 0, res: 0, upd: 0;
       c2zNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zNj() //  [R1]
         { info_tbl: [(c2zNj,
                       label: block_c2zNj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zNj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zNr; else goto c2zNq;
       c2zNr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zNq: // global
           _s2vbK::I64 = I64[Sp + 8];
           if (_s2vbK::I64 > I64[R1 + 7]) goto c2zNv; else goto c2zNI;
       c2zNv: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zNI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbK::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.104015087 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.105044909 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { info_tbl: [(c2zNU,
                       label: GHC.Word.byteSwap32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zNU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zO5; else goto c2zO6;
       c2zO5: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zO6: // global
           I64[Sp - 8] = block_c2zNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zOa; else goto c2zNS;
       u2zOa: // global
           call _c2zNR(R1) args: 0, res: 0, upd: 0;
       c2zNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zNR() //  [R1]
         { info_tbl: [(c2zNR,
                       label: block_c2zNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zNR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zO9; else goto c2zO8;
       c2zO9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zO8: // global
           (_c2zNX::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2zNX::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.106459227 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2zOi,
                       label: GHC.Word.$fBitsWord64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zOi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zOp; else goto c2zOq;
       c2zOp: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zOq: // global
           I64[Sp - 8] = block_c2zOf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zOu; else goto c2zOg;
       u2zOu: // global
           call _c2zOf(R1) args: 0, res: 0, upd: 0;
       c2zOg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zOf() //  [R1]
         { info_tbl: [(c2zOf,
                       label: block_c2zOf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zOf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zOt; else goto c2zOs;
       c2zOt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zOs: // global
           _s2vc0::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vc0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.107562953 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.108280203 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2zOz,
                       label: GHC.Word.$fBitsWord64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zOz: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.109352031 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { info_tbl: [(c2zOJ,
                       label: GHC.Word.$fBitsWord64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zOJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zOK; else goto c2zOL;
       c2zOK: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zOL: // global
           I64[Sp - 8] = block_c2zOG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zP1; else goto c2zOH;
       u2zP1: // global
           call _c2zOG(R1) args: 0, res: 0, upd: 0;
       c2zOH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zOG() //  [R1]
         { info_tbl: [(c2zOG,
                       label: block_c2zOG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zOG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zOQ; else goto c2zOP;
       c2zOQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zOP: // global
           _s2vc4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vc4::I64, 64)) goto c2zOZ; else goto c2zP0;
       c2zOZ: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2vc4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zP0: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.111059811 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2zP9,
                       label: GHC.Word.$fBitsWord64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zP9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zPd; else goto c2zPe;
       c2zPd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zPe: // global
           I64[Sp - 16] = block_c2zP6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zPK; else goto c2zP7;
       u2zPK: // global
           call _c2zP6(R1) args: 0, res: 0, upd: 0;
       c2zP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zP6() //  [R1]
         { info_tbl: [(c2zP6,
                       label: block_c2zP6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zP6: // global
           I64[Sp] = block_c2zPc_info;
           _s2vca::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vca::I64;
           if (R1 & 7 != 0) goto u2zPJ; else goto c2zPg;
       u2zPJ: // global
           call _c2zPc(R1) args: 0, res: 0, upd: 0;
       c2zPg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zPc() //  [R1]
         { info_tbl: [(c2zPc,
                       label: block_c2zPc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zPc: // global
           _s2vcc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2vcc::I64, 64)) goto c2zPI; else goto c2zPH;
       c2zPH: // global
           if (I64[Sp + 8] & (1 << _s2vcc::I64) == 0) goto c2zPI; else goto c2zPw;
       c2zPI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zPw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.113957096 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2zPS,
                       label: GHC.Word.$fBitsWord64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zPS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zPW; else goto c2zPX;
       c2zPW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zPX: // global
           I64[Sp - 16] = block_c2zPP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zQK; else goto c2zPQ;
       u2zQK: // global
           call _c2zPP(R1) args: 0, res: 0, upd: 0;
       c2zPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zPP() //  [R1]
         { info_tbl: [(c2zPP,
                       label: block_c2zPP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zPP: // global
           I64[Sp - 8] = block_c2zPV_info;
           _s2vci::P64 = R1;
           _s2vcj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcj::I64;
           P64[Sp + 8] = _s2vci::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zQJ; else goto c2zPZ;
       u2zQJ: // global
           call _c2zPV(R1) args: 0, res: 0, upd: 0;
       c2zPZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zPV() //  [R1]
         { info_tbl: [(c2zPV,
                       label: block_c2zPV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zPV: // global
           _s2vcp::I64 = -I64[R1 + 7] & 63;
           if (_s2vcp::I64 != 0) goto u2zQH; else goto c2zQD;
       u2zQH: // global
           I64[Sp + 16] = _s2vcp::I64;
           Sp = Sp + 8;
           call _c2zQh() args: 0, res: 0, upd: 0;
       c2zQD: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zQh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zQh: // global
           Hp = Hp + 16;
           _s2vcp::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2zQA; else goto c2zQz;
       c2zQA: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2zQg_info;
           R1 = _s2vcp::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2zQz: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2vcj::I64 = I64[Sp];
           I64[Hp] = (_s2vcj::I64 << _s2vcp::I64) | (_s2vcj::I64 >> 64 - _s2vcp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2zQg() //  [R1]
         { info_tbl: [(c2zQg,
                       label: block_c2zQg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zQg: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2zQh() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.116101179 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2zQU,
                       label: GHC.Word.$fBitsWord64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zQU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zQY; else goto c2zQZ;
       c2zQY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zQZ: // global
           I64[Sp - 16] = block_c2zQR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zRm; else goto c2zQS;
       u2zRm: // global
           call _c2zQR(R1) args: 0, res: 0, upd: 0;
       c2zQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zQR() //  [R1]
         { info_tbl: [(c2zQR,
                       label: block_c2zQR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zQR: // global
           I64[Sp - 8] = block_c2zQX_info;
           _s2vcw::P64 = R1;
           _s2vcx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcx::I64;
           P64[Sp + 8] = _s2vcw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zRl; else goto c2zR1;
       u2zRl: // global
           call _c2zQX(R1) args: 0, res: 0, upd: 0;
       c2zR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zQX() //  [R1]
         { info_tbl: [(c2zQX,
                       label: block_c2zQX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zQX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zR7; else goto c2zR6;
       c2zR7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zR6: // global
           _s2vcz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcz::I64, 64)) goto c2zRj; else goto c2zRk;
       c2zRj: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2vcz::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zRk: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.11807511 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2zRu,
                       label: GHC.Word.$fBitsWord64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zRy; else goto c2zRz;
       c2zRy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zRz: // global
           I64[Sp - 16] = block_c2zRr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zS4; else goto c2zRs;
       u2zS4: // global
           call _c2zRr(R1) args: 0, res: 0, upd: 0;
       c2zRs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zRr() //  [R1]
         { info_tbl: [(c2zRr,
                       label: block_c2zRr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zRr: // global
           I64[Sp] = block_c2zRx_info;
           _s2vcG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vcG::I64;
           if (R1 & 7 != 0) goto u2zS3; else goto c2zRB;
       u2zS3: // global
           call _c2zRx(R1) args: 0, res: 0, upd: 0;
       c2zRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zRx() //  [R1]
         { info_tbl: [(c2zRx,
                       label: block_c2zRx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zRx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zRH; else goto c2zRG;
       c2zRH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zRG: // global
           _s2vcG::I64 = I64[Sp + 8];
           _s2vcI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcI::I64, 64)) goto c2zRW; else goto c2zS2;
       c2zRW: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & (1 << _s2vcI::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zS2: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.119976623 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2zSc,
                       label: GHC.Word.$fBitsWord64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zSc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zSg; else goto c2zSh;
       c2zSg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zSh: // global
           I64[Sp - 16] = block_c2zS9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zSE; else goto c2zSa;
       u2zSE: // global
           call _c2zS9(R1) args: 0, res: 0, upd: 0;
       c2zSa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zS9() //  [R1]
         { info_tbl: [(c2zS9,
                       label: block_c2zS9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zS9: // global
           I64[Sp - 8] = block_c2zSf_info;
           _s2vcQ::P64 = R1;
           _s2vcR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcR::I64;
           P64[Sp + 8] = _s2vcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zSD; else goto c2zSj;
       u2zSD: // global
           call _c2zSf(R1) args: 0, res: 0, upd: 0;
       c2zSj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zSf() //  [R1]
         { info_tbl: [(c2zSf,
                       label: block_c2zSf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zSf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zSp; else goto c2zSo;
       c2zSp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zSo: // global
           _s2vcT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcT::I64, 64)) goto c2zSB; else goto c2zSC;
       c2zSB: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2vcT::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zSC: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.121624413 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2zSJ,
                       label: GHC.Word.$fBitsWord64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zSJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.122403642 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.123137041 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.124311061 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2zST,
                       label: GHC.Word.$fIxWord64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zST: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zT2; else goto c2zT3;
       c2zT2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zT3: // global
           I64[Sp - 16] = block_c2zSQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zTq; else goto c2zSR;
       u2zTq: // global
           call _c2zSQ(R1) args: 0, res: 0, upd: 0;
       c2zSR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zSQ() //  [R1]
         { info_tbl: [(c2zSQ,
                       label: block_c2zSQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zSQ: // global
           I64[Sp - 8] = block_c2zSW_info;
           _s2vd1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vd1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zTp; else goto c2zSX;
       u2zTp: // global
           call _c2zSW(R1) args: 0, res: 0, upd: 0;
       c2zSX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zSW() //  [R1]
         { info_tbl: [(c2zSW,
                       label: block_c2zSW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zSW: // global
           I64[Sp] = block_c2zT1_info;
           _s2vd3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vd3::I64;
           if (R1 & 7 != 0) goto u2zTr; else goto c2zT6;
       u2zTr: // global
           call _c2zT1(R1) args: 0, res: 0, upd: 0;
       c2zT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zT1() //  [R1]
         { info_tbl: [(c2zT1,
                       label: block_c2zT1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zT1: // global
           _s2vd5::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vd5::I64) goto c2zTe; else goto c2zTi;
       c2zTe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zTi: // global
           _s2vd1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2zTh_info;
           R1 = _s2vd1::P64;
           I64[Sp + 16] = _s2vd5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2zTs; else goto c2zTj;
       u2zTs: // global
           call _c2zTh(R1) args: 0, res: 0, upd: 0;
       c2zTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zTh() //  [R1]
         { info_tbl: [(c2zTh,
                       label: block_c2zTh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTh: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.126506698 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { info_tbl: [(c2zTA,
                       label: GHC.Word.$fIxWord64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zTB; else goto c2zTC;
       c2zTB: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zTC: // global
           I64[Sp - 8] = block_c2zTx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zTG; else goto c2zTy;
       u2zTG: // global
           call _c2zTx(R1) args: 0, res: 0, upd: 0;
       c2zTy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zTx() //  [R1]
         { info_tbl: [(c2zTx,
                       label: block_c2zTx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTx: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.128036909 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2zTO,
                       label: GHC.Word.$fIxWord64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zU8; else goto c2zU9;
       c2zU8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zU9: // global
           I64[Sp - 16] = block_c2zTL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zUg; else goto c2zTM;
       u2zUg: // global
           call _c2zTL(R1) args: 0, res: 0, upd: 0;
       c2zTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zTL() //  [R1]
         { info_tbl: [(c2zTL,
                       label: block_c2zTL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTL: // global
           I64[Sp] = block_c2zTR_info;
           _s2vdh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vdh::P64;
           if (R1 & 7 != 0) goto u2zUf; else goto c2zTS;
       u2zUf: // global
           call _c2zTR(R1) args: 0, res: 0, upd: 0;
       c2zTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zTR() //  [R1]
         { info_tbl: [(c2zTR,
                       label: block_c2zTR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTR: // global
           I64[Sp] = block_c2zTW_info;
           _s2vdk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdk::I64;
           if (R1 & 7 != 0) goto u2zUh; else goto c2zTX;
       u2zUh: // global
           call _c2zTW(R1) args: 0, res: 0, upd: 0;
       c2zTX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zTW() //  [R1]
         { info_tbl: [(c2zTW,
                       label: block_c2zTW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zTW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zUe; else goto c2zUd;
       c2zUe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zUd: // global
           _s2vdo::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.131135564 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2zUp,
                       label: GHC.Word.$fIxWord64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zUp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zUy; else goto c2zUz;
       c2zUy: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zUz: // global
           I64[Sp - 8] = block_c2zUm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zV1; else goto c2zUn;
       u2zV1: // global
           call _c2zUm(R1) args: 0, res: 0, upd: 0;
       c2zUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zUm() //  [R1]
         { info_tbl: [(c2zUm,
                       label: block_c2zUm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zUm: // global
           I64[Sp - 8] = block_c2zUs_info;
           _s2vds::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vds::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zV0; else goto c2zUt;
       u2zV0: // global
           call _c2zUs(R1) args: 0, res: 0, upd: 0;
       c2zUt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zUs() //  [R1]
         { info_tbl: [(c2zUs,
                       label: block_c2zUs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zUs: // global
           I64[Sp] = block_c2zUx_info;
           _s2vdu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdu::I64;
           if (R1 & 7 != 0) goto u2zV2; else goto c2zUC;
       u2zV2: // global
           call _c2zUx(R1) args: 0, res: 0, upd: 0;
       c2zUC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zUx() //  [R1]
         { info_tbl: [(c2zUx,
                       label: block_c2zUx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zUx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zUI; else goto c2zUH;
       c2zUI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zUH: // global
           _s2vdu::I64 = I64[Sp + 8];
           _s2vdw::I64 = I64[R1 + 7];
           if (_s2vdu::I64 > _s2vdw::I64) goto c2zUM; else goto c2zUZ;
       c2zUM: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2zUZ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdw::I64 - _s2vdu::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.133112681 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2zVa,
                       label: GHC.Word.$fIxWord64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2zVx; else goto c2zVy;
       c2zVx: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zVy: // global
           I64[Sp - 8] = block_c2zV7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zVF; else goto c2zV8;
       u2zVF: // global
           call _c2zV7(R1) args: 0, res: 0, upd: 0;
       c2zV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zV7() //  [R1]
         { info_tbl: [(c2zV7,
                       label: block_c2zV7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zV7: // global
           I64[Sp - 8] = block_c2zVd_info;
           _s2vdD::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vdD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zVE; else goto c2zVe;
       u2zVE: // global
           call _c2zVd(R1) args: 0, res: 0, upd: 0;
       c2zVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zVd() //  [R1]
         { info_tbl: [(c2zVd,
                       label: block_c2zVd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVd: // global
           I64[Sp] = block_c2zVi_info;
           _s2vdG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdG::I64;
           if (R1 & 7 != 0) goto u2zVG; else goto c2zVj;
       u2zVG: // global
           call _c2zVi(R1) args: 0, res: 0, upd: 0;
       c2zVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zVi() //  [R1]
         { info_tbl: [(c2zVi,
                       label: block_c2zVi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zVD; else goto c2zVC;
       c2zVD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zVC: // global
           _s2vdL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.135322305 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2zVO,
                       label: GHC.Word.$fIxWord64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2zVX; else goto c2zVY;
       c2zVX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2zVY: // global
           I64[Sp - 16] = block_c2zVL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2zWA; else goto c2zVM;
       u2zWA: // global
           call _c2zVL(R1) args: 0, res: 0, upd: 0;
       c2zVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zVL() //  [R1]
         { info_tbl: [(c2zVL,
                       label: block_c2zVL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVL: // global
           I64[Sp - 8] = block_c2zVR_info;
           _s2vdQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vdQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zWz; else goto c2zVS;
       u2zWz: // global
           call _c2zVR(R1) args: 0, res: 0, upd: 0;
       c2zVS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zVR() //  [R1]
         { info_tbl: [(c2zVR,
                       label: block_c2zVR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVR: // global
           I64[Sp] = block_c2zVW_info;
           _s2vdS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vdS::I64;
           if (R1 & 7 != 0) goto u2zWB; else goto c2zW1;
       u2zWB: // global
           call _c2zVW(R1) args: 0, res: 0, upd: 0;
       c2zW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zVW() //  [R1]
         { info_tbl: [(c2zVW,
                       label: block_c2zVW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zVW: // global
           _s2vdU::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vdU::I64) goto c2zW9; else goto c2zWd;
       c2zW9: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zWd: // global
           I64[Sp] = block_c2zWc_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdU::I64;
           if (R1 & 7 != 0) goto u2zWC; else goto c2zWe;
       u2zWC: // global
           call _c2zWc(R1) args: 0, res: 0, upd: 0;
       c2zWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zWc() //  [R1]
         { info_tbl: [(c2zWc,
                       label: block_c2zWc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zWc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zWk; else goto c2zWj;
       c2zWk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zWj: // global
           _s2vdU::I64 = I64[Sp + 8];
           if (_s2vdU::I64 > I64[R1 + 7]) goto c2zWo; else goto c2zWy;
       c2zWo: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2zWy: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.137203931 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.138096848 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c2zWI,
                       label: GHC.Word.uncheckedShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zWI: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.138912618 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { info_tbl: [(c2zWQ,
                       label: GHC.Word.uncheckedShiftRL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zWQ: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.139892864 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { info_tbl: [(c2zX0,
                       label: GHC.Word.byteSwap64_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zX0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zX8; else goto c2zX9;
       c2zX8: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zX9: // global
           I64[Sp - 8] = block_c2zWX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zXd; else goto c2zWY;
       u2zXd: // global
           call _c2zWX(R1) args: 0, res: 0, upd: 0;
       c2zWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zWX() //  [R1]
         { info_tbl: [(c2zWX,
                       label: block_c2zWX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zWX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zXc; else goto c2zXb;
       c2zXc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zXb: // global
           (_c2zX3::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2zX3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.140929797 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.141529031 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.142104286 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.142686735 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.143249213 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.1439264 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.144498125 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.145076362 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.146501433 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.147116974 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.147697631 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.148262785 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.148847097 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.149770657 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.150347839 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.150989126 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.151605322 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.15220821 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.152771203 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.153405179 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.154022508 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.154585774 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.155166922 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.155749723 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.156368183 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.156967883 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.157585377 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.158283643 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.158918295 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.16011926 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.160691592 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.161231434 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.161904169 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.162469812 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.163381217 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { info_tbl: [(c2zXj,
                       label: GHC.Word.W8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zXn; else goto c2zXm;
       c2zXn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zXm: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.164419425 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { info_tbl: [(c2zXt,
                       label: GHC.Word.W16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zXx; else goto c2zXw;
       c2zXx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zXw: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.165454276 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { info_tbl: [(c2zXD,
                       label: GHC.Word.W32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zXH; else goto c2zXG;
       c2zXH: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zXG: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.166447158 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { info_tbl: [(c2zXN,
                       label: GHC.Word.W64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zXR; else goto c2zXQ;
       c2zXR: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zXQ: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.167329096 UTC

[GHC.Word.W8#_con_entry() //  [R1]
         { info_tbl: [(c2zXS,
                       label: GHC.Word.W8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.168074106 UTC

[GHC.Word.W16#_con_entry() //  [R1]
         { info_tbl: [(c2zXU,
                       label: GHC.Word.W16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.168797708 UTC

[GHC.Word.W32#_con_entry() //  [R1]
         { info_tbl: [(c2zXW,
                       label: GHC.Word.W32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXW: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.1695696 UTC

[GHC.Word.W64#_con_entry() //  [R1]
         { info_tbl: [(c2zXY,
                       label: GHC.Word.W64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zXY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.170229154 UTC

[section ""relreadonly" . S2vim_srt" {
     S2vim_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2uHi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.171808705 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:11.173508943 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2zY7,
                       label: GHC.Word.$fEnumWord8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zY7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zYe; else goto c2zYf;
       c2zYe: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zYf: // global
           I64[Sp - 8] = block_c2zY4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zYj; else goto c2zY5;
       u2zYj: // global
           call _c2zY4(R1) args: 0, res: 0, upd: 0;
       c2zY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zY4() //  [R1]
         { info_tbl: [(c2zY4,
                       label: block_c2zY4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zY4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zYi; else goto c2zYh;
       c2zYi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zYh: // global
           _s2uFW::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.1807387 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2zYB,
                       label: GHC.Word.$fEnumWord16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zYB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zYI; else goto c2zYJ;
       c2zYI: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zYJ: // global
           I64[Sp - 8] = block_c2zYy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zYN; else goto c2zYz;
       u2zYN: // global
           call _c2zYy(R1) args: 0, res: 0, upd: 0;
       c2zYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zYy() //  [R1]
         { info_tbl: [(c2zYy,
                       label: block_c2zYy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zYy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zYM; else goto c2zYL;
       c2zYM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zYL: // global
           _s2uG0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.186945818 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2zZ5,
                       label: GHC.Word.$fEnumWord32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zZ5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zZc; else goto c2zZd;
       c2zZc: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zZd: // global
           I64[Sp - 8] = block_c2zZ2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zZh; else goto c2zZ3;
       u2zZh: // global
           call _c2zZ2(R1) args: 0, res: 0, upd: 0;
       c2zZ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2zZ2() //  [R1]
         { info_tbl: [(c2zZ2,
                       label: block_c2zZ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zZ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zZg; else goto c2zZf;
       c2zZg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zZf: // global
           _s2uG4::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.193668553 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2zZy,
                       label: GHC.Word.$fNumWord64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zZy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zZC; else goto c2zZD;
       c2zZC: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zZD: // global
           I64[Sp - 8] = block_c2zZw_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2zZw() //  [R1]
         { info_tbl: [(c2zZw,
                       label: block_c2zZw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zZw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zZG; else goto c2zZF;
       c2zZG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2zZF: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.200657652 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { info_tbl: [(c2zZU,
                       label: GHC.Word.$fNumWord64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2zZU: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.205511672 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { info_tbl: [(c2A0a,
                       label: GHC.Word.$fNumWord64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A0a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A0n; else goto c2A0o;
       c2A0n: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A0o: // global
           I64[Sp - 8] = block_c2A07_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A0s; else goto c2A08;
       u2A0s: // global
           call _c2A07(R1) args: 0, res: 0, upd: 0;
       c2A08: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A07() //  [R1]
         { info_tbl: [(c2A07,
                       label: block_c2A07_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A07: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A0r; else goto c2A0q;
       c2A0r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A0q: // global
           _s2uGd::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.212552291 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2A0K,
                       label: GHC.Word.$fNumWord64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A0K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A0W; else goto c2A0X;
       c2A0W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A0X: // global
           I64[Sp - 16] = block_c2A0H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A13; else goto c2A0I;
       u2A13: // global
           call _c2A0H(R1) args: 0, res: 0, upd: 0;
       c2A0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A0H() //  [R1]
         { info_tbl: [(c2A0H,
                       label: block_c2A0H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A0H: // global
           I64[Sp] = block_c2A0N_info;
           _s2uGh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGh::I64;
           if (R1 & 7 != 0) goto u2A12; else goto c2A0O;
       u2A12: // global
           call _c2A0N(R1) args: 0, res: 0, upd: 0;
       c2A0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A0N() //  [R1]
         { info_tbl: [(c2A0N,
                       label: block_c2A0N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A0N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A11; else goto c2A10;
       c2A11: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A10: // global
           _s2uGk::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.220873805 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2A1r,
                       label: GHC.Word.$fNumWord64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A1r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A1D; else goto c2A1E;
       c2A1D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A1E: // global
           I64[Sp - 16] = block_c2A1o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A1K; else goto c2A1p;
       u2A1K: // global
           call _c2A1o(R1) args: 0, res: 0, upd: 0;
       c2A1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A1o() //  [R1]
         { info_tbl: [(c2A1o,
                       label: block_c2A1o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A1o: // global
           I64[Sp] = block_c2A1u_info;
           _s2uGo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGo::I64;
           if (R1 & 7 != 0) goto u2A1J; else goto c2A1v;
       u2A1J: // global
           call _c2A1u(R1) args: 0, res: 0, upd: 0;
       c2A1v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A1u() //  [R1]
         { info_tbl: [(c2A1u,
                       label: block_c2A1u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A1u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A1I; else goto c2A1H;
       c2A1I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A1H: // global
           _s2uGr::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.229732271 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2A28,
                       label: GHC.Word.$fNumWord64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A28: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A2k; else goto c2A2l;
       c2A2k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A2l: // global
           I64[Sp - 16] = block_c2A25_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A2r; else goto c2A26;
       u2A2r: // global
           call _c2A25(R1) args: 0, res: 0, upd: 0;
       c2A26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A25() //  [R1]
         { info_tbl: [(c2A25,
                       label: block_c2A25_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A25: // global
           I64[Sp] = block_c2A2b_info;
           _s2uGv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGv::I64;
           if (R1 & 7 != 0) goto u2A2q; else goto c2A2c;
       u2A2q: // global
           call _c2A2b(R1) args: 0, res: 0, upd: 0;
       c2A2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A2b() //  [R1]
         { info_tbl: [(c2A2b,
                       label: block_c2A2b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A2b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A2p; else goto c2A2o;
       c2A2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A2o: // global
           _s2uGy::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.237552179 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.239638108 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { info_tbl: [(c2A2P,
                       label: lvl_r2uFF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A2P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A2Q; else goto c2A2R;
       c2A2Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A2R: // global
           (_c2A2M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A2M::I64 == 0) goto c2A2O; else goto c2A2N;
       c2A2O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A2N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A2M::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.244381277 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2A36,
                       label: GHC.Word.$fIntegralWord64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A36: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A37; else goto c2A38;
       c2A37: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A38: // global
           I64[Sp - 8] = block_c2A33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A3k; else goto c2A34;
       u2A3k: // global
           call _c2A33(R1) args: 0, res: 0, upd: 0;
       c2A34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A33() //  [R1]
         { info_tbl: [(c2A33,
                       label: block_c2A33_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A33: // global
           _s2uGB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGB::I64, 0)) goto c2A3i; else goto c2A3j;
       c2A3i: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2A3j: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.251233749 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2uGF_entry() //  [R1]
         { info_tbl: [(c2A3F,
                       label: w1_s2uGF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A3F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A3G; else goto c2A3H;
       c2A3G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A3H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2A3C_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A3T; else goto c2A3D;
       u2A3T: // global
           call _c2A3C(R1) args: 0, res: 0, upd: 0;
       c2A3D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2A3C() //  [R1]
         { info_tbl: [(c2A3C,
                       label: block_c2A3C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A3C: // global
           _s2uGH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGH::I64, 0)) goto c2A3R; else goto c2A3S;
       c2A3R: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2A3S: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uGO_entry() //  [R1, R2]
         { info_tbl: [(c2A42,
                       label: sat_s2uGO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A42: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A43; else goto c2A44;
       c2A43: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A44: // global
           I64[Sp - 8] = block_c2A3Z_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A3Z() //  [R1, R2]
         { info_tbl: [(c2A3Z,
                       label: block_c2A3Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A3Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A47; else goto c2A46;
       c2A47: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A46: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { info_tbl: [(c2A48,
                       label: GHC.Word.$fShowWord3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A48: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2A4c; else goto c2A4b;
       c2A4c: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A4b: // global
           I64[Hp - 32] = w1_s2uGF_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2uGO_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.263510666 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2A4D,
                       label: GHC.Word.$fShowWord64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A4D: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.267300465 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { info_tbl: [(c2A4Q,
                       label: GHC.Word.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A4Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A4R; else goto c2A4S;
       c2A4R: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A4S: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2A4Z; else goto c2A56;
       c2A4Z: // global
           I64[Sp - 8] = block_c2A4X_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2A56: // global
           I64[Sp - 8] = block_c2A55_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A4X() //  [R1]
         { info_tbl: [(c2A4X,
                       label: block_c2A4X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A4X: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2A55() //  [R1]
         { info_tbl: [(c2A55,
                       label: block_c2A55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A55: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.275648351 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { info_tbl: [(c2A5t,
                       label: GHC.Word.$fShowWord64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A5t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A5z; else goto c2A5A;
       c2A5z: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A5A: // global
           I64[Sp - 8] = block_c2A5q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A5F; else goto c2A5r;
       u2A5F: // global
           call _c2A5q(R1) args: 0, res: 0, upd: 0;
       c2A5r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A5q() //  [R1]
         { info_tbl: [(c2A5q,
                       label: block_c2A5q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A5q: // global
           I64[Sp] = block_c2A5w_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A5w() //  [R1, R2]
         { info_tbl: [(c2A5w,
                       label: block_c2A5w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A5w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A5E; else goto c2A5D;
       c2A5E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A5D: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.28447876 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2uH4_entry() //  [R1]
         { info_tbl: [(c2A64,
                       label: w1_s2uH4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A64: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A65; else goto c2A66;
       c2A65: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A66: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2A61_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A6i; else goto c2A62;
       u2A6i: // global
           call _c2A61(R1) args: 0, res: 0, upd: 0;
       c2A62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2A61() //  [R1]
         { info_tbl: [(c2A61,
                       label: block_c2A61_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A61: // global
           _s2uH6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uH6::I64, 0)) goto c2A6g; else goto c2A6h;
       c2A6g: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2A6h: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uHf_entry() //  [R1, R2]
         { info_tbl: [(c2A6r,
                       label: sat_s2uHf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A6x; else goto c2A6y;
       c2A6x: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A6y: // global
           I64[Sp - 24] = block_c2A6o_info;
           _s2uH4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2uH4::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A6D; else goto c2A6p;
       u2A6D: // global
           call _c2A6o(R1) args: 0, res: 0, upd: 0;
       c2A6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A6o() //  [R1]
         { info_tbl: [(c2A6o,
                       label: block_c2A6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A6o: // global
           _s2uH9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2A6u_info;
           R4 = _s2uH9::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A6u() //  [R1, R2]
         { info_tbl: [(c2A6u,
                       label: block_c2A6u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A6u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A6C; else goto c2A6B;
       c2A6C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A6B: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c2A6E,
                       label: GHC.Word.$fShowWord64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A6E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2A6I; else goto c2A6H;
       c2A6I: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A6H: // global
           I64[Hp - 40] = w1_s2uH4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2uHf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.298503021 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.300638399 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { info_tbl: [(c2A7e,
                       label: GHC.Word.$fEnumWord5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A7e: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.304675129 UTC

[section ""data" . sat_s2uHh_closure" {
     sat_s2uHh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.306468687 UTC

[section ""data" . sat_s2uHi_closure" {
     sat_s2uHi_closure:
         const :_con_info;
         const sat_s2uHh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.308469698 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { info_tbl: [(c2A7t,
                       label: GHC.Word.$fRealWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A7u; else goto c2A7v;
       c2A7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A7v: // global
           (_c2A7q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A7q::I64 == 0) goto c2A7s; else goto c2A7r;
       c2A7s: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A7r: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A7q::I64;
           R3 = sat_s2uHi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.31353905 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { info_tbl: [(c2A7J,
                       label: GHC.Word.$w$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A7J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A7K; else goto c2A7L;
       c2A7K: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A7L: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2A7W; else goto c2A88;
       c2A7W: // global
           I64[Sp - 8] = block_c2A7Q_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2A88: // global
           I64[Sp - 8] = block_c2A83_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A7Q() //  [R1]
         { info_tbl: [(c2A7Q,
                       label: block_c2A7Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A7Q: // global
           I64[Sp] = block_c2A7U_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A7U() //  [R1]
         { info_tbl: [(c2A7U,
                       label: block_c2A7U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A7U: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2A83() //  [R1]
         { info_tbl: [(c2A83,
                       label: block_c2A83_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A83: // global
           I64[Sp] = block_c2A87_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A87() //  [R1]
         { info_tbl: [(c2A87,
                       label: block_c2A87_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A87: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.324447473 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2A8C,
                       label: GHC.Word.$fRealWord64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A8C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A8I; else goto c2A8J;
       c2A8I: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A8J: // global
           I64[Sp - 8] = block_c2A8z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A8O; else goto c2A8A;
       u2A8O: // global
           call _c2A8z(R1) args: 0, res: 0, upd: 0;
       c2A8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A8z() //  [R1]
         { info_tbl: [(c2A8z,
                       label: block_c2A8z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A8z: // global
           I64[Sp] = block_c2A8F_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2A8F() //  [R1, R2]
         { info_tbl: [(c2A8F,
                       label: block_c2A8F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A8F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A8N; else goto c2A8M;
       c2A8N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A8M: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.33179011 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.334526992 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { info_tbl: [(c2A9b,
                       label: GHC.Word.$fEnumWord10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A9c; else goto c2A9d;
       c2A9c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A9d: // global
           (_c2A96::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A96::I64 == 0) goto c2A98; else goto c2A97;
       c2A98: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A97: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A96::I64;
           I64[Sp - 24] = block_c2A99_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2A99() //  [R1]
         { info_tbl: [(c2A99,
                       label: block_c2A99_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A99: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.34089774 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { info_tbl: [(c2A9z,
                       label: GHC.Word.$fEnumWord11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A9A; else goto c2A9B;
       c2A9A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A9B: // global
           (_c2A9u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A9u::I64 == 0) goto c2A9w; else goto c2A9v;
       c2A9w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A9v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A9u::I64;
           I64[Sp - 24] = block_c2A9x_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2A9x() //  [R1]
         { info_tbl: [(c2A9x,
                       label: block_c2A9x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9x: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.346953978 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { info_tbl: [(c2A9W,
                       label: GHC.Word.neWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aa0; else goto c2Aa1;
       c2Aa0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aa1: // global
           I64[Sp - 16] = block_c2A9T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Aaa; else goto c2A9U;
       u2Aaa: // global
           call _c2A9T(R1) args: 0, res: 0, upd: 0;
       c2A9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A9T() //  [R1]
         { info_tbl: [(c2A9T,
                       label: block_c2A9T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9T: // global
           I64[Sp] = block_c2A9Z_info;
           _s2uHB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHB::I64;
           if (R1 & 7 != 0) goto u2Aa9; else goto c2Aa3;
       u2Aa9: // global
           call _c2A9Z(R1) args: 0, res: 0, upd: 0;
       c2Aa3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2A9Z() //  [R1]
         { info_tbl: [(c2A9Z,
                       label: block_c2A9Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2A9Z: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.356282815 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { info_tbl: [(c2Aay,
                       label: lvl2_r2uFH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aay: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aaz; else goto c2AaA;
       c2Aaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AaA: // global
           (_c2Aav::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Aav::I64 == 0) goto c2Aax; else goto c2Aaw;
       c2Aax: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Aaw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Aav::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.360397818 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.363020712 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { info_tbl: [(c2AaQ,
                       label: GHC.Word.$fEnumWord8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AaQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AaR; else goto c2AaS;
       c2AaR: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AaS: // global
           I64[Sp - 8] = block_c2AaN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Aba; else goto c2AaO;
       u2Aba: // global
           call _c2AaN(R1) args: 0, res: 0, upd: 0;
       c2AaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AaN() //  [R1]
         { info_tbl: [(c2AaN,
                       label: block_c2AaN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AaN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AaX; else goto c2AaW;
       c2AaX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AaW: // global
           _s2uHI::I64 = I64[R1 + 7];
           if (_s2uHI::I64 != 0) goto c2Ab8; else goto c2Ab9;
       c2Ab8: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHI::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ab9: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.369783313 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.371600443 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.374320074 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { info_tbl: [(c2Abx,
                       label: GHC.Word.$fEnumWord8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Abx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Aby; else goto c2Abz;
       c2Aby: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Abz: // global
           I64[Sp - 8] = block_c2Abu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AbR; else goto c2Abv;
       u2AbR: // global
           call _c2Abu(R1) args: 0, res: 0, upd: 0;
       c2Abv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Abu() //  [R1]
         { info_tbl: [(c2Abu,
                       label: block_c2Abu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Abu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AbE; else goto c2AbD;
       c2AbE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AbD: // global
           _s2uHO::I64 = I64[R1 + 7];
           if (_s2uHO::I64 != 255) goto c2AbP; else goto c2AbQ;
       c2AbP: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHO::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AbQ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.38112775 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2Acc,
                       label: GHC.Word.$fShowWord8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Acc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Acq; else goto c2Acr;
       c2Acq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Acr: // global
           I64[Sp - 24] = block_c2Ac9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Acy; else goto c2Aca;
       u2Acy: // global
           call _c2Ac9(R1) args: 0, res: 0, upd: 0;
       c2Aca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ac9() //  [R1]
         { info_tbl: [(c2Ac9,
                       label: block_c2Ac9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ac9: // global
           I64[Sp] = block_c2Acf_info;
           _s2uHV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHV::I64;
           if (R1 & 7 != 0) goto u2Acx; else goto c2Acg;
       u2Acx: // global
           call _c2Acf(R1) args: 0, res: 0, upd: 0;
       c2Acg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Acf() //  [R1]
         { info_tbl: [(c2Acf,
                       label: block_c2Acf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Acf: // global
           _s2uHT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2Acn_info;
           R4 = _s2uHT::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Acn() //  [R1, R2]
         { info_tbl: [(c2Acn,
                       label: block_c2Acn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Acn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Acw; else goto c2Acv;
       c2Acw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Acv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.391628459 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { info_tbl: [(c2AcX,
                       label: GHC.Word.$fShowWord8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AcX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ad6; else goto c2Ad7;
       c2Ad6: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ad7: // global
           I64[Sp - 8] = block_c2AcU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Adc; else goto c2AcV;
       u2Adc: // global
           call _c2AcU(R1) args: 0, res: 0, upd: 0;
       c2AcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AcU() //  [R1]
         { info_tbl: [(c2AcU,
                       label: block_c2AcU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AcU: // global
           I64[Sp] = block_c2Ad3_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ad3() //  [R1, R2]
         { info_tbl: [(c2Ad3,
                       label: block_c2Ad3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ad3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Adb; else goto c2Ada;
       c2Adb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ada: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.400449931 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { info_tbl: [(c2Adx,
                       label: GHC.Word.$fShowWord4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Adx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AdG; else goto c2AdH;
       c2AdG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AdH: // global
           I64[Sp - 16] = block_c2Adu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AdM; else goto c2Adv;
       u2AdM: // global
           call _c2Adu(R1) args: 0, res: 0, upd: 0;
       c2Adv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Adu() //  [R1]
         { info_tbl: [(c2Adu,
                       label: block_c2Adu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Adu: // global
           _s2uIa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2AdD_info;
           R4 = _s2uIa::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AdD() //  [R1, R2]
         { info_tbl: [(c2AdD,
                       label: block_c2AdD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AdD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AdL; else goto c2AdK;
       c2AdL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AdK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.408135493 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2Ae4,
                       label: GHC.Word.$fShowWord8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ae4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.41190358 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.414479874 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { info_tbl: [(c2Aeg,
                       label: GHC.Word.$wlvl3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aeg: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.418601073 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c2Aew,
                       label: GHC.Word.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aew: // global
           _s2uIk::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2AeE; else goto c2Aev;
       c2Aev: // global
           if (%MO_S_Gt_W64(_s2uIk::I64, 255)) goto c2AeE; else goto c2AeI;
       c2AeE: // global
           R2 = _s2uIk::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2AeI: // global
           R1 = _s2uIk::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.422862411 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2AeV,
                       label: GHC.Word.$fEnumWord8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AeV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Af3; else goto c2Af4;
       c2Af3: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Af4: // global
           I64[Sp - 8] = block_c2AeS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Af9; else goto c2AeT;
       u2Af9: // global
           call _c2AeS(R1) args: 0, res: 0, upd: 0;
       c2AeT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AeS() //  [R1]
         { info_tbl: [(c2AeS,
                       label: block_c2AeS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AeS: // global
           I64[Sp] = block_c2AeY_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AeY() //  [R1]
         { info_tbl: [(c2AeY,
                       label: block_c2AeY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AeY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Af8; else goto c2Af7;
       c2Af8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Af7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.434721726 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2uIP_entry() //  [R1]
         { info_tbl: [(c2Ag4,
                       label: sat_s2uIP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ag4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ag5; else goto c2Ag6;
       c2Ag5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ag6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIN_entry() //  [R1]
         { info_tbl: [(c2Agg,
                       label: sat_s2uIN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Agg: // global
           _s2uIN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Agh; else goto c2Agi;
       c2Agi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Agk; else goto c2Agj;
       c2Agk: // global
           HpAlloc = 16;
           goto c2Agh;
       c2Agh: // global
           R1 = _s2uIN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Agj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIN::P64;
           _s2uII::I64 = I64[_s2uIN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2Agq; else goto c2Agf;
       c2Agf: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2Agq; else goto c2Agx;
       c2Agq: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Agx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIT_entry() //  [R1]
         { info_tbl: [(c2AgI,
                       label: sat_s2uIT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AgI: // global
           _s2uIT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AgJ; else goto c2AgK;
       c2AgK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AgM; else goto c2AgL;
       c2AgM: // global
           HpAlloc = 16;
           goto c2AgJ;
       c2AgJ: // global
           R1 = _s2uIT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AgL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIT::P64;
           _s2uII::I64 = I64[_s2uIT::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2AgS; else goto c2AgH;
       c2AgH: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2AgS; else goto c2AgZ;
       c2AgS: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AgZ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uIH_entry() //  [R1, R2]
         { info_tbl: [(c2Ah3,
                       label: go_dn_s2uIH_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ah3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Ah7; else goto c2Ah6;
       c2Ah7: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ah6: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2Ah1; else goto c2Ah2;
       c2Ah1: // global
           _s2uIF::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uIP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uIF::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uIN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ah2: // global
           I64[Hp - 80] = sat_s2uIT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Ah9::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Ah9::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uIU_entry() //  [R1]
         { info_tbl: [(c2Aha,
                       label: sat_s2uIU_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aha: // global
           _s2uIU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ahb; else goto c2Ahc;
       c2Ahc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Ahe; else goto c2Ahd;
       c2Ahe: // global
           HpAlloc = 24;
           goto c2Ahb;
       c2Ahb: // global
           R1 = _s2uIU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ahd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIU::P64;
           _s2uIx::I64 = I64[_s2uIU::P64 + 24];
           _s2uIF::I64 = _s2uIx::I64 - I64[_s2uIU::P64 + 16];
           _s2uIG::I64 = I64[_s2uIU::P64 + 32] - _s2uIF::I64;
           I64[Hp - 16] = go_dn_s2uIH_info;
           I64[Hp - 8] = _s2uIF::I64;
           I64[Hp] = _s2uIG::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIE_entry() //  [R1]
         { info_tbl: [(c2Aho,
                       label: sat_s2uIE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aho: // global
           _s2uIE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ahp; else goto c2Ahq;
       c2Ahq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ahs; else goto c2Ahr;
       c2Ahs: // global
           HpAlloc = 16;
           goto c2Ahp;
       c2Ahp: // global
           R1 = _s2uIE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ahr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIE::P64;
           _s2uIw::I64 = I64[_s2uIE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Ahy; else goto c2Ahn;
       c2Ahn: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Ahy; else goto c2AhF;
       c2Ahy: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AhF: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uIZ_entry() //  [R1]
         { info_tbl: [(c2AhT,
                       label: sat_s2uIZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AhT: // global
           _s2uIZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AhU; else goto c2AhV;
       c2AhV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AhX; else goto c2AhW;
       c2AhX: // global
           HpAlloc = 16;
           goto c2AhU;
       c2AhU: // global
           R1 = _s2uIZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AhW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIZ::P64;
           _s2uIw::I64 = I64[_s2uIZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Ai3; else goto c2AhS;
       c2AhS: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Ai3; else goto c2Aia;
       c2Ai3: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aia: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJg_entry() //  [R1]
         { info_tbl: [(c2AiG,
                       label: sat_s2uJg_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AiG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AiH; else goto c2AiI;
       c2AiH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AiI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJe_entry() //  [R1]
         { info_tbl: [(c2AiS,
                       label: sat_s2uJe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AiS: // global
           _s2uJe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AiT; else goto c2AiU;
       c2AiU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AiW; else goto c2AiV;
       c2AiW: // global
           HpAlloc = 16;
           goto c2AiT;
       c2AiT: // global
           R1 = _s2uJe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AiV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJe::P64;
           _s2uJ9::I64 = I64[_s2uJe::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2Aj2; else goto c2AiR;
       c2AiR: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2Aj2; else goto c2Aj9;
       c2Aj2: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aj9: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJk_entry() //  [R1]
         { info_tbl: [(c2Ajk,
                       label: sat_s2uJk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ajk: // global
           _s2uJk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ajl; else goto c2Ajm;
       c2Ajm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ajo; else goto c2Ajn;
       c2Ajo: // global
           HpAlloc = 16;
           goto c2Ajl;
       c2Ajl: // global
           R1 = _s2uJk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ajn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJk::P64;
           _s2uJ9::I64 = I64[_s2uJk::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2Aju; else goto c2Ajj;
       c2Ajj: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2Aju; else goto c2AjB;
       c2Aju: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AjB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uJ8_entry() //  [R1, R2]
         { info_tbl: [(c2AjF,
                       label: go_up_s2uJ8_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AjF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AjJ; else goto c2AjI;
       c2AjJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AjI: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2AjD; else goto c2AjE;
       c2AjD: // global
           _s2uJ6::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJg_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJ6::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AjE: // global
           I64[Hp - 80] = sat_s2uJk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AjL::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AjL::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uJl_entry() //  [R1]
         { info_tbl: [(c2AjM,
                       label: sat_s2uJl_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AjM: // global
           _s2uJl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AjN; else goto c2AjO;
       c2AjO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AjQ; else goto c2AjP;
       c2AjQ: // global
           HpAlloc = 24;
           goto c2AjN;
       c2AjN: // global
           R1 = _s2uJl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AjP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJl::P64;
           _s2uIx::I64 = I64[_s2uJl::P64 + 24];
           _s2uJ6::I64 = _s2uIx::I64 - I64[_s2uJl::P64 + 16];
           _s2uJ7::I64 = I64[_s2uJl::P64 + 32] - _s2uJ6::I64;
           I64[Hp - 16] = go_up_s2uJ8_info;
           I64[Hp - 8] = _s2uJ6::I64;
           I64[Hp] = _s2uJ7::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJ5_entry() //  [R1]
         { info_tbl: [(c2Ak0,
                       label: sat_s2uJ5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ak0: // global
           _s2uJ5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ak1; else goto c2Ak2;
       c2Ak2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ak4; else goto c2Ak3;
       c2Ak4: // global
           HpAlloc = 16;
           goto c2Ak1;
       c2Ak1: // global
           R1 = _s2uJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ak3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJ5::P64;
           _s2uIw::I64 = I64[_s2uJ5::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Aka; else goto c2AjZ;
       c2AjZ: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Aka; else goto c2Akh;
       c2Aka: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Akh: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJq_entry() //  [R1]
         { info_tbl: [(c2Akv,
                       label: sat_s2uJq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Akv: // global
           _s2uJq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Akw; else goto c2Akx;
       c2Akx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Akz; else goto c2Aky;
       c2Akz: // global
           HpAlloc = 16;
           goto c2Akw;
       c2Akw: // global
           R1 = _s2uJq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Aky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJq::P64;
           _s2uIw::I64 = I64[_s2uJq::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2AkF; else goto c2Aku;
       c2Aku: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2AkF; else goto c2AkM;
       c2AkF: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AkM: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AkN,
                       label: GHC.Word.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AkN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AkR; else goto c2AkQ;
       c2AkR: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AkQ: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2Al1; else goto c2Ala;
       c2Al1: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2AkU; else goto c2AkZ;
       c2AkU: // global
           I64[Hp - 80] = sat_s2uIU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uIE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AkZ: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2Al8; else goto c2AkX;
       c2AkX: // global
           I64[Hp - 80] = sat_s2uIZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AkV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AkV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ala: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2Al4; else goto c2Al9;
       c2Al4: // global
           I64[Hp - 80] = sat_s2uJl_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uJ5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Al9: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2Al8; else goto c2Al7;
       c2Al8: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Al7: // global
           I64[Hp - 80] = sat_s2uJq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Al5::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Al5::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.476474139 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AmP,
                       label: GHC.Word.$fEnumWord8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AmP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AmY; else goto c2AmZ;
       c2AmY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AmZ: // global
           I64[Sp - 24] = block_c2AmM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2An8; else goto c2AmN;
       u2An8: // global
           call _c2AmM(R1) args: 0, res: 0, upd: 0;
       c2AmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AmM() //  [R1]
         { info_tbl: [(c2AmM,
                       label: block_c2AmM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AmM: // global
           I64[Sp] = block_c2AmS_info;
           _s2uJv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJv::I64;
           if (R1 & 7 != 0) goto u2An7; else goto c2AmT;
       u2An7: // global
           call _c2AmS(R1) args: 0, res: 0, upd: 0;
       c2AmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AmS() //  [R1]
         { info_tbl: [(c2AmS,
                       label: block_c2AmS_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AmS: // global
           I64[Sp] = block_c2AmX_info;
           _s2uJx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uJx::I64;
           if (R1 & 7 != 0) goto u2An9; else goto c2An2;
       u2An9: // global
           call _c2AmX(R1) args: 0, res: 0, upd: 0;
       c2An2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AmX() //  [R1]
         { info_tbl: [(c2AmX,
                       label: block_c2AmX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AmX: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.487358005 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2uJN_entry() //  [R1]
         { info_tbl: [(c2AnS,
                       label: sat_s2uJN_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AnS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AnT; else goto c2AnU;
       c2AnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AnU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJG::I64 = I64[R1 + 32];
           if (_s2uJG::I64 == I64[R1 + 24]) goto c2AnR; else goto c2AnQ;
       c2AnR: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AnQ: // global
           R2 = _s2uJG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uJF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJK_entry() //  [R1]
         { info_tbl: [(c2Ao6,
                       label: sat_s2uJK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ao6: // global
           _s2uJK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ao7; else goto c2Ao8;
       c2Ao8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aoa; else goto c2Ao9;
       c2Aoa: // global
           HpAlloc = 16;
           goto c2Ao7;
       c2Ao7: // global
           R1 = _s2uJK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ao9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJK::P64;
           _s2uJG::I64 = I64[_s2uJK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJG::I64, 0)) goto c2Aog; else goto c2Ao5;
       c2Ao5: // global
           if (%MO_S_Gt_W64(_s2uJG::I64, 255)) goto c2Aog; else goto c2Aon;
       c2Aog: // global
           Hp = Hp - 16;
           R2 = _s2uJG::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aon: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uJF_entry() //  [R1, R2]
         { info_tbl: [(c2Aop,
                       label: go_s2uJF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aop: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Aot; else goto c2Aos;
       c2Aot: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Aos: // global
           _s2uJD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c2Aou,
                       label: GHC.Word.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aoy; else goto c2Aox;
       c2Aoy: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aox: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2AoA; else goto c2AoB;
       c2AoA: // global
           I64[Hp - 8] = go_s2uJF_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uJF_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2AoB: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.499555132 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2Ap4,
                       label: GHC.Word.$fEnumWord8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ap4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ap8; else goto c2Ap9;
       c2Ap8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ap9: // global
           I64[Sp - 16] = block_c2Ap1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Aph; else goto c2Ap2;
       u2Aph: // global
           call _c2Ap1(R1) args: 0, res: 0, upd: 0;
       c2Ap2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ap1() //  [R1]
         { info_tbl: [(c2Ap1,
                       label: block_c2Ap1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ap1: // global
           I64[Sp] = block_c2Ap7_info;
           _s2uJR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJR::I64;
           if (R1 & 7 != 0) goto u2Apg; else goto c2Apb;
       u2Apg: // global
           call _c2Ap7(R1) args: 0, res: 0, upd: 0;
       c2Apb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ap7() //  [R1]
         { info_tbl: [(c2Ap7,
                       label: block_c2Ap7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ap7: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.507989073 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2uK4_entry() //  [R1]
         { info_tbl: [(c2ApH,
                       label: sat_s2uK4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ApH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ApI; else goto c2ApT;
       c2ApI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ApT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJZ::I64 = I64[R1 + 16];
           if (_s2uJZ::I64 != 255) goto c2ApF; else goto c2ApG;
       c2ApF: // global
           I64[Sp - 24] = block_c2ApN_info;
           R2 = _s2uJZ::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2ApG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2ApN() //  [R1, R2]
         { info_tbl: [(c2ApN,
                       label: block_c2ApN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ApN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ApS; else goto c2ApR;
       c2ApS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2ApR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uJY_entry() //  [R1]
         { info_tbl: [(c2Aq3,
                       label: sat_s2uJY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aq3: // global
           _s2uJY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aq4; else goto c2Aq5;
       c2Aq5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aq7; else goto c2Aq6;
       c2Aq7: // global
           HpAlloc = 16;
           goto c2Aq4;
       c2Aq4: // global
           R1 = _s2uJY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Aq6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJY::P64;
           _s2uJU::I64 = I64[_s2uJY::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJU::I64, 0)) goto c2Aqd; else goto c2Aq2;
       c2Aq2: // global
           if (%MO_S_Gt_W64(_s2uJU::I64, 255)) goto c2Aqd; else goto c2Aqk;
       c2Aqd: // global
           Hp = Hp - 16;
           R2 = _s2uJU::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aqk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJU::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { info_tbl: [(c2Aql,
                       label: GHC.Word.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aql: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2Aqp; else goto c2Aqo;
       c2Aqp: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Aqo: // global
           I64[Hp - 40] = sat_s2uK4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uJY_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.519587669 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { info_tbl: [(c2AqQ,
                       label: GHC.Word.$fEnumWord8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AqQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AqR; else goto c2AqS;
       c2AqR: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AqS: // global
           I64[Sp - 8] = block_c2AqN_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AqN() //  [R1, R2]
         { info_tbl: [(c2AqN,
                       label: block_c2AqN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AqN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AqV; else goto c2AqU;
       c2AqV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AqU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.526282142 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2Arc,
                       label: GHC.Word.$fEnumWord8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Arc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ard; else goto c2Are;
       c2Ard: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Are: // global
           I64[Sp - 8] = block_c2Ar9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Arq; else goto c2Ara;
       u2Arq: // global
           call _c2Ar9(R1) args: 0, res: 0, upd: 0;
       c2Ara: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ar9() //  [R1]
         { info_tbl: [(c2Ar9,
                       label: block_c2Ar9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ar9: // global
           _s2uKc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uKc::I64, 255)) goto c2Aro; else goto c2Arp;
       c2Aro: // global
           R2 = _s2uKc::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2Arp: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.532549254 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2ArF,
                       label: GHC.Word.$fEnumWord8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ArF: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.537060599 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.539246259 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { info_tbl: [(c2ArW,
                       label: GHC.Word.$fEnumWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ArW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ArX; else goto c2ArY;
       c2ArX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ArY: // global
           (_c2ArR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2ArR::I64 == 0) goto c2ArT; else goto c2ArS;
       c2ArT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2ArS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2ArR::I64;
           I64[Sp - 24] = block_c2ArU_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2ArU() //  [R1]
         { info_tbl: [(c2ArU,
                       label: block_c2ArU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ArU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.546307866 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { info_tbl: [(c2Ask,
                       label: GHC.Word.$fEnumWord2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ask: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Asl; else goto c2Asm;
       c2Asl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Asm: // global
           (_c2Asf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Asf::I64 == 0) goto c2Ash; else goto c2Asg;
       c2Ash: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Asg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Asf::I64;
           I64[Sp - 24] = block_c2Asi_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2Asi() //  [R1]
         { info_tbl: [(c2Asi,
                       label: block_c2Asi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Asi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.552474703 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { info_tbl: [(c2AsH,
                       label: GHC.Word.neWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AsH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AsL; else goto c2AsM;
       c2AsL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AsM: // global
           I64[Sp - 16] = block_c2AsE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AsV; else goto c2AsF;
       u2AsV: // global
           call _c2AsE(R1) args: 0, res: 0, upd: 0;
       c2AsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AsE() //  [R1]
         { info_tbl: [(c2AsE,
                       label: block_c2AsE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AsE: // global
           I64[Sp] = block_c2AsK_info;
           _s2uKj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKj::I64;
           if (R1 & 7 != 0) goto u2AsU; else goto c2AsO;
       u2AsU: // global
           call _c2AsK(R1) args: 0, res: 0, upd: 0;
       c2AsO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AsK() //  [R1]
         { info_tbl: [(c2AsK,
                       label: block_c2AsK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AsK: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.560730893 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { info_tbl: [(c2Atj,
                       label: lvl4_r2uFJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Atj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Atk; else goto c2Atl;
       c2Atk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Atl: // global
           (_c2Atg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Atg::I64 == 0) goto c2Ati; else goto c2Ath;
       c2Ati: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Ath: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Atg::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.56473874 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.566961812 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { info_tbl: [(c2AtB,
                       label: GHC.Word.$fEnumWord16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AtB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AtC; else goto c2AtD;
       c2AtC: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AtD: // global
           I64[Sp - 8] = block_c2Aty_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AtV; else goto c2Atz;
       u2AtV: // global
           call _c2Aty(R1) args: 0, res: 0, upd: 0;
       c2Atz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Aty() //  [R1]
         { info_tbl: [(c2Aty,
                       label: block_c2Aty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aty: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AtI; else goto c2AtH;
       c2AtI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AtH: // global
           _s2uKq::I64 = I64[R1 + 7];
           if (_s2uKq::I64 != 0) goto c2AtT; else goto c2AtU;
       c2AtT: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AtU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.574067523 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.575851446 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.578275969 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { info_tbl: [(c2Aui,
                       label: GHC.Word.$fEnumWord16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Aui: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Auj; else goto c2Auk;
       c2Auj: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Auk: // global
           I64[Sp - 8] = block_c2Auf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AuC; else goto c2Aug;
       u2AuC: // global
           call _c2Auf(R1) args: 0, res: 0, upd: 0;
       c2Aug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Auf() //  [R1]
         { info_tbl: [(c2Auf,
                       label: block_c2Auf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Auf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aup; else goto c2Auo;
       c2Aup: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Auo: // global
           _s2uKw::I64 = I64[R1 + 7];
           if (_s2uKw::I64 != 65535) goto c2AuA; else goto c2AuB;
       c2AuA: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AuB: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.585993926 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AuX,
                       label: GHC.Word.$fShowWord16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AuX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Avb; else goto c2Avc;
       c2Avb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Avc: // global
           I64[Sp - 24] = block_c2AuU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Avj; else goto c2AuV;
       u2Avj: // global
           call _c2AuU(R1) args: 0, res: 0, upd: 0;
       c2AuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AuU() //  [R1]
         { info_tbl: [(c2AuU,
                       label: block_c2AuU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AuU: // global
           I64[Sp] = block_c2Av0_info;
           _s2uKD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKD::I64;
           if (R1 & 7 != 0) goto u2Avi; else goto c2Av1;
       u2Avi: // global
           call _c2Av0(R1) args: 0, res: 0, upd: 0;
       c2Av1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Av0() //  [R1]
         { info_tbl: [(c2Av0,
                       label: block_c2Av0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Av0: // global
           _s2uKB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2Av8_info;
           R4 = _s2uKB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Av8() //  [R1, R2]
         { info_tbl: [(c2Av8,
                       label: block_c2Av8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Av8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Avh; else goto c2Avg;
       c2Avh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Avg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.596311767 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { info_tbl: [(c2AvI,
                       label: GHC.Word.$fShowWord16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AvI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AvR; else goto c2AvS;
       c2AvR: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AvS: // global
           I64[Sp - 8] = block_c2AvF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AvX; else goto c2AvG;
       u2AvX: // global
           call _c2AvF(R1) args: 0, res: 0, upd: 0;
       c2AvG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AvF() //  [R1]
         { info_tbl: [(c2AvF,
                       label: block_c2AvF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AvF: // global
           I64[Sp] = block_c2AvO_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AvO() //  [R1, R2]
         { info_tbl: [(c2AvO,
                       label: block_c2AvO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AvO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AvW; else goto c2AvV;
       c2AvW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AvV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.605199718 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { info_tbl: [(c2Awi,
                       label: GHC.Word.$fShowWord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Awi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Awr; else goto c2Aws;
       c2Awr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aws: // global
           I64[Sp - 16] = block_c2Awf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Awx; else goto c2Awg;
       u2Awx: // global
           call _c2Awf(R1) args: 0, res: 0, upd: 0;
       c2Awg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Awf() //  [R1]
         { info_tbl: [(c2Awf,
                       label: block_c2Awf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Awf: // global
           _s2uKS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Awo_info;
           R4 = _s2uKS::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Awo() //  [R1, R2]
         { info_tbl: [(c2Awo,
                       label: block_c2Awo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Awo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Aww; else goto c2Awv;
       c2Aww: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Awv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.612981955 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2AwP,
                       label: GHC.Word.$fShowWord16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AwP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.616630822 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.619281064 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { info_tbl: [(c2Ax1,
                       label: GHC.Word.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ax1: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.623411846 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2Axh,
                       label: GHC.Word.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Axh: // global
           _s2uL2::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2Axp; else goto c2Axg;
       c2Axg: // global
           if (%MO_S_Gt_W64(_s2uL2::I64, 65535)) goto c2Axp; else goto c2Axt;
       c2Axp: // global
           R2 = _s2uL2::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2Axt: // global
           R1 = _s2uL2::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.628073619 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2AxG,
                       label: GHC.Word.$fEnumWord16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AxG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AxO; else goto c2AxP;
       c2AxO: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AxP: // global
           I64[Sp - 8] = block_c2AxD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AxU; else goto c2AxE;
       u2AxU: // global
           call _c2AxD(R1) args: 0, res: 0, upd: 0;
       c2AxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AxD() //  [R1]
         { info_tbl: [(c2AxD,
                       label: block_c2AxD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AxD: // global
           I64[Sp] = block_c2AxJ_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AxJ() //  [R1]
         { info_tbl: [(c2AxJ,
                       label: block_c2AxJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AxJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AxT; else goto c2AxS;
       c2AxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2AxS: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.640254804 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2uLx_entry() //  [R1]
         { info_tbl: [(c2AyP,
                       label: sat_s2uLx_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AyQ; else goto c2AyR;
       c2AyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AyR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLv_entry() //  [R1]
         { info_tbl: [(c2Az1,
                       label: sat_s2uLv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Az1: // global
           _s2uLv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Az2; else goto c2Az3;
       c2Az3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Az5; else goto c2Az4;
       c2Az5: // global
           HpAlloc = 16;
           goto c2Az2;
       c2Az2: // global
           R1 = _s2uLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Az4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLv::P64;
           _s2uLq::I64 = I64[_s2uLv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2Azb; else goto c2Az0;
       c2Az0: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2Azb; else goto c2Azi;
       c2Azb: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2Azi: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLB_entry() //  [R1]
         { info_tbl: [(c2Azt,
                       label: sat_s2uLB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Azt: // global
           _s2uLB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Azu; else goto c2Azv;
       c2Azv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Azx; else goto c2Azw;
       c2Azx: // global
           HpAlloc = 16;
           goto c2Azu;
       c2Azu: // global
           R1 = _s2uLB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Azw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLB::P64;
           _s2uLq::I64 = I64[_s2uLB::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2AzD; else goto c2Azs;
       c2Azs: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2AzD; else goto c2AzK;
       c2AzD: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AzK: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uLp_entry() //  [R1, R2]
         { info_tbl: [(c2AzO,
                       label: go_dn_s2uLp_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AzO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AzS; else goto c2AzR;
       c2AzS: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AzR: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2AzM; else goto c2AzN;
       c2AzM: // global
           _s2uLn::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLx_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLn::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AzN: // global
           I64[Hp - 80] = sat_s2uLB_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AzU::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AzU::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uLC_entry() //  [R1]
         { info_tbl: [(c2AzV,
                       label: sat_s2uLC_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AzV: // global
           _s2uLC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AzW; else goto c2AzX;
       c2AzX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AzZ; else goto c2AzY;
       c2AzZ: // global
           HpAlloc = 24;
           goto c2AzW;
       c2AzW: // global
           R1 = _s2uLC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AzY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLC::P64;
           _s2uLf::I64 = I64[_s2uLC::P64 + 24];
           _s2uLn::I64 = _s2uLf::I64 - I64[_s2uLC::P64 + 16];
           _s2uLo::I64 = I64[_s2uLC::P64 + 32] - _s2uLn::I64;
           I64[Hp - 16] = go_dn_s2uLp_info;
           I64[Hp - 8] = _s2uLn::I64;
           I64[Hp] = _s2uLo::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLm_entry() //  [R1]
         { info_tbl: [(c2AA9,
                       label: sat_s2uLm_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AA9: // global
           _s2uLm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AAa; else goto c2AAb;
       c2AAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AAd; else goto c2AAc;
       c2AAd: // global
           HpAlloc = 16;
           goto c2AAa;
       c2AAa: // global
           R1 = _s2uLm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AAc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLm::P64;
           _s2uLe::I64 = I64[_s2uLm::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2AAj; else goto c2AA8;
       c2AA8: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2AAj; else goto c2AAq;
       c2AAj: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AAq: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLH_entry() //  [R1]
         { info_tbl: [(c2AAE,
                       label: sat_s2uLH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AAE: // global
           _s2uLH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AAF; else goto c2AAG;
       c2AAG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AAI; else goto c2AAH;
       c2AAI: // global
           HpAlloc = 16;
           goto c2AAF;
       c2AAF: // global
           R1 = _s2uLH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AAH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLH::P64;
           _s2uLe::I64 = I64[_s2uLH::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2AAO; else goto c2AAD;
       c2AAD: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2AAO; else goto c2AAV;
       c2AAO: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AAV: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLY_entry() //  [R1]
         { info_tbl: [(c2ABr,
                       label: sat_s2uLY_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ABr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ABs; else goto c2ABt;
       c2ABs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ABt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLW_entry() //  [R1]
         { info_tbl: [(c2ABD,
                       label: sat_s2uLW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ABD: // global
           _s2uLW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ABE; else goto c2ABF;
       c2ABF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ABH; else goto c2ABG;
       c2ABH: // global
           HpAlloc = 16;
           goto c2ABE;
       c2ABE: // global
           R1 = _s2uLW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ABG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLW::P64;
           _s2uLR::I64 = I64[_s2uLW::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2ABN; else goto c2ABC;
       c2ABC: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2ABN; else goto c2ABU;
       c2ABN: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ABU: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM2_entry() //  [R1]
         { info_tbl: [(c2AC5,
                       label: sat_s2uM2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AC5: // global
           _s2uM2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AC6; else goto c2AC7;
       c2AC7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AC9; else goto c2AC8;
       c2AC9: // global
           HpAlloc = 16;
           goto c2AC6;
       c2AC6: // global
           R1 = _s2uM2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AC8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM2::P64;
           _s2uLR::I64 = I64[_s2uM2::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2ACf; else goto c2AC4;
       c2AC4: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2ACf; else goto c2ACm;
       c2ACf: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ACm: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uLQ_entry() //  [R1, R2]
         { info_tbl: [(c2ACq,
                       label: go_up_s2uLQ_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ACq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ACu; else goto c2ACt;
       c2ACu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ACt: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2ACo; else goto c2ACp;
       c2ACo: // global
           _s2uLO::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLY_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLO::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ACp: // global
           I64[Hp - 80] = sat_s2uM2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ACw::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ACw::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uM3_entry() //  [R1]
         { info_tbl: [(c2ACx,
                       label: sat_s2uM3_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ACx: // global
           _s2uM3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ACy; else goto c2ACz;
       c2ACz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ACB; else goto c2ACA;
       c2ACB: // global
           HpAlloc = 24;
           goto c2ACy;
       c2ACy: // global
           R1 = _s2uM3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ACA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM3::P64;
           _s2uLf::I64 = I64[_s2uM3::P64 + 24];
           _s2uLO::I64 = _s2uLf::I64 - I64[_s2uM3::P64 + 16];
           _s2uLP::I64 = I64[_s2uM3::P64 + 32] - _s2uLO::I64;
           I64[Hp - 16] = go_up_s2uLQ_info;
           I64[Hp - 8] = _s2uLO::I64;
           I64[Hp] = _s2uLP::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uLN_entry() //  [R1]
         { info_tbl: [(c2ACL,
                       label: sat_s2uLN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ACL: // global
           _s2uLN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ACM; else goto c2ACN;
       c2ACN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ACP; else goto c2ACO;
       c2ACP: // global
           HpAlloc = 16;
           goto c2ACM;
       c2ACM: // global
           R1 = _s2uLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ACO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLN::P64;
           _s2uLe::I64 = I64[_s2uLN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2ACV; else goto c2ACK;
       c2ACK: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2ACV; else goto c2AD2;
       c2ACV: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AD2: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uM8_entry() //  [R1]
         { info_tbl: [(c2ADg,
                       label: sat_s2uM8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ADg: // global
           _s2uM8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ADh; else goto c2ADi;
       c2ADi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ADk; else goto c2ADj;
       c2ADk: // global
           HpAlloc = 16;
           goto c2ADh;
       c2ADh: // global
           R1 = _s2uM8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ADj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM8::P64;
           _s2uLe::I64 = I64[_s2uM8::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2ADq; else goto c2ADf;
       c2ADf: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2ADq; else goto c2ADx;
       c2ADq: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ADx: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2ADy,
                       label: GHC.Word.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ADy: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ADC; else goto c2ADB;
       c2ADC: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ADB: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2ADM; else goto c2ADV;
       c2ADM: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2ADF; else goto c2ADK;
       c2ADF: // global
           I64[Hp - 80] = sat_s2uLC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADK: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2ADT; else goto c2ADI;
       c2ADI: // global
           I64[Hp - 80] = sat_s2uLH_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ADG::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ADG::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADV: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2ADP; else goto c2ADU;
       c2ADP: // global
           I64[Hp - 80] = sat_s2uM3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADU: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2ADT; else goto c2ADS;
       c2ADT: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADS: // global
           I64[Hp - 80] = sat_s2uM8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ADQ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ADQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.691180105 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AFA,
                       label: GHC.Word.$fEnumWord16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AFA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AFJ; else goto c2AFK;
       c2AFJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AFK: // global
           I64[Sp - 24] = block_c2AFx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AFT; else goto c2AFy;
       u2AFT: // global
           call _c2AFx(R1) args: 0, res: 0, upd: 0;
       c2AFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AFx() //  [R1]
         { info_tbl: [(c2AFx,
                       label: block_c2AFx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AFx: // global
           I64[Sp] = block_c2AFD_info;
           _s2uMd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMd::I64;
           if (R1 & 7 != 0) goto u2AFS; else goto c2AFE;
       u2AFS: // global
           call _c2AFD(R1) args: 0, res: 0, upd: 0;
       c2AFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AFD() //  [R1]
         { info_tbl: [(c2AFD,
                       label: block_c2AFD_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AFD: // global
           I64[Sp] = block_c2AFI_info;
           _s2uMf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uMf::I64;
           if (R1 & 7 != 0) goto u2AFU; else goto c2AFN;
       u2AFU: // global
           call _c2AFI(R1) args: 0, res: 0, upd: 0;
       c2AFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AFI() //  [R1]
         { info_tbl: [(c2AFI,
                       label: block_c2AFI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AFI: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.702281815 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2uMv_entry() //  [R1]
         { info_tbl: [(c2AGD,
                       label: sat_s2uMv_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AGE; else goto c2AGF;
       c2AGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMo::I64 = I64[R1 + 32];
           if (_s2uMo::I64 == I64[R1 + 24]) goto c2AGC; else goto c2AGB;
       c2AGC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AGB: // global
           R2 = _s2uMo::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uMn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMs_entry() //  [R1]
         { info_tbl: [(c2AGR,
                       label: sat_s2uMs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AGR: // global
           _s2uMs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AGS; else goto c2AGT;
       c2AGT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AGV; else goto c2AGU;
       c2AGV: // global
           HpAlloc = 16;
           goto c2AGS;
       c2AGS: // global
           R1 = _s2uMs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AGU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMs::P64;
           _s2uMo::I64 = I64[_s2uMs::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMo::I64, 0)) goto c2AH1; else goto c2AGQ;
       c2AGQ: // global
           if (%MO_S_Gt_W64(_s2uMo::I64, 65535)) goto c2AH1; else goto c2AH8;
       c2AH1: // global
           Hp = Hp - 16;
           R2 = _s2uMo::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AH8: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMo::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uMn_entry() //  [R1, R2]
         { info_tbl: [(c2AHa,
                       label: go_s2uMn_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AHa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AHe; else goto c2AHd;
       c2AHe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AHd: // global
           _s2uMl::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uMv_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uMl::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uMs_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2AHf,
                       label: GHC.Word.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AHf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AHj; else goto c2AHi;
       c2AHj: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AHi: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2AHl; else goto c2AHm;
       c2AHl: // global
           I64[Hp - 8] = go_s2uMn_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uMn_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2AHm: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.714752089 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2AHP,
                       label: GHC.Word.$fEnumWord16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AHP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AHT; else goto c2AHU;
       c2AHT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AHU: // global
           I64[Sp - 16] = block_c2AHM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AI2; else goto c2AHN;
       u2AI2: // global
           call _c2AHM(R1) args: 0, res: 0, upd: 0;
       c2AHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AHM() //  [R1]
         { info_tbl: [(c2AHM,
                       label: block_c2AHM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AHM: // global
           I64[Sp] = block_c2AHS_info;
           _s2uMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMz::I64;
           if (R1 & 7 != 0) goto u2AI1; else goto c2AHW;
       u2AI1: // global
           call _c2AHS(R1) args: 0, res: 0, upd: 0;
       c2AHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AHS() //  [R1]
         { info_tbl: [(c2AHS,
                       label: block_c2AHS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AHS: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.72397902 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2uMM_entry() //  [R1]
         { info_tbl: [(c2AIs,
                       label: sat_s2uMM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AIs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AIt; else goto c2AIE;
       c2AIt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMH::I64 = I64[R1 + 16];
           if (_s2uMH::I64 != 65535) goto c2AIq; else goto c2AIr;
       c2AIq: // global
           I64[Sp - 24] = block_c2AIy_info;
           R2 = _s2uMH::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2AIr: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2AIy() //  [R1, R2]
         { info_tbl: [(c2AIy,
                       label: block_c2AIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AIy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AID; else goto c2AIC;
       c2AID: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2AIC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uMG_entry() //  [R1]
         { info_tbl: [(c2AIO,
                       label: sat_s2uMG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AIO: // global
           _s2uMG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AIP; else goto c2AIQ;
       c2AIQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AIS; else goto c2AIR;
       c2AIS: // global
           HpAlloc = 16;
           goto c2AIP;
       c2AIP: // global
           R1 = _s2uMG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AIR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMG::P64;
           _s2uMC::I64 = I64[_s2uMG::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMC::I64, 0)) goto c2AIY; else goto c2AIN;
       c2AIN: // global
           if (%MO_S_Gt_W64(_s2uMC::I64, 65535)) goto c2AIY; else goto c2AJ5;
       c2AIY: // global
           Hp = Hp - 16;
           R2 = _s2uMC::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AJ5: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo_entry() //  [R2]
         { info_tbl: [(c2AJ6,
                       label: GHC.Word.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AJ6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2AJa; else goto c2AJ9;
       c2AJa: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJ9: // global
           I64[Hp - 40] = sat_s2uMM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uMG_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.734930416 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { info_tbl: [(c2AJB,
                       label: GHC.Word.$fEnumWord16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AJB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AJC; else goto c2AJD;
       c2AJC: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJD: // global
           I64[Sp - 8] = block_c2AJy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AJy() //  [R1, R2]
         { info_tbl: [(c2AJy,
                       label: block_c2AJy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AJy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AJG; else goto c2AJF;
       c2AJG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AJF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.741672444 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2AJX,
                       label: GHC.Word.$fEnumWord16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AJX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AJY; else goto c2AJZ;
       c2AJY: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJZ: // global
           I64[Sp - 8] = block_c2AJU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AKb; else goto c2AJV;
       u2AKb: // global
           call _c2AJU(R1) args: 0, res: 0, upd: 0;
       c2AJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AJU() //  [R1]
         { info_tbl: [(c2AJU,
                       label: block_c2AJU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AJU: // global
           _s2uMU::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uMU::I64, 65535)) goto c2AK9; else goto c2AKa;
       c2AK9: // global
           R2 = _s2uMU::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2AKa: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.747639915 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2AKq,
                       label: GHC.Word.$fEnumWord16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AKq: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.752005018 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.754259289 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { info_tbl: [(c2AKH,
                       label: GHC.Word.$fEnumWord3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AKH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AKI; else goto c2AKJ;
       c2AKI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AKJ: // global
           (_c2AKC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AKC::I64 == 0) goto c2AKE; else goto c2AKD;
       c2AKE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AKD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AKC::I64;
           I64[Sp - 24] = block_c2AKF_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2AKF() //  [R1]
         { info_tbl: [(c2AKF,
                       label: block_c2AKF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AKF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.761290133 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { info_tbl: [(c2AL5,
                       label: GHC.Word.$fEnumWord4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AL5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AL6; else goto c2AL7;
       c2AL6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AL7: // global
           (_c2AL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AL0::I64 == 0) goto c2AL2; else goto c2AL1;
       c2AL2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AL1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AL0::I64;
           I64[Sp - 24] = block_c2AL3_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2AL3() //  [R1]
         { info_tbl: [(c2AL3,
                       label: block_c2AL3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AL3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.767360908 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { info_tbl: [(c2ALs,
                       label: GHC.Word.neWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ALs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ALw; else goto c2ALx;
       c2ALw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ALx: // global
           I64[Sp - 16] = block_c2ALp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ALG; else goto c2ALq;
       u2ALG: // global
           call _c2ALp(R1) args: 0, res: 0, upd: 0;
       c2ALq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ALp() //  [R1]
         { info_tbl: [(c2ALp,
                       label: block_c2ALp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ALp: // global
           I64[Sp] = block_c2ALv_info;
           _s2uN1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uN1::I64;
           if (R1 & 7 != 0) goto u2ALF; else goto c2ALz;
       u2ALF: // global
           call _c2ALv(R1) args: 0, res: 0, upd: 0;
       c2ALz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ALv() //  [R1]
         { info_tbl: [(c2ALv,
                       label: block_c2ALv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ALv: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.775590063 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { info_tbl: [(c2AM4,
                       label: lvl6_r2uFL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AM5; else goto c2AM6;
       c2AM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AM6: // global
           (_c2AM1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AM1::I64 == 0) goto c2AM3; else goto c2AM2;
       c2AM3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AM2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AM1::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.77969642 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.782036008 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { info_tbl: [(c2AMm,
                       label: GHC.Word.$fEnumWord32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AMm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AMn; else goto c2AMo;
       c2AMn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AMo: // global
           I64[Sp - 8] = block_c2AMj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AMG; else goto c2AMk;
       u2AMG: // global
           call _c2AMj(R1) args: 0, res: 0, upd: 0;
       c2AMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AMj() //  [R1]
         { info_tbl: [(c2AMj,
                       label: block_c2AMj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AMj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AMt; else goto c2AMs;
       c2AMt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AMs: // global
           _s2uN8::I64 = I64[R1 + 7];
           if (_s2uN8::I64 != 0) goto c2AME; else goto c2AMF;
       c2AME: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uN8::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AMF: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.789015815 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.790805765 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.793078408 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { info_tbl: [(c2AN3,
                       label: GHC.Word.$fEnumWord32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AN3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AN4; else goto c2AN5;
       c2AN4: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AN5: // global
           I64[Sp - 8] = block_c2AN0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ANn; else goto c2AN1;
       u2ANn: // global
           call _c2AN0(R1) args: 0, res: 0, upd: 0;
       c2AN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AN0() //  [R1]
         { info_tbl: [(c2AN0,
                       label: block_c2AN0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AN0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ANa; else goto c2AN9;
       c2ANa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AN9: // global
           _s2uNe::I64 = I64[R1 + 7];
           if (_s2uNe::I64 != 4294967295) goto c2ANl; else goto c2ANm;
       c2ANl: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uNe::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ANm: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.800005112 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2ANJ,
                       label: GHC.Word.$fShowWord32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ANJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ANX; else goto c2ANY;
       c2ANX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ANY: // global
           I64[Sp - 24] = block_c2ANG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AO5; else goto c2ANH;
       u2AO5: // global
           call _c2ANG(R1) args: 0, res: 0, upd: 0;
       c2ANH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ANG() //  [R1]
         { info_tbl: [(c2ANG,
                       label: block_c2ANG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ANG: // global
           I64[Sp] = block_c2ANM_info;
           _s2uNl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uNl::I64;
           if (R1 & 7 != 0) goto u2AO4; else goto c2ANN;
       u2AO4: // global
           call _c2ANM(R1) args: 0, res: 0, upd: 0;
       c2ANN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ANM() //  [R1]
         { info_tbl: [(c2ANM,
                       label: block_c2ANM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ANM: // global
           _s2uNj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2ANU_info;
           R4 = _s2uNj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ANU() //  [R1, R2]
         { info_tbl: [(c2ANU,
                       label: block_c2ANU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ANU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AO3; else goto c2AO2;
       c2AO3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AO2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.810372024 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { info_tbl: [(c2AOu,
                       label: GHC.Word.$fShowWord32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AOu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AOD; else goto c2AOE;
       c2AOD: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AOE: // global
           I64[Sp - 8] = block_c2AOr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AOJ; else goto c2AOs;
       u2AOJ: // global
           call _c2AOr(R1) args: 0, res: 0, upd: 0;
       c2AOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AOr() //  [R1]
         { info_tbl: [(c2AOr,
                       label: block_c2AOr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AOr: // global
           I64[Sp] = block_c2AOA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AOA() //  [R1, R2]
         { info_tbl: [(c2AOA,
                       label: block_c2AOA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AOA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AOI; else goto c2AOH;
       c2AOI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AOH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.818843003 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { info_tbl: [(c2AP4,
                       label: GHC.Word.$fShowWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2APd; else goto c2APe;
       c2APd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2APe: // global
           I64[Sp - 16] = block_c2AP1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2APj; else goto c2AP2;
       u2APj: // global
           call _c2AP1(R1) args: 0, res: 0, upd: 0;
       c2AP2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AP1() //  [R1]
         { info_tbl: [(c2AP1,
                       label: block_c2AP1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AP1: // global
           _s2uNA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2APa_info;
           R4 = _s2uNA::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2APa() //  [R1, R2]
         { info_tbl: [(c2APa,
                       label: block_c2APa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2APa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2APi; else goto c2APh;
       c2APi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2APh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.826469813 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2APB,
                       label: GHC.Word.$fShowWord32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2APB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.830291522 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.832690026 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { info_tbl: [(c2APN,
                       label: GHC.Word.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2APN: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.83647392 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c2AQ3,
                       label: GHC.Word.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AQ3: // global
           _s2uNK::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2AQb; else goto c2AQ2;
       c2AQ2: // global
           if (%MO_S_Gt_W64(_s2uNK::I64,
                            4294967295)) goto c2AQb; else goto c2AQf;
       c2AQb: // global
           R2 = _s2uNK::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2AQf: // global
           R1 = _s2uNK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.840944176 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2AQt,
                       label: GHC.Word.$fEnumWord32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AQt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AQB; else goto c2AQC;
       c2AQB: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AQC: // global
           I64[Sp - 8] = block_c2AQq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AQH; else goto c2AQr;
       u2AQH: // global
           call _c2AQq(R1) args: 0, res: 0, upd: 0;
       c2AQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AQq() //  [R1]
         { info_tbl: [(c2AQq,
                       label: block_c2AQq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AQq: // global
           I64[Sp] = block_c2AQw_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2AQw() //  [R1]
         { info_tbl: [(c2AQw,
                       label: block_c2AQw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AQw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AQG; else goto c2AQF;
       c2AQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2AQF: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.854002937 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2uOf_entry() //  [R1]
         { info_tbl: [(c2ARC,
                       label: sat_s2uOf_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ARC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ARD; else goto c2ARE;
       c2ARD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ARE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOd_entry() //  [R1]
         { info_tbl: [(c2ARO,
                       label: sat_s2uOd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ARO: // global
           _s2uOd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ARP; else goto c2ARQ;
       c2ARQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ARS; else goto c2ARR;
       c2ARS: // global
           HpAlloc = 16;
           goto c2ARP;
       c2ARP: // global
           R1 = _s2uOd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ARR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOd::P64;
           _s2uO8::I64 = I64[_s2uOd::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2ARY; else goto c2ARN;
       c2ARN: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2ARY; else goto c2AS5;
       c2ARY: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AS5: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOj_entry() //  [R1]
         { info_tbl: [(c2ASg,
                       label: sat_s2uOj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ASg: // global
           _s2uOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASh; else goto c2ASi;
       c2ASi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ASk; else goto c2ASj;
       c2ASk: // global
           HpAlloc = 16;
           goto c2ASh;
       c2ASh: // global
           R1 = _s2uOj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOj::P64;
           _s2uO8::I64 = I64[_s2uOj::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2ASq; else goto c2ASf;
       c2ASf: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2ASq; else goto c2ASx;
       c2ASq: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ASx: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2uO7_entry() //  [R1, R2]
         { info_tbl: [(c2ASB,
                       label: go_dn_s2uO7_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ASB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ASF; else goto c2ASE;
       c2ASF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ASE: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2ASz; else goto c2ASA;
       c2ASz: // global
           _s2uO5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOf_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uO5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ASA: // global
           I64[Hp - 80] = sat_s2uOj_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ASH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ASH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOk_entry() //  [R1]
         { info_tbl: [(c2ASI,
                       label: sat_s2uOk_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ASI: // global
           _s2uOk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASJ; else goto c2ASK;
       c2ASK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ASM; else goto c2ASL;
       c2ASM: // global
           HpAlloc = 24;
           goto c2ASJ;
       c2ASJ: // global
           R1 = _s2uOk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOk::P64;
           _s2uNX::I64 = I64[_s2uOk::P64 + 24];
           _s2uO5::I64 = _s2uNX::I64 - I64[_s2uOk::P64 + 16];
           _s2uO6::I64 = I64[_s2uOk::P64 + 32] - _s2uO5::I64;
           I64[Hp - 16] = go_dn_s2uO7_info;
           I64[Hp - 8] = _s2uO5::I64;
           I64[Hp] = _s2uO6::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uO4_entry() //  [R1]
         { info_tbl: [(c2ASW,
                       label: sat_s2uO4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ASW: // global
           _s2uO4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASX; else goto c2ASY;
       c2ASY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AT0; else goto c2ASZ;
       c2AT0: // global
           HpAlloc = 16;
           goto c2ASX;
       c2ASX: // global
           R1 = _s2uO4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uO4::P64;
           _s2uNW::I64 = I64[_s2uO4::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AT6; else goto c2ASV;
       c2ASV: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AT6; else goto c2ATd;
       c2AT6: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ATd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOp_entry() //  [R1]
         { info_tbl: [(c2ATr,
                       label: sat_s2uOp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ATr: // global
           _s2uOp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ATs; else goto c2ATt;
       c2ATt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ATv; else goto c2ATu;
       c2ATv: // global
           HpAlloc = 16;
           goto c2ATs;
       c2ATs: // global
           R1 = _s2uOp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ATu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOp::P64;
           _s2uNW::I64 = I64[_s2uOp::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2ATB; else goto c2ATq;
       c2ATq: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2ATB; else goto c2ATI;
       c2ATB: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ATI: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOG_entry() //  [R1]
         { info_tbl: [(c2AUe,
                       label: sat_s2uOG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUf; else goto c2AUg;
       c2AUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOE_entry() //  [R1]
         { info_tbl: [(c2AUq,
                       label: sat_s2uOE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AUq: // global
           _s2uOE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUr; else goto c2AUs;
       c2AUs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AUu; else goto c2AUt;
       c2AUu: // global
           HpAlloc = 16;
           goto c2AUr;
       c2AUr: // global
           R1 = _s2uOE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOE::P64;
           _s2uOz::I64 = I64[_s2uOE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2AUA; else goto c2AUp;
       c2AUp: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2AUA; else goto c2AUH;
       c2AUA: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AUH: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOK_entry() //  [R1]
         { info_tbl: [(c2AUS,
                       label: sat_s2uOK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AUS: // global
           _s2uOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUT; else goto c2AUU;
       c2AUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AUW; else goto c2AUV;
       c2AUW: // global
           HpAlloc = 16;
           goto c2AUT;
       c2AUT: // global
           R1 = _s2uOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOK::P64;
           _s2uOz::I64 = I64[_s2uOK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2AV2; else goto c2AUR;
       c2AUR: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2AV2; else goto c2AV9;
       c2AV2: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AV9: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2uOy_entry() //  [R1, R2]
         { info_tbl: [(c2AVd,
                       label: go_up_s2uOy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AVd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AVh; else goto c2AVg;
       c2AVh: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AVg: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2AVb; else goto c2AVc;
       c2AVb: // global
           _s2uOw::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uOw::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AVc: // global
           I64[Hp - 80] = sat_s2uOK_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AVj::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AVj::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2uOL_entry() //  [R1]
         { info_tbl: [(c2AVk,
                       label: sat_s2uOL_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AVk: // global
           _s2uOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AVl; else goto c2AVm;
       c2AVm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AVo; else goto c2AVn;
       c2AVo: // global
           HpAlloc = 24;
           goto c2AVl;
       c2AVl: // global
           R1 = _s2uOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AVn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOL::P64;
           _s2uNX::I64 = I64[_s2uOL::P64 + 24];
           _s2uOw::I64 = _s2uNX::I64 - I64[_s2uOL::P64 + 16];
           _s2uOx::I64 = I64[_s2uOL::P64 + 32] - _s2uOw::I64;
           I64[Hp - 16] = go_up_s2uOy_info;
           I64[Hp - 8] = _s2uOw::I64;
           I64[Hp] = _s2uOx::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOv_entry() //  [R1]
         { info_tbl: [(c2AVy,
                       label: sat_s2uOv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AVy: // global
           _s2uOv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AVz; else goto c2AVA;
       c2AVA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AVC; else goto c2AVB;
       c2AVC: // global
           HpAlloc = 16;
           goto c2AVz;
       c2AVz: // global
           R1 = _s2uOv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOv::P64;
           _s2uNW::I64 = I64[_s2uOv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AVI; else goto c2AVx;
       c2AVx: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AVI; else goto c2AVP;
       c2AVI: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AVP: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uOQ_entry() //  [R1]
         { info_tbl: [(c2AW3,
                       label: sat_s2uOQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AW3: // global
           _s2uOQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AW4; else goto c2AW5;
       c2AW5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AW7; else goto c2AW6;
       c2AW7: // global
           HpAlloc = 16;
           goto c2AW4;
       c2AW4: // global
           R1 = _s2uOQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AW6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOQ::P64;
           _s2uNW::I64 = I64[_s2uOQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AWd; else goto c2AW2;
       c2AW2: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AWd; else goto c2AWk;
       c2AWd: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AWk: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AWl,
                       label: GHC.Word.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AWl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AWp; else goto c2AWo;
       c2AWp: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AWo: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2AWz; else goto c2AWI;
       c2AWz: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2AWs; else goto c2AWx;
       c2AWs: // global
           I64[Hp - 80] = sat_s2uOk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uO4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWx: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2AWG; else goto c2AWv;
       c2AWv: // global
           I64[Hp - 80] = sat_s2uOp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AWt::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AWt::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWI: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2AWC; else goto c2AWH;
       c2AWC: // global
           I64[Hp - 80] = sat_s2uOL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uOv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWH: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2AWG; else goto c2AWF;
       c2AWG: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWF: // global
           I64[Hp - 80] = sat_s2uOQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AWD::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AWD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.895932779 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2AYv,
                       label: GHC.Word.$fEnumWord32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AYv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AYE; else goto c2AYF;
       c2AYE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AYF: // global
           I64[Sp - 24] = block_c2AYs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AYO; else goto c2AYt;
       u2AYO: // global
           call _c2AYs(R1) args: 0, res: 0, upd: 0;
       c2AYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AYs() //  [R1]
         { info_tbl: [(c2AYs,
                       label: block_c2AYs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AYs: // global
           I64[Sp] = block_c2AYy_info;
           _s2uOV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uOV::I64;
           if (R1 & 7 != 0) goto u2AYN; else goto c2AYz;
       u2AYN: // global
           call _c2AYy(R1) args: 0, res: 0, upd: 0;
       c2AYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AYy() //  [R1]
         { info_tbl: [(c2AYy,
                       label: block_c2AYy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AYy: // global
           I64[Sp] = block_c2AYD_info;
           _s2uOX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uOX::I64;
           if (R1 & 7 != 0) goto u2AYP; else goto c2AYI;
       u2AYP: // global
           call _c2AYD(R1) args: 0, res: 0, upd: 0;
       c2AYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2AYD() //  [R1]
         { info_tbl: [(c2AYD,
                       label: block_c2AYD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AYD: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.906093916 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2uPd_entry() //  [R1]
         { info_tbl: [(c2AZy,
                       label: sat_s2uPd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AZy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AZz; else goto c2AZA;
       c2AZz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AZA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uP6::I64 = I64[R1 + 32];
           if (_s2uP6::I64 == I64[R1 + 24]) goto c2AZx; else goto c2AZw;
       c2AZx: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AZw: // global
           R2 = _s2uP6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uP5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPa_entry() //  [R1]
         { info_tbl: [(c2AZM,
                       label: sat_s2uPa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2AZM: // global
           _s2uPa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AZN; else goto c2AZO;
       c2AZO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AZQ; else goto c2AZP;
       c2AZQ: // global
           HpAlloc = 16;
           goto c2AZN;
       c2AZN: // global
           R1 = _s2uPa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AZP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPa::P64;
           _s2uP6::I64 = I64[_s2uPa::P64 + 16];
           if (%MO_S_Lt_W64(_s2uP6::I64, 0)) goto c2AZW; else goto c2AZL;
       c2AZL: // global
           if (%MO_S_Gt_W64(_s2uP6::I64,
                            4294967295)) goto c2AZW; else goto c2B03;
       c2AZW: // global
           Hp = Hp - 16;
           R2 = _s2uP6::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2B03: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uP6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2uP5_entry() //  [R1, R2]
         { info_tbl: [(c2B05,
                       label: go_s2uP5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B05: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2B09; else goto c2B08;
       c2B09: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B08: // global
           _s2uP3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uPd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uP3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uPa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c2B0a,
                       label: GHC.Word.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B0a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B0e; else goto c2B0d;
       c2B0e: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B0d: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2B0g; else goto c2B0h;
       c2B0g: // global
           I64[Hp - 8] = go_s2uP5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uP5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2B0h: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.918648397 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2B0L,
                       label: GHC.Word.$fEnumWord32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B0L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B0P; else goto c2B0Q;
       c2B0P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B0Q: // global
           I64[Sp - 16] = block_c2B0I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B0Y; else goto c2B0J;
       u2B0Y: // global
           call _c2B0I(R1) args: 0, res: 0, upd: 0;
       c2B0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B0I() //  [R1]
         { info_tbl: [(c2B0I,
                       label: block_c2B0I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B0I: // global
           I64[Sp] = block_c2B0O_info;
           _s2uPh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPh::I64;
           if (R1 & 7 != 0) goto u2B0X; else goto c2B0S;
       u2B0X: // global
           call _c2B0O(R1) args: 0, res: 0, upd: 0;
       c2B0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B0O() //  [R1]
         { info_tbl: [(c2B0O,
                       label: block_c2B0O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B0O: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.927825945 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2uPu_entry() //  [R1]
         { info_tbl: [(c2B1o,
                       label: sat_s2uPu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B1o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2B1p; else goto c2B1A;
       c2B1p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B1A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uPp::I64 = I64[R1 + 16];
           if (_s2uPp::I64 != 4294967295) goto c2B1m; else goto c2B1n;
       c2B1m: // global
           I64[Sp - 24] = block_c2B1u_info;
           R2 = _s2uPp::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2B1n: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2B1u() //  [R1, R2]
         { info_tbl: [(c2B1u,
                       label: block_c2B1u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B1u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2B1z; else goto c2B1y;
       c2B1z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2B1y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uPo_entry() //  [R1]
         { info_tbl: [(c2B1K,
                       label: sat_s2uPo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B1K: // global
           _s2uPo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B1L; else goto c2B1M;
       c2B1M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B1O; else goto c2B1N;
       c2B1O: // global
           HpAlloc = 16;
           goto c2B1L;
       c2B1L: // global
           R1 = _s2uPo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B1N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPo::P64;
           _s2uPk::I64 = I64[_s2uPo::P64 + 16];
           if (%MO_S_Lt_W64(_s2uPk::I64, 0)) goto c2B1U; else goto c2B1J;
       c2B1J: // global
           if (%MO_S_Gt_W64(_s2uPk::I64,
                            4294967295)) goto c2B1U; else goto c2B21;
       c2B1U: // global
           Hp = Hp - 16;
           R2 = _s2uPk::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2B21: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uPk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { info_tbl: [(c2B22,
                       label: GHC.Word.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B22: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2B26; else goto c2B25;
       c2B26: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B25: // global
           I64[Hp - 40] = sat_s2uPu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uPo_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.938297357 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { info_tbl: [(c2B2z,
                       label: GHC.Word.$fEnumWord32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B2z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B2A; else goto c2B2B;
       c2B2A: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B2B: // global
           I64[Sp - 8] = block_c2B2w_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2B2w() //  [R1, R2]
         { info_tbl: [(c2B2w,
                       label: block_c2B2w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B2w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2B2E; else goto c2B2D;
       c2B2E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2B2D: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.944533318 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2B2V,
                       label: GHC.Word.$fEnumWord32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B2V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B2W; else goto c2B2X;
       c2B2W: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B2X: // global
           I64[Sp - 8] = block_c2B2S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B39; else goto c2B2T;
       u2B39: // global
           call _c2B2S(R1) args: 0, res: 0, upd: 0;
       c2B2T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B2S() //  [R1]
         { info_tbl: [(c2B2S,
                       label: block_c2B2S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B2S: // global
           _s2uPC::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uPC::I64,
                            4294967295)) goto c2B37; else goto c2B38;
       c2B37: // global
           R2 = _s2uPC::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2B38: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.950341807 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2B3p,
                       label: GHC.Word.$fEnumWord32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B3p: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.95457807 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.956310975 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.959023438 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { info_tbl: [(c2B3G,
                       label: GHC.Word.eqWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B3G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B3K; else goto c2B3L;
       c2B3K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B3L: // global
           I64[Sp - 16] = block_c2B3D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B3U; else goto c2B3E;
       u2B3U: // global
           call _c2B3D(R1) args: 0, res: 0, upd: 0;
       c2B3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B3D() //  [R1]
         { info_tbl: [(c2B3D,
                       label: block_c2B3D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B3D: // global
           I64[Sp] = block_c2B3J_info;
           _s2uPH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPH::I64;
           if (R1 & 7 != 0) goto u2B3T; else goto c2B3N;
       u2B3T: // global
           call _c2B3J(R1) args: 0, res: 0, upd: 0;
       c2B3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B3J() //  [R1]
         { info_tbl: [(c2B3J,
                       label: block_c2B3J_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B3J: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.966415333 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { info_tbl: [(c2B4j,
                       label: GHC.Word.$fNumWord64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B4j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B4k; else goto c2B4l;
       c2B4k: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B4l: // global
           I64[Sp - 8] = block_c2B4g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B4t; else goto c2B4h;
       u2B4t: // global
           call _c2B4g(R1) args: 0, res: 0, upd: 0;
       c2B4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B4g() //  [R1]
         { info_tbl: [(c2B4g,
                       label: block_c2B4g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B4g: // global
           if (I64[R1 + 7] == 0) goto c2B4s; else goto c2B4r;
       c2B4s: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B4r: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.972358849 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.97523262 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2B4P_srtd" {
     u2B4P_srtd:
         const S2vim_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { info_tbl: [(c2B4M,
                       label: GHC.Word.$fEnumWord7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B4N; else goto c2B4O;
       c2B4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B4O: // global
           (_c2B4J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2B4J::I64 == 0) goto c2B4L; else goto c2B4K;
       c2B4L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2B4K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2B4J::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.979935745 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2B57_srtd" {
     u2B57_srtd:
         const S2vim_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { info_tbl: [(c2B54,
                       label: GHC.Word.$fEnumWord9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B55; else goto c2B56;
       c2B55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B56: // global
           (_c2B51::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2B51::I64 == 0) goto c2B53; else goto c2B52;
       c2B53: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2B52: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2B51::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.984816893 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { info_tbl: [(c2B5n,
                       label: GHC.Word.neWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B5n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B5r; else goto c2B5s;
       c2B5r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B5s: // global
           I64[Sp - 16] = block_c2B5k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B5B; else goto c2B5l;
       u2B5B: // global
           call _c2B5k(R1) args: 0, res: 0, upd: 0;
       c2B5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B5k() //  [R1]
         { info_tbl: [(c2B5k,
                       label: block_c2B5k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B5k: // global
           I64[Sp] = block_c2B5q_info;
           _s2uPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPS::I64;
           if (R1 & 7 != 0) goto u2B5A; else goto c2B5u;
       u2B5A: // global
           call _c2B5q(R1) args: 0, res: 0, upd: 0;
       c2B5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B5q() //  [R1]
         { info_tbl: [(c2B5q,
                       label: block_c2B5q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B5q: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:11.993110948 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2uQ6_entry() //  [R1]
         { info_tbl: [(c2B6f,
                       label: sat_s2uQ6_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B6f: // global
           _s2uQ6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6i; else goto c2B6j;
       c2B6j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B6l; else goto c2B6k;
       c2B6l: // global
           HpAlloc = 16;
           goto c2B6i;
       c2B6i: // global
           R1 = _s2uQ6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ6::P64;
           _s2uQ5::I64 = I64[_s2uQ6::P64 + 16] % I64[_s2uQ6::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2uQ4_entry() //  [R1]
         { info_tbl: [(c2B6s,
                       label: sat_s2uQ4_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B6s: // global
           _s2uQ4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6v; else goto c2B6w;
       c2B6w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B6y; else goto c2B6x;
       c2B6y: // global
           HpAlloc = 16;
           goto c2B6v;
       c2B6v: // global
           R1 = _s2uQ4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B6x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ4::P64;
           _s2uQ3::I64 = I64[_s2uQ4::P64 + 16] / I64[_s2uQ4::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2B6z,
                       label: GHC.Word.$fIntegralWord64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6A; else goto c2B6B;
       c2B6A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B6B: // global
           I64[Sp - 16] = block_c2B5X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B6L; else goto c2B5Y;
       u2B6L: // global
           call _c2B5X(R1) args: 0, res: 0, upd: 0;
       c2B5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B5X() //  [R1]
         { info_tbl: [(c2B5X,
                       label: block_c2B5X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B5X: // global
           I64[Sp] = block_c2B62_info;
           _s2uPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPZ::I64;
           if (R1 & 7 != 0) goto u2B6K; else goto c2B63;
       u2B6K: // global
           call _c2B62(R1) args: 0, res: 0, upd: 0;
       c2B63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B62() //  [R1]
         { info_tbl: [(c2B62,
                       label: block_c2B62_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B62: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2B6F; else goto c2B6E;
       c2B6F: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B6E: // global
           _s2uQ2::I64 = I64[R1 + 7];
           if (_s2uQ2::I64 != 0) goto c2B6I; else goto c2B6J;
       c2B6I: // global
           I64[Hp - 80] = sat_s2uQ6_info;
           _s2uPZ::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2uPZ::I64;
           I64[Hp - 56] = _s2uQ2::I64;
           I64[Hp - 48] = sat_s2uQ4_info;
           I64[Hp - 32] = _s2uPZ::I64;
           I64[Hp - 24] = _s2uQ2::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B6J: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.006826334 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2B7j,
                       label: GHC.Word.$fIntegralWord64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B7j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B7n; else goto c2B7o;
       c2B7n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B7o: // global
           I64[Sp - 16] = block_c2B7g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B7G; else goto c2B7h;
       u2B7G: // global
           call _c2B7g(R1) args: 0, res: 0, upd: 0;
       c2B7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B7g() //  [R1]
         { info_tbl: [(c2B7g,
                       label: block_c2B7g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B7g: // global
           I64[Sp] = block_c2B7m_info;
           _s2uQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQa::I64;
           if (R1 & 7 != 0) goto u2B7F; else goto c2B7q;
       u2B7F: // global
           call _c2B7m(R1) args: 0, res: 0, upd: 0;
       c2B7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B7m() //  [R1]
         { info_tbl: [(c2B7m,
                       label: block_c2B7m_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B7m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2B7w; else goto c2B7v;
       c2B7w: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B7v: // global
           _s2uQd::I64 = I64[R1 + 7];
           if (_s2uQd::I64 != 0) goto c2B7D; else goto c2B7E;
       c2B7D: // global
           (_s2uQf::I64, _s2uQg::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2uQd::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2uQg::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2uQf::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B7E: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.015792922 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c2B84,
                       label: GHC.Word.$fIntegralWord64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B84: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B88; else goto c2B89;
       c2B88: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B89: // global
           I64[Sp - 16] = block_c2B81_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B8s; else goto c2B82;
       u2B8s: // global
           call _c2B81(R1) args: 0, res: 0, upd: 0;
       c2B82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B81() //  [R1]
         { info_tbl: [(c2B81,
                       label: block_c2B81_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B81: // global
           I64[Sp] = block_c2B87_info;
           _s2uQm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQm::I64;
           if (R1 & 7 != 0) goto u2B8r; else goto c2B8b;
       u2B8r: // global
           call _c2B87(R1) args: 0, res: 0, upd: 0;
       c2B8b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B87() //  [R1]
         { info_tbl: [(c2B87,
                       label: block_c2B87_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B87: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B8h; else goto c2B8g;
       c2B8h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B8g: // global
           _s2uQp::I64 = I64[R1 + 7];
           if (_s2uQp::I64 != 0) goto c2B8p; else goto c2B8q;
       c2B8p: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2uQp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B8q: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.024613433 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c2B8P,
                       label: GHC.Word.$fIntegralWord64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B8P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B8T; else goto c2B8U;
       c2B8T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B8U: // global
           I64[Sp - 16] = block_c2B8M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B9d; else goto c2B8N;
       u2B9d: // global
           call _c2B8M(R1) args: 0, res: 0, upd: 0;
       c2B8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B8M() //  [R1]
         { info_tbl: [(c2B8M,
                       label: block_c2B8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B8M: // global
           I64[Sp] = block_c2B8S_info;
           _s2uQu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQu::I64;
           if (R1 & 7 != 0) goto u2B9c; else goto c2B8W;
       u2B9c: // global
           call _c2B8S(R1) args: 0, res: 0, upd: 0;
       c2B8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B8S() //  [R1]
         { info_tbl: [(c2B8S,
                       label: block_c2B8S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B92; else goto c2B91;
       c2B92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B91: // global
           _s2uQx::I64 = I64[R1 + 7];
           if (_s2uQx::I64 != 0) goto c2B9a; else goto c2B9b;
       c2B9a: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2uQx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B9b: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.032261481 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.034950693 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { info_tbl: [(c2B9B,
                       label: GHC.Word.$fEnumWord64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B9B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B9C; else goto c2B9D;
       c2B9C: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B9D: // global
           I64[Sp - 8] = block_c2B9y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B9S; else goto c2B9z;
       u2B9S: // global
           call _c2B9y(R1) args: 0, res: 0, upd: 0;
       c2B9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2B9y() //  [R1]
         { info_tbl: [(c2B9y,
                       label: block_c2B9y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2B9y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B9I; else goto c2B9H;
       c2B9I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B9H: // global
           _s2uQC::I64 = I64[R1 + 7];
           if (_s2uQC::I64 != 0) goto c2B9Q; else goto c2B9R;
       c2B9Q: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQC::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B9R: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.041331031 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.043000827 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.045302712 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { info_tbl: [(c2Bae,
                       label: GHC.Word.$fEnumWord64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bae: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Baf; else goto c2Bag;
       c2Baf: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bag: // global
           I64[Sp - 8] = block_c2Bab_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bav; else goto c2Bac;
       u2Bav: // global
           call _c2Bab(R1) args: 0, res: 0, upd: 0;
       c2Bac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bab() //  [R1]
         { info_tbl: [(c2Bab,
                       label: block_c2Bab_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bab: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bal; else goto c2Bak;
       c2Bal: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bak: // global
           _s2uQH::I64 = I64[R1 + 7];
           if (_s2uQH::I64 != 18446744073709551615) goto c2Bat; else goto c2Bau;
       c2Bat: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQH::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bau: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.052232506 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2BaP_srtd" {
     u2BaP_srtd:
         const S2vim_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { info_tbl: [(c2BaM,
                       label: GHC.Word.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BaM: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.056703806 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { info_tbl: [(c2Bb2,
                       label: GHC.Word.$fEnumWord6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bb2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bb3; else goto c2Bb4;
       c2Bb3: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bb4: // global
           I64[Sp - 8] = block_c2BaZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bb8; else goto c2Bb0;
       u2Bb8: // global
           call _c2BaZ(R1) args: 0, res: 0, upd: 0;
       c2Bb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BaZ() //  [R1]
         { info_tbl: [(c2BaZ,
                       label: block_c2BaZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BaZ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.06279069 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2Bbp,
                       label: GHC.Word.$fEnumWord64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bbp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bbq; else goto c2Bbr;
       c2Bbq: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bbr: // global
           I64[Sp - 8] = block_c2Bbm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BbI; else goto c2Bbn;
       u2BbI: // global
           call _c2Bbm(R1) args: 0, res: 0, upd: 0;
       c2Bbn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bbm() //  [R1]
         { info_tbl: [(c2Bbm,
                       label: block_c2Bbm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bbm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bbw; else goto c2Bbv;
       c2Bbw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bbv: // global
           _s2uQP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uQP::I64, 0)) goto c2BbA; else goto c2BbH;
       c2BbA: // global
           Hp = Hp - 16;
           R2 = _s2uQP::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2BbH: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.069872898 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Bc0,
                       label: GHC.Word.gtWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bc0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bc4; else goto c2Bc5;
       c2Bc4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bc5: // global
           I64[Sp - 16] = block_c2BbX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bce; else goto c2BbY;
       u2Bce: // global
           call _c2BbX(R1) args: 0, res: 0, upd: 0;
       c2BbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BbX() //  [R1]
         { info_tbl: [(c2BbX,
                       label: block_c2BbX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BbX: // global
           I64[Sp] = block_c2Bc3_info;
           _s2uQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQV::I64;
           if (R1 & 7 != 0) goto u2Bcd; else goto c2Bc7;
       u2Bcd: // global
           call _c2Bc3(R1) args: 0, res: 0, upd: 0;
       c2Bc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bc3() //  [R1]
         { info_tbl: [(c2Bc3,
                       label: block_c2Bc3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bc3: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.077905205 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { info_tbl: [(c2BcD,
                       label: GHC.Word.geWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BcD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BcH; else goto c2BcI;
       c2BcH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BcI: // global
           I64[Sp - 16] = block_c2BcA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BcR; else goto c2BcB;
       u2BcR: // global
           call _c2BcA(R1) args: 0, res: 0, upd: 0;
       c2BcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BcA() //  [R1]
         { info_tbl: [(c2BcA,
                       label: block_c2BcA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BcA: // global
           I64[Sp] = block_c2BcG_info;
           _s2uR2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR2::I64;
           if (R1 & 7 != 0) goto u2BcQ; else goto c2BcK;
       u2BcQ: // global
           call _c2BcG(R1) args: 0, res: 0, upd: 0;
       c2BcK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BcG() //  [R1]
         { info_tbl: [(c2BcG,
                       label: block_c2BcG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BcG: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.086005677 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Bdg,
                       label: GHC.Word.ltWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bdg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bdk; else goto c2Bdl;
       c2Bdk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bdl: // global
           I64[Sp - 16] = block_c2Bdd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bdu; else goto c2Bde;
       u2Bdu: // global
           call _c2Bdd(R1) args: 0, res: 0, upd: 0;
       c2Bde: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bdd() //  [R1]
         { info_tbl: [(c2Bdd,
                       label: block_c2Bdd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bdd: // global
           I64[Sp] = block_c2Bdj_info;
           _s2uR9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR9::I64;
           if (R1 & 7 != 0) goto u2Bdt; else goto c2Bdn;
       u2Bdt: // global
           call _c2Bdj(R1) args: 0, res: 0, upd: 0;
       c2Bdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bdj() //  [R1]
         { info_tbl: [(c2Bdj,
                       label: block_c2Bdj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bdj: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.093498206 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { info_tbl: [(c2BdT,
                       label: GHC.Word.leWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BdT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BdX; else goto c2BdY;
       c2BdX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BdY: // global
           I64[Sp - 16] = block_c2BdQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Be7; else goto c2BdR;
       u2Be7: // global
           call _c2BdQ(R1) args: 0, res: 0, upd: 0;
       c2BdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BdQ() //  [R1]
         { info_tbl: [(c2BdQ,
                       label: block_c2BdQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BdQ: // global
           I64[Sp] = block_c2BdW_info;
           _s2uRg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRg::I64;
           if (R1 & 7 != 0) goto u2Be6; else goto c2Be0;
       u2Be6: // global
           call _c2BdW(R1) args: 0, res: 0, upd: 0;
       c2Be0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BdW() //  [R1]
         { info_tbl: [(c2BdW,
                       label: block_c2BdW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BdW: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.101688734 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2Bew,
                       label: GHC.Word.$fOrdWord64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bew: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BeA; else goto c2BeB;
       c2BeA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BeB: // global
           I64[Sp - 16] = block_c2Bet_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BeO; else goto c2Beu;
       u2BeO: // global
           call _c2Bet(R1) args: 0, res: 0, upd: 0;
       c2Beu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bet() //  [R1]
         { info_tbl: [(c2Bet,
                       label: block_c2Bet_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bet: // global
           I64[Sp - 8] = block_c2Bez_info;
           _s2uRm::P64 = R1;
           _s2uRn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRn::I64;
           P64[Sp + 8] = _s2uRm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BeN; else goto c2BeD;
       u2BeN: // global
           call _c2Bez(R1) args: 0, res: 0, upd: 0;
       c2BeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bez() //  [R1]
         { info_tbl: [(c2Bez,
                       label: block_c2Bez_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bez: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2BeL; else goto c2BeM;
       c2BeL: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2BeM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.10968556 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2Bfe,
                       label: GHC.Word.$fOrdWord64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bfe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Bfi; else goto c2Bfj;
       c2Bfi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bfj: // global
           I64[Sp - 16] = block_c2Bfb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bfw; else goto c2Bfc;
       u2Bfw: // global
           call _c2Bfb(R1) args: 0, res: 0, upd: 0;
       c2Bfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bfb() //  [R1]
         { info_tbl: [(c2Bfb,
                       label: block_c2Bfb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bfb: // global
           I64[Sp - 8] = block_c2Bfh_info;
           _s2uRt::P64 = R1;
           _s2uRu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRu::I64;
           P64[Sp + 8] = _s2uRt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bfv; else goto c2Bfl;
       u2Bfv: // global
           call _c2Bfh(R1) args: 0, res: 0, upd: 0;
       c2Bfl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bfh() //  [R1]
         { info_tbl: [(c2Bfh,
                       label: block_c2Bfh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bfh: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Bft; else goto c2Bfu;
       c2Bft: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Bfu: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.118288536 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2BfW,
                       label: GHC.Word.$fOrdWord64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bg0; else goto c2Bg1;
       c2Bg0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bg1: // global
           I64[Sp - 16] = block_c2BfT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bgk; else goto c2BfU;
       u2Bgk: // global
           call _c2BfT(R1) args: 0, res: 0, upd: 0;
       c2BfU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BfT() //  [R1]
         { info_tbl: [(c2BfT,
                       label: block_c2BfT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BfT: // global
           I64[Sp] = block_c2BfZ_info;
           _s2uRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRB::I64;
           if (R1 & 7 != 0) goto u2Bgj; else goto c2Bg3;
       u2Bgj: // global
           call _c2BfZ(R1) args: 0, res: 0, upd: 0;
       c2Bg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BfZ() //  [R1]
         { info_tbl: [(c2BfZ,
                       label: block_c2BfZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BfZ: // global
           _s2uRB::I64 = I64[Sp + 8];
           _s2uRD::I64 = I64[R1 + 7];
           if (_s2uRB::I64 == _s2uRD::I64) goto c2Bgi; else goto c2Bgh;
       c2Bgi: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bgh: // global
           if (_s2uRB::I64 > _s2uRD::I64) goto c2Bge; else goto c2Bgf;
       c2Bge: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bgf: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.126290978 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.12862918 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.130965619 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2BgK,
                       label: GHC.Word.$fEnumWord64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BgK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BgL; else goto c2BgM;
       c2BgL: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BgM: // global
           I64[Sp - 8] = block_c2BgH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bh3; else goto c2BgI;
       u2Bh3: // global
           call _c2BgH(R1) args: 0, res: 0, upd: 0;
       c2BgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BgH() //  [R1]
         { info_tbl: [(c2BgH,
                       label: block_c2BgH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BgH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BgR; else goto c2BgQ;
       c2BgR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BgQ: // global
           _s2uRI::I64 = I64[R1 + 7];
           if (_s2uRI::I64 > 9223372036854775807) goto c2BgV; else goto c2Bh2;
       c2BgV: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2Bh2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uRI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.137668192 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2Bhj,
                       label: GHC.Word.$fEnumWord64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bhj: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2Bhq,
                       label: GHC.Word.$fEnumWord64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bhq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2Bhx,
                       label: GHC.Word.$fEnumWord64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bhx: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2BhE,
                       label: GHC.Word.$fEnumWord64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BhE: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.151456831 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2Bi5,
                       label: GHC.Word.$fNumWord8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bi5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bic; else goto c2Bid;
       c2Bic: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bid: // global
           I64[Sp - 8] = block_c2Bi3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bi3() //  [R1]
         { info_tbl: [(c2Bi3,
                       label: block_c2Bi3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bi3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Big; else goto c2Bif;
       c2Big: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Bif: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.157942868 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { info_tbl: [(c2Biw,
                       label: GHC.Word.$fNumWord8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Biw: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.161800201 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { info_tbl: [(c2BiM,
                       label: GHC.Word.$fNumWord8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BiM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bj2; else goto c2Bj3;
       c2Bj2: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bj3: // global
           I64[Sp - 8] = block_c2BiJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bj7; else goto c2BiK;
       u2Bj7: // global
           call _c2BiJ(R1) args: 0, res: 0, upd: 0;
       c2BiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BiJ() //  [R1]
         { info_tbl: [(c2BiJ,
                       label: block_c2BiJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BiJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bj6; else goto c2Bj5;
       c2Bj6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bj5: // global
           _s2uRV::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uRV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.168089877 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2Bjq,
                       label: GHC.Word.$fNumWord8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bjq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BjF; else goto c2BjG;
       c2BjF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BjG: // global
           I64[Sp - 16] = block_c2Bjn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BjM; else goto c2Bjo;
       u2BjM: // global
           call _c2Bjn(R1) args: 0, res: 0, upd: 0;
       c2Bjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bjn() //  [R1]
         { info_tbl: [(c2Bjn,
                       label: block_c2Bjn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bjn: // global
           I64[Sp] = block_c2Bjt_info;
           _s2uRZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRZ::I64;
           if (R1 & 7 != 0) goto u2BjL; else goto c2Bju;
       u2BjL: // global
           call _c2Bjt(R1) args: 0, res: 0, upd: 0;
       c2Bju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bjt() //  [R1]
         { info_tbl: [(c2Bjt,
                       label: block_c2Bjt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bjt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BjK; else goto c2BjJ;
       c2BjK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BjJ: // global
           _s2uS3::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.177129125 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2Bkb,
                       label: GHC.Word.$fNumWord8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bkb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bkq; else goto c2Bkr;
       c2Bkq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bkr: // global
           I64[Sp - 16] = block_c2Bk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bkx; else goto c2Bk9;
       u2Bkx: // global
           call _c2Bk8(R1) args: 0, res: 0, upd: 0;
       c2Bk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bk8() //  [R1]
         { info_tbl: [(c2Bk8,
                       label: block_c2Bk8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bk8: // global
           I64[Sp] = block_c2Bke_info;
           _s2uS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uS7::I64;
           if (R1 & 7 != 0) goto u2Bkw; else goto c2Bkf;
       u2Bkw: // global
           call _c2Bke(R1) args: 0, res: 0, upd: 0;
       c2Bkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bke() //  [R1]
         { info_tbl: [(c2Bke,
                       label: block_c2Bke_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bke: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bkv; else goto c2Bku;
       c2Bkv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bku: // global
           _s2uSb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.185336365 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2BkW,
                       label: GHC.Word.$fNumWord8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BkW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Blb; else goto c2Blc;
       c2Blb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Blc: // global
           I64[Sp - 16] = block_c2BkT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bli; else goto c2BkU;
       u2Bli: // global
           call _c2BkT(R1) args: 0, res: 0, upd: 0;
       c2BkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BkT() //  [R1]
         { info_tbl: [(c2BkT,
                       label: block_c2BkT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BkT: // global
           I64[Sp] = block_c2BkZ_info;
           _s2uSf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSf::I64;
           if (R1 & 7 != 0) goto u2Blh; else goto c2Bl0;
       u2Blh: // global
           call _c2BkZ(R1) args: 0, res: 0, upd: 0;
       c2Bl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BkZ() //  [R1]
         { info_tbl: [(c2BkZ,
                       label: block_c2BkZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BkZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Blg; else goto c2Blf;
       c2Blg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Blf: // global
           _s2uSj::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.193902163 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2BlH,
                       label: GHC.Word.$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BlH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BlI; else goto c2BlJ;
       c2BlI: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BlJ: // global
           I64[Sp - 8] = block_c2BlE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BlO; else goto c2BlF;
       u2BlO: // global
           call _c2BlE(R1) args: 0, res: 0, upd: 0;
       c2BlF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BlE() //  [R1]
         { info_tbl: [(c2BlE,
                       label: block_c2BlE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BlE: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.200548661 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2Bm5,
                       label: GHC.Word.$fBitsWord8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bm5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bmg; else goto c2Bmh;
       c2Bmg: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bmh: // global
           I64[Sp - 8] = block_c2Bm2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bml; else goto c2Bm3;
       u2Bml: // global
           call _c2Bm2(R1) args: 0, res: 0, upd: 0;
       c2Bm3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bm2() //  [R1]
         { info_tbl: [(c2Bm2,
                       label: block_c2Bm2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bm2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bmk; else goto c2Bmj;
       c2Bmk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bmj: // global
           (_c2Bm8::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Bm8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.207888384 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BmD,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BmP; else goto c2BmQ;
       c2BmP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BmQ: // global
           I64[Sp - 16] = block_c2BmA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BmW; else goto c2BmB;
       u2BmW: // global
           call _c2BmA(R1) args: 0, res: 0, upd: 0;
       c2BmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BmA() //  [R1]
         { info_tbl: [(c2BmA,
                       label: block_c2BmA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BmA: // global
           I64[Sp] = block_c2BmG_info;
           _s2uSw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSw::I64;
           if (R1 & 7 != 0) goto u2BmV; else goto c2BmH;
       u2BmV: // global
           call _c2BmG(R1) args: 0, res: 0, upd: 0;
       c2BmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BmG() //  [R1]
         { info_tbl: [(c2BmG,
                       label: block_c2BmG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BmG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BmU; else goto c2BmT;
       c2BmU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BmT: // global
           _s2uSz::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.216360913 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2Bnj,
                       label: GHC.Word.$fBitsWord8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bnj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bnn; else goto c2Bno;
       c2Bnn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bno: // global
           I64[Sp - 16] = block_c2Bng_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BnI; else goto c2Bnh;
       u2BnI: // global
           call _c2Bng(R1) args: 0, res: 0, upd: 0;
       c2Bnh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bng() //  [R1]
         { info_tbl: [(c2Bng,
                       label: block_c2Bng_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bng: // global
           I64[Sp] = block_c2Bnm_info;
           _s2uSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSD::I64;
           if (R1 & 7 != 0) goto u2BnH; else goto c2Bnq;
       u2BnH: // global
           call _c2Bnm(R1) args: 0, res: 0, upd: 0;
       c2Bnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bnm() //  [R1]
         { info_tbl: [(c2Bnm,
                       label: block_c2Bnm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bnm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bnw; else goto c2Bnv;
       c2Bnw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bnv: // global
           _s2uSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSF::I64, 64)) goto c2BnF; else goto c2BnG;
       c2BnF: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uSF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BnG: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.225838978 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2Bo6,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bo6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bol; else goto c2Bom;
       c2Bol: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bom: // global
           I64[Sp - 16] = block_c2Bo3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bos; else goto c2Bo4;
       u2Bos: // global
           call _c2Bo3(R1) args: 0, res: 0, upd: 0;
       c2Bo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bo3() //  [R1]
         { info_tbl: [(c2Bo3,
                       label: block_c2Bo3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bo3: // global
           I64[Sp] = block_c2Bo9_info;
           _s2uSL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSL::I64;
           if (R1 & 7 != 0) goto u2Bor; else goto c2Boa;
       u2Bor: // global
           call _c2Bo9(R1) args: 0, res: 0, upd: 0;
       c2Boa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bo9() //  [R1]
         { info_tbl: [(c2Bo9,
                       label: block_c2Bo9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bo9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Boq; else goto c2Bop;
       c2Boq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bop: // global
           _s2uSP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.234054461 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BoQ,
                       label: GHC.Word.$fBitsWord8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BoU; else goto c2BoV;
       c2BoU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BoV: // global
           I64[Sp - 16] = block_c2BoN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bpi; else goto c2BoO;
       u2Bpi: // global
           call _c2BoN(R1) args: 0, res: 0, upd: 0;
       c2BoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BoN() //  [R1]
         { info_tbl: [(c2BoN,
                       label: block_c2BoN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BoN: // global
           I64[Sp] = block_c2BoT_info;
           _s2uST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uST::I64;
           if (R1 & 7 != 0) goto u2Bph; else goto c2BoX;
       u2Bph: // global
           call _c2BoT(R1) args: 0, res: 0, upd: 0;
       c2BoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BoT() //  [R1]
         { info_tbl: [(c2BoT,
                       label: block_c2BoT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BoT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bp3; else goto c2Bp2;
       c2Bp3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bp2: // global
           _s2uSV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSV::I64, 64)) goto c2Bpf; else goto c2Bpg;
       c2Bpf: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2uSV::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bpg: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.242795476 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { info_tbl: [(c2BpF,
                       label: GHC.Word.$fBitsWord8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BpF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.246870729 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2BpU,
                       label: GHC.Word.$fBitsWord8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BpU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BpY; else goto c2BpZ;
       c2BpY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BpZ: // global
           I64[Sp - 16] = block_c2BpR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BqM; else goto c2BpS;
       u2BqM: // global
           call _c2BpR(R1) args: 0, res: 0, upd: 0;
       c2BpS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BpR() //  [R1]
         { info_tbl: [(c2BpR,
                       label: block_c2BpR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BpR: // global
           I64[Sp - 8] = block_c2BpX_info;
           _s2uT2::P64 = R1;
           _s2uT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uT3::I64;
           P64[Sp + 8] = _s2uT2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BqL; else goto c2Bq1;
       u2BqL: // global
           call _c2BpX(R1) args: 0, res: 0, upd: 0;
       c2Bq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BpX() //  [R1]
         { info_tbl: [(c2BpX,
                       label: block_c2BpX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BpX: // global
           _s2uT8::I64 = I64[R1 + 7] & 7;
           if (_s2uT8::I64 != 0) goto u2BqJ; else goto c2BqF;
       u2BqJ: // global
           I64[Sp + 16] = _s2uT8::I64;
           Sp = Sp + 8;
           call _c2Bqg() args: 0, res: 0, upd: 0;
       c2BqF: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Bqg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bqg: // global
           Hp = Hp + 16;
           _s2uT8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BqC; else goto c2BqB;
       c2BqC: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Bqf_info;
           R1 = _s2uT8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BqB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2uT3::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2uT3::I64 << _s2uT8::I64) | (_s2uT3::I64 >> 8 - _s2uT8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Bqf() //  [R1]
         { info_tbl: [(c2Bqf,
                       label: block_c2Bqf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bqf: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Bqg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.259769808 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2Bro,
                       label: GHC.Word.$fBitsWord8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bro: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Brs; else goto c2Brt;
       c2Brs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Brt: // global
           I64[Sp - 16] = block_c2Brl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bsa; else goto c2Brm;
       u2Bsa: // global
           call _c2Brl(R1) args: 0, res: 0, upd: 0;
       c2Brm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Brl() //  [R1]
         { info_tbl: [(c2Brl,
                       label: block_c2Brl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Brl: // global
           I64[Sp] = block_c2Brr_info;
           _s2uTh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTh::I64;
           if (R1 & 7 != 0) goto u2Bs9; else goto c2Brv;
       u2Bs9: // global
           call _c2Brr(R1) args: 0, res: 0, upd: 0;
       c2Brv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Brr() //  [R1]
         { info_tbl: [(c2Brr,
                       label: block_c2Brr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Brr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BrB; else goto c2BrA;
       c2BrB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BrA: // global
           _s2uTh::I64 = I64[Sp + 8];
           _s2uTj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uTj::I64, 0)) goto c2BrT; else goto c2Bs8;
       c2BrT: // global
           _s2uTl::I64 = -_s2uTj::I64;
           if (%MO_S_Ge_W64(_s2uTl::I64, 64)) goto c2Bs7; else goto c2BrQ;
       c2BrQ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTh::I64 >> _s2uTl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bs8: // global
           if (%MO_S_Ge_W64(_s2uTj::I64, 64)) goto c2Bs7; else goto c2Bs6;
       c2Bs7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bs6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uTh::I64 << _s2uTj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.269706383 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2BsC,
                       label: GHC.Word.$fBitsWord8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BsO; else goto c2BsP;
       c2BsO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BsP: // global
           I64[Sp - 16] = block_c2Bsz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BsV; else goto c2BsA;
       u2BsV: // global
           call _c2Bsz(R1) args: 0, res: 0, upd: 0;
       c2BsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bsz() //  [R1]
         { info_tbl: [(c2Bsz,
                       label: block_c2Bsz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bsz: // global
           I64[Sp] = block_c2BsF_info;
           _s2uTu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTu::I64;
           if (R1 & 7 != 0) goto u2BsU; else goto c2BsG;
       u2BsU: // global
           call _c2BsF(R1) args: 0, res: 0, upd: 0;
       c2BsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BsF() //  [R1]
         { info_tbl: [(c2BsF,
                       label: block_c2BsF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BsF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BsT; else goto c2BsS;
       c2BsT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BsS: // global
           _s2uTx::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.278008024 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2Btj,
                       label: GHC.Word.$fBitsWord8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Btj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Btv; else goto c2Btw;
       c2Btv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Btw: // global
           I64[Sp - 16] = block_c2Btg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BtC; else goto c2Bth;
       u2BtC: // global
           call _c2Btg(R1) args: 0, res: 0, upd: 0;
       c2Bth: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Btg() //  [R1]
         { info_tbl: [(c2Btg,
                       label: block_c2Btg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Btg: // global
           I64[Sp] = block_c2Btm_info;
           _s2uTB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTB::I64;
           if (R1 & 7 != 0) goto u2BtB; else goto c2Btn;
       u2BtB: // global
           call _c2Btm(R1) args: 0, res: 0, upd: 0;
       c2Btn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Btm() //  [R1]
         { info_tbl: [(c2Btm,
                       label: block_c2Btm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Btm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BtA; else goto c2Btz;
       c2BtA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Btz: // global
           _s2uTE::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.286942163 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2Bu0,
                       label: GHC.Word.$fBitsWord8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bu0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Buc; else goto c2Bud;
       c2Buc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bud: // global
           I64[Sp - 16] = block_c2BtX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Buj; else goto c2BtY;
       u2Buj: // global
           call _c2BtX(R1) args: 0, res: 0, upd: 0;
       c2BtY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BtX() //  [R1]
         { info_tbl: [(c2BtX,
                       label: block_c2BtX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BtX: // global
           I64[Sp] = block_c2Bu3_info;
           _s2uTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTI::I64;
           if (R1 & 7 != 0) goto u2Bui; else goto c2Bu4;
       u2Bui: // global
           call _c2Bu3(R1) args: 0, res: 0, upd: 0;
       c2Bu4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bu3() //  [R1]
         { info_tbl: [(c2Bu3,
                       label: block_c2Bu3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bu3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Buh; else goto c2Bug;
       c2Buh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bug: // global
           _s2uTL::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.295381616 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2BuH,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BuH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BuS; else goto c2BuT;
       c2BuS: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BuT: // global
           I64[Sp - 8] = block_c2BuE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BuX; else goto c2BuF;
       u2BuX: // global
           call _c2BuE(R1) args: 0, res: 0, upd: 0;
       c2BuF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BuE() //  [R1]
         { info_tbl: [(c2BuE,
                       label: block_c2BuE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BuE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BuW; else goto c2BuV;
       c2BuW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BuV: // global
           (_c2BuK::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BuK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.302243676 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2Bvh,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bvh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bvs; else goto c2Bvt;
       c2Bvs: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bvt: // global
           I64[Sp - 8] = block_c2Bve_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bvx; else goto c2Bvf;
       u2Bvx: // global
           call _c2Bve(R1) args: 0, res: 0, upd: 0;
       c2Bvf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bve() //  [R1]
         { info_tbl: [(c2Bve,
                       label: block_c2Bve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bve: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bvw; else goto c2Bvv;
       c2Bvw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bvv: // global
           (_c2Bvk::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Bvk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.307859151 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.309826391 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2BvP,
                       label: GHC.Word.$fBitsWord8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BvP: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.314138212 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2Bw3,
                       label: GHC.Word.$fNumWord16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bw3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bwa; else goto c2Bwb;
       c2Bwa: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bwb: // global
           I64[Sp - 8] = block_c2Bw1_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bw1() //  [R1]
         { info_tbl: [(c2Bw1,
                       label: block_c2Bw1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bw1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bwe; else goto c2Bwd;
       c2Bwe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Bwd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.320231295 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { info_tbl: [(c2Bwu,
                       label: GHC.Word.$fNumWord16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bwu: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.324137364 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { info_tbl: [(c2BwK,
                       label: GHC.Word.$fNumWord16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BwK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bx0; else goto c2Bx1;
       c2Bx0: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bx1: // global
           I64[Sp - 8] = block_c2BwH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bx5; else goto c2BwI;
       u2Bx5: // global
           call _c2BwH(R1) args: 0, res: 0, upd: 0;
       c2BwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BwH() //  [R1]
         { info_tbl: [(c2BwH,
                       label: block_c2BwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BwH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bx4; else goto c2Bx3;
       c2Bx4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bx3: // global
           _s2uU7::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uU7::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.331181736 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2Bxo,
                       label: GHC.Word.$fNumWord16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bxo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BxD; else goto c2BxE;
       c2BxD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BxE: // global
           I64[Sp - 16] = block_c2Bxl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BxK; else goto c2Bxm;
       u2BxK: // global
           call _c2Bxl(R1) args: 0, res: 0, upd: 0;
       c2Bxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bxl() //  [R1]
         { info_tbl: [(c2Bxl,
                       label: block_c2Bxl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bxl: // global
           I64[Sp] = block_c2Bxr_info;
           _s2uUb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUb::I64;
           if (R1 & 7 != 0) goto u2BxJ; else goto c2Bxs;
       u2BxJ: // global
           call _c2Bxr(R1) args: 0, res: 0, upd: 0;
       c2Bxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Bxr() //  [R1]
         { info_tbl: [(c2Bxr,
                       label: block_c2Bxr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Bxr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BxI; else goto c2BxH;
       c2BxI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BxH: // global
           _s2uUf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.339229498 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2By9,
                       label: GHC.Word.$fNumWord16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2By9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Byo; else goto c2Byp;
       c2Byo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Byp: // global
           I64[Sp - 16] = block_c2By6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Byv; else goto c2By7;
       u2Byv: // global
           call _c2By6(R1) args: 0, res: 0, upd: 0;
       c2By7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2By6() //  [R1]
         { info_tbl: [(c2By6,
                       label: block_c2By6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2By6: // global
           I64[Sp] = block_c2Byc_info;
           _s2uUj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUj::I64;
           if (R1 & 7 != 0) goto u2Byu; else goto c2Byd;
       u2Byu: // global
           call _c2Byc(R1) args: 0, res: 0, upd: 0;
       c2Byd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Byc() //  [R1]
         { info_tbl: [(c2Byc,
                       label: block_c2Byc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Byc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Byt; else goto c2Bys;
       c2Byt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bys: // global
           _s2uUn::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.347792246 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2ByU,
                       label: GHC.Word.$fNumWord16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ByU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bz9; else goto c2Bza;
       c2Bz9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bza: // global
           I64[Sp - 16] = block_c2ByR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bzg; else goto c2ByS;
       u2Bzg: // global
           call _c2ByR(R1) args: 0, res: 0, upd: 0;
       c2ByS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ByR() //  [R1]
         { info_tbl: [(c2ByR,
                       label: block_c2ByR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ByR: // global
           I64[Sp] = block_c2ByX_info;
           _s2uUr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUr::I64;
           if (R1 & 7 != 0) goto u2Bzf; else goto c2ByY;
       u2Bzf: // global
           call _c2ByX(R1) args: 0, res: 0, upd: 0;
       c2ByY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ByX() //  [R1]
         { info_tbl: [(c2ByX,
                       label: block_c2ByX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ByX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bze; else goto c2Bzd;
       c2Bze: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bzd: // global
           _s2uUv::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.35568133 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { info_tbl: [(c2BzF,
                       label: GHC.Word.$ctoInteger1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BzF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BzG; else goto c2BzH;
       c2BzG: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BzH: // global
           I64[Sp - 8] = block_c2BzC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BzM; else goto c2BzD;
       u2BzM: // global
           call _c2BzC(R1) args: 0, res: 0, upd: 0;
       c2BzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BzC() //  [R1]
         { info_tbl: [(c2BzC,
                       label: block_c2BzC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BzC: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.362118857 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2BA3,
                       label: GHC.Word.$fBitsWord16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BA3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BAe; else goto c2BAf;
       c2BAe: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BAf: // global
           I64[Sp - 8] = block_c2BA0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BAj; else goto c2BA1;
       u2BAj: // global
           call _c2BA0(R1) args: 0, res: 0, upd: 0;
       c2BA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BA0() //  [R1]
         { info_tbl: [(c2BA0,
                       label: block_c2BA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BA0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BAi; else goto c2BAh;
       c2BAi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BAh: // global
           (_c2BA6::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BA6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.368583536 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BAB,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BAB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BAN; else goto c2BAO;
       c2BAN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BAO: // global
           I64[Sp - 16] = block_c2BAy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BAU; else goto c2BAz;
       u2BAU: // global
           call _c2BAy(R1) args: 0, res: 0, upd: 0;
       c2BAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BAy() //  [R1]
         { info_tbl: [(c2BAy,
                       label: block_c2BAy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BAy: // global
           I64[Sp] = block_c2BAE_info;
           _s2uUI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUI::I64;
           if (R1 & 7 != 0) goto u2BAT; else goto c2BAF;
       u2BAT: // global
           call _c2BAE(R1) args: 0, res: 0, upd: 0;
       c2BAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BAE() //  [R1]
         { info_tbl: [(c2BAE,
                       label: block_c2BAE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BAE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BAS; else goto c2BAR;
       c2BAS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BAR: // global
           _s2uUL::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.377754655 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BBh,
                       label: GHC.Word.$fBitsWord16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BBl; else goto c2BBm;
       c2BBl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BBm: // global
           I64[Sp - 16] = block_c2BBe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BBG; else goto c2BBf;
       u2BBG: // global
           call _c2BBe(R1) args: 0, res: 0, upd: 0;
       c2BBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BBe() //  [R1]
         { info_tbl: [(c2BBe,
                       label: block_c2BBe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BBe: // global
           I64[Sp] = block_c2BBk_info;
           _s2uUP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUP::I64;
           if (R1 & 7 != 0) goto u2BBF; else goto c2BBo;
       u2BBF: // global
           call _c2BBk(R1) args: 0, res: 0, upd: 0;
       c2BBo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BBk() //  [R1]
         { info_tbl: [(c2BBk,
                       label: block_c2BBk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BBk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BBu; else goto c2BBt;
       c2BBu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BBt: // global
           _s2uUR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uUR::I64, 64)) goto c2BBD; else goto c2BBE;
       c2BBD: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uUR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BBE: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.386331979 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BC4,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BC4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BCj; else goto c2BCk;
       c2BCj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BCk: // global
           I64[Sp - 16] = block_c2BC1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BCq; else goto c2BC2;
       u2BCq: // global
           call _c2BC1(R1) args: 0, res: 0, upd: 0;
       c2BC2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BC1() //  [R1]
         { info_tbl: [(c2BC1,
                       label: block_c2BC1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BC1: // global
           I64[Sp] = block_c2BC7_info;
           _s2uUX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUX::I64;
           if (R1 & 7 != 0) goto u2BCp; else goto c2BC8;
       u2BCp: // global
           call _c2BC7(R1) args: 0, res: 0, upd: 0;
       c2BC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BC7() //  [R1]
         { info_tbl: [(c2BC7,
                       label: block_c2BC7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BC7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BCo; else goto c2BCn;
       c2BCo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BCn: // global
           _s2uV1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uV1::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.3954526 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BCO,
                       label: GHC.Word.$fBitsWord16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BCO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BCS; else goto c2BCT;
       c2BCS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BCT: // global
           I64[Sp - 16] = block_c2BCL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BDg; else goto c2BCM;
       u2BDg: // global
           call _c2BCL(R1) args: 0, res: 0, upd: 0;
       c2BCM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BCL() //  [R1]
         { info_tbl: [(c2BCL,
                       label: block_c2BCL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BCL: // global
           I64[Sp] = block_c2BCR_info;
           _s2uV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uV5::I64;
           if (R1 & 7 != 0) goto u2BDf; else goto c2BCV;
       u2BDf: // global
           call _c2BCR(R1) args: 0, res: 0, upd: 0;
       c2BCV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BCR() //  [R1]
         { info_tbl: [(c2BCR,
                       label: block_c2BCR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BCR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BD1; else goto c2BD0;
       c2BD1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BD0: // global
           _s2uV7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uV7::I64, 64)) goto c2BDd; else goto c2BDe;
       c2BDd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2uV7::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BDe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.403821589 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { info_tbl: [(c2BDD,
                       label: GHC.Word.$fBitsWord16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BDD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.408537143 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2BDS,
                       label: GHC.Word.$fBitsWord16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BDS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BDW; else goto c2BDX;
       c2BDW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BDX: // global
           I64[Sp - 16] = block_c2BDP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BEK; else goto c2BDQ;
       u2BEK: // global
           call _c2BDP(R1) args: 0, res: 0, upd: 0;
       c2BDQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BDP() //  [R1]
         { info_tbl: [(c2BDP,
                       label: block_c2BDP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BDP: // global
           I64[Sp - 8] = block_c2BDV_info;
           _s2uVe::P64 = R1;
           _s2uVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uVf::I64;
           P64[Sp + 8] = _s2uVe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BEJ; else goto c2BDZ;
       u2BEJ: // global
           call _c2BDV(R1) args: 0, res: 0, upd: 0;
       c2BDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BDV() //  [R1]
         { info_tbl: [(c2BDV,
                       label: block_c2BDV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BDV: // global
           _s2uVk::I64 = I64[R1 + 7] & 15;
           if (_s2uVk::I64 != 0) goto u2BEH; else goto c2BED;
       u2BEH: // global
           I64[Sp + 16] = _s2uVk::I64;
           Sp = Sp + 8;
           call _c2BEe() args: 0, res: 0, upd: 0;
       c2BED: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BEe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BEe: // global
           Hp = Hp + 16;
           _s2uVk::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BEA; else goto c2BEz;
       c2BEA: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2BEd_info;
           R1 = _s2uVk::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BEz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2uVf::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2uVf::I64 << _s2uVk::I64) | (_s2uVf::I64 >> 16 - _s2uVk::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BEd() //  [R1]
         { info_tbl: [(c2BEd,
                       label: block_c2BEd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BEd: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2BEe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.420541865 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2BFm,
                       label: GHC.Word.$fBitsWord16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BFq; else goto c2BFr;
       c2BFq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BFr: // global
           I64[Sp - 16] = block_c2BFj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BG8; else goto c2BFk;
       u2BG8: // global
           call _c2BFj(R1) args: 0, res: 0, upd: 0;
       c2BFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BFj() //  [R1]
         { info_tbl: [(c2BFj,
                       label: block_c2BFj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BFj: // global
           I64[Sp] = block_c2BFp_info;
           _s2uVt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVt::I64;
           if (R1 & 7 != 0) goto u2BG7; else goto c2BFt;
       u2BG7: // global
           call _c2BFp(R1) args: 0, res: 0, upd: 0;
       c2BFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BFp() //  [R1]
         { info_tbl: [(c2BFp,
                       label: block_c2BFp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BFp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BFz; else goto c2BFy;
       c2BFz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BFy: // global
           _s2uVt::I64 = I64[Sp + 8];
           _s2uVv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uVv::I64, 0)) goto c2BFR; else goto c2BG6;
       c2BFR: // global
           _s2uVx::I64 = -_s2uVv::I64;
           if (%MO_S_Ge_W64(_s2uVx::I64, 64)) goto c2BG5; else goto c2BFO;
       c2BFO: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVt::I64 >> _s2uVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BG6: // global
           if (%MO_S_Ge_W64(_s2uVv::I64, 64)) goto c2BG5; else goto c2BG4;
       c2BG5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BG4: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uVt::I64 << _s2uVv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.430686754 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2BGA,
                       label: GHC.Word.$fBitsWord16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BGA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BGM; else goto c2BGN;
       c2BGM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BGN: // global
           I64[Sp - 16] = block_c2BGx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BGT; else goto c2BGy;
       u2BGT: // global
           call _c2BGx(R1) args: 0, res: 0, upd: 0;
       c2BGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BGx() //  [R1]
         { info_tbl: [(c2BGx,
                       label: block_c2BGx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BGx: // global
           I64[Sp] = block_c2BGD_info;
           _s2uVG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVG::I64;
           if (R1 & 7 != 0) goto u2BGS; else goto c2BGE;
       u2BGS: // global
           call _c2BGD(R1) args: 0, res: 0, upd: 0;
       c2BGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BGD() //  [R1]
         { info_tbl: [(c2BGD,
                       label: block_c2BGD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BGD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BGR; else goto c2BGQ;
       c2BGR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BGQ: // global
           _s2uVJ::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.439565568 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2BHh,
                       label: GHC.Word.$fBitsWord16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BHt; else goto c2BHu;
       c2BHt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BHu: // global
           I64[Sp - 16] = block_c2BHe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BHA; else goto c2BHf;
       u2BHA: // global
           call _c2BHe(R1) args: 0, res: 0, upd: 0;
       c2BHf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BHe() //  [R1]
         { info_tbl: [(c2BHe,
                       label: block_c2BHe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BHe: // global
           I64[Sp] = block_c2BHk_info;
           _s2uVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVN::I64;
           if (R1 & 7 != 0) goto u2BHz; else goto c2BHl;
       u2BHz: // global
           call _c2BHk(R1) args: 0, res: 0, upd: 0;
       c2BHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BHk() //  [R1]
         { info_tbl: [(c2BHk,
                       label: block_c2BHk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BHk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BHy; else goto c2BHx;
       c2BHy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BHx: // global
           _s2uVQ::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.447737732 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2BHY,
                       label: GHC.Word.$fBitsWord16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BHY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BIa; else goto c2BIb;
       c2BIa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BIb: // global
           I64[Sp - 16] = block_c2BHV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BIh; else goto c2BHW;
       u2BIh: // global
           call _c2BHV(R1) args: 0, res: 0, upd: 0;
       c2BHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BHV() //  [R1]
         { info_tbl: [(c2BHV,
                       label: block_c2BHV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BHV: // global
           I64[Sp] = block_c2BI1_info;
           _s2uVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVU::I64;
           if (R1 & 7 != 0) goto u2BIg; else goto c2BI2;
       u2BIg: // global
           call _c2BI1(R1) args: 0, res: 0, upd: 0;
       c2BI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BI1() //  [R1]
         { info_tbl: [(c2BI1,
                       label: block_c2BI1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BI1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BIf; else goto c2BIe;
       c2BIf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BIe: // global
           _s2uVX::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.456702836 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2BIF,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BIF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BIQ; else goto c2BIR;
       c2BIQ: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BIR: // global
           I64[Sp - 8] = block_c2BIC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BIV; else goto c2BID;
       u2BIV: // global
           call _c2BIC(R1) args: 0, res: 0, upd: 0;
       c2BID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BIC() //  [R1]
         { info_tbl: [(c2BIC,
                       label: block_c2BIC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BIC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BIU; else goto c2BIT;
       c2BIU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BIT: // global
           (_c2BII::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BII::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.463054788 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2BJf,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BJf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BJq; else goto c2BJr;
       c2BJq: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BJr: // global
           I64[Sp - 8] = block_c2BJc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BJv; else goto c2BJd;
       u2BJv: // global
           call _c2BJc(R1) args: 0, res: 0, upd: 0;
       c2BJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BJc() //  [R1]
         { info_tbl: [(c2BJc,
                       label: block_c2BJc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BJu; else goto c2BJt;
       c2BJu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BJt: // global
           (_c2BJi::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BJi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.469437672 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.471308215 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2BJN,
                       label: GHC.Word.$fBitsWord16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BJN: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.475203408 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2BK1,
                       label: GHC.Word.$fNumWord32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BK1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BK8; else goto c2BK9;
       c2BK8: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BK9: // global
           I64[Sp - 8] = block_c2BJZ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2BJZ() //  [R1]
         { info_tbl: [(c2BJZ,
                       label: block_c2BJZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BKc; else goto c2BKb;
       c2BKc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BKb: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.481090255 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { info_tbl: [(c2BKr,
                       label: GHC.Word.$fNumWord32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BKr: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.485484377 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { info_tbl: [(c2BKH,
                       label: GHC.Word.$fNumWord32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BKH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BKX; else goto c2BKY;
       c2BKX: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BKY: // global
           I64[Sp - 8] = block_c2BKE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BL2; else goto c2BKF;
       u2BL2: // global
           call _c2BKE(R1) args: 0, res: 0, upd: 0;
       c2BKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BKE() //  [R1]
         { info_tbl: [(c2BKE,
                       label: block_c2BKE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BKE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BL1; else goto c2BL0;
       c2BL1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BL0: // global
           _s2uWj::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.492228359 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2BLl,
                       label: GHC.Word.$fNumWord32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BLA; else goto c2BLB;
       c2BLA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BLB: // global
           I64[Sp - 16] = block_c2BLi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BLH; else goto c2BLj;
       u2BLH: // global
           call _c2BLi(R1) args: 0, res: 0, upd: 0;
       c2BLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BLi() //  [R1]
         { info_tbl: [(c2BLi,
                       label: block_c2BLi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BLi: // global
           I64[Sp] = block_c2BLo_info;
           _s2uWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWn::I64;
           if (R1 & 7 != 0) goto u2BLG; else goto c2BLp;
       u2BLG: // global
           call _c2BLo(R1) args: 0, res: 0, upd: 0;
       c2BLp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BLo() //  [R1]
         { info_tbl: [(c2BLo,
                       label: block_c2BLo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BLo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BLF; else goto c2BLE;
       c2BLF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BLE: // global
           _s2uWr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.501520883 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2BM6,
                       label: GHC.Word.$fNumWord32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BM6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BMl; else goto c2BMm;
       c2BMl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BMm: // global
           I64[Sp - 16] = block_c2BM3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BMs; else goto c2BM4;
       u2BMs: // global
           call _c2BM3(R1) args: 0, res: 0, upd: 0;
       c2BM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BM3() //  [R1]
         { info_tbl: [(c2BM3,
                       label: block_c2BM3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BM3: // global
           I64[Sp] = block_c2BM9_info;
           _s2uWv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWv::I64;
           if (R1 & 7 != 0) goto u2BMr; else goto c2BMa;
       u2BMr: // global
           call _c2BM9(R1) args: 0, res: 0, upd: 0;
       c2BMa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BM9() //  [R1]
         { info_tbl: [(c2BM9,
                       label: block_c2BM9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BM9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BMq; else goto c2BMp;
       c2BMq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BMp: // global
           _s2uWz::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.509511816 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2BMR,
                       label: GHC.Word.$fNumWord32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BMR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BN6; else goto c2BN7;
       c2BN6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BN7: // global
           I64[Sp - 16] = block_c2BMO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BNd; else goto c2BMP;
       u2BNd: // global
           call _c2BMO(R1) args: 0, res: 0, upd: 0;
       c2BMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BMO() //  [R1]
         { info_tbl: [(c2BMO,
                       label: block_c2BMO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BMO: // global
           I64[Sp] = block_c2BMU_info;
           _s2uWD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWD::I64;
           if (R1 & 7 != 0) goto u2BNc; else goto c2BMV;
       u2BNc: // global
           call _c2BMU(R1) args: 0, res: 0, upd: 0;
       c2BMV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BMU() //  [R1]
         { info_tbl: [(c2BMU,
                       label: block_c2BMU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BMU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BNb; else goto c2BNa;
       c2BNb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BNa: // global
           _s2uWH::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.519054362 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { info_tbl: [(c2BNC,
                       label: GHC.Word.$ctoInteger2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BNC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BND; else goto c2BNE;
       c2BND: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BNE: // global
           I64[Sp - 8] = block_c2BNz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BNJ; else goto c2BNA;
       u2BNJ: // global
           call _c2BNz(R1) args: 0, res: 0, upd: 0;
       c2BNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BNz() //  [R1]
         { info_tbl: [(c2BNz,
                       label: block_c2BNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BNz: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.524848228 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2BO0,
                       label: GHC.Word.$fBitsWord32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BO0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BOb; else goto c2BOc;
       c2BOb: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BOc: // global
           I64[Sp - 8] = block_c2BNX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BOg; else goto c2BNY;
       u2BOg: // global
           call _c2BNX(R1) args: 0, res: 0, upd: 0;
       c2BNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BNX() //  [R1]
         { info_tbl: [(c2BNX,
                       label: block_c2BNX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BNX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BOf; else goto c2BOe;
       c2BOf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BOe: // global
           (_c2BO3::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BO3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.532043372 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BOy,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BOy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BOK; else goto c2BOL;
       c2BOK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BOL: // global
           I64[Sp - 16] = block_c2BOv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BOR; else goto c2BOw;
       u2BOR: // global
           call _c2BOv(R1) args: 0, res: 0, upd: 0;
       c2BOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BOv() //  [R1]
         { info_tbl: [(c2BOv,
                       label: block_c2BOv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BOv: // global
           I64[Sp] = block_c2BOB_info;
           _s2uWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWU::I64;
           if (R1 & 7 != 0) goto u2BOQ; else goto c2BOC;
       u2BOQ: // global
           call _c2BOB(R1) args: 0, res: 0, upd: 0;
       c2BOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BOB() //  [R1]
         { info_tbl: [(c2BOB,
                       label: block_c2BOB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BOB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BOP; else goto c2BOO;
       c2BOP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BOO: // global
           _s2uWX::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.540493856 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BPe,
                       label: GHC.Word.$fBitsWord32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BPe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BPi; else goto c2BPj;
       c2BPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BPj: // global
           I64[Sp - 16] = block_c2BPb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BPD; else goto c2BPc;
       u2BPD: // global
           call _c2BPb(R1) args: 0, res: 0, upd: 0;
       c2BPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BPb() //  [R1]
         { info_tbl: [(c2BPb,
                       label: block_c2BPb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BPb: // global
           I64[Sp] = block_c2BPh_info;
           _s2uX1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX1::I64;
           if (R1 & 7 != 0) goto u2BPC; else goto c2BPl;
       u2BPC: // global
           call _c2BPh(R1) args: 0, res: 0, upd: 0;
       c2BPl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BPh() //  [R1]
         { info_tbl: [(c2BPh,
                       label: block_c2BPh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BPh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BPr; else goto c2BPq;
       c2BPr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BPq: // global
           _s2uX3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uX3::I64, 64)) goto c2BPA; else goto c2BPB;
       c2BPA: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uX3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BPB: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.549928603 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BQ1,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BQg; else goto c2BQh;
       c2BQg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BQh: // global
           I64[Sp - 16] = block_c2BPY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BQn; else goto c2BPZ;
       u2BQn: // global
           call _c2BPY(R1) args: 0, res: 0, upd: 0;
       c2BPZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BPY() //  [R1]
         { info_tbl: [(c2BPY,
                       label: block_c2BPY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BPY: // global
           I64[Sp] = block_c2BQ4_info;
           _s2uX9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX9::I64;
           if (R1 & 7 != 0) goto u2BQm; else goto c2BQ5;
       u2BQm: // global
           call _c2BQ4(R1) args: 0, res: 0, upd: 0;
       c2BQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BQ4() //  [R1]
         { info_tbl: [(c2BQ4,
                       label: block_c2BQ4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BQ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BQl; else goto c2BQk;
       c2BQl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BQk: // global
           _s2uXd::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.55870413 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BQK,
                       label: GHC.Word.$fBitsWord32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BQO; else goto c2BQP;
       c2BQO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BQP: // global
           I64[Sp - 16] = block_c2BQH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BRc; else goto c2BQI;
       u2BRc: // global
           call _c2BQH(R1) args: 0, res: 0, upd: 0;
       c2BQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BQH() //  [R1]
         { info_tbl: [(c2BQH,
                       label: block_c2BQH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BQH: // global
           I64[Sp] = block_c2BQN_info;
           _s2uXh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXh::I64;
           if (R1 & 7 != 0) goto u2BRb; else goto c2BQR;
       u2BRb: // global
           call _c2BQN(R1) args: 0, res: 0, upd: 0;
       c2BQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BQN() //  [R1]
         { info_tbl: [(c2BQN,
                       label: block_c2BQN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BQX; else goto c2BQW;
       c2BQX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BQW: // global
           _s2uXj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXj::I64, 64)) goto c2BR9; else goto c2BRa;
       c2BR9: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2uXj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BRa: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.567493173 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { info_tbl: [(c2BRy,
                       label: GHC.Word.$fBitsWord32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BRy: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.571794157 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2BRN,
                       label: GHC.Word.$fBitsWord32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BRN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BRR; else goto c2BRS;
       c2BRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BRS: // global
           I64[Sp - 16] = block_c2BRK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BSF; else goto c2BRL;
       u2BSF: // global
           call _c2BRK(R1) args: 0, res: 0, upd: 0;
       c2BRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BRK() //  [R1]
         { info_tbl: [(c2BRK,
                       label: block_c2BRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BRK: // global
           I64[Sp - 8] = block_c2BRQ_info;
           _s2uXq::P64 = R1;
           _s2uXr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uXr::I64;
           P64[Sp + 8] = _s2uXq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BSE; else goto c2BRU;
       u2BSE: // global
           call _c2BRQ(R1) args: 0, res: 0, upd: 0;
       c2BRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BRQ() //  [R1]
         { info_tbl: [(c2BRQ,
                       label: block_c2BRQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BRQ: // global
           _s2uXw::I64 = I64[R1 + 7] & 31;
           if (_s2uXw::I64 != 0) goto u2BSC; else goto c2BSy;
       u2BSC: // global
           I64[Sp + 16] = _s2uXw::I64;
           Sp = Sp + 8;
           call _c2BS9() args: 0, res: 0, upd: 0;
       c2BSy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BS9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BS9: // global
           Hp = Hp + 16;
           _s2uXw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BSv; else goto c2BSu;
       c2BSv: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2BS8_info;
           R1 = _s2uXw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BSu: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2uXr::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2uXr::I64 << _s2uXw::I64) | (_s2uXr::I64 >> 32 - _s2uXw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BS8() //  [R1]
         { info_tbl: [(c2BS8,
                       label: block_c2BS8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BS8: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2BS9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.584306316 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2BTh,
                       label: GHC.Word.$fBitsWord32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BTh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BTl; else goto c2BTm;
       c2BTl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BTm: // global
           I64[Sp - 16] = block_c2BTe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BU3; else goto c2BTf;
       u2BU3: // global
           call _c2BTe(R1) args: 0, res: 0, upd: 0;
       c2BTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BTe() //  [R1]
         { info_tbl: [(c2BTe,
                       label: block_c2BTe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BTe: // global
           I64[Sp] = block_c2BTk_info;
           _s2uXF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXF::I64;
           if (R1 & 7 != 0) goto u2BU2; else goto c2BTo;
       u2BU2: // global
           call _c2BTk(R1) args: 0, res: 0, upd: 0;
       c2BTo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BTk() //  [R1]
         { info_tbl: [(c2BTk,
                       label: block_c2BTk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BTk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BTu; else goto c2BTt;
       c2BTu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BTt: // global
           _s2uXF::I64 = I64[Sp + 8];
           _s2uXH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXH::I64, 0)) goto c2BTM; else goto c2BU1;
       c2BTM: // global
           _s2uXJ::I64 = -_s2uXH::I64;
           if (%MO_S_Ge_W64(_s2uXJ::I64, 64)) goto c2BU0; else goto c2BTJ;
       c2BTJ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXF::I64 >> _s2uXJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BU1: // global
           if (%MO_S_Ge_W64(_s2uXH::I64, 64)) goto c2BU0; else goto c2BTZ;
       c2BU0: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BTZ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uXF::I64 << _s2uXH::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.59422859 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2BUu,
                       label: GHC.Word.$fBitsWord32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BUu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BUG; else goto c2BUH;
       c2BUG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BUH: // global
           I64[Sp - 16] = block_c2BUr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BUN; else goto c2BUs;
       u2BUN: // global
           call _c2BUr(R1) args: 0, res: 0, upd: 0;
       c2BUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BUr() //  [R1]
         { info_tbl: [(c2BUr,
                       label: block_c2BUr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BUr: // global
           I64[Sp] = block_c2BUx_info;
           _s2uXS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXS::I64;
           if (R1 & 7 != 0) goto u2BUM; else goto c2BUy;
       u2BUM: // global
           call _c2BUx(R1) args: 0, res: 0, upd: 0;
       c2BUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BUx() //  [R1]
         { info_tbl: [(c2BUx,
                       label: block_c2BUx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BUx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BUL; else goto c2BUK;
       c2BUL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BUK: // global
           _s2uXV::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.602505703 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2BVb,
                       label: GHC.Word.$fBitsWord32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BVn; else goto c2BVo;
       c2BVn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BVo: // global
           I64[Sp - 16] = block_c2BV8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BVu; else goto c2BV9;
       u2BVu: // global
           call _c2BV8(R1) args: 0, res: 0, upd: 0;
       c2BV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BV8() //  [R1]
         { info_tbl: [(c2BV8,
                       label: block_c2BV8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BV8: // global
           I64[Sp] = block_c2BVe_info;
           _s2uXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXZ::I64;
           if (R1 & 7 != 0) goto u2BVt; else goto c2BVf;
       u2BVt: // global
           call _c2BVe(R1) args: 0, res: 0, upd: 0;
       c2BVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BVe() //  [R1]
         { info_tbl: [(c2BVe,
                       label: block_c2BVe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BVe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BVs; else goto c2BVr;
       c2BVs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BVr: // global
           _s2uY2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.611425977 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2BVS,
                       label: GHC.Word.$fBitsWord32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BVS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BW4; else goto c2BW5;
       c2BW4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BW5: // global
           I64[Sp - 16] = block_c2BVP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BWb; else goto c2BVQ;
       u2BWb: // global
           call _c2BVP(R1) args: 0, res: 0, upd: 0;
       c2BVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BVP() //  [R1]
         { info_tbl: [(c2BVP,
                       label: block_c2BVP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BVP: // global
           I64[Sp] = block_c2BVV_info;
           _s2uY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uY6::I64;
           if (R1 & 7 != 0) goto u2BWa; else goto c2BVW;
       u2BWa: // global
           call _c2BVV(R1) args: 0, res: 0, upd: 0;
       c2BVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BVV() //  [R1]
         { info_tbl: [(c2BVV,
                       label: block_c2BVV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BVV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BW9; else goto c2BW8;
       c2BW9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BW8: // global
           _s2uY9::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.620141148 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2BWz,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BWz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BWK; else goto c2BWL;
       c2BWK: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BWL: // global
           I64[Sp - 8] = block_c2BWw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BWP; else goto c2BWx;
       u2BWP: // global
           call _c2BWw(R1) args: 0, res: 0, upd: 0;
       c2BWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BWw() //  [R1]
         { info_tbl: [(c2BWw,
                       label: block_c2BWw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BWw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BWO; else goto c2BWN;
       c2BWO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BWN: // global
           (_c2BWC::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BWC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.626881626 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2BX9,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BX9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BXk; else goto c2BXl;
       c2BXk: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BXl: // global
           I64[Sp - 8] = block_c2BX6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BXp; else goto c2BX7;
       u2BXp: // global
           call _c2BX6(R1) args: 0, res: 0, upd: 0;
       c2BX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BX6() //  [R1]
         { info_tbl: [(c2BX6,
                       label: block_c2BX6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BX6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BXo; else goto c2BXn;
       c2BXo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BXn: // global
           (_c2BXc::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BXc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.632821866 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.635575706 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2BXH,
                       label: GHC.Word.$fBitsWord32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BXH: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.639417938 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2BXW,
                       label: GHC.Word.$fBitsWord64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BXW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BY7; else goto c2BY8;
       c2BY7: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BY8: // global
           I64[Sp - 8] = block_c2BXT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BYc; else goto c2BXU;
       u2BYc: // global
           call _c2BXT(R1) args: 0, res: 0, upd: 0;
       c2BXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BXT() //  [R1]
         { info_tbl: [(c2BXT,
                       label: block_c2BXT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BXT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BYb; else goto c2BYa;
       c2BYb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BYa: // global
           (_c2BXZ::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BXZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.646238184 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BYu,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BYu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BYG; else goto c2BYH;
       c2BYG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BYH: // global
           I64[Sp - 16] = block_c2BYr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BYN; else goto c2BYs;
       u2BYN: // global
           call _c2BYr(R1) args: 0, res: 0, upd: 0;
       c2BYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BYr() //  [R1]
         { info_tbl: [(c2BYr,
                       label: block_c2BYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BYr: // global
           I64[Sp] = block_c2BYx_info;
           _s2uYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYt::I64;
           if (R1 & 7 != 0) goto u2BYM; else goto c2BYy;
       u2BYM: // global
           call _c2BYx(R1) args: 0, res: 0, upd: 0;
       c2BYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BYx() //  [R1]
         { info_tbl: [(c2BYx,
                       label: block_c2BYx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BYx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BYL; else goto c2BYK;
       c2BYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BYK: // global
           _s2uYw::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.655111245 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2BZa,
                       label: GHC.Word.$fBitsWord64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BZa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BZe; else goto c2BZf;
       c2BZe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BZf: // global
           I64[Sp - 16] = block_c2BZ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BZz; else goto c2BZ8;
       u2BZz: // global
           call _c2BZ7(R1) args: 0, res: 0, upd: 0;
       c2BZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BZ7() //  [R1]
         { info_tbl: [(c2BZ7,
                       label: block_c2BZ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BZ7: // global
           I64[Sp] = block_c2BZd_info;
           _s2uYA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYA::I64;
           if (R1 & 7 != 0) goto u2BZy; else goto c2BZh;
       u2BZy: // global
           call _c2BZd(R1) args: 0, res: 0, upd: 0;
       c2BZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BZd() //  [R1]
         { info_tbl: [(c2BZd,
                       label: block_c2BZd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BZd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BZn; else goto c2BZm;
       c2BZn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BZm: // global
           _s2uYC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYC::I64, 64)) goto c2BZw; else goto c2BZx;
       c2BZw: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uYC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BZx: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.663838791 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2BZX,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BZX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C09; else goto c2C0a;
       c2C09: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C0a: // global
           I64[Sp - 16] = block_c2BZU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C0g; else goto c2BZV;
       u2C0g: // global
           call _c2BZU(R1) args: 0, res: 0, upd: 0;
       c2BZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2BZU() //  [R1]
         { info_tbl: [(c2BZU,
                       label: block_c2BZU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2BZU: // global
           I64[Sp] = block_c2C00_info;
           _s2uYI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYI::I64;
           if (R1 & 7 != 0) goto u2C0f; else goto c2C01;
       u2C0f: // global
           call _c2C00(R1) args: 0, res: 0, upd: 0;
       c2C01: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C00() //  [R1]
         { info_tbl: [(c2C00,
                       label: block_c2C00_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C00: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C0e; else goto c2C0d;
       c2C0e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C0d: // global
           _s2uYL::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.672622948 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2C0D,
                       label: GHC.Word.$fBitsWord64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C0D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C0H; else goto c2C0I;
       c2C0H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C0I: // global
           I64[Sp - 16] = block_c2C0A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C12; else goto c2C0B;
       u2C12: // global
           call _c2C0A(R1) args: 0, res: 0, upd: 0;
       c2C0B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C0A() //  [R1]
         { info_tbl: [(c2C0A,
                       label: block_c2C0A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C0A: // global
           I64[Sp] = block_c2C0G_info;
           _s2uYP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYP::I64;
           if (R1 & 7 != 0) goto u2C11; else goto c2C0K;
       u2C11: // global
           call _c2C0G(R1) args: 0, res: 0, upd: 0;
       c2C0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C0G() //  [R1]
         { info_tbl: [(c2C0G,
                       label: block_c2C0G_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C0G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C0Q; else goto c2C0P;
       c2C0Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C0P: // global
           _s2uYR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYR::I64, 64)) goto c2C0Z; else goto c2C10;
       c2C0Z: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2uYR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C10: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.681525355 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { info_tbl: [(c2C1n,
                       label: GHC.Word.$fBitsWord64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1n: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.686094997 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2C1C,
                       label: GHC.Word.$fBitsWord64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2C1G; else goto c2C1H;
       c2C1G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C1H: // global
           I64[Sp - 16] = block_c2C1z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C2r; else goto c2C1A;
       u2C2r: // global
           call _c2C1z(R1) args: 0, res: 0, upd: 0;
       c2C1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C1z() //  [R1]
         { info_tbl: [(c2C1z,
                       label: block_c2C1z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1z: // global
           I64[Sp - 8] = block_c2C1F_info;
           _s2uYX::P64 = R1;
           _s2uYY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uYY::I64;
           P64[Sp + 8] = _s2uYX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C2q; else goto c2C1J;
       u2C2q: // global
           call _c2C1F(R1) args: 0, res: 0, upd: 0;
       c2C1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C1F() //  [R1]
         { info_tbl: [(c2C1F,
                       label: block_c2C1F_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1F: // global
           _s2uZ3::I64 = I64[R1 + 7] & 63;
           if (_s2uZ3::I64 != 0) goto u2C2o; else goto c2C2k;
       u2C2o: // global
           I64[Sp + 16] = _s2uZ3::I64;
           Sp = Sp + 8;
           call _c2C1Y() args: 0, res: 0, upd: 0;
       c2C2k: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2C1Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1Y: // global
           Hp = Hp + 16;
           _s2uZ3::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2C2h; else goto c2C2g;
       c2C2h: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2C1X_info;
           R1 = _s2uZ3::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2C2g: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2uYY::I64 = I64[Sp];
           I64[Hp] = (_s2uYY::I64 << _s2uZ3::I64) | (_s2uYY::I64 >> 64 - _s2uZ3::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2C1X() //  [R1]
         { info_tbl: [(c2C1X,
                       label: block_c2C1X_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C1X: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2C1Y() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.698004947 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2C32,
                       label: GHC.Word.$fBitsWord64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C36; else goto c2C37;
       c2C36: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C37: // global
           I64[Sp - 16] = block_c2C2Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C3L; else goto c2C30;
       u2C3L: // global
           call _c2C2Z(R1) args: 0, res: 0, upd: 0;
       c2C30: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C2Z() //  [R1]
         { info_tbl: [(c2C2Z,
                       label: block_c2C2Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C2Z: // global
           I64[Sp] = block_c2C35_info;
           _s2uZb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZb::I64;
           if (R1 & 7 != 0) goto u2C3K; else goto c2C39;
       u2C3K: // global
           call _c2C35(R1) args: 0, res: 0, upd: 0;
       c2C39: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C35() //  [R1]
         { info_tbl: [(c2C35,
                       label: block_c2C35_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C3f; else goto c2C3e;
       c2C3f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C3e: // global
           _s2uZb::I64 = I64[Sp + 8];
           _s2uZd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uZd::I64, 0)) goto c2C3x; else goto c2C3J;
       c2C3x: // global
           _s2uZf::I64 = -_s2uZd::I64;
           if (%MO_S_Ge_W64(_s2uZf::I64, 64)) goto c2C3I; else goto c2C3u;
       c2C3u: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 >> _s2uZf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C3J: // global
           if (%MO_S_Ge_W64(_s2uZd::I64, 64)) goto c2C3I; else goto c2C3H;
       c2C3I: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C3H: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 << _s2uZd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.707341585 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2C4b,
                       label: GHC.Word.$fBitsWord64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C4b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C4n; else goto c2C4o;
       c2C4n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C4o: // global
           I64[Sp - 16] = block_c2C48_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C4u; else goto c2C49;
       u2C4u: // global
           call _c2C48(R1) args: 0, res: 0, upd: 0;
       c2C49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C48() //  [R1]
         { info_tbl: [(c2C48,
                       label: block_c2C48_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C48: // global
           I64[Sp] = block_c2C4e_info;
           _s2uZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZn::I64;
           if (R1 & 7 != 0) goto u2C4t; else goto c2C4f;
       u2C4t: // global
           call _c2C4e(R1) args: 0, res: 0, upd: 0;
       c2C4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C4e() //  [R1]
         { info_tbl: [(c2C4e,
                       label: block_c2C4e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C4e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C4s; else goto c2C4r;
       c2C4s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C4r: // global
           _s2uZq::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.715996126 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2C4S,
                       label: GHC.Word.$fBitsWord64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C54; else goto c2C55;
       c2C54: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C55: // global
           I64[Sp - 16] = block_c2C4P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C5b; else goto c2C4Q;
       u2C5b: // global
           call _c2C4P(R1) args: 0, res: 0, upd: 0;
       c2C4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C4P() //  [R1]
         { info_tbl: [(c2C4P,
                       label: block_c2C4P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C4P: // global
           I64[Sp] = block_c2C4V_info;
           _s2uZu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZu::I64;
           if (R1 & 7 != 0) goto u2C5a; else goto c2C4W;
       u2C5a: // global
           call _c2C4V(R1) args: 0, res: 0, upd: 0;
       c2C4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C4V() //  [R1]
         { info_tbl: [(c2C4V,
                       label: block_c2C4V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C4V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C59; else goto c2C58;
       c2C59: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C58: // global
           _s2uZx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.724480345 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2C5z,
                       label: GHC.Word.$fBitsWord64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C5L; else goto c2C5M;
       c2C5L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C5M: // global
           I64[Sp - 16] = block_c2C5w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C5S; else goto c2C5x;
       u2C5S: // global
           call _c2C5w(R1) args: 0, res: 0, upd: 0;
       c2C5x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C5w() //  [R1]
         { info_tbl: [(c2C5w,
                       label: block_c2C5w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C5w: // global
           I64[Sp] = block_c2C5C_info;
           _s2uZB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZB::I64;
           if (R1 & 7 != 0) goto u2C5R; else goto c2C5D;
       u2C5R: // global
           call _c2C5C(R1) args: 0, res: 0, upd: 0;
       c2C5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C5C() //  [R1]
         { info_tbl: [(c2C5C,
                       label: block_c2C5C_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C5C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C5Q; else goto c2C5P;
       c2C5Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C5P: // global
           _s2uZE::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.73316579 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2C6g,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C6g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C6r; else goto c2C6s;
       c2C6r: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C6s: // global
           I64[Sp - 8] = block_c2C6d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C6w; else goto c2C6e;
       u2C6w: // global
           call _c2C6d(R1) args: 0, res: 0, upd: 0;
       c2C6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C6d() //  [R1]
         { info_tbl: [(c2C6d,
                       label: block_c2C6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C6d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C6v; else goto c2C6u;
       c2C6v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C6u: // global
           (_c2C6j::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2C6j::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.739308669 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2C6Q,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C6Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C71; else goto c2C72;
       c2C71: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C72: // global
           I64[Sp - 8] = block_c2C6N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C76; else goto c2C6O;
       u2C76: // global
           call _c2C6N(R1) args: 0, res: 0, upd: 0;
       c2C6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C6N() //  [R1]
         { info_tbl: [(c2C6N,
                       label: block_c2C6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C6N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C75; else goto c2C74;
       c2C75: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C74: // global
           (_c2C6T::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2C6T::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.74559606 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.747559566 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2C7o,
                       label: GHC.Word.$fBitsWord64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C7o: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.751220363 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { info_tbl: [(c2C7D,
                       label: GHC.Word.eqWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C7H; else goto c2C7I;
       c2C7H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C7I: // global
           I64[Sp - 16] = block_c2C7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C7R; else goto c2C7B;
       u2C7R: // global
           call _c2C7A(R1) args: 0, res: 0, upd: 0;
       c2C7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C7A() //  [R1]
         { info_tbl: [(c2C7A,
                       label: block_c2C7A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C7A: // global
           I64[Sp] = block_c2C7G_info;
           _s2uZT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZT::I64;
           if (R1 & 7 != 0) goto u2C7Q; else goto c2C7K;
       u2C7Q: // global
           call _c2C7G(R1) args: 0, res: 0, upd: 0;
       c2C7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C7G() //  [R1]
         { info_tbl: [(c2C7G,
                       label: block_c2C7G_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C7G: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.759073983 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.760876346 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.76305927 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { info_tbl: [(c2C8i,
                       label: GHC.Word.$fNumWord8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C8i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C8j; else goto c2C8k;
       c2C8j: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C8k: // global
           I64[Sp - 8] = block_c2C8f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C8s; else goto c2C8g;
       u2C8s: // global
           call _c2C8f(R1) args: 0, res: 0, upd: 0;
       c2C8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C8f() //  [R1]
         { info_tbl: [(c2C8f,
                       label: block_c2C8f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C8f: // global
           if (I64[R1 + 7] == 0) goto c2C8r; else goto c2C8q;
       c2C8r: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C8q: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.769104582 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.771568209 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2C8M,
                       label: GHC.Word.$fBitsWord8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C8M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C8T; else goto c2C8U;
       c2C8T: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C8U: // global
           I64[Sp - 8] = block_c2C8J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C8Y; else goto c2C8K;
       u2C8Y: // global
           call _c2C8J(R1) args: 0, res: 0, upd: 0;
       c2C8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C8J() //  [R1]
         { info_tbl: [(c2C8J,
                       label: block_c2C8J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C8J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C8X; else goto c2C8W;
       c2C8X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C8W: // global
           _s2v04::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v04::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.777541901 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.779601691 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2C9f,
                       label: GHC.Word.$fBitsWord8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C9f: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.784164126 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { info_tbl: [(c2C9u,
                       label: GHC.Word.$fBitsWord8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C9v; else goto c2C9w;
       c2C9v: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C9w: // global
           I64[Sp - 8] = block_c2C9r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C9P; else goto c2C9s;
       u2C9P: // global
           call _c2C9r(R1) args: 0, res: 0, upd: 0;
       c2C9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2C9r() //  [R1]
         { info_tbl: [(c2C9r,
                       label: block_c2C9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2C9r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C9B; else goto c2C9A;
       c2C9B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C9A: // global
           _s2v08::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v08::I64, 64)) goto c2C9N; else goto c2C9O;
       c2C9N: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v08::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C9O: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.791118244 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2Cab,
                       label: GHC.Word.$fBitsWord8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Caf; else goto c2Cag;
       c2Caf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cag: // global
           I64[Sp - 16] = block_c2Ca8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CaP; else goto c2Ca9;
       u2CaP: // global
           call _c2Ca8(R1) args: 0, res: 0, upd: 0;
       c2Ca9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ca8() //  [R1]
         { info_tbl: [(c2Ca8,
                       label: block_c2Ca8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ca8: // global
           I64[Sp] = block_c2Cae_info;
           _s2v0f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0f::I64;
           if (R1 & 7 != 0) goto u2CaO; else goto c2Cai;
       u2CaO: // global
           call _c2Cae(R1) args: 0, res: 0, upd: 0;
       c2Cai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cae() //  [R1]
         { info_tbl: [(c2Cae,
                       label: block_c2Cae_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cae: // global
           _s2v0h::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v0h::I64, 64)) goto c2CaN; else goto c2CaM;
       c2CaM: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0h::I64)) == 0) goto c2CaN; else goto c2CaB;
       c2CaN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CaB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.800543941 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2Cbh,
                       label: GHC.Word.$fBitsWord8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cbh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cbl; else goto c2Cbm;
       c2Cbl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cbm: // global
           I64[Sp - 16] = block_c2Cbe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ccc; else goto c2Cbf;
       u2Ccc: // global
           call _c2Cbe(R1) args: 0, res: 0, upd: 0;
       c2Cbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cbe() //  [R1]
         { info_tbl: [(c2Cbe,
                       label: block_c2Cbe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cbe: // global
           I64[Sp - 8] = block_c2Cbk_info;
           _s2v0o::P64 = R1;
           _s2v0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0p::I64;
           P64[Sp + 8] = _s2v0o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ccb; else goto c2Cbo;
       u2Ccb: // global
           call _c2Cbk(R1) args: 0, res: 0, upd: 0;
       c2Cbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cbk() //  [R1]
         { info_tbl: [(c2Cbk,
                       label: block_c2Cbk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cbk: // global
           _s2v0v::I64 = -I64[R1 + 7] & 7;
           if (_s2v0v::I64 != 0) goto u2Cc9; else goto c2Cc5;
       u2Cc9: // global
           I64[Sp + 16] = _s2v0v::I64;
           Sp = Sp + 8;
           call _c2CbG() args: 0, res: 0, upd: 0;
       c2Cc5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CbG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CbG: // global
           Hp = Hp + 16;
           _s2v0v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Cc2; else goto c2Cc1;
       c2Cc2: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2CbF_info;
           R1 = _s2v0v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Cc1: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2v0p::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2v0p::I64 << _s2v0v::I64) | (_s2v0p::I64 >> 8 - _s2v0v::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CbF() //  [R1]
         { info_tbl: [(c2CbF,
                       label: block_c2CbF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CbF: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2CbG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.811734962 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2CcL,
                       label: GHC.Word.$fBitsWord8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CcL: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.816113931 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2CcZ,
                       label: GHC.Word.$fBitsWord8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CcZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cd3; else goto c2Cd4;
       c2Cd3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cd4: // global
           I64[Sp - 16] = block_c2CcW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cdu; else goto c2CcX;
       u2Cdu: // global
           call _c2CcW(R1) args: 0, res: 0, upd: 0;
       c2CcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CcW() //  [R1]
         { info_tbl: [(c2CcW,
                       label: block_c2CcW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CcW: // global
           I64[Sp - 8] = block_c2Cd2_info;
           _s2v0D::P64 = R1;
           _s2v0E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0E::I64;
           P64[Sp + 8] = _s2v0D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cdt; else goto c2Cd6;
       u2Cdt: // global
           call _c2Cd2(R1) args: 0, res: 0, upd: 0;
       c2Cd6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cd2() //  [R1]
         { info_tbl: [(c2Cd2,
                       label: block_c2Cd2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cd2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cdc; else goto c2Cdb;
       c2Cdc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cdb: // global
           _s2v0G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0G::I64, 64)) goto c2Cdr; else goto c2Cds;
       c2Cdr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0G::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cds: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.824799968 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2CdX,
                       label: GHC.Word.$fBitsWord8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CdX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ce1; else goto c2Ce2;
       c2Ce1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ce2: // global
           I64[Sp - 16] = block_c2CdU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CeA; else goto c2CdV;
       u2CeA: // global
           call _c2CdU(R1) args: 0, res: 0, upd: 0;
       c2CdV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CdU() //  [R1]
         { info_tbl: [(c2CdU,
                       label: block_c2CdU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CdU: // global
           I64[Sp] = block_c2Ce0_info;
           _s2v0O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0O::I64;
           if (R1 & 7 != 0) goto u2Cez; else goto c2Ce4;
       u2Cez: // global
           call _c2Ce0(R1) args: 0, res: 0, upd: 0;
       c2Ce4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ce0() //  [R1]
         { info_tbl: [(c2Ce0,
                       label: block_c2Ce0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ce0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cea; else goto c2Ce9;
       c2Cea: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ce9: // global
           _s2v0O::I64 = I64[Sp + 8];
           _s2v0Q::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0Q::I64, 64)) goto c2Ces; else goto c2Cey;
       c2Ces: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0Q::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cey: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.833958672 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2Cf5,
                       label: GHC.Word.$fBitsWord8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cf5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cf9; else goto c2Cfa;
       c2Cf9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cfa: // global
           I64[Sp - 16] = block_c2Cf2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CfA; else goto c2Cf3;
       u2CfA: // global
           call _c2Cf2(R1) args: 0, res: 0, upd: 0;
       c2Cf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cf2() //  [R1]
         { info_tbl: [(c2Cf2,
                       label: block_c2Cf2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cf2: // global
           I64[Sp - 8] = block_c2Cf8_info;
           _s2v0Z::P64 = R1;
           _s2v10::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v10::I64;
           P64[Sp + 8] = _s2v0Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cfz; else goto c2Cfc;
       u2Cfz: // global
           call _c2Cf8(R1) args: 0, res: 0, upd: 0;
       c2Cfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cf8() //  [R1]
         { info_tbl: [(c2Cf8,
                       label: block_c2Cf8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cf8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cfi; else goto c2Cfh;
       c2Cfi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cfh: // global
           _s2v12::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v12::I64, 64)) goto c2Cfx; else goto c2Cfy;
       c2Cfx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v12::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cfy: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.8429665 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.845203342 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.84768295 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2Cg5,
                       label: GHC.Word.$fIntegralWord8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cg9; else goto c2Cga;
       c2Cg9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cga: // global
           I64[Sp - 16] = block_c2Cg2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cgt; else goto c2Cg3;
       u2Cgt: // global
           call _c2Cg2(R1) args: 0, res: 0, upd: 0;
       c2Cg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cg2() //  [R1]
         { info_tbl: [(c2Cg2,
                       label: block_c2Cg2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cg2: // global
           I64[Sp] = block_c2Cg8_info;
           _s2v1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1a::I64;
           if (R1 & 7 != 0) goto u2Cgs; else goto c2Cgc;
       u2Cgs: // global
           call _c2Cg8(R1) args: 0, res: 0, upd: 0;
       c2Cgc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cg8() //  [R1]
         { info_tbl: [(c2Cg8,
                       label: block_c2Cg8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cg8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cgi; else goto c2Cgh;
       c2Cgi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cgh: // global
           _s2v1d::I64 = I64[R1 + 7];
           if (_s2v1d::I64 != 0) goto c2Cgq; else goto c2Cgr;
       c2Cgq: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v1d::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cgr: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.856837008 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2CgQ,
                       label: GHC.Word.$fIntegralWord8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CgQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CgU; else goto c2CgV;
       c2CgU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CgV: // global
           I64[Sp - 16] = block_c2CgN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Che; else goto c2CgO;
       u2Che: // global
           call _c2CgN(R1) args: 0, res: 0, upd: 0;
       c2CgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CgN() //  [R1]
         { info_tbl: [(c2CgN,
                       label: block_c2CgN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CgN: // global
           I64[Sp] = block_c2CgT_info;
           _s2v1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1i::I64;
           if (R1 & 7 != 0) goto u2Chd; else goto c2CgX;
       u2Chd: // global
           call _c2CgT(R1) args: 0, res: 0, upd: 0;
       c2CgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CgT() //  [R1]
         { info_tbl: [(c2CgT,
                       label: block_c2CgT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CgT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ch3; else goto c2Ch2;
       c2Ch3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ch2: // global
           _s2v1l::I64 = I64[R1 + 7];
           if (_s2v1l::I64 != 0) goto c2Chb; else goto c2Chc;
       c2Chb: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v1l::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Chc: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.867104118 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2ChB,
                       label: GHC.Word.$fIntegralWord8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ChB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ChF; else goto c2ChG;
       c2ChF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ChG: // global
           I64[Sp - 16] = block_c2Chy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ChY; else goto c2Chz;
       u2ChY: // global
           call _c2Chy(R1) args: 0, res: 0, upd: 0;
       c2Chz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Chy() //  [R1]
         { info_tbl: [(c2Chy,
                       label: block_c2Chy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Chy: // global
           I64[Sp] = block_c2ChE_info;
           _s2v1q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1q::I64;
           if (R1 & 7 != 0) goto u2ChX; else goto c2ChI;
       u2ChX: // global
           call _c2ChE(R1) args: 0, res: 0, upd: 0;
       c2ChI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ChE() //  [R1]
         { info_tbl: [(c2ChE,
                       label: block_c2ChE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ChE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2ChO; else goto c2ChN;
       c2ChO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ChN: // global
           _s2v1t::I64 = I64[R1 + 7];
           if (_s2v1t::I64 != 0) goto c2ChV; else goto c2ChW;
       c2ChV: // global
           (_s2v1v::I64, _s2v1w::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v1t::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2v1w::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2v1v::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ChW: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.877531963 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2v1J_entry() //  [R1]
         { info_tbl: [(c2CiB,
                       label: sat_s2v1J_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CiB: // global
           _s2v1J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiE; else goto c2CiF;
       c2CiF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CiH; else goto c2CiG;
       c2CiH: // global
           HpAlloc = 16;
           goto c2CiE;
       c2CiE: // global
           R1 = _s2v1J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1J::P64;
           _s2v1I::I64 = I64[_s2v1J::P64 + 16] % I64[_s2v1J::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1I::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v1H_entry() //  [R1]
         { info_tbl: [(c2CiO,
                       label: sat_s2v1H_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CiO: // global
           _s2v1H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiR; else goto c2CiS;
       c2CiS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CiU; else goto c2CiT;
       c2CiU: // global
           HpAlloc = 16;
           goto c2CiR;
       c2CiR: // global
           R1 = _s2v1H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CiT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1H::P64;
           _s2v1G::I64 = I64[_s2v1H::P64 + 16] / I64[_s2v1H::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1G::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2CiV,
                       label: GHC.Word.$fIntegralWord8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CiV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiW; else goto c2CiX;
       c2CiW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CiX: // global
           I64[Sp - 16] = block_c2Cij_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cj7; else goto c2Cik;
       u2Cj7: // global
           call _c2Cij(R1) args: 0, res: 0, upd: 0;
       c2Cik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cij() //  [R1]
         { info_tbl: [(c2Cij,
                       label: block_c2Cij_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cij: // global
           I64[Sp] = block_c2Cio_info;
           _s2v1C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1C::I64;
           if (R1 & 7 != 0) goto u2Cj6; else goto c2Cip;
       u2Cj6: // global
           call _c2Cio(R1) args: 0, res: 0, upd: 0;
       c2Cip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cio() //  [R1]
         { info_tbl: [(c2Cio,
                       label: block_c2Cio_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cio: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Cj1; else goto c2Cj0;
       c2Cj1: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cj0: // global
           _s2v1F::I64 = I64[R1 + 7];
           if (_s2v1F::I64 != 0) goto c2Cj4; else goto c2Cj5;
       c2Cj4: // global
           I64[Hp - 80] = sat_s2v1J_info;
           _s2v1C::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v1C::I64;
           I64[Hp - 56] = _s2v1F::I64;
           I64[Hp - 48] = sat_s2v1H_info;
           I64[Hp - 32] = _s2v1C::I64;
           I64[Hp - 24] = _s2v1F::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cj5: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.891293406 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { info_tbl: [(c2CjF,
                       label: GHC.Word.gtWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CjJ; else goto c2CjK;
       c2CjJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CjK: // global
           I64[Sp - 16] = block_c2CjC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CjT; else goto c2CjD;
       u2CjT: // global
           call _c2CjC(R1) args: 0, res: 0, upd: 0;
       c2CjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CjC() //  [R1]
         { info_tbl: [(c2CjC,
                       label: block_c2CjC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CjC: // global
           I64[Sp] = block_c2CjI_info;
           _s2v1N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1N::I64;
           if (R1 & 7 != 0) goto u2CjS; else goto c2CjM;
       u2CjS: // global
           call _c2CjI(R1) args: 0, res: 0, upd: 0;
       c2CjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CjI() //  [R1]
         { info_tbl: [(c2CjI,
                       label: block_c2CjI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CjI: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.899330344 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { info_tbl: [(c2Cki,
                       label: GHC.Word.geWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ckm; else goto c2Ckn;
       c2Ckm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ckn: // global
           I64[Sp - 16] = block_c2Ckf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ckw; else goto c2Ckg;
       u2Ckw: // global
           call _c2Ckf(R1) args: 0, res: 0, upd: 0;
       c2Ckg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ckf() //  [R1]
         { info_tbl: [(c2Ckf,
                       label: block_c2Ckf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ckf: // global
           I64[Sp] = block_c2Ckl_info;
           _s2v1U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1U::I64;
           if (R1 & 7 != 0) goto u2Ckv; else goto c2Ckp;
       u2Ckv: // global
           call _c2Ckl(R1) args: 0, res: 0, upd: 0;
       c2Ckp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ckl() //  [R1]
         { info_tbl: [(c2Ckl,
                       label: block_c2Ckl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ckl: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.907528734 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { info_tbl: [(c2CkV,
                       label: GHC.Word.ltWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CkV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CkZ; else goto c2Cl0;
       c2CkZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cl0: // global
           I64[Sp - 16] = block_c2CkS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cl9; else goto c2CkT;
       u2Cl9: // global
           call _c2CkS(R1) args: 0, res: 0, upd: 0;
       c2CkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CkS() //  [R1]
         { info_tbl: [(c2CkS,
                       label: block_c2CkS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CkS: // global
           I64[Sp] = block_c2CkY_info;
           _s2v21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v21::I64;
           if (R1 & 7 != 0) goto u2Cl8; else goto c2Cl2;
       u2Cl8: // global
           call _c2CkY(R1) args: 0, res: 0, upd: 0;
       c2Cl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CkY() //  [R1]
         { info_tbl: [(c2CkY,
                       label: block_c2CkY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CkY: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.915498448 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { info_tbl: [(c2Cly,
                       label: GHC.Word.leWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ClC; else goto c2ClD;
       c2ClC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ClD: // global
           I64[Sp - 16] = block_c2Clv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ClM; else goto c2Clw;
       u2ClM: // global
           call _c2Clv(R1) args: 0, res: 0, upd: 0;
       c2Clw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Clv() //  [R1]
         { info_tbl: [(c2Clv,
                       label: block_c2Clv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Clv: // global
           I64[Sp] = block_c2ClB_info;
           _s2v28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v28::I64;
           if (R1 & 7 != 0) goto u2ClL; else goto c2ClF;
       u2ClL: // global
           call _c2ClB(R1) args: 0, res: 0, upd: 0;
       c2ClF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ClB() //  [R1]
         { info_tbl: [(c2ClB,
                       label: block_c2ClB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ClB: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.923732473 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2Cmb,
                       label: GHC.Word.$fOrdWord8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cmf; else goto c2Cmg;
       c2Cmf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cmg: // global
           I64[Sp - 16] = block_c2Cm8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cmz; else goto c2Cm9;
       u2Cmz: // global
           call _c2Cm8(R1) args: 0, res: 0, upd: 0;
       c2Cm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cm8() //  [R1]
         { info_tbl: [(c2Cm8,
                       label: block_c2Cm8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cm8: // global
           I64[Sp] = block_c2Cme_info;
           _s2v2f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v2f::I64;
           if (R1 & 7 != 0) goto u2Cmy; else goto c2Cmi;
       u2Cmy: // global
           call _c2Cme(R1) args: 0, res: 0, upd: 0;
       c2Cmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cme() //  [R1]
         { info_tbl: [(c2Cme,
                       label: block_c2Cme_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cme: // global
           _s2v2f::I64 = I64[Sp + 8];
           _s2v2h::I64 = I64[R1 + 7];
           if (_s2v2f::I64 == _s2v2h::I64) goto c2Cmx; else goto c2Cmw;
       c2Cmx: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cmw: // global
           if (_s2v2f::I64 > _s2v2h::I64) goto c2Cmt; else goto c2Cmu;
       c2Cmt: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cmu: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.933142729 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2CmX,
                       label: GHC.Word.$fOrdWord8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CmX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cn1; else goto c2Cn2;
       c2Cn1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cn2: // global
           I64[Sp - 16] = block_c2CmU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cnf; else goto c2CmV;
       u2Cnf: // global
           call _c2CmU(R1) args: 0, res: 0, upd: 0;
       c2CmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CmU() //  [R1]
         { info_tbl: [(c2CmU,
                       label: block_c2CmU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CmU: // global
           I64[Sp - 8] = block_c2Cn0_info;
           _s2v2m::P64 = R1;
           _s2v2n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2n::I64;
           P64[Sp + 8] = _s2v2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cne; else goto c2Cn4;
       u2Cne: // global
           call _c2Cn0(R1) args: 0, res: 0, upd: 0;
       c2Cn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cn0() //  [R1]
         { info_tbl: [(c2Cn0,
                       label: block_c2Cn0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cn0: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Cnc; else goto c2Cnd;
       c2Cnc: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Cnd: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.941565986 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2CnF,
                       label: GHC.Word.$fOrdWord8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CnF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CnJ; else goto c2CnK;
       c2CnJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CnK: // global
           I64[Sp - 16] = block_c2CnC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CnX; else goto c2CnD;
       u2CnX: // global
           call _c2CnC(R1) args: 0, res: 0, upd: 0;
       c2CnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CnC() //  [R1]
         { info_tbl: [(c2CnC,
                       label: block_c2CnC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CnC: // global
           I64[Sp - 8] = block_c2CnI_info;
           _s2v2t::P64 = R1;
           _s2v2u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2u::I64;
           P64[Sp + 8] = _s2v2t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CnW; else goto c2CnM;
       u2CnW: // global
           call _c2CnI(R1) args: 0, res: 0, upd: 0;
       c2CnM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CnI() //  [R1]
         { info_tbl: [(c2CnI,
                       label: block_c2CnI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CnI: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CnU; else goto c2CnV;
       c2CnU: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CnV: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.950153282 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.952750689 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2Coo,
                       label: GHC.Word.$fIxWord8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Coo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cox; else goto c2Coy;
       c2Cox: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Coy: // global
           I64[Sp - 16] = block_c2Col_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CoV; else goto c2Com;
       u2CoV: // global
           call _c2Col(R1) args: 0, res: 0, upd: 0;
       c2Com: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Col() //  [R1]
         { info_tbl: [(c2Col,
                       label: block_c2Col_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Col: // global
           I64[Sp - 8] = block_c2Cor_info;
           _s2v2C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CoU; else goto c2Cos;
       u2CoU: // global
           call _c2Cor(R1) args: 0, res: 0, upd: 0;
       c2Cos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cor() //  [R1]
         { info_tbl: [(c2Cor,
                       label: block_c2Cor_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cor: // global
           I64[Sp] = block_c2Cow_info;
           _s2v2E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v2E::I64;
           if (R1 & 7 != 0) goto u2CoW; else goto c2CoB;
       u2CoW: // global
           call _c2Cow(R1) args: 0, res: 0, upd: 0;
       c2CoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cow() //  [R1]
         { info_tbl: [(c2Cow,
                       label: block_c2Cow_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cow: // global
           _s2v2G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v2G::I64) goto c2CoJ; else goto c2CoN;
       c2CoJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CoN: // global
           _s2v2C::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2CoM_info;
           R1 = _s2v2C::P64;
           I64[Sp + 16] = _s2v2G::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2CoX; else goto c2CoO;
       u2CoX: // global
           call _c2CoM(R1) args: 0, res: 0, upd: 0;
       c2CoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CoM() //  [R1]
         { info_tbl: [(c2CoM,
                       label: block_c2CoM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CoM: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.965002211 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2Cpv,
                       label: GHC.Word.$fRealWord8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cpv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CpM; else goto c2CpN;
       c2CpM: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CpN: // global
           I64[Sp - 8] = block_c2Cps_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CpU; else goto c2Cpt;
       u2CpU: // global
           call _c2Cps(R1) args: 0, res: 0, upd: 0;
       c2Cpt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cps() //  [R1]
         { info_tbl: [(c2Cps,
                       label: block_c2Cps_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cps: // global
           I64[Sp] = block_c2CpB_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CpB() //  [R1]
         { info_tbl: [(c2CpB,
                       label: block_c2CpB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CpB: // global
           I64[Sp] = block_c2CpF_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CpF() //  [R1]
         { info_tbl: [(c2CpF,
                       label: block_c2CpF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CpF: // global
           I64[Sp] = block_c2CpJ_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CpJ() //  [R1, R2]
         { info_tbl: [(c2CpJ,
                       label: block_c2CpJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CpJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2CpT; else goto c2CpS;
       c2CpT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2CpS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.975995251 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.978005733 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.980556394 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2Cqn,
                       label: GHC.Word.$fIxWord8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cqn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CqK; else goto c2CqL;
       c2CqK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CqL: // global
           I64[Sp - 16] = block_c2Cqk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CqS; else goto c2Cql;
       u2CqS: // global
           call _c2Cqk(R1) args: 0, res: 0, upd: 0;
       c2Cql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cqk() //  [R1]
         { info_tbl: [(c2Cqk,
                       label: block_c2Cqk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cqk: // global
           I64[Sp] = block_c2Cqq_info;
           _s2v2X::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v2X::P64;
           if (R1 & 7 != 0) goto u2CqR; else goto c2Cqr;
       u2CqR: // global
           call _c2Cqq(R1) args: 0, res: 0, upd: 0;
       c2Cqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cqq() //  [R1]
         { info_tbl: [(c2Cqq,
                       label: block_c2Cqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cqq: // global
           I64[Sp] = block_c2Cqv_info;
           _s2v30::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v30::I64;
           if (R1 & 7 != 0) goto u2CqT; else goto c2Cqw;
       u2CqT: // global
           call _c2Cqv(R1) args: 0, res: 0, upd: 0;
       c2Cqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cqv() //  [R1]
         { info_tbl: [(c2Cqv,
                       label: block_c2Cqv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CqQ; else goto c2CqP;
       c2CqQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CqP: // global
           _s2v35::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v35::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.991123361 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { info_tbl: [(c2Crm,
                       label: GHC.Word.$fIxWord8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Crm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Crn; else goto c2Cro;
       c2Crn: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cro: // global
           I64[Sp - 8] = block_c2Crj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Crs; else goto c2Crk;
       u2Crs: // global
           call _c2Crj(R1) args: 0, res: 0, upd: 0;
       c2Crk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Crj() //  [R1]
         { info_tbl: [(c2Crj,
                       label: block_c2Crj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Crj: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.996891853 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:12.999405662 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2CrK,
                       label: GHC.Word.$fIxWord8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CrK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CrT; else goto c2CrU;
       c2CrT: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CrU: // global
           I64[Sp - 8] = block_c2CrH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Csp; else goto c2CrI;
       u2Csp: // global
           call _c2CrH(R1) args: 0, res: 0, upd: 0;
       c2CrI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CrH() //  [R1]
         { info_tbl: [(c2CrH,
                       label: block_c2CrH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CrH: // global
           I64[Sp - 8] = block_c2CrN_info;
           _s2v3d::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cso; else goto c2CrO;
       u2Cso: // global
           call _c2CrN(R1) args: 0, res: 0, upd: 0;
       c2CrO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CrN() //  [R1]
         { info_tbl: [(c2CrN,
                       label: block_c2CrN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CrN: // global
           I64[Sp] = block_c2CrS_info;
           _s2v3f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3f::I64;
           if (R1 & 7 != 0) goto u2Csq; else goto c2CrX;
       u2Csq: // global
           call _c2CrS(R1) args: 0, res: 0, upd: 0;
       c2CrX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CrS() //  [R1]
         { info_tbl: [(c2CrS,
                       label: block_c2CrS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CrS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cs3; else goto c2Cs2;
       c2Cs3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cs2: // global
           _s2v3f::I64 = I64[Sp + 8];
           _s2v3h::I64 = I64[R1 + 7];
           if (_s2v3f::I64 > _s2v3h::I64) goto c2Cs7; else goto c2Csn;
       c2Cs7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Csn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3h::I64 - _s2v3f::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.010083285 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2CsV,
                       label: GHC.Word.$fIxWord8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CsV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ctl; else goto c2Ctm;
       c2Ctl: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ctm: // global
           I64[Sp - 8] = block_c2CsS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ctt; else goto c2CsT;
       u2Ctt: // global
           call _c2CsS(R1) args: 0, res: 0, upd: 0;
       c2CsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CsS() //  [R1]
         { info_tbl: [(c2CsS,
                       label: block_c2CsS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CsS: // global
           I64[Sp - 8] = block_c2CsY_info;
           _s2v3p::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v3p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cts; else goto c2CsZ;
       u2Cts: // global
           call _c2CsY(R1) args: 0, res: 0, upd: 0;
       c2CsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CsY() //  [R1]
         { info_tbl: [(c2CsY,
                       label: block_c2CsY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CsY: // global
           I64[Sp] = block_c2Ct3_info;
           _s2v3s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3s::I64;
           if (R1 & 7 != 0) goto u2Ctu; else goto c2Ct4;
       u2Ctu: // global
           call _c2Ct3(R1) args: 0, res: 0, upd: 0;
       c2Ct4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ct3() //  [R1]
         { info_tbl: [(c2Ct3,
                       label: block_c2Ct3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ct3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ctr; else goto c2Ctq;
       c2Ctr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ctq: // global
           _s2v3y::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v3y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.021503891 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2CtY,
                       label: GHC.Word.$fIxWord8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CtY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cu7; else goto c2Cu8;
       c2Cu7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cu8: // global
           I64[Sp - 16] = block_c2CtV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CuN; else goto c2CtW;
       u2CuN: // global
           call _c2CtV(R1) args: 0, res: 0, upd: 0;
       c2CtW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CtV() //  [R1]
         { info_tbl: [(c2CtV,
                       label: block_c2CtV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CtV: // global
           I64[Sp - 8] = block_c2Cu1_info;
           _s2v3D::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CuM; else goto c2Cu2;
       u2CuM: // global
           call _c2Cu1(R1) args: 0, res: 0, upd: 0;
       c2Cu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cu1() //  [R1]
         { info_tbl: [(c2Cu1,
                       label: block_c2Cu1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cu1: // global
           I64[Sp] = block_c2Cu6_info;
           _s2v3F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v3F::I64;
           if (R1 & 7 != 0) goto u2CuO; else goto c2Cub;
       u2CuO: // global
           call _c2Cu6(R1) args: 0, res: 0, upd: 0;
       c2Cub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cu6() //  [R1]
         { info_tbl: [(c2Cu6,
                       label: block_c2Cu6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cu6: // global
           _s2v3H::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v3H::I64) goto c2Cuj; else goto c2Cun;
       c2Cuj: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Cun: // global
           I64[Sp] = block_c2Cum_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3H::I64;
           if (R1 & 7 != 0) goto u2CuP; else goto c2Cuo;
       u2CuP: // global
           call _c2Cum(R1) args: 0, res: 0, upd: 0;
       c2Cuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cum() //  [R1]
         { info_tbl: [(c2Cum,
                       label: block_c2Cum_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cum: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cuu; else goto c2Cut;
       c2Cuu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cut: // global
           _s2v3H::I64 = I64[Sp + 8];
           if (_s2v3H::I64 > I64[R1 + 7]) goto c2Cuy; else goto c2CuL;
       c2Cuy: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CuL: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3H::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.033563141 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.036407666 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { info_tbl: [(c2Cvp,
                       label: GHC.Word.eqWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cvt; else goto c2Cvu;
       c2Cvt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cvu: // global
           I64[Sp - 16] = block_c2Cvm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CvD; else goto c2Cvn;
       u2CvD: // global
           call _c2Cvm(R1) args: 0, res: 0, upd: 0;
       c2Cvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cvm() //  [R1]
         { info_tbl: [(c2Cvm,
                       label: block_c2Cvm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cvm: // global
           I64[Sp] = block_c2Cvs_info;
           _s2v3S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3S::I64;
           if (R1 & 7 != 0) goto u2CvC; else goto c2Cvw;
       u2CvC: // global
           call _c2Cvs(R1) args: 0, res: 0, upd: 0;
       c2Cvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cvs() //  [R1]
         { info_tbl: [(c2Cvs,
                       label: block_c2Cvs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cvs: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.044013277 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.045822252 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.047966022 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { info_tbl: [(c2Cw4,
                       label: GHC.Word.$fNumWord16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cw4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Cw5; else goto c2Cw6;
       c2Cw5: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cw6: // global
           I64[Sp - 8] = block_c2Cw1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cwe; else goto c2Cw2;
       u2Cwe: // global
           call _c2Cw1(R1) args: 0, res: 0, upd: 0;
       c2Cw2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cw1() //  [R1]
         { info_tbl: [(c2Cw1,
                       label: block_c2Cw1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cw1: // global
           if (I64[R1 + 7] == 0) goto c2Cwd; else goto c2Cwc;
       c2Cwd: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cwc: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.054213128 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.056479928 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2Cwy,
                       label: GHC.Word.$fBitsWord16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cwy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CwF; else goto c2CwG;
       c2CwF: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CwG: // global
           I64[Sp - 8] = block_c2Cwv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CwK; else goto c2Cww;
       u2CwK: // global
           call _c2Cwv(R1) args: 0, res: 0, upd: 0;
       c2Cww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cwv() //  [R1]
         { info_tbl: [(c2Cwv,
                       label: block_c2Cwv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cwv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CwJ; else goto c2CwI;
       c2CwJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CwI: // global
           _s2v43::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v43::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.062517362 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.064929953 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2Cx1,
                       label: GHC.Word.$fBitsWord16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cx1: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.068908338 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { info_tbl: [(c2Cxg,
                       label: GHC.Word.$fBitsWord16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cxg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Cxh; else goto c2Cxi;
       c2Cxh: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cxi: // global
           I64[Sp - 8] = block_c2Cxd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CxB; else goto c2Cxe;
       u2CxB: // global
           call _c2Cxd(R1) args: 0, res: 0, upd: 0;
       c2Cxe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cxd() //  [R1]
         { info_tbl: [(c2Cxd,
                       label: block_c2Cxd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cxd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cxn; else goto c2Cxm;
       c2Cxn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cxm: // global
           _s2v47::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v47::I64, 64)) goto c2Cxz; else goto c2CxA;
       c2Cxz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v47::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CxA: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.075889028 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2CxX,
                       label: GHC.Word.$fBitsWord16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cy1; else goto c2Cy2;
       c2Cy1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cy2: // global
           I64[Sp - 16] = block_c2CxU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CyB; else goto c2CxV;
       u2CyB: // global
           call _c2CxU(R1) args: 0, res: 0, upd: 0;
       c2CxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CxU() //  [R1]
         { info_tbl: [(c2CxU,
                       label: block_c2CxU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CxU: // global
           I64[Sp] = block_c2Cy0_info;
           _s2v4e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4e::I64;
           if (R1 & 7 != 0) goto u2CyA; else goto c2Cy4;
       u2CyA: // global
           call _c2Cy0(R1) args: 0, res: 0, upd: 0;
       c2Cy4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cy0() //  [R1]
         { info_tbl: [(c2Cy0,
                       label: block_c2Cy0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cy0: // global
           _s2v4g::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v4g::I64, 64)) goto c2Cyz; else goto c2Cyy;
       c2Cyy: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4g::I64)) == 0) goto c2Cyz; else goto c2Cyn;
       c2Cyz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cyn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.084930883 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2Cz3,
                       label: GHC.Word.$fBitsWord16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cz3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cz7; else goto c2Cz8;
       c2Cz7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cz8: // global
           I64[Sp - 16] = block_c2Cz0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CzY; else goto c2Cz1;
       u2CzY: // global
           call _c2Cz0(R1) args: 0, res: 0, upd: 0;
       c2Cz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cz0() //  [R1]
         { info_tbl: [(c2Cz0,
                       label: block_c2Cz0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cz0: // global
           I64[Sp - 8] = block_c2Cz6_info;
           _s2v4n::P64 = R1;
           _s2v4o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4o::I64;
           P64[Sp + 8] = _s2v4n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CzX; else goto c2Cza;
       u2CzX: // global
           call _c2Cz6(R1) args: 0, res: 0, upd: 0;
       c2Cza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Cz6() //  [R1]
         { info_tbl: [(c2Cz6,
                       label: block_c2Cz6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Cz6: // global
           _s2v4u::I64 = -I64[R1 + 7] & 15;
           if (_s2v4u::I64 != 0) goto u2CzV; else goto c2CzR;
       u2CzV: // global
           I64[Sp + 16] = _s2v4u::I64;
           Sp = Sp + 8;
           call _c2Czs() args: 0, res: 0, upd: 0;
       c2CzR: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Czs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Czs: // global
           Hp = Hp + 16;
           _s2v4u::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2CzO; else goto c2CzN;
       c2CzO: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Czr_info;
           R1 = _s2v4u::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2CzN: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2v4o::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2v4o::I64 << _s2v4u::I64) | (_s2v4o::I64 >> 16 - _s2v4u::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Czr() //  [R1]
         { info_tbl: [(c2Czr,
                       label: block_c2Czr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Czr: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Czs() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.096616532 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2CAx,
                       label: GHC.Word.$fBitsWord16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CAx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.101067202 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2CAL,
                       label: GHC.Word.$fBitsWord16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CAL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CAP; else goto c2CAQ;
       c2CAP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CAQ: // global
           I64[Sp - 16] = block_c2CAI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CBg; else goto c2CAJ;
       u2CBg: // global
           call _c2CAI(R1) args: 0, res: 0, upd: 0;
       c2CAJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CAI() //  [R1]
         { info_tbl: [(c2CAI,
                       label: block_c2CAI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CAI: // global
           I64[Sp - 8] = block_c2CAO_info;
           _s2v4C::P64 = R1;
           _s2v4D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4D::I64;
           P64[Sp + 8] = _s2v4C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CBf; else goto c2CAS;
       u2CBf: // global
           call _c2CAO(R1) args: 0, res: 0, upd: 0;
       c2CAS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CAO() //  [R1]
         { info_tbl: [(c2CAO,
                       label: block_c2CAO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CAO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CAY; else goto c2CAX;
       c2CAY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CAX: // global
           _s2v4F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4F::I64, 64)) goto c2CBd; else goto c2CBe;
       c2CBd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CBe: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.110586052 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2CBJ,
                       label: GHC.Word.$fBitsWord16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CBN; else goto c2CBO;
       c2CBN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CBO: // global
           I64[Sp - 16] = block_c2CBG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CCm; else goto c2CBH;
       u2CCm: // global
           call _c2CBG(R1) args: 0, res: 0, upd: 0;
       c2CBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CBG() //  [R1]
         { info_tbl: [(c2CBG,
                       label: block_c2CBG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CBG: // global
           I64[Sp] = block_c2CBM_info;
           _s2v4N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4N::I64;
           if (R1 & 7 != 0) goto u2CCl; else goto c2CBQ;
       u2CCl: // global
           call _c2CBM(R1) args: 0, res: 0, upd: 0;
       c2CBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CBM() //  [R1]
         { info_tbl: [(c2CBM,
                       label: block_c2CBM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CBM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CBW; else goto c2CBV;
       c2CBW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CBV: // global
           _s2v4N::I64 = I64[Sp + 8];
           _s2v4P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4P::I64, 64)) goto c2CCe; else goto c2CCk;
       c2CCe: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4P::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CCk: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.119520999 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2CCR,
                       label: GHC.Word.$fBitsWord16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CCR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CCV; else goto c2CCW;
       c2CCV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CCW: // global
           I64[Sp - 16] = block_c2CCO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CDm; else goto c2CCP;
       u2CDm: // global
           call _c2CCO(R1) args: 0, res: 0, upd: 0;
       c2CCP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CCO() //  [R1]
         { info_tbl: [(c2CCO,
                       label: block_c2CCO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CCO: // global
           I64[Sp - 8] = block_c2CCU_info;
           _s2v4Y::P64 = R1;
           _s2v4Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4Z::I64;
           P64[Sp + 8] = _s2v4Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CDl; else goto c2CCY;
       u2CDl: // global
           call _c2CCU(R1) args: 0, res: 0, upd: 0;
       c2CCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CCU() //  [R1]
         { info_tbl: [(c2CCU,
                       label: block_c2CCU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CCU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CD4; else goto c2CD3;
       c2CD4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CD3: // global
           _s2v51::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v51::I64, 64)) goto c2CDj; else goto c2CDk;
       c2CDj: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v51::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CDk: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.128334824 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.130659461 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.133221293 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2CDR,
                       label: GHC.Word.$fIntegralWord16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CDR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CDV; else goto c2CDW;
       c2CDV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CDW: // global
           I64[Sp - 16] = block_c2CDO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CEf; else goto c2CDP;
       u2CEf: // global
           call _c2CDO(R1) args: 0, res: 0, upd: 0;
       c2CDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CDO() //  [R1]
         { info_tbl: [(c2CDO,
                       label: block_c2CDO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CDO: // global
           I64[Sp] = block_c2CDU_info;
           _s2v59::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v59::I64;
           if (R1 & 7 != 0) goto u2CEe; else goto c2CDY;
       u2CEe: // global
           call _c2CDU(R1) args: 0, res: 0, upd: 0;
       c2CDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CDU() //  [R1]
         { info_tbl: [(c2CDU,
                       label: block_c2CDU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CDU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CE4; else goto c2CE3;
       c2CE4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CE3: // global
           _s2v5c::I64 = I64[R1 + 7];
           if (_s2v5c::I64 != 0) goto c2CEc; else goto c2CEd;
       c2CEc: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v5c::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CEd: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.142784303 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2CEC,
                       label: GHC.Word.$fIntegralWord16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CEC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CEG; else goto c2CEH;
       c2CEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CEH: // global
           I64[Sp - 16] = block_c2CEz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CF0; else goto c2CEA;
       u2CF0: // global
           call _c2CEz(R1) args: 0, res: 0, upd: 0;
       c2CEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CEz() //  [R1]
         { info_tbl: [(c2CEz,
                       label: block_c2CEz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CEz: // global
           I64[Sp] = block_c2CEF_info;
           _s2v5h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5h::I64;
           if (R1 & 7 != 0) goto u2CEZ; else goto c2CEJ;
       u2CEZ: // global
           call _c2CEF(R1) args: 0, res: 0, upd: 0;
       c2CEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CEF() //  [R1]
         { info_tbl: [(c2CEF,
                       label: block_c2CEF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CEF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CEP; else goto c2CEO;
       c2CEP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CEO: // global
           _s2v5k::I64 = I64[R1 + 7];
           if (_s2v5k::I64 != 0) goto c2CEX; else goto c2CEY;
       c2CEX: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v5k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CEY: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.151869121 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2CFn,
                       label: GHC.Word.$fIntegralWord16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CFn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CFr; else goto c2CFs;
       c2CFr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CFs: // global
           I64[Sp - 16] = block_c2CFk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CFK; else goto c2CFl;
       u2CFK: // global
           call _c2CFk(R1) args: 0, res: 0, upd: 0;
       c2CFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CFk() //  [R1]
         { info_tbl: [(c2CFk,
                       label: block_c2CFk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CFk: // global
           I64[Sp] = block_c2CFq_info;
           _s2v5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5p::I64;
           if (R1 & 7 != 0) goto u2CFJ; else goto c2CFu;
       u2CFJ: // global
           call _c2CFq(R1) args: 0, res: 0, upd: 0;
       c2CFu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CFq() //  [R1]
         { info_tbl: [(c2CFq,
                       label: block_c2CFq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CFq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2CFA; else goto c2CFz;
       c2CFA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CFz: // global
           _s2v5s::I64 = I64[R1 + 7];
           if (_s2v5s::I64 != 0) goto c2CFH; else goto c2CFI;
       c2CFH: // global
           (_s2v5u::I64, _s2v5v::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v5s::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2v5v::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2v5u::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CFI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.16175784 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2v5I_entry() //  [R1]
         { info_tbl: [(c2CGn,
                       label: sat_s2v5I_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CGn: // global
           _s2v5I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGq; else goto c2CGr;
       c2CGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CGt; else goto c2CGs;
       c2CGt: // global
           HpAlloc = 16;
           goto c2CGq;
       c2CGq: // global
           R1 = _s2v5I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CGs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5I::P64;
           _s2v5H::I64 = I64[_s2v5I::P64 + 16] % I64[_s2v5I::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5H::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v5G_entry() //  [R1]
         { info_tbl: [(c2CGA,
                       label: sat_s2v5G_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CGA: // global
           _s2v5G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGD; else goto c2CGE;
       c2CGE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CGG; else goto c2CGF;
       c2CGG: // global
           HpAlloc = 16;
           goto c2CGD;
       c2CGD: // global
           R1 = _s2v5G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5G::P64;
           _s2v5F::I64 = I64[_s2v5G::P64 + 16] / I64[_s2v5G::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5F::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2CGH,
                       label: GHC.Word.$fIntegralWord16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CGH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGI; else goto c2CGJ;
       c2CGI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CGJ: // global
           I64[Sp - 16] = block_c2CG5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CGT; else goto c2CG6;
       u2CGT: // global
           call _c2CG5(R1) args: 0, res: 0, upd: 0;
       c2CG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CG5() //  [R1]
         { info_tbl: [(c2CG5,
                       label: block_c2CG5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CG5: // global
           I64[Sp] = block_c2CGa_info;
           _s2v5B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5B::I64;
           if (R1 & 7 != 0) goto u2CGS; else goto c2CGb;
       u2CGS: // global
           call _c2CGa(R1) args: 0, res: 0, upd: 0;
       c2CGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CGa() //  [R1]
         { info_tbl: [(c2CGa,
                       label: block_c2CGa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CGa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2CGN; else goto c2CGM;
       c2CGN: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CGM: // global
           _s2v5E::I64 = I64[R1 + 7];
           if (_s2v5E::I64 != 0) goto c2CGQ; else goto c2CGR;
       c2CGQ: // global
           I64[Hp - 80] = sat_s2v5I_info;
           _s2v5B::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v5B::I64;
           I64[Hp - 56] = _s2v5E::I64;
           I64[Hp - 48] = sat_s2v5G_info;
           I64[Hp - 32] = _s2v5B::I64;
           I64[Hp - 24] = _s2v5E::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CGR: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.17520626 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { info_tbl: [(c2CHr,
                       label: GHC.Word.gtWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CHv; else goto c2CHw;
       c2CHv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CHw: // global
           I64[Sp - 16] = block_c2CHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CHF; else goto c2CHp;
       u2CHF: // global
           call _c2CHo(R1) args: 0, res: 0, upd: 0;
       c2CHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CHo() //  [R1]
         { info_tbl: [(c2CHo,
                       label: block_c2CHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CHo: // global
           I64[Sp] = block_c2CHu_info;
           _s2v5M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5M::I64;
           if (R1 & 7 != 0) goto u2CHE; else goto c2CHy;
       u2CHE: // global
           call _c2CHu(R1) args: 0, res: 0, upd: 0;
       c2CHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CHu() //  [R1]
         { info_tbl: [(c2CHu,
                       label: block_c2CHu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CHu: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.183650614 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { info_tbl: [(c2CI4,
                       label: GHC.Word.geWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CI8; else goto c2CI9;
       c2CI8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CI9: // global
           I64[Sp - 16] = block_c2CI1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CIi; else goto c2CI2;
       u2CIi: // global
           call _c2CI1(R1) args: 0, res: 0, upd: 0;
       c2CI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CI1() //  [R1]
         { info_tbl: [(c2CI1,
                       label: block_c2CI1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CI1: // global
           I64[Sp] = block_c2CI7_info;
           _s2v5T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5T::I64;
           if (R1 & 7 != 0) goto u2CIh; else goto c2CIb;
       u2CIh: // global
           call _c2CI7(R1) args: 0, res: 0, upd: 0;
       c2CIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CI7() //  [R1]
         { info_tbl: [(c2CI7,
                       label: block_c2CI7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CI7: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.191373858 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { info_tbl: [(c2CIH,
                       label: GHC.Word.ltWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CIH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CIL; else goto c2CIM;
       c2CIL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CIM: // global
           I64[Sp - 16] = block_c2CIE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CIV; else goto c2CIF;
       u2CIV: // global
           call _c2CIE(R1) args: 0, res: 0, upd: 0;
       c2CIF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CIE() //  [R1]
         { info_tbl: [(c2CIE,
                       label: block_c2CIE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CIE: // global
           I64[Sp] = block_c2CIK_info;
           _s2v60::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v60::I64;
           if (R1 & 7 != 0) goto u2CIU; else goto c2CIO;
       u2CIU: // global
           call _c2CIK(R1) args: 0, res: 0, upd: 0;
       c2CIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CIK() //  [R1]
         { info_tbl: [(c2CIK,
                       label: block_c2CIK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CIK: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.199710626 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { info_tbl: [(c2CJk,
                       label: GHC.Word.leWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CJk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CJo; else goto c2CJp;
       c2CJo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CJp: // global
           I64[Sp - 16] = block_c2CJh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CJy; else goto c2CJi;
       u2CJy: // global
           call _c2CJh(R1) args: 0, res: 0, upd: 0;
       c2CJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CJh() //  [R1]
         { info_tbl: [(c2CJh,
                       label: block_c2CJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CJh: // global
           I64[Sp] = block_c2CJn_info;
           _s2v67::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v67::I64;
           if (R1 & 7 != 0) goto u2CJx; else goto c2CJr;
       u2CJx: // global
           call _c2CJn(R1) args: 0, res: 0, upd: 0;
       c2CJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CJn() //  [R1]
         { info_tbl: [(c2CJn,
                       label: block_c2CJn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CJn: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.207310388 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2CJX,
                       label: GHC.Word.$fOrdWord16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CJX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CK1; else goto c2CK2;
       c2CK1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CK2: // global
           I64[Sp - 16] = block_c2CJU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CKl; else goto c2CJV;
       u2CKl: // global
           call _c2CJU(R1) args: 0, res: 0, upd: 0;
       c2CJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CJU() //  [R1]
         { info_tbl: [(c2CJU,
                       label: block_c2CJU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CJU: // global
           I64[Sp] = block_c2CK0_info;
           _s2v6e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6e::I64;
           if (R1 & 7 != 0) goto u2CKk; else goto c2CK4;
       u2CKk: // global
           call _c2CK0(R1) args: 0, res: 0, upd: 0;
       c2CK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CK0() //  [R1]
         { info_tbl: [(c2CK0,
                       label: block_c2CK0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CK0: // global
           _s2v6e::I64 = I64[Sp + 8];
           _s2v6g::I64 = I64[R1 + 7];
           if (_s2v6e::I64 == _s2v6g::I64) goto c2CKj; else goto c2CKi;
       c2CKj: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CKi: // global
           if (_s2v6e::I64 > _s2v6g::I64) goto c2CKf; else goto c2CKg;
       c2CKf: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CKg: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.216024026 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2CKJ,
                       label: GHC.Word.$fOrdWord16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CKJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CKN; else goto c2CKO;
       c2CKN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CKO: // global
           I64[Sp - 16] = block_c2CKG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CL1; else goto c2CKH;
       u2CL1: // global
           call _c2CKG(R1) args: 0, res: 0, upd: 0;
       c2CKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CKG() //  [R1]
         { info_tbl: [(c2CKG,
                       label: block_c2CKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CKG: // global
           I64[Sp - 8] = block_c2CKM_info;
           _s2v6l::P64 = R1;
           _s2v6m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6m::I64;
           P64[Sp + 8] = _s2v6l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CL0; else goto c2CKQ;
       u2CL0: // global
           call _c2CKM(R1) args: 0, res: 0, upd: 0;
       c2CKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CKM() //  [R1]
         { info_tbl: [(c2CKM,
                       label: block_c2CKM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CKM: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CKY; else goto c2CKZ;
       c2CKY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CKZ: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.22414917 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2CLr,
                       label: GHC.Word.$fOrdWord16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CLr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CLv; else goto c2CLw;
       c2CLv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CLw: // global
           I64[Sp - 16] = block_c2CLo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CLJ; else goto c2CLp;
       u2CLJ: // global
           call _c2CLo(R1) args: 0, res: 0, upd: 0;
       c2CLp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CLo() //  [R1]
         { info_tbl: [(c2CLo,
                       label: block_c2CLo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CLo: // global
           I64[Sp - 8] = block_c2CLu_info;
           _s2v6s::P64 = R1;
           _s2v6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6t::I64;
           P64[Sp + 8] = _s2v6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CLI; else goto c2CLy;
       u2CLI: // global
           call _c2CLu(R1) args: 0, res: 0, upd: 0;
       c2CLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CLu() //  [R1]
         { info_tbl: [(c2CLu,
                       label: block_c2CLu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CLu: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CLG; else goto c2CLH;
       c2CLG: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CLH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.232340734 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.235447694 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2CMa,
                       label: GHC.Word.$fIxWord16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CMa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CMj; else goto c2CMk;
       c2CMj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CMk: // global
           I64[Sp - 16] = block_c2CM7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CMH; else goto c2CM8;
       u2CMH: // global
           call _c2CM7(R1) args: 0, res: 0, upd: 0;
       c2CM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CM7() //  [R1]
         { info_tbl: [(c2CM7,
                       label: block_c2CM7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CM7: // global
           I64[Sp - 8] = block_c2CMd_info;
           _s2v6B::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v6B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CMG; else goto c2CMe;
       u2CMG: // global
           call _c2CMd(R1) args: 0, res: 0, upd: 0;
       c2CMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CMd() //  [R1]
         { info_tbl: [(c2CMd,
                       label: block_c2CMd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CMd: // global
           I64[Sp] = block_c2CMi_info;
           _s2v6D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v6D::I64;
           if (R1 & 7 != 0) goto u2CMI; else goto c2CMn;
       u2CMI: // global
           call _c2CMi(R1) args: 0, res: 0, upd: 0;
       c2CMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CMi() //  [R1]
         { info_tbl: [(c2CMi,
                       label: block_c2CMi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CMi: // global
           _s2v6F::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v6F::I64) goto c2CMv; else goto c2CMz;
       c2CMv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CMz: // global
           _s2v6B::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2CMy_info;
           R1 = _s2v6B::P64;
           I64[Sp + 16] = _s2v6F::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2CMJ; else goto c2CMA;
       u2CMJ: // global
           call _c2CMy(R1) args: 0, res: 0, upd: 0;
       c2CMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CMy() //  [R1]
         { info_tbl: [(c2CMy,
                       label: block_c2CMy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CMy: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.247710664 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2CNh,
                       label: GHC.Word.$fRealWord16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CNh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CNy; else goto c2CNz;
       c2CNy: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CNz: // global
           I64[Sp - 8] = block_c2CNe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CNG; else goto c2CNf;
       u2CNG: // global
           call _c2CNe(R1) args: 0, res: 0, upd: 0;
       c2CNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CNe() //  [R1]
         { info_tbl: [(c2CNe,
                       label: block_c2CNe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CNe: // global
           I64[Sp] = block_c2CNn_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CNn() //  [R1]
         { info_tbl: [(c2CNn,
                       label: block_c2CNn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CNn: // global
           I64[Sp] = block_c2CNr_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CNr() //  [R1]
         { info_tbl: [(c2CNr,
                       label: block_c2CNr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CNr: // global
           I64[Sp] = block_c2CNv_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2CNv() //  [R1, R2]
         { info_tbl: [(c2CNv,
                       label: block_c2CNv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CNv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2CNF; else goto c2CNE;
       c2CNF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2CNE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.259747448 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.261591342 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.264138611 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2CO9,
                       label: GHC.Word.$fIxWord16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CO9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2COw; else goto c2COx;
       c2COw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2COx: // global
           I64[Sp - 16] = block_c2CO6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2COE; else goto c2CO7;
       u2COE: // global
           call _c2CO6(R1) args: 0, res: 0, upd: 0;
       c2CO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CO6() //  [R1]
         { info_tbl: [(c2CO6,
                       label: block_c2CO6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CO6: // global
           I64[Sp] = block_c2COc_info;
           _s2v6W::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v6W::P64;
           if (R1 & 7 != 0) goto u2COD; else goto c2COd;
       u2COD: // global
           call _c2COc(R1) args: 0, res: 0, upd: 0;
       c2COd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2COc() //  [R1]
         { info_tbl: [(c2COc,
                       label: block_c2COc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2COc: // global
           I64[Sp] = block_c2COh_info;
           _s2v6Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6Z::I64;
           if (R1 & 7 != 0) goto u2COF; else goto c2COi;
       u2COF: // global
           call _c2COh(R1) args: 0, res: 0, upd: 0;
       c2COi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2COh() //  [R1]
         { info_tbl: [(c2COh,
                       label: block_c2COh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2COh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2COC; else goto c2COB;
       c2COC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2COB: // global
           _s2v74::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v74::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.274352568 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { info_tbl: [(c2CP8,
                       label: GHC.Word.$fIxWord16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CP8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CP9; else goto c2CPa;
       c2CP9: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CPa: // global
           I64[Sp - 8] = block_c2CP5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CPe; else goto c2CP6;
       u2CPe: // global
           call _c2CP5(R1) args: 0, res: 0, upd: 0;
       c2CP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CP5() //  [R1]
         { info_tbl: [(c2CP5,
                       label: block_c2CP5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CP5: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.280444688 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2CPv,
                       label: GHC.Word.$fIxWord16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CPv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CPE; else goto c2CPF;
       c2CPE: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CPF: // global
           I64[Sp - 8] = block_c2CPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CQa; else goto c2CPt;
       u2CQa: // global
           call _c2CPs(R1) args: 0, res: 0, upd: 0;
       c2CPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CPs() //  [R1]
         { info_tbl: [(c2CPs,
                       label: block_c2CPs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CPs: // global
           I64[Sp - 8] = block_c2CPy_info;
           _s2v7c::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7c::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CQ9; else goto c2CPz;
       u2CQ9: // global
           call _c2CPy(R1) args: 0, res: 0, upd: 0;
       c2CPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CPy() //  [R1]
         { info_tbl: [(c2CPy,
                       label: block_c2CPy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CPy: // global
           I64[Sp] = block_c2CPD_info;
           _s2v7e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7e::I64;
           if (R1 & 7 != 0) goto u2CQb; else goto c2CPI;
       u2CQb: // global
           call _c2CPD(R1) args: 0, res: 0, upd: 0;
       c2CPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CPD() //  [R1]
         { info_tbl: [(c2CPD,
                       label: block_c2CPD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CPD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CPO; else goto c2CPN;
       c2CPO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CPN: // global
           _s2v7e::I64 = I64[Sp + 8];
           _s2v7g::I64 = I64[R1 + 7];
           if (_s2v7e::I64 > _s2v7g::I64) goto c2CPS; else goto c2CQ8;
       c2CPS: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CQ8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7g::I64 - _s2v7e::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.290881532 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2CQG,
                       label: GHC.Word.$fIxWord16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CQG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CR6; else goto c2CR7;
       c2CR6: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CR7: // global
           I64[Sp - 8] = block_c2CQD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CRe; else goto c2CQE;
       u2CRe: // global
           call _c2CQD(R1) args: 0, res: 0, upd: 0;
       c2CQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CQD() //  [R1]
         { info_tbl: [(c2CQD,
                       label: block_c2CQD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CQD: // global
           I64[Sp - 8] = block_c2CQJ_info;
           _s2v7o::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v7o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CRd; else goto c2CQK;
       u2CRd: // global
           call _c2CQJ(R1) args: 0, res: 0, upd: 0;
       c2CQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CQJ() //  [R1]
         { info_tbl: [(c2CQJ,
                       label: block_c2CQJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CQJ: // global
           I64[Sp] = block_c2CQO_info;
           _s2v7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7r::I64;
           if (R1 & 7 != 0) goto u2CRf; else goto c2CQP;
       u2CRf: // global
           call _c2CQO(R1) args: 0, res: 0, upd: 0;
       c2CQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CQO() //  [R1]
         { info_tbl: [(c2CQO,
                       label: block_c2CQO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CRc; else goto c2CRb;
       c2CRc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CRb: // global
           _s2v7x::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v7x::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.301622403 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2CRJ,
                       label: GHC.Word.$fIxWord16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CRJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CRS; else goto c2CRT;
       c2CRS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CRT: // global
           I64[Sp - 16] = block_c2CRG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CSy; else goto c2CRH;
       u2CSy: // global
           call _c2CRG(R1) args: 0, res: 0, upd: 0;
       c2CRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CRG() //  [R1]
         { info_tbl: [(c2CRG,
                       label: block_c2CRG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CRG: // global
           I64[Sp - 8] = block_c2CRM_info;
           _s2v7C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CSx; else goto c2CRN;
       u2CSx: // global
           call _c2CRM(R1) args: 0, res: 0, upd: 0;
       c2CRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CRM() //  [R1]
         { info_tbl: [(c2CRM,
                       label: block_c2CRM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CRM: // global
           I64[Sp] = block_c2CRR_info;
           _s2v7E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v7E::I64;
           if (R1 & 7 != 0) goto u2CSz; else goto c2CRW;
       u2CSz: // global
           call _c2CRR(R1) args: 0, res: 0, upd: 0;
       c2CRW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CRR() //  [R1]
         { info_tbl: [(c2CRR,
                       label: block_c2CRR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CRR: // global
           _s2v7G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v7G::I64) goto c2CS4; else goto c2CS8;
       c2CS4: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CS8: // global
           I64[Sp] = block_c2CS7_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7G::I64;
           if (R1 & 7 != 0) goto u2CSA; else goto c2CS9;
       u2CSA: // global
           call _c2CS7(R1) args: 0, res: 0, upd: 0;
       c2CS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CS7() //  [R1]
         { info_tbl: [(c2CS7,
                       label: block_c2CS7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CS7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CSf; else goto c2CSe;
       c2CSf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CSe: // global
           _s2v7G::I64 = I64[Sp + 8];
           if (_s2v7G::I64 > I64[R1 + 7]) goto c2CSj; else goto c2CSw;
       c2CSj: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CSw: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7G::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.313739302 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.31608429 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { info_tbl: [(c2CTa,
                       label: GHC.Word.byteSwap16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CTa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CTl; else goto c2CTm;
       c2CTl: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CTm: // global
           I64[Sp - 8] = block_c2CT7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CTq; else goto c2CT8;
       u2CTq: // global
           call _c2CT7(R1) args: 0, res: 0, upd: 0;
       c2CT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CT7() //  [R1]
         { info_tbl: [(c2CT7,
                       label: block_c2CT7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CT7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CTp; else goto c2CTo;
       c2CTp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CTo: // global
           (_c2CTd::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2CTd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.322152727 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { info_tbl: [(c2CTK,
                       label: GHC.Word.eqWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CTO; else goto c2CTP;
       c2CTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CTP: // global
           I64[Sp - 16] = block_c2CTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CTY; else goto c2CTI;
       u2CTY: // global
           call _c2CTH(R1) args: 0, res: 0, upd: 0;
       c2CTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CTH() //  [R1]
         { info_tbl: [(c2CTH,
                       label: block_c2CTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CTH: // global
           I64[Sp] = block_c2CTN_info;
           _s2v7W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7W::I64;
           if (R1 & 7 != 0) goto u2CTX; else goto c2CTR;
       u2CTX: // global
           call _c2CTN(R1) args: 0, res: 0, upd: 0;
       c2CTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CTN() //  [R1]
         { info_tbl: [(c2CTN,
                       label: block_c2CTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CTN: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.330229149 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.331951357 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.334050013 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { info_tbl: [(c2CUp,
                       label: GHC.Word.$fNumWord32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CUp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CUq; else goto c2CUr;
       c2CUq: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CUr: // global
           I64[Sp - 8] = block_c2CUm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CUz; else goto c2CUn;
       u2CUz: // global
           call _c2CUm(R1) args: 0, res: 0, upd: 0;
       c2CUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CUm() //  [R1]
         { info_tbl: [(c2CUm,
                       label: block_c2CUm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CUm: // global
           if (I64[R1 + 7] == 0) goto c2CUy; else goto c2CUx;
       c2CUy: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CUx: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.339668099 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.342718136 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2CUT,
                       label: GHC.Word.$fBitsWord32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CUT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CV0; else goto c2CV1;
       c2CV0: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CV1: // global
           I64[Sp - 8] = block_c2CUQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CV5; else goto c2CUR;
       u2CV5: // global
           call _c2CUQ(R1) args: 0, res: 0, upd: 0;
       c2CUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CUQ() //  [R1]
         { info_tbl: [(c2CUQ,
                       label: block_c2CUQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CUQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CV4; else goto c2CV3;
       c2CV4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CV3: // global
           _s2v87::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v87::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.348277518 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.350218783 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2CVn,
                       label: GHC.Word.$fBitsWord32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CVn: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.354008262 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { info_tbl: [(c2CVC,
                       label: GHC.Word.$fBitsWord32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CVC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CVD; else goto c2CVE;
       c2CVD: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CVE: // global
           I64[Sp - 8] = block_c2CVz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CVX; else goto c2CVA;
       u2CVX: // global
           call _c2CVz(R1) args: 0, res: 0, upd: 0;
       c2CVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CVz() //  [R1]
         { info_tbl: [(c2CVz,
                       label: block_c2CVz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CVz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CVJ; else goto c2CVI;
       c2CVJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CVI: // global
           _s2v8b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8b::I64, 64)) goto c2CVV; else goto c2CVW;
       c2CVV: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8b::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CVW: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.361749255 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2CWi,
                       label: GHC.Word.$fBitsWord32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CWi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CWm; else goto c2CWn;
       c2CWm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CWn: // global
           I64[Sp - 16] = block_c2CWf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CWW; else goto c2CWg;
       u2CWW: // global
           call _c2CWf(R1) args: 0, res: 0, upd: 0;
       c2CWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CWf() //  [R1]
         { info_tbl: [(c2CWf,
                       label: block_c2CWf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CWf: // global
           I64[Sp] = block_c2CWl_info;
           _s2v8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8i::I64;
           if (R1 & 7 != 0) goto u2CWV; else goto c2CWp;
       u2CWV: // global
           call _c2CWl(R1) args: 0, res: 0, upd: 0;
       c2CWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CWl() //  [R1]
         { info_tbl: [(c2CWl,
                       label: block_c2CWl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CWl: // global
           _s2v8k::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v8k::I64, 64)) goto c2CWU; else goto c2CWT;
       c2CWT: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8k::I64)) == 0) goto c2CWU; else goto c2CWI;
       c2CWU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CWI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.370641709 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2CXn,
                       label: GHC.Word.$fBitsWord32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CXn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CXr; else goto c2CXs;
       c2CXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CXs: // global
           I64[Sp - 16] = block_c2CXk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CYi; else goto c2CXl;
       u2CYi: // global
           call _c2CXk(R1) args: 0, res: 0, upd: 0;
       c2CXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CXk() //  [R1]
         { info_tbl: [(c2CXk,
                       label: block_c2CXk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CXk: // global
           I64[Sp - 8] = block_c2CXq_info;
           _s2v8r::P64 = R1;
           _s2v8s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8s::I64;
           P64[Sp + 8] = _s2v8r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CYh; else goto c2CXu;
       u2CYh: // global
           call _c2CXq(R1) args: 0, res: 0, upd: 0;
       c2CXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CXq() //  [R1]
         { info_tbl: [(c2CXq,
                       label: block_c2CXq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CXq: // global
           _s2v8y::I64 = -I64[R1 + 7] & 31;
           if (_s2v8y::I64 != 0) goto u2CYf; else goto c2CYb;
       u2CYf: // global
           I64[Sp + 16] = _s2v8y::I64;
           Sp = Sp + 8;
           call _c2CXM() args: 0, res: 0, upd: 0;
       c2CYb: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CXM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CXM: // global
           Hp = Hp + 16;
           _s2v8y::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2CY8; else goto c2CY7;
       c2CY8: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2CXL_info;
           R1 = _s2v8y::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2CY7: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2v8s::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2v8s::I64 << _s2v8y::I64) | (_s2v8s::I64 >> 32 - _s2v8y::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CXL() //  [R1]
         { info_tbl: [(c2CXL,
                       label: block_c2CXL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CXL: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2CXM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.382198056 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2CYU,
                       label: GHC.Word.$fBitsWord32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CYU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CYY; else goto c2CYZ;
       c2CYY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CYZ: // global
           I64[Sp - 16] = block_c2CYR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CZp; else goto c2CYS;
       u2CZp: // global
           call _c2CYR(R1) args: 0, res: 0, upd: 0;
       c2CYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CYR() //  [R1]
         { info_tbl: [(c2CYR,
                       label: block_c2CYR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CYR: // global
           I64[Sp - 8] = block_c2CYX_info;
           _s2v8G::P64 = R1;
           _s2v8H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8H::I64;
           P64[Sp + 8] = _s2v8G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CZo; else goto c2CZ1;
       u2CZo: // global
           call _c2CYX(R1) args: 0, res: 0, upd: 0;
       c2CZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CYX() //  [R1]
         { info_tbl: [(c2CYX,
                       label: block_c2CYX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CYX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CZ7; else goto c2CZ6;
       c2CZ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CZ6: // global
           _s2v8J::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8J::I64, 64)) goto c2CZm; else goto c2CZn;
       c2CZm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8J::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CZn: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.391122759 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2CZR,
                       label: GHC.Word.$fBitsWord32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CZR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CZV; else goto c2CZW;
       c2CZV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CZW: // global
           I64[Sp - 16] = block_c2CZO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D0u; else goto c2CZP;
       u2D0u: // global
           call _c2CZO(R1) args: 0, res: 0, upd: 0;
       c2CZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CZO() //  [R1]
         { info_tbl: [(c2CZO,
                       label: block_c2CZO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CZO: // global
           I64[Sp] = block_c2CZU_info;
           _s2v8R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8R::I64;
           if (R1 & 7 != 0) goto u2D0t; else goto c2CZY;
       u2D0t: // global
           call _c2CZU(R1) args: 0, res: 0, upd: 0;
       c2CZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2CZU() //  [R1]
         { info_tbl: [(c2CZU,
                       label: block_c2CZU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2CZU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D04; else goto c2D03;
       c2D04: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D03: // global
           _s2v8R::I64 = I64[Sp + 8];
           _s2v8T::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8T::I64, 64)) goto c2D0m; else goto c2D0s;
       c2D0m: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8T::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D0s: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.400271999 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2D10,
                       label: GHC.Word.$fBitsWord32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D10: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D14; else goto c2D15;
       c2D14: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D15: // global
           I64[Sp - 16] = block_c2D0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D1v; else goto c2D0Y;
       u2D1v: // global
           call _c2D0X(R1) args: 0, res: 0, upd: 0;
       c2D0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D0X() //  [R1]
         { info_tbl: [(c2D0X,
                       label: block_c2D0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D0X: // global
           I64[Sp - 8] = block_c2D13_info;
           _s2v92::P64 = R1;
           _s2v93::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v93::I64;
           P64[Sp + 8] = _s2v92::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2D1u; else goto c2D17;
       u2D1u: // global
           call _c2D13(R1) args: 0, res: 0, upd: 0;
       c2D17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D13() //  [R1]
         { info_tbl: [(c2D13,
                       label: block_c2D13_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D13: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D1d; else goto c2D1c;
       c2D1d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D1c: // global
           _s2v95::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v95::I64, 64)) goto c2D1s; else goto c2D1t;
       c2D1s: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v95::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D1t: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.408148329 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2D1U,
                       label: GHC.Word.$fBitsWord32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D1U: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.411452044 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.414500945 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.416912592 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2D2a,
                       label: GHC.Word.$fIntegralWord32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D2a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D2e; else goto c2D2f;
       c2D2e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D2f: // global
           I64[Sp - 16] = block_c2D27_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D2y; else goto c2D28;
       u2D2y: // global
           call _c2D27(R1) args: 0, res: 0, upd: 0;
       c2D28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D27() //  [R1]
         { info_tbl: [(c2D27,
                       label: block_c2D27_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D27: // global
           I64[Sp] = block_c2D2d_info;
           _s2v9d::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9d::I64;
           if (R1 & 7 != 0) goto u2D2x; else goto c2D2h;
       u2D2x: // global
           call _c2D2d(R1) args: 0, res: 0, upd: 0;
       c2D2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D2d() //  [R1]
         { info_tbl: [(c2D2d,
                       label: block_c2D2d_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D2d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D2n; else goto c2D2m;
       c2D2n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D2m: // global
           _s2v9g::I64 = I64[R1 + 7];
           if (_s2v9g::I64 != 0) goto c2D2v; else goto c2D2w;
       c2D2v: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v9g::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D2w: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.425427901 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2D2V,
                       label: GHC.Word.$fIntegralWord32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D2V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D2Z; else goto c2D30;
       c2D2Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D30: // global
           I64[Sp - 16] = block_c2D2S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D3j; else goto c2D2T;
       u2D3j: // global
           call _c2D2S(R1) args: 0, res: 0, upd: 0;
       c2D2T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D2S() //  [R1]
         { info_tbl: [(c2D2S,
                       label: block_c2D2S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D2S: // global
           I64[Sp] = block_c2D2Y_info;
           _s2v9l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9l::I64;
           if (R1 & 7 != 0) goto u2D3i; else goto c2D32;
       u2D3i: // global
           call _c2D2Y(R1) args: 0, res: 0, upd: 0;
       c2D32: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D2Y() //  [R1]
         { info_tbl: [(c2D2Y,
                       label: block_c2D2Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D2Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D38; else goto c2D37;
       c2D38: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D37: // global
           _s2v9o::I64 = I64[R1 + 7];
           if (_s2v9o::I64 != 0) goto c2D3g; else goto c2D3h;
       c2D3g: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v9o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D3h: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.434566509 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2D3G,
                       label: GHC.Word.$fIntegralWord32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D3G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D3K; else goto c2D3L;
       c2D3K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D3L: // global
           I64[Sp - 16] = block_c2D3D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D43; else goto c2D3E;
       u2D43: // global
           call _c2D3D(R1) args: 0, res: 0, upd: 0;
       c2D3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D3D() //  [R1]
         { info_tbl: [(c2D3D,
                       label: block_c2D3D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D3D: // global
           I64[Sp] = block_c2D3J_info;
           _s2v9t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9t::I64;
           if (R1 & 7 != 0) goto u2D42; else goto c2D3N;
       u2D42: // global
           call _c2D3J(R1) args: 0, res: 0, upd: 0;
       c2D3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D3J() //  [R1]
         { info_tbl: [(c2D3J,
                       label: block_c2D3J_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D3J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2D3T; else goto c2D3S;
       c2D3T: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D3S: // global
           _s2v9w::I64 = I64[R1 + 7];
           if (_s2v9w::I64 != 0) goto c2D40; else goto c2D41;
       c2D40: // global
           (_s2v9y::I64, _s2v9z::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v9w::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2v9z::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2v9y::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D41: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.444208862 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2v9M_entry() //  [R1]
         { info_tbl: [(c2D4G,
                       label: sat_s2v9M_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D4G: // global
           _s2v9M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2D4J; else goto c2D4K;
       c2D4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D4M; else goto c2D4L;
       c2D4M: // global
           HpAlloc = 16;
           goto c2D4J;
       c2D4J: // global
           R1 = _s2v9M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2D4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9M::P64;
           _s2v9L::I64 = I64[_s2v9M::P64 + 16] % I64[_s2v9M::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9L::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2v9K_entry() //  [R1]
         { info_tbl: [(c2D4T,
                       label: sat_s2v9K_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D4T: // global
           _s2v9K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2D4W; else goto c2D4X;
       c2D4X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D4Z; else goto c2D4Y;
       c2D4Z: // global
           HpAlloc = 16;
           goto c2D4W;
       c2D4W: // global
           R1 = _s2v9K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2D4Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9K::P64;
           _s2v9J::I64 = I64[_s2v9K::P64 + 16] / I64[_s2v9K::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9J::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2D50,
                       label: GHC.Word.$fIntegralWord32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D51; else goto c2D52;
       c2D51: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D52: // global
           I64[Sp - 16] = block_c2D4o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D5c; else goto c2D4p;
       u2D5c: // global
           call _c2D4o(R1) args: 0, res: 0, upd: 0;
       c2D4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D4o() //  [R1]
         { info_tbl: [(c2D4o,
                       label: block_c2D4o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D4o: // global
           I64[Sp] = block_c2D4t_info;
           _s2v9F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9F::I64;
           if (R1 & 7 != 0) goto u2D5b; else goto c2D4u;
       u2D5b: // global
           call _c2D4t(R1) args: 0, res: 0, upd: 0;
       c2D4u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D4t() //  [R1]
         { info_tbl: [(c2D4t,
                       label: block_c2D4t_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D4t: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2D56; else goto c2D55;
       c2D56: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D55: // global
           _s2v9I::I64 = I64[R1 + 7];
           if (_s2v9I::I64 != 0) goto c2D59; else goto c2D5a;
       c2D59: // global
           I64[Hp - 80] = sat_s2v9M_info;
           _s2v9F::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v9F::I64;
           I64[Hp - 56] = _s2v9I::I64;
           I64[Hp - 48] = sat_s2v9K_info;
           I64[Hp - 32] = _s2v9F::I64;
           I64[Hp - 24] = _s2v9I::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D5a: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.458111558 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { info_tbl: [(c2D5K,
                       label: GHC.Word.gtWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D5K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D5O; else goto c2D5P;
       c2D5O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D5P: // global
           I64[Sp - 16] = block_c2D5H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D5Y; else goto c2D5I;
       u2D5Y: // global
           call _c2D5H(R1) args: 0, res: 0, upd: 0;
       c2D5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D5H() //  [R1]
         { info_tbl: [(c2D5H,
                       label: block_c2D5H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D5H: // global
           I64[Sp] = block_c2D5N_info;
           _s2v9Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9Q::I64;
           if (R1 & 7 != 0) goto u2D5X; else goto c2D5R;
       u2D5X: // global
           call _c2D5N(R1) args: 0, res: 0, upd: 0;
       c2D5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D5N() //  [R1]
         { info_tbl: [(c2D5N,
                       label: block_c2D5N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D5N: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.46583195 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { info_tbl: [(c2D6n,
                       label: GHC.Word.geWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D6n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D6r; else goto c2D6s;
       c2D6r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D6s: // global
           I64[Sp - 16] = block_c2D6k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D6B; else goto c2D6l;
       u2D6B: // global
           call _c2D6k(R1) args: 0, res: 0, upd: 0;
       c2D6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D6k() //  [R1]
         { info_tbl: [(c2D6k,
                       label: block_c2D6k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D6k: // global
           I64[Sp] = block_c2D6q_info;
           _s2v9X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9X::I64;
           if (R1 & 7 != 0) goto u2D6A; else goto c2D6u;
       u2D6A: // global
           call _c2D6q(R1) args: 0, res: 0, upd: 0;
       c2D6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D6q() //  [R1]
         { info_tbl: [(c2D6q,
                       label: block_c2D6q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D6q: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.474099726 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { info_tbl: [(c2D70,
                       label: GHC.Word.ltWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D74; else goto c2D75;
       c2D74: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D75: // global
           I64[Sp - 16] = block_c2D6X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D7e; else goto c2D6Y;
       u2D7e: // global
           call _c2D6X(R1) args: 0, res: 0, upd: 0;
       c2D6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D6X() //  [R1]
         { info_tbl: [(c2D6X,
                       label: block_c2D6X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D6X: // global
           I64[Sp] = block_c2D73_info;
           _s2va4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2va4::I64;
           if (R1 & 7 != 0) goto u2D7d; else goto c2D77;
       u2D7d: // global
           call _c2D73(R1) args: 0, res: 0, upd: 0;
       c2D77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D73() //  [R1]
         { info_tbl: [(c2D73,
                       label: block_c2D73_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D73: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.481850827 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { info_tbl: [(c2D7D,
                       label: GHC.Word.leWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D7H; else goto c2D7I;
       c2D7H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D7I: // global
           I64[Sp - 16] = block_c2D7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D7R; else goto c2D7B;
       u2D7R: // global
           call _c2D7A(R1) args: 0, res: 0, upd: 0;
       c2D7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D7A() //  [R1]
         { info_tbl: [(c2D7A,
                       label: block_c2D7A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D7A: // global
           I64[Sp] = block_c2D7G_info;
           _s2vab::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vab::I64;
           if (R1 & 7 != 0) goto u2D7Q; else goto c2D7K;
       u2D7Q: // global
           call _c2D7G(R1) args: 0, res: 0, upd: 0;
       c2D7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D7G() //  [R1]
         { info_tbl: [(c2D7G,
                       label: block_c2D7G_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D7G: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.490035663 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2D8g,
                       label: GHC.Word.$fOrdWord32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D8g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D8k; else goto c2D8l;
       c2D8k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D8l: // global
           I64[Sp - 16] = block_c2D8d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D8E; else goto c2D8e;
       u2D8E: // global
           call _c2D8d(R1) args: 0, res: 0, upd: 0;
       c2D8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D8d() //  [R1]
         { info_tbl: [(c2D8d,
                       label: block_c2D8d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D8d: // global
           I64[Sp] = block_c2D8j_info;
           _s2vai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vai::I64;
           if (R1 & 7 != 0) goto u2D8D; else goto c2D8n;
       u2D8D: // global
           call _c2D8j(R1) args: 0, res: 0, upd: 0;
       c2D8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D8j() //  [R1]
         { info_tbl: [(c2D8j,
                       label: block_c2D8j_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D8j: // global
           _s2vai::I64 = I64[Sp + 8];
           _s2vak::I64 = I64[R1 + 7];
           if (_s2vai::I64 == _s2vak::I64) goto c2D8C; else goto c2D8B;
       c2D8C: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D8B: // global
           if (_s2vai::I64 > _s2vak::I64) goto c2D8y; else goto c2D8z;
       c2D8y: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D8z: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.498269258 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2D92,
                       label: GHC.Word.$fOrdWord32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D92: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D96; else goto c2D97;
       c2D96: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D97: // global
           I64[Sp - 16] = block_c2D8Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D9k; else goto c2D90;
       u2D9k: // global
           call _c2D8Z(R1) args: 0, res: 0, upd: 0;
       c2D90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D8Z() //  [R1]
         { info_tbl: [(c2D8Z,
                       label: block_c2D8Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D8Z: // global
           I64[Sp - 8] = block_c2D95_info;
           _s2vap::P64 = R1;
           _s2vaq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vaq::I64;
           P64[Sp + 8] = _s2vap::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2D9j; else goto c2D99;
       u2D9j: // global
           call _c2D95(R1) args: 0, res: 0, upd: 0;
       c2D99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D95() //  [R1]
         { info_tbl: [(c2D95,
                       label: block_c2D95_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D95: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2D9h; else goto c2D9i;
       c2D9h: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2D9i: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.506837621 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2D9K,
                       label: GHC.Word.$fOrdWord32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D9K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D9O; else goto c2D9P;
       c2D9O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D9P: // global
           I64[Sp - 16] = block_c2D9H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Da2; else goto c2D9I;
       u2Da2: // global
           call _c2D9H(R1) args: 0, res: 0, upd: 0;
       c2D9I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D9H() //  [R1]
         { info_tbl: [(c2D9H,
                       label: block_c2D9H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D9H: // global
           I64[Sp - 8] = block_c2D9N_info;
           _s2vaw::P64 = R1;
           _s2vax::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vax::I64;
           P64[Sp + 8] = _s2vaw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Da1; else goto c2D9R;
       u2Da1: // global
           call _c2D9N(R1) args: 0, res: 0, upd: 0;
       c2D9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2D9N() //  [R1]
         { info_tbl: [(c2D9N,
                       label: block_c2D9N_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2D9N: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2D9Z; else goto c2Da0;
       c2D9Z: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Da0: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.515146909 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.517938467 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2Dat,
                       label: GHC.Word.$fIxWord32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dat: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DaC; else goto c2DaD;
       c2DaC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DaD: // global
           I64[Sp - 16] = block_c2Daq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Db0; else goto c2Dar;
       u2Db0: // global
           call _c2Daq(R1) args: 0, res: 0, upd: 0;
       c2Dar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Daq() //  [R1]
         { info_tbl: [(c2Daq,
                       label: block_c2Daq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Daq: // global
           I64[Sp - 8] = block_c2Daw_info;
           _s2vaF::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vaF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DaZ; else goto c2Dax;
       u2DaZ: // global
           call _c2Daw(R1) args: 0, res: 0, upd: 0;
       c2Dax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Daw() //  [R1]
         { info_tbl: [(c2Daw,
                       label: block_c2Daw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Daw: // global
           I64[Sp] = block_c2DaB_info;
           _s2vaH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vaH::I64;
           if (R1 & 7 != 0) goto u2Db1; else goto c2DaG;
       u2Db1: // global
           call _c2DaB(R1) args: 0, res: 0, upd: 0;
       c2DaG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DaB() //  [R1]
         { info_tbl: [(c2DaB,
                       label: block_c2DaB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DaB: // global
           _s2vaJ::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vaJ::I64) goto c2DaO; else goto c2DaS;
       c2DaO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DaS: // global
           _s2vaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2DaR_info;
           R1 = _s2vaF::P64;
           I64[Sp + 16] = _s2vaJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2Db2; else goto c2DaT;
       u2Db2: // global
           call _c2DaR(R1) args: 0, res: 0, upd: 0;
       c2DaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DaR() //  [R1]
         { info_tbl: [(c2DaR,
                       label: block_c2DaR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DaR: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.530518237 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2DbA,
                       label: GHC.Word.$fRealWord32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DbA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DbR; else goto c2DbS;
       c2DbR: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DbS: // global
           I64[Sp - 8] = block_c2Dbx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DbZ; else goto c2Dby;
       u2DbZ: // global
           call _c2Dbx(R1) args: 0, res: 0, upd: 0;
       c2Dby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dbx() //  [R1]
         { info_tbl: [(c2Dbx,
                       label: block_c2Dbx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dbx: // global
           I64[Sp] = block_c2DbG_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2DbG() //  [R1]
         { info_tbl: [(c2DbG,
                       label: block_c2DbG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DbG: // global
           I64[Sp] = block_c2DbK_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2DbK() //  [R1]
         { info_tbl: [(c2DbK,
                       label: block_c2DbK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DbK: // global
           I64[Sp] = block_c2DbO_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2DbO() //  [R1, R2]
         { info_tbl: [(c2DbO,
                       label: block_c2DbO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DbO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2DbY; else goto c2DbX;
       c2DbY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2DbX: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.54185992 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.544226886 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.546834307 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2Dcs,
                       label: GHC.Word.$fIxWord32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dcs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DcP; else goto c2DcQ;
       c2DcP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DcQ: // global
           I64[Sp - 16] = block_c2Dcp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DcX; else goto c2Dcq;
       u2DcX: // global
           call _c2Dcp(R1) args: 0, res: 0, upd: 0;
       c2Dcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dcp() //  [R1]
         { info_tbl: [(c2Dcp,
                       label: block_c2Dcp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dcp: // global
           I64[Sp] = block_c2Dcv_info;
           _s2vb0::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vb0::P64;
           if (R1 & 7 != 0) goto u2DcW; else goto c2Dcw;
       u2DcW: // global
           call _c2Dcv(R1) args: 0, res: 0, upd: 0;
       c2Dcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dcv() //  [R1]
         { info_tbl: [(c2Dcv,
                       label: block_c2Dcv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dcv: // global
           I64[Sp] = block_c2DcA_info;
           _s2vb3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vb3::I64;
           if (R1 & 7 != 0) goto u2DcY; else goto c2DcB;
       u2DcY: // global
           call _c2DcA(R1) args: 0, res: 0, upd: 0;
       c2DcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DcA() //  [R1]
         { info_tbl: [(c2DcA,
                       label: block_c2DcA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DcA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DcV; else goto c2DcU;
       c2DcV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DcU: // global
           _s2vb8::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vb8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.556646269 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { info_tbl: [(c2Ddr,
                       label: GHC.Word.$fIxWord32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ddr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dds; else goto c2Ddt;
       c2Dds: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ddt: // global
           I64[Sp - 8] = block_c2Ddo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ddx; else goto c2Ddp;
       u2Ddx: // global
           call _c2Ddo(R1) args: 0, res: 0, upd: 0;
       c2Ddp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ddo() //  [R1]
         { info_tbl: [(c2Ddo,
                       label: block_c2Ddo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ddo: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.563456107 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2DdO,
                       label: GHC.Word.$fIxWord32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DdO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DdX; else goto c2DdY;
       c2DdX: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DdY: // global
           I64[Sp - 8] = block_c2DdL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Det; else goto c2DdM;
       u2Det: // global
           call _c2DdL(R1) args: 0, res: 0, upd: 0;
       c2DdM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DdL() //  [R1]
         { info_tbl: [(c2DdL,
                       label: block_c2DdL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DdL: // global
           I64[Sp - 8] = block_c2DdR_info;
           _s2vbg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Des; else goto c2DdS;
       u2Des: // global
           call _c2DdR(R1) args: 0, res: 0, upd: 0;
       c2DdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DdR() //  [R1]
         { info_tbl: [(c2DdR,
                       label: block_c2DdR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DdR: // global
           I64[Sp] = block_c2DdW_info;
           _s2vbi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbi::I64;
           if (R1 & 7 != 0) goto u2Deu; else goto c2De1;
       u2Deu: // global
           call _c2DdW(R1) args: 0, res: 0, upd: 0;
       c2De1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DdW() //  [R1]
         { info_tbl: [(c2DdW,
                       label: block_c2DdW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2De7; else goto c2De6;
       c2De7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2De6: // global
           _s2vbi::I64 = I64[Sp + 8];
           _s2vbk::I64 = I64[R1 + 7];
           if (_s2vbi::I64 > _s2vbk::I64) goto c2Deb; else goto c2Der;
       c2Deb: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Der: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbk::I64 - _s2vbi::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.574061829 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2DeZ,
                       label: GHC.Word.$fIxWord32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DeZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Dfp; else goto c2Dfq;
       c2Dfp: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dfq: // global
           I64[Sp - 8] = block_c2DeW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dfx; else goto c2DeX;
       u2Dfx: // global
           call _c2DeW(R1) args: 0, res: 0, upd: 0;
       c2DeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DeW() //  [R1]
         { info_tbl: [(c2DeW,
                       label: block_c2DeW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DeW: // global
           I64[Sp - 8] = block_c2Df2_info;
           _s2vbs::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vbs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dfw; else goto c2Df3;
       u2Dfw: // global
           call _c2Df2(R1) args: 0, res: 0, upd: 0;
       c2Df3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Df2() //  [R1]
         { info_tbl: [(c2Df2,
                       label: block_c2Df2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Df2: // global
           I64[Sp] = block_c2Df7_info;
           _s2vbv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbv::I64;
           if (R1 & 7 != 0) goto u2Dfy; else goto c2Df8;
       u2Dfy: // global
           call _c2Df7(R1) args: 0, res: 0, upd: 0;
       c2Df8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Df7() //  [R1]
         { info_tbl: [(c2Df7,
                       label: block_c2Df7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Df7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dfv; else goto c2Dfu;
       c2Dfv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dfu: // global
           _s2vbB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vbB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.584166416 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2Dg2,
                       label: GHC.Word.$fIxWord32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dg2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dgb; else goto c2Dgc;
       c2Dgb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dgc: // global
           I64[Sp - 16] = block_c2DfZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DgR; else goto c2Dg0;
       u2DgR: // global
           call _c2DfZ(R1) args: 0, res: 0, upd: 0;
       c2Dg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DfZ() //  [R1]
         { info_tbl: [(c2DfZ,
                       label: block_c2DfZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DfZ: // global
           I64[Sp - 8] = block_c2Dg5_info;
           _s2vbG::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DgQ; else goto c2Dg6;
       u2DgQ: // global
           call _c2Dg5(R1) args: 0, res: 0, upd: 0;
       c2Dg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dg5() //  [R1]
         { info_tbl: [(c2Dg5,
                       label: block_c2Dg5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dg5: // global
           I64[Sp] = block_c2Dga_info;
           _s2vbI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vbI::I64;
           if (R1 & 7 != 0) goto u2DgS; else goto c2Dgf;
       u2DgS: // global
           call _c2Dga(R1) args: 0, res: 0, upd: 0;
       c2Dgf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dga() //  [R1]
         { info_tbl: [(c2Dga,
                       label: block_c2Dga_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dga: // global
           _s2vbK::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vbK::I64) goto c2Dgn; else goto c2Dgr;
       c2Dgn: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Dgr: // global
           I64[Sp] = block_c2Dgq_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbK::I64;
           if (R1 & 7 != 0) goto u2DgT; else goto c2Dgs;
       u2DgT: // global
           call _c2Dgq(R1) args: 0, res: 0, upd: 0;
       c2Dgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dgq() //  [R1]
         { info_tbl: [(c2Dgq,
                       label: block_c2Dgq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dgq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dgy; else goto c2Dgx;
       c2Dgy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dgx: // global
           _s2vbK::I64 = I64[Sp + 8];
           if (_s2vbK::I64 > I64[R1 + 7]) goto c2DgC; else goto c2DgP;
       c2DgC: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2DgP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbK::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.596660533 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.599575756 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { info_tbl: [(c2Dht,
                       label: GHC.Word.byteSwap32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dht: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DhE; else goto c2DhF;
       c2DhE: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DhF: // global
           I64[Sp - 8] = block_c2Dhq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DhJ; else goto c2Dhr;
       u2DhJ: // global
           call _c2Dhq(R1) args: 0, res: 0, upd: 0;
       c2Dhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dhq() //  [R1]
         { info_tbl: [(c2Dhq,
                       label: block_c2Dhq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dhq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DhI; else goto c2DhH;
       c2DhI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DhH: // global
           (_c2Dhw::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2Dhw::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.606257328 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2Di2,
                       label: GHC.Word.$fBitsWord64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Di2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Di9; else goto c2Dia;
       c2Di9: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dia: // global
           I64[Sp - 8] = block_c2DhZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Die; else goto c2Di0;
       u2Die: // global
           call _c2DhZ(R1) args: 0, res: 0, upd: 0;
       c2Di0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DhZ() //  [R1]
         { info_tbl: [(c2DhZ,
                       label: block_c2DhZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DhZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Did; else goto c2Dic;
       c2Did: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dic: // global
           _s2vc0::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vc0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.613048064 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.615566473 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2Div,
                       label: GHC.Word.$fBitsWord64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Div: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.619482699 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { info_tbl: [(c2DiK,
                       label: GHC.Word.$fBitsWord64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DiK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DiL; else goto c2DiM;
       c2DiL: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DiM: // global
           I64[Sp - 8] = block_c2DiH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dj2; else goto c2DiI;
       u2Dj2: // global
           call _c2DiH(R1) args: 0, res: 0, upd: 0;
       c2DiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DiH() //  [R1]
         { info_tbl: [(c2DiH,
                       label: block_c2DiH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DiH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DiR; else goto c2DiQ;
       c2DiR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DiQ: // global
           _s2vc4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vc4::I64, 64)) goto c2Dj0; else goto c2Dj1;
       c2Dj0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2vc4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dj1: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.626265564 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2Djm,
                       label: GHC.Word.$fBitsWord64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Djm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Djq; else goto c2Djr;
       c2Djq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Djr: // global
           I64[Sp - 16] = block_c2Djj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DjX; else goto c2Djk;
       u2DjX: // global
           call _c2Djj(R1) args: 0, res: 0, upd: 0;
       c2Djk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Djj() //  [R1]
         { info_tbl: [(c2Djj,
                       label: block_c2Djj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Djj: // global
           I64[Sp] = block_c2Djp_info;
           _s2vca::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vca::I64;
           if (R1 & 7 != 0) goto u2DjW; else goto c2Djt;
       u2DjW: // global
           call _c2Djp(R1) args: 0, res: 0, upd: 0;
       c2Djt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Djp() //  [R1]
         { info_tbl: [(c2Djp,
                       label: block_c2Djp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Djp: // global
           _s2vcc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2vcc::I64, 64)) goto c2DjV; else goto c2DjU;
       c2DjU: // global
           if (I64[Sp + 8] & (1 << _s2vcc::I64) == 0) goto c2DjV; else goto c2DjJ;
       c2DjV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DjJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.635077708 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2Dkn,
                       label: GHC.Word.$fBitsWord64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dkn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dkr; else goto c2Dks;
       c2Dkr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dks: // global
           I64[Sp - 16] = block_c2Dkk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dlf; else goto c2Dkl;
       u2Dlf: // global
           call _c2Dkk(R1) args: 0, res: 0, upd: 0;
       c2Dkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dkk() //  [R1]
         { info_tbl: [(c2Dkk,
                       label: block_c2Dkk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dkk: // global
           I64[Sp - 8] = block_c2Dkq_info;
           _s2vci::P64 = R1;
           _s2vcj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcj::I64;
           P64[Sp + 8] = _s2vci::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dle; else goto c2Dku;
       u2Dle: // global
           call _c2Dkq(R1) args: 0, res: 0, upd: 0;
       c2Dku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dkq() //  [R1]
         { info_tbl: [(c2Dkq,
                       label: block_c2Dkq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dkq: // global
           _s2vcp::I64 = -I64[R1 + 7] & 63;
           if (_s2vcp::I64 != 0) goto u2Dlc; else goto c2Dl8;
       u2Dlc: // global
           I64[Sp + 16] = _s2vcp::I64;
           Sp = Sp + 8;
           call _c2DkM() args: 0, res: 0, upd: 0;
       c2Dl8: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2DkM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DkM: // global
           Hp = Hp + 16;
           _s2vcp::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Dl5; else goto c2Dl4;
       c2Dl5: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2DkL_info;
           R1 = _s2vcp::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Dl4: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2vcj::I64 = I64[Sp];
           I64[Hp] = (_s2vcj::I64 << _s2vcp::I64) | (_s2vcj::I64 >> 64 - _s2vcp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2DkL() //  [R1]
         { info_tbl: [(c2DkL,
                       label: block_c2DkL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DkL: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2DkM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.64670775 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2DlQ,
                       label: GHC.Word.$fBitsWord64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DlQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DlU; else goto c2DlV;
       c2DlU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DlV: // global
           I64[Sp - 16] = block_c2DlN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dmi; else goto c2DlO;
       u2Dmi: // global
           call _c2DlN(R1) args: 0, res: 0, upd: 0;
       c2DlO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DlN() //  [R1]
         { info_tbl: [(c2DlN,
                       label: block_c2DlN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DlN: // global
           I64[Sp - 8] = block_c2DlT_info;
           _s2vcw::P64 = R1;
           _s2vcx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcx::I64;
           P64[Sp + 8] = _s2vcw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dmh; else goto c2DlX;
       u2Dmh: // global
           call _c2DlT(R1) args: 0, res: 0, upd: 0;
       c2DlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DlT() //  [R1]
         { info_tbl: [(c2DlT,
                       label: block_c2DlT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DlT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dm3; else goto c2Dm2;
       c2Dm3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dm2: // global
           _s2vcz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcz::I64, 64)) goto c2Dmf; else goto c2Dmg;
       c2Dmf: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2vcz::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dmg: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.655400202 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2DmJ,
                       label: GHC.Word.$fBitsWord64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DmJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DmN; else goto c2DmO;
       c2DmN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DmO: // global
           I64[Sp - 16] = block_c2DmG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dnj; else goto c2DmH;
       u2Dnj: // global
           call _c2DmG(R1) args: 0, res: 0, upd: 0;
       c2DmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DmG() //  [R1]
         { info_tbl: [(c2DmG,
                       label: block_c2DmG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DmG: // global
           I64[Sp] = block_c2DmM_info;
           _s2vcG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vcG::I64;
           if (R1 & 7 != 0) goto u2Dni; else goto c2DmQ;
       u2Dni: // global
           call _c2DmM(R1) args: 0, res: 0, upd: 0;
       c2DmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DmM() //  [R1]
         { info_tbl: [(c2DmM,
                       label: block_c2DmM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DmW; else goto c2DmV;
       c2DmW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DmV: // global
           _s2vcG::I64 = I64[Sp + 8];
           _s2vcI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcI::I64, 64)) goto c2Dnb; else goto c2Dnh;
       c2Dnb: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & (1 << _s2vcI::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dnh: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.664743256 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2DnN,
                       label: GHC.Word.$fBitsWord64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DnN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DnR; else goto c2DnS;
       c2DnR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DnS: // global
           I64[Sp - 16] = block_c2DnK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dof; else goto c2DnL;
       u2Dof: // global
           call _c2DnK(R1) args: 0, res: 0, upd: 0;
       c2DnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DnK() //  [R1]
         { info_tbl: [(c2DnK,
                       label: block_c2DnK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DnK: // global
           I64[Sp - 8] = block_c2DnQ_info;
           _s2vcQ::P64 = R1;
           _s2vcR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcR::I64;
           P64[Sp + 8] = _s2vcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Doe; else goto c2DnU;
       u2Doe: // global
           call _c2DnQ(R1) args: 0, res: 0, upd: 0;
       c2DnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DnQ() //  [R1]
         { info_tbl: [(c2DnQ,
                       label: block_c2DnQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DnQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Do0; else goto c2DnZ;
       c2Do0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DnZ: // global
           _s2vcT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcT::I64, 64)) goto c2Doc; else goto c2Dod;
       c2Doc: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2vcT::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dod: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.673419091 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2DoD,
                       label: GHC.Word.$fBitsWord64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DoD: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.676692554 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.679066981 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.681696053 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2DoT,
                       label: GHC.Word.$fIxWord64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DoT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dp2; else goto c2Dp3;
       c2Dp2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dp3: // global
           I64[Sp - 16] = block_c2DoQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dpq; else goto c2DoR;
       u2Dpq: // global
           call _c2DoQ(R1) args: 0, res: 0, upd: 0;
       c2DoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DoQ() //  [R1]
         { info_tbl: [(c2DoQ,
                       label: block_c2DoQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DoQ: // global
           I64[Sp - 8] = block_c2DoW_info;
           _s2vd1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vd1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dpp; else goto c2DoX;
       u2Dpp: // global
           call _c2DoW(R1) args: 0, res: 0, upd: 0;
       c2DoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DoW() //  [R1]
         { info_tbl: [(c2DoW,
                       label: block_c2DoW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DoW: // global
           I64[Sp] = block_c2Dp1_info;
           _s2vd3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vd3::I64;
           if (R1 & 7 != 0) goto u2Dpr; else goto c2Dp6;
       u2Dpr: // global
           call _c2Dp1(R1) args: 0, res: 0, upd: 0;
       c2Dp6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dp1() //  [R1]
         { info_tbl: [(c2Dp1,
                       label: block_c2Dp1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dp1: // global
           _s2vd5::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vd5::I64) goto c2Dpe; else goto c2Dpi;
       c2Dpe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dpi: // global
           _s2vd1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Dph_info;
           R1 = _s2vd1::P64;
           I64[Sp + 16] = _s2vd5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2Dps; else goto c2Dpj;
       u2Dps: // global
           call _c2Dph(R1) args: 0, res: 0, upd: 0;
       c2Dpj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dph() //  [R1]
         { info_tbl: [(c2Dph,
                       label: block_c2Dph_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dph: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.694543585 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { info_tbl: [(c2Dq0,
                       label: GHC.Word.$fIxWord64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dq1; else goto c2Dq2;
       c2Dq1: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dq2: // global
           I64[Sp - 8] = block_c2DpX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dq6; else goto c2DpY;
       u2Dq6: // global
           call _c2DpX(R1) args: 0, res: 0, upd: 0;
       c2DpY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DpX() //  [R1]
         { info_tbl: [(c2DpX,
                       label: block_c2DpX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DpX: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.700857519 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2Dqn,
                       label: GHC.Word.$fIxWord64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dqn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DqH; else goto c2DqI;
       c2DqH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DqI: // global
           I64[Sp - 16] = block_c2Dqk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DqP; else goto c2Dql;
       u2DqP: // global
           call _c2Dqk(R1) args: 0, res: 0, upd: 0;
       c2Dql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dqk() //  [R1]
         { info_tbl: [(c2Dqk,
                       label: block_c2Dqk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dqk: // global
           I64[Sp] = block_c2Dqq_info;
           _s2vdh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vdh::P64;
           if (R1 & 7 != 0) goto u2DqO; else goto c2Dqr;
       u2DqO: // global
           call _c2Dqq(R1) args: 0, res: 0, upd: 0;
       c2Dqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dqq() //  [R1]
         { info_tbl: [(c2Dqq,
                       label: block_c2Dqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dqq: // global
           I64[Sp] = block_c2Dqv_info;
           _s2vdk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdk::I64;
           if (R1 & 7 != 0) goto u2DqQ; else goto c2Dqw;
       u2DqQ: // global
           call _c2Dqv(R1) args: 0, res: 0, upd: 0;
       c2Dqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dqv() //  [R1]
         { info_tbl: [(c2Dqv,
                       label: block_c2Dqv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DqN; else goto c2DqM;
       c2DqN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DqM: // global
           _s2vdo::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.710782022 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2Dri,
                       label: GHC.Word.$fIxWord64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dri: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Drr; else goto c2Drs;
       c2Drr: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Drs: // global
           I64[Sp - 8] = block_c2Drf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DrU; else goto c2Drg;
       u2DrU: // global
           call _c2Drf(R1) args: 0, res: 0, upd: 0;
       c2Drg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Drf() //  [R1]
         { info_tbl: [(c2Drf,
                       label: block_c2Drf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Drf: // global
           I64[Sp - 8] = block_c2Drl_info;
           _s2vds::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vds::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DrT; else goto c2Drm;
       u2DrT: // global
           call _c2Drl(R1) args: 0, res: 0, upd: 0;
       c2Drm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Drl() //  [R1]
         { info_tbl: [(c2Drl,
                       label: block_c2Drl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Drl: // global
           I64[Sp] = block_c2Drq_info;
           _s2vdu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdu::I64;
           if (R1 & 7 != 0) goto u2DrV; else goto c2Drv;
       u2DrV: // global
           call _c2Drq(R1) args: 0, res: 0, upd: 0;
       c2Drv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Drq() //  [R1]
         { info_tbl: [(c2Drq,
                       label: block_c2Drq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Drq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DrB; else goto c2DrA;
       c2DrB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DrA: // global
           _s2vdu::I64 = I64[Sp + 8];
           _s2vdw::I64 = I64[R1 + 7];
           if (_s2vdu::I64 > _s2vdw::I64) goto c2DrF; else goto c2DrS;
       c2DrF: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DrS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdw::I64 - _s2vdu::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.722010323 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2Dsp,
                       label: GHC.Word.$fIxWord64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dsp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DsM; else goto c2DsN;
       c2DsM: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DsN: // global
           I64[Sp - 8] = block_c2Dsm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DsU; else goto c2Dsn;
       u2DsU: // global
           call _c2Dsm(R1) args: 0, res: 0, upd: 0;
       c2Dsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dsm() //  [R1]
         { info_tbl: [(c2Dsm,
                       label: block_c2Dsm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dsm: // global
           I64[Sp - 8] = block_c2Dss_info;
           _s2vdD::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vdD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DsT; else goto c2Dst;
       u2DsT: // global
           call _c2Dss(R1) args: 0, res: 0, upd: 0;
       c2Dst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dss() //  [R1]
         { info_tbl: [(c2Dss,
                       label: block_c2Dss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dss: // global
           I64[Sp] = block_c2Dsx_info;
           _s2vdG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdG::I64;
           if (R1 & 7 != 0) goto u2DsV; else goto c2Dsy;
       u2DsV: // global
           call _c2Dsx(R1) args: 0, res: 0, upd: 0;
       c2Dsy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dsx() //  [R1]
         { info_tbl: [(c2Dsx,
                       label: block_c2Dsx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dsx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DsS; else goto c2DsR;
       c2DsS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DsR: // global
           _s2vdL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.732492654 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2Dto,
                       label: GHC.Word.$fIxWord64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dto: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dtx; else goto c2Dty;
       c2Dtx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dty: // global
           I64[Sp - 16] = block_c2Dtl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dua; else goto c2Dtm;
       u2Dua: // global
           call _c2Dtl(R1) args: 0, res: 0, upd: 0;
       c2Dtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dtl() //  [R1]
         { info_tbl: [(c2Dtl,
                       label: block_c2Dtl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dtl: // global
           I64[Sp - 8] = block_c2Dtr_info;
           _s2vdQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vdQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Du9; else goto c2Dts;
       u2Du9: // global
           call _c2Dtr(R1) args: 0, res: 0, upd: 0;
       c2Dts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dtr() //  [R1]
         { info_tbl: [(c2Dtr,
                       label: block_c2Dtr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dtr: // global
           I64[Sp] = block_c2Dtw_info;
           _s2vdS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vdS::I64;
           if (R1 & 7 != 0) goto u2Dub; else goto c2DtB;
       u2Dub: // global
           call _c2Dtw(R1) args: 0, res: 0, upd: 0;
       c2DtB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dtw() //  [R1]
         { info_tbl: [(c2Dtw,
                       label: block_c2Dtw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dtw: // global
           _s2vdU::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vdU::I64) goto c2DtJ; else goto c2DtN;
       c2DtJ: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2DtN: // global
           I64[Sp] = block_c2DtM_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdU::I64;
           if (R1 & 7 != 0) goto u2Duc; else goto c2DtO;
       u2Duc: // global
           call _c2DtM(R1) args: 0, res: 0, upd: 0;
       c2DtO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2DtM() //  [R1]
         { info_tbl: [(c2DtM,
                       label: block_c2DtM_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DtU; else goto c2DtT;
       c2DtU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DtT: // global
           _s2vdU::I64 = I64[Sp + 8];
           if (_s2vdU::I64 > I64[R1 + 7]) goto c2DtY; else goto c2Du8;
       c2DtY: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Du8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.744690408 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.746783036 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c2DuJ,
                       label: GHC.Word.uncheckedShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DuJ: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.750373331 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { info_tbl: [(c2DuX,
                       label: GHC.Word.uncheckedShiftRL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DuX: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.754848001 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { info_tbl: [(c2Dvd,
                       label: GHC.Word.byteSwap64_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dvd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dvl; else goto c2Dvm;
       c2Dvl: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dvm: // global
           I64[Sp - 8] = block_c2Dva_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dvq; else goto c2Dvb;
       u2Dvq: // global
           call _c2Dva(R1) args: 0, res: 0, upd: 0;
       c2Dvb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Dva() //  [R1]
         { info_tbl: [(c2Dva,
                       label: block_c2Dva_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dva: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dvp; else goto c2Dvo;
       c2Dvp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dvo: // global
           (_c2Dvg::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2Dvg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.760473951 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.762228262 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.763910768 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.766180671 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.768478503 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.77027146 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.771956588 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.773668661 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.775493523 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.777439902 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.779644898 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.781407211 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.783151766 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.785016856 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.786772888 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.788734437 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.79065688 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.792856359 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.794594997 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.796319018 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.79852925 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.800228965 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.802105468 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.804462619 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.806239485 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.807882888 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.809635058 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.811531613 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.813765458 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.816128435 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.817890311 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.819671641 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.821395845 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.82316623 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.82597944 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { info_tbl: [(c2Dwe,
                       label: GHC.Word.W8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dwe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dwi; else goto c2Dwh;
       c2Dwi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dwh: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.830501204 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { info_tbl: [(c2Dwt,
                       label: GHC.Word.W16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dwt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dwx; else goto c2Dww;
       c2Dwx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dww: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.834250874 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { info_tbl: [(c2DwI,
                       label: GHC.Word.W32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DwI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DwM; else goto c2DwL;
       c2DwM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DwL: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.83796118 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { info_tbl: [(c2DwX,
                       label: GHC.Word.W64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2DwX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dx1; else goto c2Dx0;
       c2Dx1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dx0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.842114941 UTC

[GHC.Word.W8#_con_entry() //  [R1]
         { info_tbl: [(c2Dx7,
                       label: GHC.Word.W8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dx7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.845660178 UTC

[GHC.Word.W16#_con_entry() //  [R1]
         { info_tbl: [(c2Dxd,
                       label: GHC.Word.W16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dxd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.848765404 UTC

[GHC.Word.W32#_con_entry() //  [R1]
         { info_tbl: [(c2Dxj,
                       label: GHC.Word.W32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dxj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.852027547 UTC

[GHC.Word.W64#_con_entry() //  [R1]
         { info_tbl: [(c2Dxp,
                       label: GHC.Word.W64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Dxp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:13.855715845 UTC

[section ""relreadonly" . S2vim_srt" {
     S2vim_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2uHi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.609910778 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:22.611445922 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2E5P,
                       label: GHC.Word.$fEnumWord8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E5P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E5W; else goto c2E5X;
       c2E5W: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E5X: // global
           I64[Sp - 8] = block_c2E5M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E61; else goto c2E5N;
       u2E61: // global
           call _c2E5M(R1) args: 0, res: 0, upd: 0;
       c2E5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E5M() //  [R1]
         { info_tbl: [(c2E5M,
                       label: block_c2E5M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E5M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E60; else goto c2E5Z;
       c2E60: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E5Z: // global
           _s2Dxz::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2Dxz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.617621821 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2E6l,
                       label: GHC.Word.$fEnumWord16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E6l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E6s; else goto c2E6t;
       c2E6s: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E6t: // global
           I64[Sp - 8] = block_c2E6i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E6x; else goto c2E6j;
       u2E6x: // global
           call _c2E6i(R1) args: 0, res: 0, upd: 0;
       c2E6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E6i() //  [R1]
         { info_tbl: [(c2E6i,
                       label: block_c2E6i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E6w; else goto c2E6v;
       c2E6w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E6v: // global
           _s2DxD::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DxD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.623599909 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2E6R,
                       label: GHC.Word.$fEnumWord32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E6Y; else goto c2E6Z;
       c2E6Y: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E6Z: // global
           I64[Sp - 8] = block_c2E6O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E73; else goto c2E6P;
       u2E73: // global
           call _c2E6O(R1) args: 0, res: 0, upd: 0;
       c2E6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E6O() //  [R1]
         { info_tbl: [(c2E6O,
                       label: block_c2E6O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E72; else goto c2E71;
       c2E72: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E71: // global
           _s2DxH::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DxH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.629692194 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2E7m,
                       label: GHC.Word.$fNumWord64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E7m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E7q; else goto c2E7r;
       c2E7q: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E7r: // global
           I64[Sp - 8] = block_c2E7k_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2E7k() //  [R1]
         { info_tbl: [(c2E7k,
                       label: block_c2E7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E7u; else goto c2E7t;
       c2E7u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2E7t: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.636560802 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { info_tbl: [(c2E7K,
                       label: GHC.Word.$fNumWord64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E7K: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.640042212 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { info_tbl: [(c2E80,
                       label: GHC.Word.$fNumWord64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E80: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E8d; else goto c2E8e;
       c2E8d: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E8e: // global
           I64[Sp - 8] = block_c2E7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E8i; else goto c2E7Y;
       u2E8i: // global
           call _c2E7X(R1) args: 0, res: 0, upd: 0;
       c2E7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E7X() //  [R1]
         { info_tbl: [(c2E7X,
                       label: block_c2E7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E7X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E8h; else goto c2E8g;
       c2E8h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E8g: // global
           _s2DxQ::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DxQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.646418227 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2E8C,
                       label: GHC.Word.$fNumWord64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2E8O; else goto c2E8P;
       c2E8O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2E8P: // global
           I64[Sp - 16] = block_c2E8z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2E8V; else goto c2E8A;
       u2E8V: // global
           call _c2E8z(R1) args: 0, res: 0, upd: 0;
       c2E8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E8z() //  [R1]
         { info_tbl: [(c2E8z,
                       label: block_c2E8z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E8z: // global
           I64[Sp] = block_c2E8F_info;
           _s2DxU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DxU::I64;
           if (R1 & 7 != 0) goto u2E8U; else goto c2E8G;
       u2E8U: // global
           call _c2E8F(R1) args: 0, res: 0, upd: 0;
       c2E8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E8F() //  [R1]
         { info_tbl: [(c2E8F,
                       label: block_c2E8F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E8F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E8T; else goto c2E8S;
       c2E8T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E8S: // global
           _s2DxX::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DxX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.654281951 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2E9m,
                       label: GHC.Word.$fNumWord64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E9m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2E9y; else goto c2E9z;
       c2E9y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2E9z: // global
           I64[Sp - 16] = block_c2E9j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2E9F; else goto c2E9k;
       u2E9F: // global
           call _c2E9j(R1) args: 0, res: 0, upd: 0;
       c2E9k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E9j() //  [R1]
         { info_tbl: [(c2E9j,
                       label: block_c2E9j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E9j: // global
           I64[Sp] = block_c2E9p_info;
           _s2Dy1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dy1::I64;
           if (R1 & 7 != 0) goto u2E9E; else goto c2E9q;
       u2E9E: // global
           call _c2E9p(R1) args: 0, res: 0, upd: 0;
       c2E9q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2E9p() //  [R1]
         { info_tbl: [(c2E9p,
                       label: block_c2E9p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2E9p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E9D; else goto c2E9C;
       c2E9D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E9C: // global
           _s2Dy4::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2Dy4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.66219998 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2Ea6,
                       label: GHC.Word.$fNumWord64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ea6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eai; else goto c2Eaj;
       c2Eai: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Eaj: // global
           I64[Sp - 16] = block_c2Ea3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Eap; else goto c2Ea4;
       u2Eap: // global
           call _c2Ea3(R1) args: 0, res: 0, upd: 0;
       c2Ea4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ea3() //  [R1]
         { info_tbl: [(c2Ea3,
                       label: block_c2Ea3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ea3: // global
           I64[Sp] = block_c2Ea9_info;
           _s2Dy8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dy8::I64;
           if (R1 & 7 != 0) goto u2Eao; else goto c2Eaa;
       u2Eao: // global
           call _c2Ea9(R1) args: 0, res: 0, upd: 0;
       c2Eaa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ea9() //  [R1]
         { info_tbl: [(c2Ea9,
                       label: block_c2Ea9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ea9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ean; else goto c2Eam;
       c2Ean: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Eam: // global
           _s2Dyb::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2Dyb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.669977911 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.671965223 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { info_tbl: [(c2EaQ,
                       label: lvl_r2uFF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EaQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EaR; else goto c2EaS;
       c2EaR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EaS: // global
           (_c2EaN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EaN::I64 == 0) goto c2EaP; else goto c2EaO;
       c2EaP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EaO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EaN::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.676349802 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2Eb8,
                       label: GHC.Word.$fIntegralWord64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eb8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Eb9; else goto c2Eba;
       c2Eb9: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eba: // global
           I64[Sp - 8] = block_c2Eb5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ebm; else goto c2Eb6;
       u2Ebm: // global
           call _c2Eb5(R1) args: 0, res: 0, upd: 0;
       c2Eb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Eb5() //  [R1]
         { info_tbl: [(c2Eb5,
                       label: block_c2Eb5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eb5: // global
           _s2Dye::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2Dye::I64, 0)) goto c2Ebk; else goto c2Ebl;
       c2Ebk: // global
           R2 = _s2Dye::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2Ebl: // global
           R2 = _s2Dye::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.682695819 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2Dyi_entry() //  [R1]
         { info_tbl: [(c2EbI,
                       label: w1_s2Dyi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EbI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EbJ; else goto c2EbK;
       c2EbJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EbK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2EbF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EbW; else goto c2EbG;
       u2EbW: // global
           call _c2EbF(R1) args: 0, res: 0, upd: 0;
       c2EbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2EbF() //  [R1]
         { info_tbl: [(c2EbF,
                       label: block_c2EbF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EbF: // global
           _s2Dyk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2Dyk::I64, 0)) goto c2EbU; else goto c2EbV;
       c2EbU: // global
           R2 = _s2Dyk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2EbV: // global
           R2 = _s2Dyk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2Dyr_entry() //  [R1, R2]
         { info_tbl: [(c2Ec5,
                       label: sat_s2Dyr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ec5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ec6; else goto c2Ec7;
       c2Ec6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ec7: // global
           I64[Sp - 8] = block_c2Ec2_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ec2() //  [R1, R2]
         { info_tbl: [(c2Ec2,
                       label: block_c2Ec2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ec2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Eca; else goto c2Ec9;
       c2Eca: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ec9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { info_tbl: [(c2Ecb,
                       label: GHC.Word.$fShowWord3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ecb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2Ecf; else goto c2Ece;
       c2Ecf: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ece: // global
           I64[Hp - 32] = w1_s2Dyi_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2Dyr_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.694135691 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2EcN,
                       label: GHC.Word.$fShowWord64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EcN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.698062777 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { info_tbl: [(c2Ed0,
                       label: GHC.Word.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ed0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ed1; else goto c2Ed2;
       c2Ed1: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ed2: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2Ed9; else goto c2Edg;
       c2Ed9: // global
           I64[Sp - 8] = block_c2Ed7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2Edg: // global
           I64[Sp - 8] = block_c2Edf_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ed7() //  [R1]
         { info_tbl: [(c2Ed7,
                       label: block_c2Ed7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ed7: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2Edf() //  [R1]
         { info_tbl: [(c2Edf,
                       label: block_c2Edf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Edf: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.706188173 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { info_tbl: [(c2EdH,
                       label: GHC.Word.$fShowWord64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EdH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EdN; else goto c2EdO;
       c2EdN: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EdO: // global
           I64[Sp - 8] = block_c2EdE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EdT; else goto c2EdF;
       u2EdT: // global
           call _c2EdE(R1) args: 0, res: 0, upd: 0;
       c2EdF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EdE() //  [R1]
         { info_tbl: [(c2EdE,
                       label: block_c2EdE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EdE: // global
           I64[Sp] = block_c2EdK_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EdK() //  [R1, R2]
         { info_tbl: [(c2EdK,
                       label: block_c2EdK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EdK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EdS; else goto c2EdR;
       c2EdS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EdR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.71458803 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2DyH_entry() //  [R1]
         { info_tbl: [(c2Eel,
                       label: w1_s2DyH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eel: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Eem; else goto c2Een;
       c2Eem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Een: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2Eei_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Eez; else goto c2Eej;
       u2Eez: // global
           call _c2Eei(R1) args: 0, res: 0, upd: 0;
       c2Eej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c2Eei() //  [R1]
         { info_tbl: [(c2Eei,
                       label: block_c2Eei_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eei: // global
           _s2DyJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DyJ::I64, 0)) goto c2Eex; else goto c2Eey;
       c2Eex: // global
           R2 = _s2DyJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2Eey: // global
           R2 = _s2DyJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DyS_entry() //  [R1, R2]
         { info_tbl: [(c2EeI,
                       label: sat_s2DyS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EeI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EeO; else goto c2EeP;
       c2EeO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EeP: // global
           I64[Sp - 24] = block_c2EeF_info;
           _s2DyH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2DyH::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EeU; else goto c2EeG;
       u2EeU: // global
           call _c2EeF(R1) args: 0, res: 0, upd: 0;
       c2EeG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EeF() //  [R1]
         { info_tbl: [(c2EeF,
                       label: block_c2EeF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EeF: // global
           _s2DyM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EeL_info;
           R4 = _s2DyM::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EeL() //  [R1, R2]
         { info_tbl: [(c2EeL,
                       label: block_c2EeL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EeL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EeT; else goto c2EeS;
       c2EeT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EeS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c2EeV,
                       label: GHC.Word.$fShowWord64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EeV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EeZ; else goto c2EeY;
       c2EeZ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EeY: // global
           I64[Hp - 40] = w1_s2DyH_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2DyS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.728024967 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.730175774 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { info_tbl: [(c2EfC,
                       label: GHC.Word.$fEnumWord5_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EfC: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.733745772 UTC

[section ""data" . sat_s2DyU_closure" {
     sat_s2DyU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.735471007 UTC

[section ""data" . sat_s2DyV_closure" {
     sat_s2DyV_closure:
         const :_con_info;
         const sat_s2DyU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.737917295 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { info_tbl: [(c2EfR,
                       label: GHC.Word.$fRealWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EfS; else goto c2EfT;
       c2EfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EfT: // global
           (_c2EfO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EfO::I64 == 0) goto c2EfQ; else goto c2EfP;
       c2EfQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EfP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EfO::I64;
           R3 = sat_s2DyV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.742887374 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { info_tbl: [(c2Eg9,
                       label: GHC.Word.$w$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eg9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ega; else goto c2Egb;
       c2Ega: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Egb: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2Egm; else goto c2Egy;
       c2Egm: // global
           I64[Sp - 8] = block_c2Egg_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2Egy: // global
           I64[Sp - 8] = block_c2Egt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Egg() //  [R1]
         { info_tbl: [(c2Egg,
                       label: block_c2Egg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Egg: // global
           I64[Sp] = block_c2Egk_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Egk() //  [R1]
         { info_tbl: [(c2Egk,
                       label: block_c2Egk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Egk: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c2Egt() //  [R1]
         { info_tbl: [(c2Egt,
                       label: block_c2Egt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Egt: // global
           I64[Sp] = block_c2Egx_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Egx() //  [R1]
         { info_tbl: [(c2Egx,
                       label: block_c2Egx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Egx: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.753417711 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2Eh6,
                       label: GHC.Word.$fRealWord64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eh6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ehc; else goto c2Ehd;
       c2Ehc: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ehd: // global
           I64[Sp - 8] = block_c2Eh3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ehi; else goto c2Eh4;
       u2Ehi: // global
           call _c2Eh3(R1) args: 0, res: 0, upd: 0;
       c2Eh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Eh3() //  [R1]
         { info_tbl: [(c2Eh3,
                       label: block_c2Eh3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eh3: // global
           I64[Sp] = block_c2Eh9_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Eh9() //  [R1, R2]
         { info_tbl: [(c2Eh9,
                       label: block_c2Eh9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eh9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Ehh; else goto c2Ehg;
       c2Ehh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ehg: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.760694758 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.762676486 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { info_tbl: [(c2EhI,
                       label: GHC.Word.$fEnumWord10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EhI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EhJ; else goto c2EhK;
       c2EhJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EhK: // global
           (_c2EhD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EhD::I64 == 0) goto c2EhF; else goto c2EhE;
       c2EhF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EhE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EhD::I64;
           I64[Sp - 24] = block_c2EhG_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2EhG() //  [R1]
         { info_tbl: [(c2EhG,
                       label: block_c2EhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EhG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.768338786 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { info_tbl: [(c2Ei8,
                       label: GHC.Word.$fEnumWord11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ei8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Ei9; else goto c2Eia;
       c2Ei9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eia: // global
           (_c2Ei3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Ei3::I64 == 0) goto c2Ei5; else goto c2Ei4;
       c2Ei5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Ei4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Ei3::I64;
           I64[Sp - 24] = block_c2Ei6_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2Ei6() //  [R1]
         { info_tbl: [(c2Ei6,
                       label: block_c2Ei6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ei6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.774472514 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { info_tbl: [(c2Eix,
                       label: GHC.Word.neWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eix: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EiB; else goto c2EiC;
       c2EiB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EiC: // global
           I64[Sp - 16] = block_c2Eiu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EiL; else goto c2Eiv;
       u2EiL: // global
           call _c2Eiu(R1) args: 0, res: 0, upd: 0;
       c2Eiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Eiu() //  [R1]
         { info_tbl: [(c2Eiu,
                       label: block_c2Eiu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eiu: // global
           I64[Sp] = block_c2EiA_info;
           _s2Dze::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dze::I64;
           if (R1 & 7 != 0) goto u2EiK; else goto c2EiE;
       u2EiK: // global
           call _c2EiA(R1) args: 0, res: 0, upd: 0;
       c2EiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EiA() //  [R1]
         { info_tbl: [(c2EiA,
                       label: block_c2EiA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EiA: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.782388017 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { info_tbl: [(c2Ejc,
                       label: lvl2_r2uFH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ejc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ejd; else goto c2Eje;
       c2Ejd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eje: // global
           (_c2Ej9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Ej9::I64 == 0) goto c2Ejb; else goto c2Eja;
       c2Ejb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Eja: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Ej9::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.786253137 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.788366237 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { info_tbl: [(c2Ejv,
                       label: GHC.Word.$fEnumWord8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ejv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ejw; else goto c2Ejx;
       c2Ejw: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ejx: // global
           I64[Sp - 8] = block_c2Ejs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EjP; else goto c2Ejt;
       u2EjP: // global
           call _c2Ejs(R1) args: 0, res: 0, upd: 0;
       c2Ejt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ejs() //  [R1]
         { info_tbl: [(c2Ejs,
                       label: block_c2Ejs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ejs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EjC; else goto c2EjB;
       c2EjC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EjB: // global
           _s2Dzl::I64 = I64[R1 + 7];
           if (_s2Dzl::I64 != 0) goto c2EjN; else goto c2EjO;
       c2EjN: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2Dzl::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EjO: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.794921746 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.796704573 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.79892244 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { info_tbl: [(c2Eke,
                       label: GHC.Word.$fEnumWord8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eke: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ekf; else goto c2Ekg;
       c2Ekf: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ekg: // global
           I64[Sp - 8] = block_c2Ekb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Eky; else goto c2Ekc;
       u2Eky: // global
           call _c2Ekb(R1) args: 0, res: 0, upd: 0;
       c2Ekc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ekb() //  [R1]
         { info_tbl: [(c2Ekb,
                       label: block_c2Ekb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ekb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ekl; else goto c2Ekk;
       c2Ekl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ekk: // global
           _s2Dzr::I64 = I64[R1 + 7];
           if (_s2Dzr::I64 != 255) goto c2Ekw; else goto c2Ekx;
       c2Ekw: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2Dzr::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ekx: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.805866005 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EkV,
                       label: GHC.Word.$fShowWord8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EkV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2El9; else goto c2Ela;
       c2El9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ela: // global
           I64[Sp - 24] = block_c2EkS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Elh; else goto c2EkT;
       u2Elh: // global
           call _c2EkS(R1) args: 0, res: 0, upd: 0;
       c2EkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EkS() //  [R1]
         { info_tbl: [(c2EkS,
                       label: block_c2EkS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EkS: // global
           I64[Sp] = block_c2EkY_info;
           _s2Dzy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dzy::I64;
           if (R1 & 7 != 0) goto u2Elg; else goto c2EkZ;
       u2Elg: // global
           call _c2EkY(R1) args: 0, res: 0, upd: 0;
       c2EkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EkY() //  [R1]
         { info_tbl: [(c2EkY,
                       label: block_c2EkY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EkY: // global
           _s2Dzw::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2El6_info;
           R4 = _s2Dzw::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2El6() //  [R1, R2]
         { info_tbl: [(c2El6,
                       label: block_c2El6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2El6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Elf; else goto c2Ele;
       c2Elf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ele: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.816430537 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { info_tbl: [(c2ElK,
                       label: GHC.Word.$fShowWord8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ElK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ElT; else goto c2ElU;
       c2ElT: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ElU: // global
           I64[Sp - 8] = block_c2ElH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ElZ; else goto c2ElI;
       u2ElZ: // global
           call _c2ElH(R1) args: 0, res: 0, upd: 0;
       c2ElI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ElH() //  [R1]
         { info_tbl: [(c2ElH,
                       label: block_c2ElH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ElH: // global
           I64[Sp] = block_c2ElQ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2ElQ() //  [R1, R2]
         { info_tbl: [(c2ElQ,
                       label: block_c2ElQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ElQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ElY; else goto c2ElX;
       c2ElY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ElX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.824167209 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { info_tbl: [(c2Emo,
                       label: GHC.Word.$fShowWord4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Emo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Emx; else goto c2Emy;
       c2Emx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Emy: // global
           I64[Sp - 16] = block_c2Eml_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EmD; else goto c2Emm;
       u2EmD: // global
           call _c2Eml(R1) args: 0, res: 0, upd: 0;
       c2Emm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Eml() //  [R1]
         { info_tbl: [(c2Eml,
                       label: block_c2Eml_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eml: // global
           _s2DzN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Emu_info;
           R4 = _s2DzN::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Emu() //  [R1, R2]
         { info_tbl: [(c2Emu,
                       label: block_c2Emu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Emu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EmC; else goto c2EmB;
       c2EmC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EmB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.831757346 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2EmY,
                       label: GHC.Word.$fShowWord8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EmY: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.835661125 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.837592405 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { info_tbl: [(c2Ena,
                       label: GHC.Word.$wlvl3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ena: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.841279448 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c2Enq,
                       label: GHC.Word.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Enq: // global
           _s2DzX::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2Eny; else goto c2Enp;
       c2Enp: // global
           if (%MO_S_Gt_W64(_s2DzX::I64, 255)) goto c2Eny; else goto c2EnC;
       c2Eny: // global
           R2 = _s2DzX::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2EnC: // global
           R1 = _s2DzX::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.845225094 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2EnP,
                       label: GHC.Word.$fEnumWord8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EnP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EnX; else goto c2EnY;
       c2EnX: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EnY: // global
           I64[Sp - 8] = block_c2EnM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Eo3; else goto c2EnN;
       u2Eo3: // global
           call _c2EnM(R1) args: 0, res: 0, upd: 0;
       c2EnN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EnM() //  [R1]
         { info_tbl: [(c2EnM,
                       label: block_c2EnM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EnM: // global
           I64[Sp] = block_c2EnS_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EnS() //  [R1]
         { info_tbl: [(c2EnS,
                       label: block_c2EnS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EnS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eo2; else goto c2Eo1;
       c2Eo2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Eo1: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.856965679 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2DAs_entry() //  [R1]
         { info_tbl: [(c2Ep1,
                       label: sat_s2DAs_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ep1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ep2; else goto c2Ep3;
       c2Ep2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ep3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DAk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAq_entry() //  [R1]
         { info_tbl: [(c2Epd,
                       label: sat_s2DAq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Epd: // global
           _s2DAq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Epe; else goto c2Epf;
       c2Epf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eph; else goto c2Epg;
       c2Eph: // global
           HpAlloc = 16;
           goto c2Epe;
       c2Epe: // global
           R1 = _s2DAq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Epg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAq::P64;
           _s2DAl::I64 = I64[_s2DAq::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAl::I64, 0)) goto c2Epn; else goto c2Epc;
       c2Epc: // global
           if (%MO_S_Gt_W64(_s2DAl::I64, 255)) goto c2Epn; else goto c2Epu;
       c2Epn: // global
           Hp = Hp - 16;
           R2 = _s2DAl::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Epu: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAw_entry() //  [R1]
         { info_tbl: [(c2EpF,
                       label: sat_s2DAw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EpF: // global
           _s2DAw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EpG; else goto c2EpH;
       c2EpH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EpJ; else goto c2EpI;
       c2EpJ: // global
           HpAlloc = 16;
           goto c2EpG;
       c2EpG: // global
           R1 = _s2DAw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EpI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAw::P64;
           _s2DAl::I64 = I64[_s2DAw::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAl::I64, 0)) goto c2EpP; else goto c2EpE;
       c2EpE: // global
           if (%MO_S_Gt_W64(_s2DAl::I64, 255)) goto c2EpP; else goto c2EpW;
       c2EpP: // global
           Hp = Hp - 16;
           R2 = _s2DAl::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EpW: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2DAk_entry() //  [R1, R2]
         { info_tbl: [(c2Eq0,
                       label: go_dn_s2DAk_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eq0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Eq4; else goto c2Eq3;
       c2Eq4: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eq3: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2EpY; else goto c2EpZ;
       c2EpY: // global
           _s2DAi::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DAs_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DAi::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DAq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EpZ: // global
           I64[Hp - 80] = sat_s2DAw_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Eq6::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Eq6::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DAx_entry() //  [R1]
         { info_tbl: [(c2Eq7,
                       label: sat_s2DAx_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eq7: // global
           _s2DAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eq8; else goto c2Eq9;
       c2Eq9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Eqb; else goto c2Eqa;
       c2Eqb: // global
           HpAlloc = 24;
           goto c2Eq8;
       c2Eq8: // global
           R1 = _s2DAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAx::P64;
           _s2DAa::I64 = I64[_s2DAx::P64 + 24];
           _s2DAi::I64 = _s2DAa::I64 - I64[_s2DAx::P64 + 16];
           _s2DAj::I64 = I64[_s2DAx::P64 + 32] - _s2DAi::I64;
           I64[Hp - 16] = go_dn_s2DAk_info;
           I64[Hp - 8] = _s2DAi::I64;
           I64[Hp] = _s2DAj::I64;
           R2 = _s2DAa::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DAk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAh_entry() //  [R1]
         { info_tbl: [(c2Eql,
                       label: sat_s2DAh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eql: // global
           _s2DAh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eqm; else goto c2Eqn;
       c2Eqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eqp; else goto c2Eqo;
       c2Eqp: // global
           HpAlloc = 16;
           goto c2Eqm;
       c2Eqm: // global
           R1 = _s2DAh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAh::P64;
           _s2DA9::I64 = I64[_s2DAh::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Eqv; else goto c2Eqk;
       c2Eqk: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Eqv; else goto c2EqC;
       c2Eqv: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EqC: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAC_entry() //  [R1]
         { info_tbl: [(c2EqQ,
                       label: sat_s2DAC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EqQ: // global
           _s2DAC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EqR; else goto c2EqS;
       c2EqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EqU; else goto c2EqT;
       c2EqU: // global
           HpAlloc = 16;
           goto c2EqR;
       c2EqR: // global
           R1 = _s2DAC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EqT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAC::P64;
           _s2DA9::I64 = I64[_s2DAC::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Er0; else goto c2EqP;
       c2EqP: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Er0; else goto c2Er7;
       c2Er0: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Er7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAT_entry() //  [R1]
         { info_tbl: [(c2ErD,
                       label: sat_s2DAT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ErD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ErE; else goto c2ErF;
       c2ErE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ErF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DAL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAR_entry() //  [R1]
         { info_tbl: [(c2ErP,
                       label: sat_s2DAR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ErP: // global
           _s2DAR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ErQ; else goto c2ErR;
       c2ErR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ErT; else goto c2ErS;
       c2ErT: // global
           HpAlloc = 16;
           goto c2ErQ;
       c2ErQ: // global
           R1 = _s2DAR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ErS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAR::P64;
           _s2DAM::I64 = I64[_s2DAR::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAM::I64, 0)) goto c2ErZ; else goto c2ErO;
       c2ErO: // global
           if (%MO_S_Gt_W64(_s2DAM::I64, 255)) goto c2ErZ; else goto c2Es6;
       c2ErZ: // global
           Hp = Hp - 16;
           R2 = _s2DAM::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Es6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAM::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAX_entry() //  [R1]
         { info_tbl: [(c2Esh,
                       label: sat_s2DAX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Esh: // global
           _s2DAX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Esi; else goto c2Esj;
       c2Esj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Esl; else goto c2Esk;
       c2Esl: // global
           HpAlloc = 16;
           goto c2Esi;
       c2Esi: // global
           R1 = _s2DAX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Esk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAX::P64;
           _s2DAM::I64 = I64[_s2DAX::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAM::I64, 0)) goto c2Esr; else goto c2Esg;
       c2Esg: // global
           if (%MO_S_Gt_W64(_s2DAM::I64, 255)) goto c2Esr; else goto c2Esy;
       c2Esr: // global
           Hp = Hp - 16;
           R2 = _s2DAM::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Esy: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAM::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2DAL_entry() //  [R1, R2]
         { info_tbl: [(c2EsC,
                       label: go_up_s2DAL_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EsC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EsG; else goto c2EsF;
       c2EsG: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EsF: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2EsA; else goto c2EsB;
       c2EsA: // global
           _s2DAJ::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DAT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DAJ::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DAR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EsB: // global
           I64[Hp - 80] = sat_s2DAX_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EsI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EsI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DAY_entry() //  [R1]
         { info_tbl: [(c2EsJ,
                       label: sat_s2DAY_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EsJ: // global
           _s2DAY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EsK; else goto c2EsL;
       c2EsL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EsN; else goto c2EsM;
       c2EsN: // global
           HpAlloc = 24;
           goto c2EsK;
       c2EsK: // global
           R1 = _s2DAY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAY::P64;
           _s2DAa::I64 = I64[_s2DAY::P64 + 24];
           _s2DAJ::I64 = _s2DAa::I64 - I64[_s2DAY::P64 + 16];
           _s2DAK::I64 = I64[_s2DAY::P64 + 32] - _s2DAJ::I64;
           I64[Hp - 16] = go_up_s2DAL_info;
           I64[Hp - 8] = _s2DAJ::I64;
           I64[Hp] = _s2DAK::I64;
           R2 = _s2DAa::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DAL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DAI_entry() //  [R1]
         { info_tbl: [(c2EsX,
                       label: sat_s2DAI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EsX: // global
           _s2DAI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EsY; else goto c2EsZ;
       c2EsZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Et1; else goto c2Et0;
       c2Et1: // global
           HpAlloc = 16;
           goto c2EsY;
       c2EsY: // global
           R1 = _s2DAI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Et0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAI::P64;
           _s2DA9::I64 = I64[_s2DAI::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Et7; else goto c2EsW;
       c2EsW: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Et7; else goto c2Ete;
       c2Et7: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Ete: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DB3_entry() //  [R1]
         { info_tbl: [(c2Ets,
                       label: sat_s2DB3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ets: // global
           _s2DB3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ett; else goto c2Etu;
       c2Etu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Etw; else goto c2Etv;
       c2Etw: // global
           HpAlloc = 16;
           goto c2Ett;
       c2Ett: // global
           R1 = _s2DB3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Etv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DB3::P64;
           _s2DA9::I64 = I64[_s2DB3::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2EtC; else goto c2Etr;
       c2Etr: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2EtC; else goto c2EtJ;
       c2EtC: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EtJ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EtK,
                       label: GHC.Word.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EtK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EtO; else goto c2EtN;
       c2EtO: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EtN: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2EtY; else goto c2Eu7;
       c2EtY: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2EtR; else goto c2EtW;
       c2EtR: // global
           I64[Hp - 80] = sat_s2DAx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DAh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EtW: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2Eu5; else goto c2EtU;
       c2EtU: // global
           I64[Hp - 80] = sat_s2DAC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EtS::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EtS::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu7: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2Eu1; else goto c2Eu6;
       c2Eu1: // global
           I64[Hp - 80] = sat_s2DAY_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DAI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu6: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2Eu5; else goto c2Eu4;
       c2Eu5: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu4: // global
           I64[Hp - 80] = sat_s2DB3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Eu2::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Eu2::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.897162786 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EwB,
                       label: GHC.Word.$fEnumWord8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EwB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EwK; else goto c2EwL;
       c2EwK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EwL: // global
           I64[Sp - 24] = block_c2Ewy_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EwU; else goto c2Ewz;
       u2EwU: // global
           call _c2Ewy(R1) args: 0, res: 0, upd: 0;
       c2Ewz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ewy() //  [R1]
         { info_tbl: [(c2Ewy,
                       label: block_c2Ewy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ewy: // global
           I64[Sp] = block_c2EwE_info;
           _s2DB8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DB8::I64;
           if (R1 & 7 != 0) goto u2EwT; else goto c2EwF;
       u2EwT: // global
           call _c2EwE(R1) args: 0, res: 0, upd: 0;
       c2EwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EwE() //  [R1]
         { info_tbl: [(c2EwE,
                       label: block_c2EwE_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EwE: // global
           I64[Sp] = block_c2EwJ_info;
           _s2DBa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DBa::I64;
           if (R1 & 7 != 0) goto u2EwV; else goto c2EwO;
       u2EwV: // global
           call _c2EwJ(R1) args: 0, res: 0, upd: 0;
       c2EwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EwJ() //  [R1]
         { info_tbl: [(c2EwJ,
                       label: block_c2EwJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EwJ: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.907927241 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2DBq_entry() //  [R1]
         { info_tbl: [(c2ExH,
                       label: sat_s2DBq_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ExH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ExI; else goto c2ExJ;
       c2ExI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ExJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DBj::I64 = I64[R1 + 32];
           if (_s2DBj::I64 == I64[R1 + 24]) goto c2ExG; else goto c2ExF;
       c2ExG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2ExF: // global
           R2 = _s2DBj::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DBi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DBn_entry() //  [R1]
         { info_tbl: [(c2ExV,
                       label: sat_s2DBn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ExV: // global
           _s2DBn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ExW; else goto c2ExX;
       c2ExX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ExZ; else goto c2ExY;
       c2ExZ: // global
           HpAlloc = 16;
           goto c2ExW;
       c2ExW: // global
           R1 = _s2DBn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ExY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DBn::P64;
           _s2DBj::I64 = I64[_s2DBn::P64 + 16];
           if (%MO_S_Lt_W64(_s2DBj::I64, 0)) goto c2Ey5; else goto c2ExU;
       c2ExU: // global
           if (%MO_S_Gt_W64(_s2DBj::I64, 255)) goto c2Ey5; else goto c2Eyc;
       c2Ey5: // global
           Hp = Hp - 16;
           R2 = _s2DBj::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Eyc: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DBj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2DBi_entry() //  [R1, R2]
         { info_tbl: [(c2Eye,
                       label: go_s2DBi_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eye: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Eyi; else goto c2Eyh;
       c2Eyi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eyh: // global
           _s2DBg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DBq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DBg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DBn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c2Eyj,
                       label: GHC.Word.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Eyj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eyn; else goto c2Eym;
       c2Eyn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Eym: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2Eyp; else goto c2Eyq;
       c2Eyp: // global
           I64[Hp - 8] = go_s2DBi_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DBi_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2Eyq: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.919406663 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2Ez2,
                       label: GHC.Word.$fEnumWord8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ez2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ez6; else goto c2Ez7;
       c2Ez6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ez7: // global
           I64[Sp - 16] = block_c2EyZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ezf; else goto c2Ez0;
       u2Ezf: // global
           call _c2EyZ(R1) args: 0, res: 0, upd: 0;
       c2Ez0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EyZ() //  [R1]
         { info_tbl: [(c2EyZ,
                       label: block_c2EyZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EyZ: // global
           I64[Sp] = block_c2Ez5_info;
           _s2DBu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DBu::I64;
           if (R1 & 7 != 0) goto u2Eze; else goto c2Ez9;
       u2Eze: // global
           call _c2Ez5(R1) args: 0, res: 0, upd: 0;
       c2Ez9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ez5() //  [R1]
         { info_tbl: [(c2Ez5,
                       label: block_c2Ez5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ez5: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.927652314 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2DBH_entry() //  [R1]
         { info_tbl: [(c2EzH,
                       label: sat_s2DBH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EzH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EzI; else goto c2EzT;
       c2EzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EzT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DBC::I64 = I64[R1 + 16];
           if (_s2DBC::I64 != 255) goto c2EzF; else goto c2EzG;
       c2EzF: // global
           I64[Sp - 24] = block_c2EzN_info;
           R2 = _s2DBC::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2EzG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2EzN() //  [R1, R2]
         { info_tbl: [(c2EzN,
                       label: block_c2EzN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EzS; else goto c2EzR;
       c2EzS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2EzR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DBB_entry() //  [R1]
         { info_tbl: [(c2EA3,
                       label: sat_s2DBB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EA3: // global
           _s2DBB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EA4; else goto c2EA5;
       c2EA5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EA7; else goto c2EA6;
       c2EA7: // global
           HpAlloc = 16;
           goto c2EA4;
       c2EA4: // global
           R1 = _s2DBB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DBB::P64;
           _s2DBx::I64 = I64[_s2DBB::P64 + 16];
           if (%MO_S_Lt_W64(_s2DBx::I64, 0)) goto c2EAd; else goto c2EA2;
       c2EA2: // global
           if (%MO_S_Gt_W64(_s2DBx::I64, 255)) goto c2EAd; else goto c2EAk;
       c2EAd: // global
           Hp = Hp - 16;
           R2 = _s2DBx::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EAk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DBx::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { info_tbl: [(c2EAl,
                       label: GHC.Word.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EAl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EAp; else goto c2EAo;
       c2EAp: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EAo: // global
           I64[Hp - 40] = sat_s2DBH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DBB_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.939037964 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { info_tbl: [(c2EAY,
                       label: GHC.Word.$fEnumWord8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EAY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EAZ; else goto c2EB0;
       c2EAZ: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EB0: // global
           I64[Sp - 8] = block_c2EAV_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EAV() //  [R1, R2]
         { info_tbl: [(c2EAV,
                       label: block_c2EAV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EAV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EB3; else goto c2EB2;
       c2EB3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EB2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.945789955 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2EBm,
                       label: GHC.Word.$fEnumWord8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EBm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EBn; else goto c2EBo;
       c2EBn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EBo: // global
           I64[Sp - 8] = block_c2EBj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EBA; else goto c2EBk;
       u2EBA: // global
           call _c2EBj(R1) args: 0, res: 0, upd: 0;
       c2EBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EBj() //  [R1]
         { info_tbl: [(c2EBj,
                       label: block_c2EBj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EBj: // global
           _s2DBP::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DBP::I64, 255)) goto c2EBy; else goto c2EBz;
       c2EBy: // global
           R2 = _s2DBP::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2EBz: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.951506835 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2EBR,
                       label: GHC.Word.$fEnumWord8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EBR: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.955845957 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.958033486 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { info_tbl: [(c2EC8,
                       label: GHC.Word.$fEnumWord1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EC8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EC9; else goto c2ECa;
       c2EC9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ECa: // global
           (_c2EC3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EC3::I64 == 0) goto c2EC5; else goto c2EC4;
       c2EC5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EC4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EC3::I64;
           I64[Sp - 24] = block_c2EC6_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2EC6() //  [R1]
         { info_tbl: [(c2EC6,
                       label: block_c2EC6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EC6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.963736475 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { info_tbl: [(c2ECy,
                       label: GHC.Word.$fEnumWord2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ECy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ECz; else goto c2ECA;
       c2ECz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ECA: // global
           (_c2ECt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2ECt::I64 == 0) goto c2ECv; else goto c2ECu;
       c2ECv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2ECu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2ECt::I64;
           I64[Sp - 24] = block_c2ECw_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2ECw() //  [R1]
         { info_tbl: [(c2ECw,
                       label: block_c2ECw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ECw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.969782384 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { info_tbl: [(c2ECX,
                       label: GHC.Word.neWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ECX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ED1; else goto c2ED2;
       c2ED1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ED2: // global
           I64[Sp - 16] = block_c2ECU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EDb; else goto c2ECV;
       u2EDb: // global
           call _c2ECU(R1) args: 0, res: 0, upd: 0;
       c2ECV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ECU() //  [R1]
         { info_tbl: [(c2ECU,
                       label: block_c2ECU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ECU: // global
           I64[Sp] = block_c2ED0_info;
           _s2DBW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DBW::I64;
           if (R1 & 7 != 0) goto u2EDa; else goto c2ED4;
       u2EDa: // global
           call _c2ED0(R1) args: 0, res: 0, upd: 0;
       c2ED4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ED0() //  [R1]
         { info_tbl: [(c2ED0,
                       label: block_c2ED0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ED0: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.977108786 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { info_tbl: [(c2EDC,
                       label: lvl4_r2uFJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EDC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EDD; else goto c2EDE;
       c2EDD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EDE: // global
           (_c2EDz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EDz::I64 == 0) goto c2EDB; else goto c2EDA;
       c2EDB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EDA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EDz::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.981506343 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.983703173 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { info_tbl: [(c2EDV,
                       label: GHC.Word.$fEnumWord16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EDV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EDW; else goto c2EDX;
       c2EDW: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EDX: // global
           I64[Sp - 8] = block_c2EDS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EEf; else goto c2EDT;
       u2EEf: // global
           call _c2EDS(R1) args: 0, res: 0, upd: 0;
       c2EDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EDS() //  [R1]
         { info_tbl: [(c2EDS,
                       label: block_c2EDS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EDS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EE2; else goto c2EE1;
       c2EE2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EE1: // global
           _s2DC3::I64 = I64[R1 + 7];
           if (_s2DC3::I64 != 0) goto c2EEd; else goto c2EEe;
       c2EEd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DC3::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EEe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.990117497 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.991778701 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:22.994269333 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { info_tbl: [(c2EEE,
                       label: GHC.Word.$fEnumWord16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EEE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EEF; else goto c2EEG;
       c2EEF: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EEG: // global
           I64[Sp - 8] = block_c2EEB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EEY; else goto c2EEC;
       u2EEY: // global
           call _c2EEB(R1) args: 0, res: 0, upd: 0;
       c2EEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EEB() //  [R1]
         { info_tbl: [(c2EEB,
                       label: block_c2EEB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EEB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EEL; else goto c2EEK;
       c2EEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EEK: // global
           _s2DC9::I64 = I64[R1 + 7];
           if (_s2DC9::I64 != 65535) goto c2EEW; else goto c2EEX;
       c2EEW: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DC9::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EEX: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.000672595 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EFl,
                       label: GHC.Word.$fShowWord16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EFl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EFz; else goto c2EFA;
       c2EFz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EFA: // global
           I64[Sp - 24] = block_c2EFi_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EFH; else goto c2EFj;
       u2EFH: // global
           call _c2EFi(R1) args: 0, res: 0, upd: 0;
       c2EFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EFi() //  [R1]
         { info_tbl: [(c2EFi,
                       label: block_c2EFi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EFi: // global
           I64[Sp] = block_c2EFo_info;
           _s2DCg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DCg::I64;
           if (R1 & 7 != 0) goto u2EFG; else goto c2EFp;
       u2EFG: // global
           call _c2EFo(R1) args: 0, res: 0, upd: 0;
       c2EFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EFo() //  [R1]
         { info_tbl: [(c2EFo,
                       label: block_c2EFo_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EFo: // global
           _s2DCe::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EFw_info;
           R4 = _s2DCe::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EFw() //  [R1, R2]
         { info_tbl: [(c2EFw,
                       label: block_c2EFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EFw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EFF; else goto c2EFE;
       c2EFF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EFE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.010445733 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { info_tbl: [(c2EGa,
                       label: GHC.Word.$fShowWord16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EGa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EGj; else goto c2EGk;
       c2EGj: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EGk: // global
           I64[Sp - 8] = block_c2EG7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EGp; else goto c2EG8;
       u2EGp: // global
           call _c2EG7(R1) args: 0, res: 0, upd: 0;
       c2EG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EG7() //  [R1]
         { info_tbl: [(c2EG7,
                       label: block_c2EG7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EG7: // global
           I64[Sp] = block_c2EGg_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EGg() //  [R1, R2]
         { info_tbl: [(c2EGg,
                       label: block_c2EGg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EGg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EGo; else goto c2EGn;
       c2EGo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EGn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.018649127 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { info_tbl: [(c2EGO,
                       label: GHC.Word.$fShowWord1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EGO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EGX; else goto c2EGY;
       c2EGX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EGY: // global
           I64[Sp - 16] = block_c2EGL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EH3; else goto c2EGM;
       u2EH3: // global
           call _c2EGL(R1) args: 0, res: 0, upd: 0;
       c2EGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EGL() //  [R1]
         { info_tbl: [(c2EGL,
                       label: block_c2EGL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EGL: // global
           _s2DCv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2EGU_info;
           R4 = _s2DCv::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EGU() //  [R1, R2]
         { info_tbl: [(c2EGU,
                       label: block_c2EGU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EGU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EH2; else goto c2EH1;
       c2EH2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EH1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.026575642 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2EHo,
                       label: GHC.Word.$fShowWord16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EHo: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.029971329 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.031900928 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { info_tbl: [(c2EHA,
                       label: GHC.Word.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EHA: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.035887974 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2EHQ,
                       label: GHC.Word.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EHQ: // global
           _s2DCF::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2EHY; else goto c2EHP;
       c2EHP: // global
           if (%MO_S_Gt_W64(_s2DCF::I64, 65535)) goto c2EHY; else goto c2EI2;
       c2EHY: // global
           R2 = _s2DCF::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2EI2: // global
           R1 = _s2DCF::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.039850527 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2EIf,
                       label: GHC.Word.$fEnumWord16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EIf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EIn; else goto c2EIo;
       c2EIn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EIo: // global
           I64[Sp - 8] = block_c2EIc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EIt; else goto c2EId;
       u2EIt: // global
           call _c2EIc(R1) args: 0, res: 0, upd: 0;
       c2EId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EIc() //  [R1]
         { info_tbl: [(c2EIc,
                       label: block_c2EIc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EIc: // global
           I64[Sp] = block_c2EIi_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EIi() //  [R1]
         { info_tbl: [(c2EIi,
                       label: block_c2EIi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EIi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EIs; else goto c2EIr;
       c2EIs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2EIr: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.051032685 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2DDa_entry() //  [R1]
         { info_tbl: [(c2EJr,
                       label: sat_s2DDa_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EJr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EJs; else goto c2EJt;
       c2EJs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EJt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DD2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DD8_entry() //  [R1]
         { info_tbl: [(c2EJD,
                       label: sat_s2DD8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EJD: // global
           _s2DD8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EJE; else goto c2EJF;
       c2EJF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EJH; else goto c2EJG;
       c2EJH: // global
           HpAlloc = 16;
           goto c2EJE;
       c2EJE: // global
           R1 = _s2DD8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EJG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DD8::P64;
           _s2DD3::I64 = I64[_s2DD8::P64 + 16];
           if (%MO_S_Lt_W64(_s2DD3::I64, 0)) goto c2EJN; else goto c2EJC;
       c2EJC: // global
           if (%MO_S_Gt_W64(_s2DD3::I64, 65535)) goto c2EJN; else goto c2EJU;
       c2EJN: // global
           Hp = Hp - 16;
           R2 = _s2DD3::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EJU: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DD3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDe_entry() //  [R1]
         { info_tbl: [(c2EK5,
                       label: sat_s2DDe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EK5: // global
           _s2DDe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EK6; else goto c2EK7;
       c2EK7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EK9; else goto c2EK8;
       c2EK9: // global
           HpAlloc = 16;
           goto c2EK6;
       c2EK6: // global
           R1 = _s2DDe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EK8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDe::P64;
           _s2DD3::I64 = I64[_s2DDe::P64 + 16];
           if (%MO_S_Lt_W64(_s2DD3::I64, 0)) goto c2EKf; else goto c2EK4;
       c2EK4: // global
           if (%MO_S_Gt_W64(_s2DD3::I64, 65535)) goto c2EKf; else goto c2EKm;
       c2EKf: // global
           Hp = Hp - 16;
           R2 = _s2DD3::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EKm: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DD3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2DD2_entry() //  [R1, R2]
         { info_tbl: [(c2EKq,
                       label: go_dn_s2DD2_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EKq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EKu; else goto c2EKt;
       c2EKu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EKt: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2EKo; else goto c2EKp;
       c2EKo: // global
           _s2DD0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DDa_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DD0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DD8_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EKp: // global
           I64[Hp - 80] = sat_s2DDe_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EKw::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EKw::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DDf_entry() //  [R1]
         { info_tbl: [(c2EKx,
                       label: sat_s2DDf_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EKx: // global
           _s2DDf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EKy; else goto c2EKz;
       c2EKz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EKB; else goto c2EKA;
       c2EKB: // global
           HpAlloc = 24;
           goto c2EKy;
       c2EKy: // global
           R1 = _s2DDf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EKA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDf::P64;
           _s2DCS::I64 = I64[_s2DDf::P64 + 24];
           _s2DD0::I64 = _s2DCS::I64 - I64[_s2DDf::P64 + 16];
           _s2DD1::I64 = I64[_s2DDf::P64 + 32] - _s2DD0::I64;
           I64[Hp - 16] = go_dn_s2DD2_info;
           I64[Hp - 8] = _s2DD0::I64;
           I64[Hp] = _s2DD1::I64;
           R2 = _s2DCS::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DD2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DCZ_entry() //  [R1]
         { info_tbl: [(c2EKL,
                       label: sat_s2DCZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EKL: // global
           _s2DCZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EKM; else goto c2EKN;
       c2EKN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EKP; else goto c2EKO;
       c2EKP: // global
           HpAlloc = 16;
           goto c2EKM;
       c2EKM: // global
           R1 = _s2DCZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EKO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DCZ::P64;
           _s2DCR::I64 = I64[_s2DCZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2EKV; else goto c2EKK;
       c2EKK: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2EKV; else goto c2EL2;
       c2EKV: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EL2: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDk_entry() //  [R1]
         { info_tbl: [(c2ELg,
                       label: sat_s2DDk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ELg: // global
           _s2DDk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ELh; else goto c2ELi;
       c2ELi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ELk; else goto c2ELj;
       c2ELk: // global
           HpAlloc = 16;
           goto c2ELh;
       c2ELh: // global
           R1 = _s2DDk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ELj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDk::P64;
           _s2DCR::I64 = I64[_s2DDk::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2ELq; else goto c2ELf;
       c2ELf: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2ELq; else goto c2ELx;
       c2ELq: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ELx: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDB_entry() //  [R1]
         { info_tbl: [(c2EM3,
                       label: sat_s2DDB_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EM3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EM4; else goto c2EM5;
       c2EM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EM5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DDt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDz_entry() //  [R1]
         { info_tbl: [(c2EMf,
                       label: sat_s2DDz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EMf: // global
           _s2DDz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EMg; else goto c2EMh;
       c2EMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EMj; else goto c2EMi;
       c2EMj: // global
           HpAlloc = 16;
           goto c2EMg;
       c2EMg: // global
           R1 = _s2DDz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDz::P64;
           _s2DDu::I64 = I64[_s2DDz::P64 + 16];
           if (%MO_S_Lt_W64(_s2DDu::I64, 0)) goto c2EMp; else goto c2EMe;
       c2EMe: // global
           if (%MO_S_Gt_W64(_s2DDu::I64, 65535)) goto c2EMp; else goto c2EMw;
       c2EMp: // global
           Hp = Hp - 16;
           R2 = _s2DDu::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EMw: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DDu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDF_entry() //  [R1]
         { info_tbl: [(c2EMH,
                       label: sat_s2DDF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EMH: // global
           _s2DDF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EMI; else goto c2EMJ;
       c2EMJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EML; else goto c2EMK;
       c2EML: // global
           HpAlloc = 16;
           goto c2EMI;
       c2EMI: // global
           R1 = _s2DDF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EMK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDF::P64;
           _s2DDu::I64 = I64[_s2DDF::P64 + 16];
           if (%MO_S_Lt_W64(_s2DDu::I64, 0)) goto c2EMR; else goto c2EMG;
       c2EMG: // global
           if (%MO_S_Gt_W64(_s2DDu::I64, 65535)) goto c2EMR; else goto c2EMY;
       c2EMR: // global
           Hp = Hp - 16;
           R2 = _s2DDu::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EMY: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DDu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2DDt_entry() //  [R1, R2]
         { info_tbl: [(c2EN2,
                       label: go_up_s2DDt_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EN2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EN6; else goto c2EN5;
       c2EN6: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EN5: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2EN0; else goto c2EN1;
       c2EN0: // global
           _s2DDr::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DDB_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DDr::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DDz_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EN1: // global
           I64[Hp - 80] = sat_s2DDF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EN8::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EN8::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DDG_entry() //  [R1]
         { info_tbl: [(c2EN9,
                       label: sat_s2DDG_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EN9: // global
           _s2DDG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENa; else goto c2ENb;
       c2ENb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ENd; else goto c2ENc;
       c2ENd: // global
           HpAlloc = 24;
           goto c2ENa;
       c2ENa: // global
           R1 = _s2DDG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDG::P64;
           _s2DCS::I64 = I64[_s2DDG::P64 + 24];
           _s2DDr::I64 = _s2DCS::I64 - I64[_s2DDG::P64 + 16];
           _s2DDs::I64 = I64[_s2DDG::P64 + 32] - _s2DDr::I64;
           I64[Hp - 16] = go_up_s2DDt_info;
           I64[Hp - 8] = _s2DDr::I64;
           I64[Hp] = _s2DDs::I64;
           R2 = _s2DCS::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DDt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDq_entry() //  [R1]
         { info_tbl: [(c2ENn,
                       label: sat_s2DDq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ENn: // global
           _s2DDq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENo; else goto c2ENp;
       c2ENp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ENr; else goto c2ENq;
       c2ENr: // global
           HpAlloc = 16;
           goto c2ENo;
       c2ENo: // global
           R1 = _s2DDq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDq::P64;
           _s2DCR::I64 = I64[_s2DDq::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2ENx; else goto c2ENm;
       c2ENm: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2ENx; else goto c2ENE;
       c2ENx: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ENE: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DDL_entry() //  [R1]
         { info_tbl: [(c2ENS,
                       label: sat_s2DDL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ENS: // global
           _s2DDL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENT; else goto c2ENU;
       c2ENU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ENW; else goto c2ENV;
       c2ENW: // global
           HpAlloc = 16;
           goto c2ENT;
       c2ENT: // global
           R1 = _s2DDL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDL::P64;
           _s2DCR::I64 = I64[_s2DDL::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2EO2; else goto c2ENR;
       c2ENR: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2EO2; else goto c2EO9;
       c2EO2: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EO9: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EOa,
                       label: GHC.Word.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EOa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EOe; else goto c2EOd;
       c2EOe: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EOd: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2EOo; else goto c2EOx;
       c2EOo: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2EOh; else goto c2EOm;
       c2EOh: // global
           I64[Hp - 80] = sat_s2DDf_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DCZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOm: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2EOv; else goto c2EOk;
       c2EOk: // global
           I64[Hp - 80] = sat_s2DDk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EOi::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EOi::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOx: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2EOr; else goto c2EOw;
       c2EOr: // global
           I64[Hp - 80] = sat_s2DDG_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DDq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOw: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2EOv; else goto c2EOu;
       c2EOv: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOu: // global
           I64[Hp - 80] = sat_s2DDL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EOs::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EOs::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.090925318 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2ER1,
                       label: GHC.Word.$fEnumWord16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ER1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ERa; else goto c2ERb;
       c2ERa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ERb: // global
           I64[Sp - 24] = block_c2EQY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2ERk; else goto c2EQZ;
       u2ERk: // global
           call _c2EQY(R1) args: 0, res: 0, upd: 0;
       c2EQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EQY() //  [R1]
         { info_tbl: [(c2EQY,
                       label: block_c2EQY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EQY: // global
           I64[Sp] = block_c2ER4_info;
           _s2DDQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DDQ::I64;
           if (R1 & 7 != 0) goto u2ERj; else goto c2ER5;
       u2ERj: // global
           call _c2ER4(R1) args: 0, res: 0, upd: 0;
       c2ER5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ER4() //  [R1]
         { info_tbl: [(c2ER4,
                       label: block_c2ER4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ER4: // global
           I64[Sp] = block_c2ER9_info;
           _s2DDS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DDS::I64;
           if (R1 & 7 != 0) goto u2ERl; else goto c2ERe;
       u2ERl: // global
           call _c2ER9(R1) args: 0, res: 0, upd: 0;
       c2ERe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ER9() //  [R1]
         { info_tbl: [(c2ER9,
                       label: block_c2ER9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ER9: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.100839266 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2DE8_entry() //  [R1]
         { info_tbl: [(c2ES7,
                       label: sat_s2DE8_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ES7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ES8; else goto c2ES9;
       c2ES8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ES9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DE1::I64 = I64[R1 + 32];
           if (_s2DE1::I64 == I64[R1 + 24]) goto c2ES6; else goto c2ES5;
       c2ES6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2ES5: // global
           R2 = _s2DE1::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DE0_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DE5_entry() //  [R1]
         { info_tbl: [(c2ESl,
                       label: sat_s2DE5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ESl: // global
           _s2DE5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ESm; else goto c2ESn;
       c2ESn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ESp; else goto c2ESo;
       c2ESp: // global
           HpAlloc = 16;
           goto c2ESm;
       c2ESm: // global
           R1 = _s2DE5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ESo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DE5::P64;
           _s2DE1::I64 = I64[_s2DE5::P64 + 16];
           if (%MO_S_Lt_W64(_s2DE1::I64, 0)) goto c2ESv; else goto c2ESk;
       c2ESk: // global
           if (%MO_S_Gt_W64(_s2DE1::I64, 65535)) goto c2ESv; else goto c2ESC;
       c2ESv: // global
           Hp = Hp - 16;
           R2 = _s2DE1::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ESC: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DE1::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2DE0_entry() //  [R1, R2]
         { info_tbl: [(c2ESE,
                       label: go_s2DE0_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ESE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ESI; else goto c2ESH;
       c2ESI: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ESH: // global
           _s2DDY::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DE8_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DDY::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DE5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2ESJ,
                       label: GHC.Word.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ESJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ESN; else goto c2ESM;
       c2ESN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ESM: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2ESP; else goto c2ESQ;
       c2ESP: // global
           I64[Hp - 8] = go_s2DE0_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DE0_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2ESQ: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.113148778 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2ETs,
                       label: GHC.Word.$fEnumWord16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ETs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ETw; else goto c2ETx;
       c2ETw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ETx: // global
           I64[Sp - 16] = block_c2ETp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ETF; else goto c2ETq;
       u2ETF: // global
           call _c2ETp(R1) args: 0, res: 0, upd: 0;
       c2ETq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ETp() //  [R1]
         { info_tbl: [(c2ETp,
                       label: block_c2ETp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ETp: // global
           I64[Sp] = block_c2ETv_info;
           _s2DEc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEc::I64;
           if (R1 & 7 != 0) goto u2ETE; else goto c2ETz;
       u2ETE: // global
           call _c2ETv(R1) args: 0, res: 0, upd: 0;
       c2ETz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2ETv() //  [R1]
         { info_tbl: [(c2ETv,
                       label: block_c2ETv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2ETv: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.121317258 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2DEp_entry() //  [R1]
         { info_tbl: [(c2EU7,
                       label: sat_s2DEp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EU7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EU8; else goto c2EUj;
       c2EU8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EUj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DEk::I64 = I64[R1 + 16];
           if (_s2DEk::I64 != 65535) goto c2EU5; else goto c2EU6;
       c2EU5: // global
           I64[Sp - 24] = block_c2EUd_info;
           R2 = _s2DEk::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2EU6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2EUd() //  [R1, R2]
         { info_tbl: [(c2EUd,
                       label: block_c2EUd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EUd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EUi; else goto c2EUh;
       c2EUi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2EUh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DEj_entry() //  [R1]
         { info_tbl: [(c2EUt,
                       label: sat_s2DEj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EUt: // global
           _s2DEj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EUu; else goto c2EUv;
       c2EUv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EUx; else goto c2EUw;
       c2EUx: // global
           HpAlloc = 16;
           goto c2EUu;
       c2EUu: // global
           R1 = _s2DEj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EUw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DEj::P64;
           _s2DEf::I64 = I64[_s2DEj::P64 + 16];
           if (%MO_S_Lt_W64(_s2DEf::I64, 0)) goto c2EUD; else goto c2EUs;
       c2EUs: // global
           if (%MO_S_Gt_W64(_s2DEf::I64, 65535)) goto c2EUD; else goto c2EUK;
       c2EUD: // global
           Hp = Hp - 16;
           R2 = _s2DEf::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EUK: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DEf::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo_entry() //  [R2]
         { info_tbl: [(c2EUL,
                       label: GHC.Word.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EUL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EUP; else goto c2EUO;
       c2EUP: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EUO: // global
           I64[Hp - 40] = sat_s2DEp_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DEj_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.131888564 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { info_tbl: [(c2EVo,
                       label: GHC.Word.$fEnumWord16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EVo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EVp; else goto c2EVq;
       c2EVp: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EVq: // global
           I64[Sp - 8] = block_c2EVl_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EVl() //  [R1, R2]
         { info_tbl: [(c2EVl,
                       label: block_c2EVl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EVl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EVt; else goto c2EVs;
       c2EVt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EVs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.137941445 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2EVM,
                       label: GHC.Word.$fEnumWord16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EVM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EVN; else goto c2EVO;
       c2EVN: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EVO: // global
           I64[Sp - 8] = block_c2EVJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EW0; else goto c2EVK;
       u2EW0: // global
           call _c2EVJ(R1) args: 0, res: 0, upd: 0;
       c2EVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EVJ() //  [R1]
         { info_tbl: [(c2EVJ,
                       label: block_c2EVJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EVJ: // global
           _s2DEx::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DEx::I64, 65535)) goto c2EVY; else goto c2EVZ;
       c2EVY: // global
           R2 = _s2DEx::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2EVZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.144124528 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2EWh,
                       label: GHC.Word.$fEnumWord16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EWh: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.148364881 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.150830818 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { info_tbl: [(c2EWy,
                       label: GHC.Word.$fEnumWord3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EWy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EWz; else goto c2EWA;
       c2EWz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EWA: // global
           (_c2EWt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EWt::I64 == 0) goto c2EWv; else goto c2EWu;
       c2EWv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EWu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EWt::I64;
           I64[Sp - 24] = block_c2EWw_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2EWw() //  [R1]
         { info_tbl: [(c2EWw,
                       label: block_c2EWw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EWw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.156879219 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { info_tbl: [(c2EWY,
                       label: GHC.Word.$fEnumWord4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EWY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EWZ; else goto c2EX0;
       c2EWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EX0: // global
           (_c2EWT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EWT::I64 == 0) goto c2EWV; else goto c2EWU;
       c2EWV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EWU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EWT::I64;
           I64[Sp - 24] = block_c2EWW_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c2EWW() //  [R1]
         { info_tbl: [(c2EWW,
                       label: block_c2EWW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EWW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.162999765 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { info_tbl: [(c2EXn,
                       label: GHC.Word.neWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EXn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EXr; else goto c2EXs;
       c2EXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EXs: // global
           I64[Sp - 16] = block_c2EXk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EXB; else goto c2EXl;
       u2EXB: // global
           call _c2EXk(R1) args: 0, res: 0, upd: 0;
       c2EXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EXk() //  [R1]
         { info_tbl: [(c2EXk,
                       label: block_c2EXk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EXk: // global
           I64[Sp] = block_c2EXq_info;
           _s2DEE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEE::I64;
           if (R1 & 7 != 0) goto u2EXA; else goto c2EXu;
       u2EXA: // global
           call _c2EXq(R1) args: 0, res: 0, upd: 0;
       c2EXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EXq() //  [R1]
         { info_tbl: [(c2EXq,
                       label: block_c2EXq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EXq: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.170615592 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { info_tbl: [(c2EY2,
                       label: lvl6_r2uFL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EY2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EY3; else goto c2EY4;
       c2EY3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EY4: // global
           (_c2EXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EXZ::I64 == 0) goto c2EY1; else goto c2EY0;
       c2EY1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EY0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EXZ::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.17455153 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.176671087 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { info_tbl: [(c2EYl,
                       label: GHC.Word.$fEnumWord32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EYl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EYm; else goto c2EYn;
       c2EYm: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EYn: // global
           I64[Sp - 8] = block_c2EYi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EYF; else goto c2EYj;
       u2EYF: // global
           call _c2EYi(R1) args: 0, res: 0, upd: 0;
       c2EYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EYi() //  [R1]
         { info_tbl: [(c2EYi,
                       label: block_c2EYi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EYi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EYs; else goto c2EYr;
       c2EYs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EYr: // global
           _s2DEL::I64 = I64[R1 + 7];
           if (_s2DEL::I64 != 0) goto c2EYD; else goto c2EYE;
       c2EYD: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DEL::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EYE: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.183295441 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.185022999 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.187904584 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { info_tbl: [(c2EZ4,
                       label: GHC.Word.$fEnumWord32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EZ5; else goto c2EZ6;
       c2EZ5: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EZ6: // global
           I64[Sp - 8] = block_c2EZ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EZo; else goto c2EZ2;
       u2EZo: // global
           call _c2EZ1(R1) args: 0, res: 0, upd: 0;
       c2EZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EZ1() //  [R1]
         { info_tbl: [(c2EZ1,
                       label: block_c2EZ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZ1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EZb; else goto c2EZa;
       c2EZb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EZa: // global
           _s2DER::I64 = I64[R1 + 7];
           if (_s2DER::I64 != 4294967295) goto c2EZm; else goto c2EZn;
       c2EZm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DER::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EZn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.194415568 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c2EZM,
                       label: GHC.Word.$fShowWord32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2F00; else goto c2F01;
       c2F00: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F01: // global
           I64[Sp - 24] = block_c2EZJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2F08; else goto c2EZK;
       u2F08: // global
           call _c2EZJ(R1) args: 0, res: 0, upd: 0;
       c2EZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EZJ() //  [R1]
         { info_tbl: [(c2EZJ,
                       label: block_c2EZJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZJ: // global
           I64[Sp] = block_c2EZP_info;
           _s2DEY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEY::I64;
           if (R1 & 7 != 0) goto u2F07; else goto c2EZQ;
       u2F07: // global
           call _c2EZP(R1) args: 0, res: 0, upd: 0;
       c2EZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2EZP() //  [R1]
         { info_tbl: [(c2EZP,
                       label: block_c2EZP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZP: // global
           _s2DEW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EZX_info;
           R4 = _s2DEW::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2EZX() //  [R1, R2]
         { info_tbl: [(c2EZX,
                       label: block_c2EZX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2EZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F06; else goto c2F05;
       c2F06: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F05: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.204291739 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { info_tbl: [(c2F0B,
                       label: GHC.Word.$fShowWord32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2F0K; else goto c2F0L;
       c2F0K: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F0L: // global
           I64[Sp - 8] = block_c2F0y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2F0Q; else goto c2F0z;
       u2F0Q: // global
           call _c2F0y(R1) args: 0, res: 0, upd: 0;
       c2F0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2F0y() //  [R1]
         { info_tbl: [(c2F0y,
                       label: block_c2F0y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F0y: // global
           I64[Sp] = block_c2F0H_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2F0H() //  [R1, R2]
         { info_tbl: [(c2F0H,
                       label: block_c2F0H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F0H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F0P; else goto c2F0O;
       c2F0P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F0O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.212102655 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { info_tbl: [(c2F1f,
                       label: GHC.Word.$fShowWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F1f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F1o; else goto c2F1p;
       c2F1o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F1p: // global
           I64[Sp - 16] = block_c2F1c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2F1u; else goto c2F1d;
       u2F1u: // global
           call _c2F1c(R1) args: 0, res: 0, upd: 0;
       c2F1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2F1c() //  [R1]
         { info_tbl: [(c2F1c,
                       label: block_c2F1c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F1c: // global
           _s2DFd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2F1l_info;
           R4 = _s2DFd::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2F1l() //  [R1, R2]
         { info_tbl: [(c2F1l,
                       label: block_c2F1l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F1l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F1t; else goto c2F1s;
       c2F1t: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F1s: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.220747017 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c2F1P,
                       label: GHC.Word.$fShowWord32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F1P: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.224159199 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.226141565 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { info_tbl: [(c2F21,
                       label: GHC.Word.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F21: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.230065664 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c2F2h,
                       label: GHC.Word.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F2h: // global
           _s2DFn::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2F2p; else goto c2F2g;
       c2F2g: // global
           if (%MO_S_Gt_W64(_s2DFn::I64,
                            4294967295)) goto c2F2p; else goto c2F2t;
       c2F2p: // global
           R2 = _s2DFn::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2F2t: // global
           R1 = _s2DFn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.234082878 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2F2H,
                       label: GHC.Word.$fEnumWord32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F2H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2F2P; else goto c2F2Q;
       c2F2P: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F2Q: // global
           I64[Sp - 8] = block_c2F2E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2F2V; else goto c2F2F;
       u2F2V: // global
           call _c2F2E(R1) args: 0, res: 0, upd: 0;
       c2F2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2F2E() //  [R1]
         { info_tbl: [(c2F2E,
                       label: block_c2F2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F2E: // global
           I64[Sp] = block_c2F2K_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2F2K() //  [R1]
         { info_tbl: [(c2F2K,
                       label: block_c2F2K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F2K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F2U; else goto c2F2T;
       c2F2U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2F2T: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.245321979 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2DFS_entry() //  [R1]
         { info_tbl: [(c2F3T,
                       label: sat_s2DFS_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F3T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F3U; else goto c2F3V;
       c2F3U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F3V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DFK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DFQ_entry() //  [R1]
         { info_tbl: [(c2F45,
                       label: sat_s2DFQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F45: // global
           _s2DFQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F46; else goto c2F47;
       c2F47: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F49; else goto c2F48;
       c2F49: // global
           HpAlloc = 16;
           goto c2F46;
       c2F46: // global
           R1 = _s2DFQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFQ::P64;
           _s2DFL::I64 = I64[_s2DFQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFL::I64, 0)) goto c2F4f; else goto c2F44;
       c2F44: // global
           if (%MO_S_Gt_W64(_s2DFL::I64,
                            4294967295)) goto c2F4f; else goto c2F4m;
       c2F4f: // global
           Hp = Hp - 16;
           R2 = _s2DFL::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F4m: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFL::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DFW_entry() //  [R1]
         { info_tbl: [(c2F4x,
                       label: sat_s2DFW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F4x: // global
           _s2DFW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F4y; else goto c2F4z;
       c2F4z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F4B; else goto c2F4A;
       c2F4B: // global
           HpAlloc = 16;
           goto c2F4y;
       c2F4y: // global
           R1 = _s2DFW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F4A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFW::P64;
           _s2DFL::I64 = I64[_s2DFW::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFL::I64, 0)) goto c2F4H; else goto c2F4w;
       c2F4w: // global
           if (%MO_S_Gt_W64(_s2DFL::I64,
                            4294967295)) goto c2F4H; else goto c2F4O;
       c2F4H: // global
           Hp = Hp - 16;
           R2 = _s2DFL::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F4O: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFL::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s2DFK_entry() //  [R1, R2]
         { info_tbl: [(c2F4S,
                       label: go_dn_s2DFK_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F4S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F4W; else goto c2F4V;
       c2F4W: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F4V: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2F4Q; else goto c2F4R;
       c2F4Q: // global
           _s2DFI::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DFS_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DFI::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DFQ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F4R: // global
           I64[Hp - 80] = sat_s2DFW_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F4Y::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F4Y::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DFX_entry() //  [R1]
         { info_tbl: [(c2F4Z,
                       label: sat_s2DFX_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F4Z: // global
           _s2DFX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F50; else goto c2F51;
       c2F51: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F53; else goto c2F52;
       c2F53: // global
           HpAlloc = 24;
           goto c2F50;
       c2F50: // global
           R1 = _s2DFX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F52: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFX::P64;
           _s2DFA::I64 = I64[_s2DFX::P64 + 24];
           _s2DFI::I64 = _s2DFA::I64 - I64[_s2DFX::P64 + 16];
           _s2DFJ::I64 = I64[_s2DFX::P64 + 32] - _s2DFI::I64;
           I64[Hp - 16] = go_dn_s2DFK_info;
           I64[Hp - 8] = _s2DFI::I64;
           I64[Hp] = _s2DFJ::I64;
           R2 = _s2DFA::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DFK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DFH_entry() //  [R1]
         { info_tbl: [(c2F5d,
                       label: sat_s2DFH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F5d: // global
           _s2DFH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F5e; else goto c2F5f;
       c2F5f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F5h; else goto c2F5g;
       c2F5h: // global
           HpAlloc = 16;
           goto c2F5e;
       c2F5e: // global
           R1 = _s2DFH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F5g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFH::P64;
           _s2DFz::I64 = I64[_s2DFH::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F5n; else goto c2F5c;
       c2F5c: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F5n; else goto c2F5u;
       c2F5n: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F5u: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DG2_entry() //  [R1]
         { info_tbl: [(c2F5I,
                       label: sat_s2DG2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F5I: // global
           _s2DG2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F5J; else goto c2F5K;
       c2F5K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F5M; else goto c2F5L;
       c2F5M: // global
           HpAlloc = 16;
           goto c2F5J;
       c2F5J: // global
           R1 = _s2DG2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F5L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DG2::P64;
           _s2DFz::I64 = I64[_s2DG2::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F5S; else goto c2F5H;
       c2F5H: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F5S; else goto c2F5Z;
       c2F5S: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F5Z: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DGj_entry() //  [R1]
         { info_tbl: [(c2F6v,
                       label: sat_s2DGj_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F6v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F6w; else goto c2F6x;
       c2F6w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F6x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DGb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DGh_entry() //  [R1]
         { info_tbl: [(c2F6H,
                       label: sat_s2DGh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F6H: // global
           _s2DGh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F6I; else goto c2F6J;
       c2F6J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F6L; else goto c2F6K;
       c2F6L: // global
           HpAlloc = 16;
           goto c2F6I;
       c2F6I: // global
           R1 = _s2DGh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGh::P64;
           _s2DGc::I64 = I64[_s2DGh::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGc::I64, 0)) goto c2F6R; else goto c2F6G;
       c2F6G: // global
           if (%MO_S_Gt_W64(_s2DGc::I64,
                            4294967295)) goto c2F6R; else goto c2F6Y;
       c2F6R: // global
           Hp = Hp - 16;
           R2 = _s2DGc::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F6Y: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGc::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DGn_entry() //  [R1]
         { info_tbl: [(c2F79,
                       label: sat_s2DGn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F79: // global
           _s2DGn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7a; else goto c2F7b;
       c2F7b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F7d; else goto c2F7c;
       c2F7d: // global
           HpAlloc = 16;
           goto c2F7a;
       c2F7a: // global
           R1 = _s2DGn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGn::P64;
           _s2DGc::I64 = I64[_s2DGn::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGc::I64, 0)) goto c2F7j; else goto c2F78;
       c2F78: // global
           if (%MO_S_Gt_W64(_s2DGc::I64,
                            4294967295)) goto c2F7j; else goto c2F7q;
       c2F7j: // global
           Hp = Hp - 16;
           R2 = _s2DGc::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F7q: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGc::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s2DGb_entry() //  [R1, R2]
         { info_tbl: [(c2F7u,
                       label: go_up_s2DGb_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F7u: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F7y; else goto c2F7x;
       c2F7y: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F7x: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2F7s; else goto c2F7t;
       c2F7s: // global
           _s2DG9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DGj_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DG9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DGh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F7t: // global
           I64[Hp - 80] = sat_s2DGn_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F7A::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F7A::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s2DGo_entry() //  [R1]
         { info_tbl: [(c2F7B,
                       label: sat_s2DGo_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F7B: // global
           _s2DGo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7C; else goto c2F7D;
       c2F7D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F7F; else goto c2F7E;
       c2F7F: // global
           HpAlloc = 24;
           goto c2F7C;
       c2F7C: // global
           R1 = _s2DGo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGo::P64;
           _s2DFA::I64 = I64[_s2DGo::P64 + 24];
           _s2DG9::I64 = _s2DFA::I64 - I64[_s2DGo::P64 + 16];
           _s2DGa::I64 = I64[_s2DGo::P64 + 32] - _s2DG9::I64;
           I64[Hp - 16] = go_up_s2DGb_info;
           I64[Hp - 8] = _s2DG9::I64;
           I64[Hp] = _s2DGa::I64;
           R2 = _s2DFA::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DGb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DG8_entry() //  [R1]
         { info_tbl: [(c2F7P,
                       label: sat_s2DG8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F7P: // global
           _s2DG8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7Q; else goto c2F7R;
       c2F7R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F7T; else goto c2F7S;
       c2F7T: // global
           HpAlloc = 16;
           goto c2F7Q;
       c2F7Q: // global
           R1 = _s2DG8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DG8::P64;
           _s2DFz::I64 = I64[_s2DG8::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F7Z; else goto c2F7O;
       c2F7O: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F7Z; else goto c2F86;
       c2F7Z: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F86: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DGt_entry() //  [R1]
         { info_tbl: [(c2F8k,
                       label: sat_s2DGt_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F8k: // global
           _s2DGt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F8l; else goto c2F8m;
       c2F8m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F8o; else goto c2F8n;
       c2F8o: // global
           HpAlloc = 16;
           goto c2F8l;
       c2F8l: // global
           R1 = _s2DGt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F8n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGt::P64;
           _s2DFz::I64 = I64[_s2DGt::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F8u; else goto c2F8j;
       c2F8j: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F8u; else goto c2F8B;
       c2F8u: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F8B: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2F8C,
                       label: GHC.Word.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2F8C: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F8G; else goto c2F8F;
       c2F8G: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F8F: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2F8Q; else goto c2F8Z;
       c2F8Q: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2F8J; else goto c2F8O;
       c2F8J: // global
           I64[Hp - 80] = sat_s2DFX_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DFH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8O: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2F8X; else goto c2F8M;
       c2F8M: // global
           I64[Hp - 80] = sat_s2DG2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F8K::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F8K::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8Z: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2F8T; else goto c2F8Y;
       c2F8T: // global
           I64[Hp - 80] = sat_s2DGo_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DG8_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8Y: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2F8X; else goto c2F8W;
       c2F8X: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8W: // global
           I64[Hp - 80] = sat_s2DGt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F8U::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F8U::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.286365642 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2FbB,
                       label: GHC.Word.$fEnumWord32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FbB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FbK; else goto c2FbL;
       c2FbK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FbL: // global
           I64[Sp - 24] = block_c2Fby_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2FbU; else goto c2Fbz;
       u2FbU: // global
           call _c2Fby(R1) args: 0, res: 0, upd: 0;
       c2Fbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fby() //  [R1]
         { info_tbl: [(c2Fby,
                       label: block_c2Fby_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fby: // global
           I64[Sp] = block_c2FbE_info;
           _s2DGy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DGy::I64;
           if (R1 & 7 != 0) goto u2FbT; else goto c2FbF;
       u2FbT: // global
           call _c2FbE(R1) args: 0, res: 0, upd: 0;
       c2FbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FbE() //  [R1]
         { info_tbl: [(c2FbE,
                       label: block_c2FbE_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FbE: // global
           I64[Sp] = block_c2FbJ_info;
           _s2DGA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DGA::I64;
           if (R1 & 7 != 0) goto u2FbV; else goto c2FbO;
       u2FbV: // global
           call _c2FbJ(R1) args: 0, res: 0, upd: 0;
       c2FbO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FbJ() //  [R1]
         { info_tbl: [(c2FbJ,
                       label: block_c2FbJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FbJ: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.296139171 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2DGQ_entry() //  [R1]
         { info_tbl: [(c2FcH,
                       label: sat_s2DGQ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FcH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FcI; else goto c2FcJ;
       c2FcI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FcJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DGJ::I64 = I64[R1 + 32];
           if (_s2DGJ::I64 == I64[R1 + 24]) goto c2FcG; else goto c2FcF;
       c2FcG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2FcF: // global
           R2 = _s2DGJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DGI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DGN_entry() //  [R1]
         { info_tbl: [(c2FcV,
                       label: sat_s2DGN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FcV: // global
           _s2DGN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2FcW; else goto c2FcX;
       c2FcX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FcZ; else goto c2FcY;
       c2FcZ: // global
           HpAlloc = 16;
           goto c2FcW;
       c2FcW: // global
           R1 = _s2DGN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FcY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGN::P64;
           _s2DGJ::I64 = I64[_s2DGN::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGJ::I64, 0)) goto c2Fd5; else goto c2FcU;
       c2FcU: // global
           if (%MO_S_Gt_W64(_s2DGJ::I64,
                            4294967295)) goto c2Fd5; else goto c2Fdc;
       c2Fd5: // global
           Hp = Hp - 16;
           R2 = _s2DGJ::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2Fdc: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s2DGI_entry() //  [R1, R2]
         { info_tbl: [(c2Fde,
                       label: go_s2DGI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fde: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Fdi; else goto c2Fdh;
       c2Fdi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fdh: // global
           _s2DGG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DGQ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DGG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DGN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c2Fdj,
                       label: GHC.Word.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fdj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fdn; else goto c2Fdm;
       c2Fdn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fdm: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2Fdp; else goto c2Fdq;
       c2Fdp: // global
           I64[Hp - 8] = go_s2DGI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DGI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2Fdq: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.308044805 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2Fe3,
                       label: GHC.Word.$fEnumWord32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fe3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fe7; else goto c2Fe8;
       c2Fe7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fe8: // global
           I64[Sp - 16] = block_c2Fe0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Feg; else goto c2Fe1;
       u2Feg: // global
           call _c2Fe0(R1) args: 0, res: 0, upd: 0;
       c2Fe1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fe0() //  [R1]
         { info_tbl: [(c2Fe0,
                       label: block_c2Fe0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fe0: // global
           I64[Sp] = block_c2Fe6_info;
           _s2DGU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DGU::I64;
           if (R1 & 7 != 0) goto u2Fef; else goto c2Fea;
       u2Fef: // global
           call _c2Fe6(R1) args: 0, res: 0, upd: 0;
       c2Fea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fe6() //  [R1]
         { info_tbl: [(c2Fe6,
                       label: block_c2Fe6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fe6: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.316133007 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2DH7_entry() //  [R1]
         { info_tbl: [(c2FeI,
                       label: sat_s2DH7_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FeI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FeJ; else goto c2FeU;
       c2FeJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FeU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DH2::I64 = I64[R1 + 16];
           if (_s2DH2::I64 != 4294967295) goto c2FeG; else goto c2FeH;
       c2FeG: // global
           I64[Sp - 24] = block_c2FeO_info;
           R2 = _s2DH2::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2FeH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c2FeO() //  [R1, R2]
         { info_tbl: [(c2FeO,
                       label: block_c2FeO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FeO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2FeT; else goto c2FeS;
       c2FeT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2FeS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DH1_entry() //  [R1]
         { info_tbl: [(c2Ff4,
                       label: sat_s2DH1_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ff4: // global
           _s2DH1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ff5; else goto c2Ff6;
       c2Ff6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ff8; else goto c2Ff7;
       c2Ff8: // global
           HpAlloc = 16;
           goto c2Ff5;
       c2Ff5: // global
           R1 = _s2DH1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ff7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DH1::P64;
           _s2DGX::I64 = I64[_s2DH1::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGX::I64, 0)) goto c2Ffe; else goto c2Ff3;
       c2Ff3: // global
           if (%MO_S_Gt_W64(_s2DGX::I64,
                            4294967295)) goto c2Ffe; else goto c2Ffl;
       c2Ffe: // global
           Hp = Hp - 16;
           R2 = _s2DGX::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2Ffl: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGX::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { info_tbl: [(c2Ffm,
                       label: GHC.Word.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ffm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2Ffq; else goto c2Ffp;
       c2Ffq: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ffp: // global
           I64[Hp - 40] = sat_s2DH7_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DH1_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.326544528 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { info_tbl: [(c2Fg1,
                       label: GHC.Word.$fEnumWord32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fg1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fg2; else goto c2Fg3;
       c2Fg2: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fg3: // global
           I64[Sp - 8] = block_c2FfY_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2FfY() //  [R1, R2]
         { info_tbl: [(c2FfY,
                       label: block_c2FfY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FfY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Fg6; else goto c2Fg5;
       c2Fg6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Fg5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.332010443 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2Fgp,
                       label: GHC.Word.$fEnumWord32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fgp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fgq; else goto c2Fgr;
       c2Fgq: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fgr: // global
           I64[Sp - 8] = block_c2Fgm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FgD; else goto c2Fgn;
       u2FgD: // global
           call _c2Fgm(R1) args: 0, res: 0, upd: 0;
       c2Fgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fgm() //  [R1]
         { info_tbl: [(c2Fgm,
                       label: block_c2Fgm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fgm: // global
           _s2DHf::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DHf::I64,
                            4294967295)) goto c2FgB; else goto c2FgC;
       c2FgB: // global
           R2 = _s2DHf::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2FgC: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.337856552 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2FgV,
                       label: GHC.Word.$fEnumWord32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FgV: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.341988889 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.344124903 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.346164044 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Fhc,
                       label: GHC.Word.eqWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fhc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fhg; else goto c2Fhh;
       c2Fhg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fhh: // global
           I64[Sp - 16] = block_c2Fh9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fhq; else goto c2Fha;
       u2Fhq: // global
           call _c2Fh9(R1) args: 0, res: 0, upd: 0;
       c2Fha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fh9() //  [R1]
         { info_tbl: [(c2Fh9,
                       label: block_c2Fh9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fh9: // global
           I64[Sp] = block_c2Fhf_info;
           _s2DHk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHk::I64;
           if (R1 & 7 != 0) goto u2Fhp; else goto c2Fhj;
       u2Fhp: // global
           call _c2Fhf(R1) args: 0, res: 0, upd: 0;
       c2Fhj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fhf() //  [R1]
         { info_tbl: [(c2Fhf,
                       label: block_c2Fhf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fhf: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.353769476 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { info_tbl: [(c2FhS,
                       label: GHC.Word.$fNumWord64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FhS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FhT; else goto c2FhU;
       c2FhT: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FhU: // global
           I64[Sp - 8] = block_c2FhP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fi2; else goto c2FhQ;
       u2Fi2: // global
           call _c2FhP(R1) args: 0, res: 0, upd: 0;
       c2FhQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FhP() //  [R1]
         { info_tbl: [(c2FhP,
                       label: block_c2FhP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FhP: // global
           if (I64[R1 + 7] == 0) goto c2Fi1; else goto c2Fi0;
       c2Fi1: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fi0: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.359224963 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.361288284 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2Fip_srtd" {
     u2Fip_srtd:
         const S2Ecg_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { info_tbl: [(c2Fim,
                       label: GHC.Word.$fEnumWord7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fim: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fin; else goto c2Fio;
       c2Fin: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Fio: // global
           (_c2Fij::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Fij::I64 == 0) goto c2Fil; else goto c2Fik;
       c2Fil: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Fik: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Fij::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.366059196 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2FiI_srtd" {
     u2FiI_srtd:
         const S2Ecg_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { info_tbl: [(c2FiF,
                       label: GHC.Word.$fEnumWord9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FiF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FiG; else goto c2FiH;
       c2FiG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FiH: // global
           (_c2FiC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2FiC::I64 == 0) goto c2FiE; else goto c2FiD;
       c2FiE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2FiD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2FiC::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.371267552 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { info_tbl: [(c2FiZ,
                       label: GHC.Word.neWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FiZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fj3; else goto c2Fj4;
       c2Fj3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fj4: // global
           I64[Sp - 16] = block_c2FiW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fjd; else goto c2FiX;
       u2Fjd: // global
           call _c2FiW(R1) args: 0, res: 0, upd: 0;
       c2FiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FiW() //  [R1]
         { info_tbl: [(c2FiW,
                       label: block_c2FiW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FiW: // global
           I64[Sp] = block_c2Fj2_info;
           _s2DHv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHv::I64;
           if (R1 & 7 != 0) goto u2Fjc; else goto c2Fj6;
       u2Fjc: // global
           call _c2Fj2(R1) args: 0, res: 0, upd: 0;
       c2Fj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fj2() //  [R1]
         { info_tbl: [(c2Fj2,
                       label: block_c2Fj2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fj2: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.379924019 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2DHJ_entry() //  [R1]
         { info_tbl: [(c2FjU,
                       label: sat_s2DHJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FjU: // global
           _s2DHJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2FjX; else goto c2FjY;
       c2FjY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fk0; else goto c2FjZ;
       c2Fk0: // global
           HpAlloc = 16;
           goto c2FjX;
       c2FjX: // global
           R1 = _s2DHJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DHJ::P64;
           _s2DHI::I64 = I64[_s2DHJ::P64 + 16] % I64[_s2DHJ::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DHI::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DHH_entry() //  [R1]
         { info_tbl: [(c2Fk7,
                       label: sat_s2DHH_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fk7: // global
           _s2DHH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fka; else goto c2Fkb;
       c2Fkb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fkd; else goto c2Fkc;
       c2Fkd: // global
           HpAlloc = 16;
           goto c2Fka;
       c2Fka: // global
           R1 = _s2DHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Fkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DHH::P64;
           _s2DHG::I64 = I64[_s2DHH::P64 + 16] / I64[_s2DHH::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DHG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2Fke,
                       label: GHC.Word.$fIntegralWord64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fkf; else goto c2Fkg;
       c2Fkf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fkg: // global
           I64[Sp - 16] = block_c2FjC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fkq; else goto c2FjD;
       u2Fkq: // global
           call _c2FjC(R1) args: 0, res: 0, upd: 0;
       c2FjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FjC() //  [R1]
         { info_tbl: [(c2FjC,
                       label: block_c2FjC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FjC: // global
           I64[Sp] = block_c2FjH_info;
           _s2DHC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHC::I64;
           if (R1 & 7 != 0) goto u2Fkp; else goto c2FjI;
       u2Fkp: // global
           call _c2FjH(R1) args: 0, res: 0, upd: 0;
       c2FjI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FjH() //  [R1]
         { info_tbl: [(c2FjH,
                       label: block_c2FjH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FjH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Fkk; else goto c2Fkj;
       c2Fkk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fkj: // global
           _s2DHF::I64 = I64[R1 + 7];
           if (_s2DHF::I64 != 0) goto c2Fkn; else goto c2Fko;
       c2Fkn: // global
           I64[Hp - 80] = sat_s2DHJ_info;
           _s2DHC::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DHC::I64;
           I64[Hp - 56] = _s2DHF::I64;
           I64[Hp - 48] = sat_s2DHH_info;
           I64[Hp - 32] = _s2DHC::I64;
           I64[Hp - 24] = _s2DHF::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fko: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.392737884 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2Fl7,
                       label: GHC.Word.$fIntegralWord64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fl7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Flb; else goto c2Flc;
       c2Flb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Flc: // global
           I64[Sp - 16] = block_c2Fl4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Flu; else goto c2Fl5;
       u2Flu: // global
           call _c2Fl4(R1) args: 0, res: 0, upd: 0;
       c2Fl5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fl4() //  [R1]
         { info_tbl: [(c2Fl4,
                       label: block_c2Fl4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fl4: // global
           I64[Sp] = block_c2Fla_info;
           _s2DHN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHN::I64;
           if (R1 & 7 != 0) goto u2Flt; else goto c2Fle;
       u2Flt: // global
           call _c2Fla(R1) args: 0, res: 0, upd: 0;
       c2Fle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fla() //  [R1]
         { info_tbl: [(c2Fla,
                       label: block_c2Fla_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fla: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2Flk; else goto c2Flj;
       c2Flk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Flj: // global
           _s2DHQ::I64 = I64[R1 + 7];
           if (_s2DHQ::I64 != 0) goto c2Flr; else goto c2Fls;
       c2Flr: // global
           (_s2DHS::I64, _s2DHT::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DHQ::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2DHT::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2DHS::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fls: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.401329784 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c2FlX,
                       label: GHC.Word.$fIntegralWord64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FlX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fm1; else goto c2Fm2;
       c2Fm1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fm2: // global
           I64[Sp - 16] = block_c2FlU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fml; else goto c2FlV;
       u2Fml: // global
           call _c2FlU(R1) args: 0, res: 0, upd: 0;
       c2FlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FlU() //  [R1]
         { info_tbl: [(c2FlU,
                       label: block_c2FlU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FlU: // global
           I64[Sp] = block_c2Fm0_info;
           _s2DHZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHZ::I64;
           if (R1 & 7 != 0) goto u2Fmk; else goto c2Fm4;
       u2Fmk: // global
           call _c2Fm0(R1) args: 0, res: 0, upd: 0;
       c2Fm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fm0() //  [R1]
         { info_tbl: [(c2Fm0,
                       label: block_c2Fm0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fm0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fma; else goto c2Fm9;
       c2Fma: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fm9: // global
           _s2DI2::I64 = I64[R1 + 7];
           if (_s2DI2::I64 != 0) goto c2Fmi; else goto c2Fmj;
       c2Fmi: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DI2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fmj: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.40981752 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c2FmL,
                       label: GHC.Word.$fIntegralWord64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FmL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FmP; else goto c2FmQ;
       c2FmP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FmQ: // global
           I64[Sp - 16] = block_c2FmI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fn9; else goto c2FmJ;
       u2Fn9: // global
           call _c2FmI(R1) args: 0, res: 0, upd: 0;
       c2FmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FmI() //  [R1]
         { info_tbl: [(c2FmI,
                       label: block_c2FmI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FmI: // global
           I64[Sp] = block_c2FmO_info;
           _s2DI7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DI7::I64;
           if (R1 & 7 != 0) goto u2Fn8; else goto c2FmS;
       u2Fn8: // global
           call _c2FmO(R1) args: 0, res: 0, upd: 0;
       c2FmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FmO() //  [R1]
         { info_tbl: [(c2FmO,
                       label: block_c2FmO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FmO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FmY; else goto c2FmX;
       c2FmY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FmX: // global
           _s2DIa::I64 = I64[R1 + 7];
           if (_s2DIa::I64 != 0) goto c2Fn6; else goto c2Fn7;
       c2Fn6: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DIa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fn7: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.419908544 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.422277835 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { info_tbl: [(c2FnA,
                       label: GHC.Word.$fEnumWord64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FnA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FnB; else goto c2FnC;
       c2FnB: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FnC: // global
           I64[Sp - 8] = block_c2Fnx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FnR; else goto c2Fny;
       u2FnR: // global
           call _c2Fnx(R1) args: 0, res: 0, upd: 0;
       c2Fny: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fnx() //  [R1]
         { info_tbl: [(c2Fnx,
                       label: block_c2Fnx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fnx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FnH; else goto c2FnG;
       c2FnH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FnG: // global
           _s2DIf::I64 = I64[R1 + 7];
           if (_s2DIf::I64 != 0) goto c2FnP; else goto c2FnQ;
       c2FnP: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIf::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FnQ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.428137964 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.430191878 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.432382836 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { info_tbl: [(c2Fof,
                       label: GHC.Word.$fEnumWord64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fof: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fog; else goto c2Foh;
       c2Fog: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Foh: // global
           I64[Sp - 8] = block_c2Foc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fow; else goto c2Fod;
       u2Fow: // global
           call _c2Foc(R1) args: 0, res: 0, upd: 0;
       c2Fod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Foc() //  [R1]
         { info_tbl: [(c2Foc,
                       label: block_c2Foc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Foc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fom; else goto c2Fol;
       c2Fom: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fol: // global
           _s2DIk::I64 = I64[R1 + 7];
           if (_s2DIk::I64 != 18446744073709551615) goto c2Fou; else goto c2Fov;
       c2Fou: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIk::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fov: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.438600755 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2FoS_srtd" {
     u2FoS_srtd:
         const S2Ecg_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { info_tbl: [(c2FoP,
                       label: GHC.Word.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FoP: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.443009428 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { info_tbl: [(c2Fp5,
                       label: GHC.Word.$fEnumWord6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fp5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fp6; else goto c2Fp7;
       c2Fp6: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fp7: // global
           I64[Sp - 8] = block_c2Fp2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fpb; else goto c2Fp3;
       u2Fpb: // global
           call _c2Fp2(R1) args: 0, res: 0, upd: 0;
       c2Fp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fp2() //  [R1]
         { info_tbl: [(c2Fp2,
                       label: block_c2Fp2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fp2: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.44881935 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c2Fpt,
                       label: GHC.Word.$fEnumWord64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fpt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fpu; else goto c2Fpv;
       c2Fpu: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fpv: // global
           I64[Sp - 8] = block_c2Fpq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FpM; else goto c2Fpr;
       u2FpM: // global
           call _c2Fpq(R1) args: 0, res: 0, upd: 0;
       c2Fpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fpq() //  [R1]
         { info_tbl: [(c2Fpq,
                       label: block_c2Fpq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fpq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FpA; else goto c2Fpz;
       c2FpA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fpz: // global
           _s2DIs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DIs::I64, 0)) goto c2FpE; else goto c2FpL;
       c2FpE: // global
           Hp = Hp - 16;
           R2 = _s2DIs::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2FpL: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.455754931 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Fq6,
                       label: GHC.Word.gtWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fq6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fqa; else goto c2Fqb;
       c2Fqa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fqb: // global
           I64[Sp - 16] = block_c2Fq3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fqk; else goto c2Fq4;
       u2Fqk: // global
           call _c2Fq3(R1) args: 0, res: 0, upd: 0;
       c2Fq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fq3() //  [R1]
         { info_tbl: [(c2Fq3,
                       label: block_c2Fq3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fq3: // global
           I64[Sp] = block_c2Fq9_info;
           _s2DIy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIy::I64;
           if (R1 & 7 != 0) goto u2Fqj; else goto c2Fqd;
       u2Fqj: // global
           call _c2Fq9(R1) args: 0, res: 0, upd: 0;
       c2Fqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fq9() //  [R1]
         { info_tbl: [(c2Fq9,
                       label: block_c2Fq9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fq9: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.463347694 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { info_tbl: [(c2FqM,
                       label: GHC.Word.geWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FqM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FqQ; else goto c2FqR;
       c2FqQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FqR: // global
           I64[Sp - 16] = block_c2FqJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fr0; else goto c2FqK;
       u2Fr0: // global
           call _c2FqJ(R1) args: 0, res: 0, upd: 0;
       c2FqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FqJ() //  [R1]
         { info_tbl: [(c2FqJ,
                       label: block_c2FqJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FqJ: // global
           I64[Sp] = block_c2FqP_info;
           _s2DIF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIF::I64;
           if (R1 & 7 != 0) goto u2FqZ; else goto c2FqT;
       u2FqZ: // global
           call _c2FqP(R1) args: 0, res: 0, upd: 0;
       c2FqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FqP() //  [R1]
         { info_tbl: [(c2FqP,
                       label: block_c2FqP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FqP: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.471070994 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Frs,
                       label: GHC.Word.ltWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Frs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Frw; else goto c2Frx;
       c2Frw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Frx: // global
           I64[Sp - 16] = block_c2Frp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FrG; else goto c2Frq;
       u2FrG: // global
           call _c2Frp(R1) args: 0, res: 0, upd: 0;
       c2Frq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Frp() //  [R1]
         { info_tbl: [(c2Frp,
                       label: block_c2Frp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Frp: // global
           I64[Sp] = block_c2Frv_info;
           _s2DIM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIM::I64;
           if (R1 & 7 != 0) goto u2FrF; else goto c2Frz;
       u2FrF: // global
           call _c2Frv(R1) args: 0, res: 0, upd: 0;
       c2Frz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Frv() //  [R1]
         { info_tbl: [(c2Frv,
                       label: block_c2Frv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Frv: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.478413829 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { info_tbl: [(c2Fs8,
                       label: GHC.Word.leWord64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fs8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fsc; else goto c2Fsd;
       c2Fsc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fsd: // global
           I64[Sp - 16] = block_c2Fs5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fsm; else goto c2Fs6;
       u2Fsm: // global
           call _c2Fs5(R1) args: 0, res: 0, upd: 0;
       c2Fs6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fs5() //  [R1]
         { info_tbl: [(c2Fs5,
                       label: block_c2Fs5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fs5: // global
           I64[Sp] = block_c2Fsb_info;
           _s2DIT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIT::I64;
           if (R1 & 7 != 0) goto u2Fsl; else goto c2Fsf;
       u2Fsl: // global
           call _c2Fsb(R1) args: 0, res: 0, upd: 0;
       c2Fsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fsb() //  [R1]
         { info_tbl: [(c2Fsb,
                       label: block_c2Fsb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fsb: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.485923444 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2FsO,
                       label: GHC.Word.$fOrdWord64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FsO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FsS; else goto c2FsT;
       c2FsS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FsT: // global
           I64[Sp - 16] = block_c2FsL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ft6; else goto c2FsM;
       u2Ft6: // global
           call _c2FsL(R1) args: 0, res: 0, upd: 0;
       c2FsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FsL() //  [R1]
         { info_tbl: [(c2FsL,
                       label: block_c2FsL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FsL: // global
           I64[Sp - 8] = block_c2FsR_info;
           _s2DIZ::P64 = R1;
           _s2DJ0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DJ0::I64;
           P64[Sp + 8] = _s2DIZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ft5; else goto c2FsV;
       u2Ft5: // global
           call _c2FsR(R1) args: 0, res: 0, upd: 0;
       c2FsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FsR() //  [R1]
         { info_tbl: [(c2FsR,
                       label: block_c2FsR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FsR: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Ft3; else goto c2Ft4;
       c2Ft3: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Ft4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.494318008 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2Fty,
                       label: GHC.Word.$fOrdWord64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fty: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FtC; else goto c2FtD;
       c2FtC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FtD: // global
           I64[Sp - 16] = block_c2Ftv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FtQ; else goto c2Ftw;
       u2FtQ: // global
           call _c2Ftv(R1) args: 0, res: 0, upd: 0;
       c2Ftw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ftv() //  [R1]
         { info_tbl: [(c2Ftv,
                       label: block_c2Ftv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ftv: // global
           I64[Sp - 8] = block_c2FtB_info;
           _s2DJ6::P64 = R1;
           _s2DJ7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DJ7::I64;
           P64[Sp + 8] = _s2DJ6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FtP; else goto c2FtF;
       u2FtP: // global
           call _c2FtB(R1) args: 0, res: 0, upd: 0;
       c2FtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FtB() //  [R1]
         { info_tbl: [(c2FtB,
                       label: block_c2FtB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FtB: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2FtN; else goto c2FtO;
       c2FtN: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2FtO: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.501748519 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2Fui,
                       label: GHC.Word.$fOrdWord64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fum; else goto c2Fun;
       c2Fum: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fun: // global
           I64[Sp - 16] = block_c2Fuf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FuG; else goto c2Fug;
       u2FuG: // global
           call _c2Fuf(R1) args: 0, res: 0, upd: 0;
       c2Fug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fuf() //  [R1]
         { info_tbl: [(c2Fuf,
                       label: block_c2Fuf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fuf: // global
           I64[Sp] = block_c2Ful_info;
           _s2DJe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJe::I64;
           if (R1 & 7 != 0) goto u2FuF; else goto c2Fup;
       u2FuF: // global
           call _c2Ful(R1) args: 0, res: 0, upd: 0;
       c2Fup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ful() //  [R1]
         { info_tbl: [(c2Ful,
                       label: block_c2Ful_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ful: // global
           _s2DJe::I64 = I64[Sp + 8];
           _s2DJg::I64 = I64[R1 + 7];
           if (_s2DJe::I64 == _s2DJg::I64) goto c2FuE; else goto c2FuD;
       c2FuE: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FuD: // global
           if (_s2DJe::I64 > _s2DJg::I64) goto c2FuA; else goto c2FuB;
       c2FuA: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FuB: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.509602161 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.511446885 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.513713008 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c2Fvb,
                       label: GHC.Word.$fEnumWord64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fvb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fvc; else goto c2Fvd;
       c2Fvc: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fvd: // global
           I64[Sp - 8] = block_c2Fv8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fvu; else goto c2Fv9;
       u2Fvu: // global
           call _c2Fv8(R1) args: 0, res: 0, upd: 0;
       c2Fv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fv8() //  [R1]
         { info_tbl: [(c2Fv8,
                       label: block_c2Fv8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fv8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fvi; else goto c2Fvh;
       c2Fvi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fvh: // global
           _s2DJl::I64 = I64[R1 + 7];
           if (_s2DJl::I64 > 9223372036854775807) goto c2Fvm; else goto c2Fvt;
       c2Fvm: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2Fvt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DJl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.519957247 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c2FvM,
                       label: GHC.Word.$fEnumWord64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FvM: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c2FvT,
                       label: GHC.Word.$fEnumWord64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FvT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c2Fw0,
                       label: GHC.Word.$fEnumWord64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fw0: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c2Fw7,
                       label: GHC.Word.$fEnumWord64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fw7: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.532773884 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2Fwy,
                       label: GHC.Word.$fNumWord8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fwy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FwF; else goto c2FwG;
       c2FwF: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FwG: // global
           I64[Sp - 8] = block_c2Fww_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fww() //  [R1]
         { info_tbl: [(c2Fww,
                       label: block_c2Fww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fww: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FwJ; else goto c2FwI;
       c2FwJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FwI: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.538853086 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { info_tbl: [(c2Fx1,
                       label: GHC.Word.$fNumWord8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fx1: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.542834679 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { info_tbl: [(c2Fxh,
                       label: GHC.Word.$fNumWord8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fxh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fxx; else goto c2Fxy;
       c2Fxx: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fxy: // global
           I64[Sp - 8] = block_c2Fxe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FxC; else goto c2Fxf;
       u2FxC: // global
           call _c2Fxe(R1) args: 0, res: 0, upd: 0;
       c2Fxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fxe() //  [R1]
         { info_tbl: [(c2Fxe,
                       label: block_c2Fxe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fxe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FxB; else goto c2FxA;
       c2FxB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FxA: // global
           _s2DJy::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.548950586 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2FxX,
                       label: GHC.Word.$fNumWord8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fyc; else goto c2Fyd;
       c2Fyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fyd: // global
           I64[Sp - 16] = block_c2FxU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fyj; else goto c2FxV;
       u2Fyj: // global
           call _c2FxU(R1) args: 0, res: 0, upd: 0;
       c2FxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FxU() //  [R1]
         { info_tbl: [(c2FxU,
                       label: block_c2FxU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FxU: // global
           I64[Sp] = block_c2Fy0_info;
           _s2DJC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJC::I64;
           if (R1 & 7 != 0) goto u2Fyi; else goto c2Fy1;
       u2Fyi: // global
           call _c2Fy0(R1) args: 0, res: 0, upd: 0;
       c2Fy1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fy0() //  [R1]
         { info_tbl: [(c2Fy0,
                       label: block_c2Fy0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fy0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fyh; else goto c2Fyg;
       c2Fyh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fyg: // global
           _s2DJG::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.556930688 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2FyL,
                       label: GHC.Word.$fNumWord8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FyL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fz0; else goto c2Fz1;
       c2Fz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fz1: // global
           I64[Sp - 16] = block_c2FyI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fz7; else goto c2FyJ;
       u2Fz7: // global
           call _c2FyI(R1) args: 0, res: 0, upd: 0;
       c2FyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FyI() //  [R1]
         { info_tbl: [(c2FyI,
                       label: block_c2FyI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FyI: // global
           I64[Sp] = block_c2FyO_info;
           _s2DJK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJK::I64;
           if (R1 & 7 != 0) goto u2Fz6; else goto c2FyP;
       u2Fz6: // global
           call _c2FyO(R1) args: 0, res: 0, upd: 0;
       c2FyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FyO() //  [R1]
         { info_tbl: [(c2FyO,
                       label: block_c2FyO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FyO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fz5; else goto c2Fz4;
       c2Fz5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fz4: // global
           _s2DJO::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.566128851 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2Fzz,
                       label: GHC.Word.$fNumWord8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fzz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FzO; else goto c2FzP;
       c2FzO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FzP: // global
           I64[Sp - 16] = block_c2Fzw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FzV; else goto c2Fzx;
       u2FzV: // global
           call _c2Fzw(R1) args: 0, res: 0, upd: 0;
       c2Fzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Fzw() //  [R1]
         { info_tbl: [(c2Fzw,
                       label: block_c2Fzw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Fzw: // global
           I64[Sp] = block_c2FzC_info;
           _s2DJS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJS::I64;
           if (R1 & 7 != 0) goto u2FzU; else goto c2FzD;
       u2FzU: // global
           call _c2FzC(R1) args: 0, res: 0, upd: 0;
       c2FzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FzC() //  [R1]
         { info_tbl: [(c2FzC,
                       label: block_c2FzC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FzC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FzT; else goto c2FzS;
       c2FzT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FzS: // global
           _s2DJW::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.573877798 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { info_tbl: [(c2FAn,
                       label: GHC.Word.$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FAn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FAo; else goto c2FAp;
       c2FAo: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FAp: // global
           I64[Sp - 8] = block_c2FAk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FAu; else goto c2FAl;
       u2FAu: // global
           call _c2FAk(R1) args: 0, res: 0, upd: 0;
       c2FAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FAk() //  [R1]
         { info_tbl: [(c2FAk,
                       label: block_c2FAk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FAk: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.579415062 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2FAM,
                       label: GHC.Word.$fBitsWord8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FAM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FAX; else goto c2FAY;
       c2FAX: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FAY: // global
           I64[Sp - 8] = block_c2FAJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FB2; else goto c2FAK;
       u2FB2: // global
           call _c2FAJ(R1) args: 0, res: 0, upd: 0;
       c2FAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FAJ() //  [R1]
         { info_tbl: [(c2FAJ,
                       label: block_c2FAJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FB1; else goto c2FB0;
       c2FB1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FB0: // global
           (_c2FAP::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FAP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.585690261 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2FBm,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FBm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FBy; else goto c2FBz;
       c2FBy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FBz: // global
           I64[Sp - 16] = block_c2FBj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FBF; else goto c2FBk;
       u2FBF: // global
           call _c2FBj(R1) args: 0, res: 0, upd: 0;
       c2FBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FBj() //  [R1]
         { info_tbl: [(c2FBj,
                       label: block_c2FBj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FBj: // global
           I64[Sp] = block_c2FBp_info;
           _s2DK9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DK9::I64;
           if (R1 & 7 != 0) goto u2FBE; else goto c2FBq;
       u2FBE: // global
           call _c2FBp(R1) args: 0, res: 0, upd: 0;
       c2FBq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FBp() //  [R1]
         { info_tbl: [(c2FBp,
                       label: block_c2FBp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FBp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FBD; else goto c2FBC;
       c2FBD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FBC: // global
           _s2DKc::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.593885494 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2FC5,
                       label: GHC.Word.$fBitsWord8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FC5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FC9; else goto c2FCa;
       c2FC9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FCa: // global
           I64[Sp - 16] = block_c2FC2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FCu; else goto c2FC3;
       u2FCu: // global
           call _c2FC2(R1) args: 0, res: 0, upd: 0;
       c2FC3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FC2() //  [R1]
         { info_tbl: [(c2FC2,
                       label: block_c2FC2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FC2: // global
           I64[Sp] = block_c2FC8_info;
           _s2DKg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKg::I64;
           if (R1 & 7 != 0) goto u2FCt; else goto c2FCc;
       u2FCt: // global
           call _c2FC8(R1) args: 0, res: 0, upd: 0;
       c2FCc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FC8() //  [R1]
         { info_tbl: [(c2FC8,
                       label: block_c2FC8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FC8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FCi; else goto c2FCh;
       c2FCi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FCh: // global
           _s2DKi::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKi::I64, 64)) goto c2FCr; else goto c2FCs;
       c2FCr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DKi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FCs: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.602620692 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2FCV,
                       label: GHC.Word.$fBitsWord8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FCV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FDa; else goto c2FDb;
       c2FDa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FDb: // global
           I64[Sp - 16] = block_c2FCS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FDh; else goto c2FCT;
       u2FDh: // global
           call _c2FCS(R1) args: 0, res: 0, upd: 0;
       c2FCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FCS() //  [R1]
         { info_tbl: [(c2FCS,
                       label: block_c2FCS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FCS: // global
           I64[Sp] = block_c2FCY_info;
           _s2DKo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKo::I64;
           if (R1 & 7 != 0) goto u2FDg; else goto c2FCZ;
       u2FDg: // global
           call _c2FCY(R1) args: 0, res: 0, upd: 0;
       c2FCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FCY() //  [R1]
         { info_tbl: [(c2FCY,
                       label: block_c2FCY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FCY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FDf; else goto c2FDe;
       c2FDf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FDe: // global
           _s2DKs::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.610819146 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2FDI,
                       label: GHC.Word.$fBitsWord8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FDM; else goto c2FDN;
       c2FDM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FDN: // global
           I64[Sp - 16] = block_c2FDF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FEa; else goto c2FDG;
       u2FEa: // global
           call _c2FDF(R1) args: 0, res: 0, upd: 0;
       c2FDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FDF() //  [R1]
         { info_tbl: [(c2FDF,
                       label: block_c2FDF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FDF: // global
           I64[Sp] = block_c2FDL_info;
           _s2DKw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKw::I64;
           if (R1 & 7 != 0) goto u2FE9; else goto c2FDP;
       u2FE9: // global
           call _c2FDL(R1) args: 0, res: 0, upd: 0;
       c2FDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FDL() //  [R1]
         { info_tbl: [(c2FDL,
                       label: block_c2FDL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FDL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FDV; else goto c2FDU;
       c2FDV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FDU: // global
           _s2DKy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKy::I64, 64)) goto c2FE7; else goto c2FE8;
       c2FE7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2DKy::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FE8: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.619253642 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { info_tbl: [(c2FEA,
                       label: GHC.Word.$fBitsWord8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FEA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.623391409 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2FEQ,
                       label: GHC.Word.$fBitsWord8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FEQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FEU; else goto c2FEV;
       c2FEU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FEV: // global
           I64[Sp - 16] = block_c2FEN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FFI; else goto c2FEO;
       u2FFI: // global
           call _c2FEN(R1) args: 0, res: 0, upd: 0;
       c2FEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FEN() //  [R1]
         { info_tbl: [(c2FEN,
                       label: block_c2FEN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FEN: // global
           I64[Sp - 8] = block_c2FET_info;
           _s2DKF::P64 = R1;
           _s2DKG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DKG::I64;
           P64[Sp + 8] = _s2DKF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FFH; else goto c2FEX;
       u2FFH: // global
           call _c2FET(R1) args: 0, res: 0, upd: 0;
       c2FEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FET() //  [R1]
         { info_tbl: [(c2FET,
                       label: block_c2FET_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FET: // global
           _s2DKL::I64 = I64[R1 + 7] & 7;
           if (_s2DKL::I64 != 0) goto u2FFF; else goto c2FFB;
       u2FFF: // global
           I64[Sp + 16] = _s2DKL::I64;
           Sp = Sp + 8;
           call _c2FFc() args: 0, res: 0, upd: 0;
       c2FFB: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FFc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FFc: // global
           Hp = Hp + 16;
           _s2DKL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2FFy; else goto c2FFx;
       c2FFy: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2FFb_info;
           R1 = _s2DKL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FFx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2DKG::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2DKG::I64 << _s2DKL::I64) | (_s2DKG::I64 >> 8 - _s2DKL::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FFb() //  [R1]
         { info_tbl: [(c2FFb,
                       label: block_c2FFb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FFb: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2FFc() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.634826134 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2FGo,
                       label: GHC.Word.$fBitsWord8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FGo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FGs; else goto c2FGt;
       c2FGs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FGt: // global
           I64[Sp - 16] = block_c2FGl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FHa; else goto c2FGm;
       u2FHa: // global
           call _c2FGl(R1) args: 0, res: 0, upd: 0;
       c2FGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FGl() //  [R1]
         { info_tbl: [(c2FGl,
                       label: block_c2FGl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FGl: // global
           I64[Sp] = block_c2FGr_info;
           _s2DKU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKU::I64;
           if (R1 & 7 != 0) goto u2FH9; else goto c2FGv;
       u2FH9: // global
           call _c2FGr(R1) args: 0, res: 0, upd: 0;
       c2FGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FGr() //  [R1]
         { info_tbl: [(c2FGr,
                       label: block_c2FGr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FGB; else goto c2FGA;
       c2FGB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FGA: // global
           _s2DKU::I64 = I64[Sp + 8];
           _s2DKW::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKW::I64, 0)) goto c2FGT; else goto c2FH8;
       c2FGT: // global
           _s2DKY::I64 = -_s2DKW::I64;
           if (%MO_S_Ge_W64(_s2DKY::I64, 64)) goto c2FH7; else goto c2FGQ;
       c2FGQ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKU::I64 >> _s2DKY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FH8: // global
           if (%MO_S_Ge_W64(_s2DKW::I64, 64)) goto c2FH7; else goto c2FH6;
       c2FH7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FH6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DKU::I64 << _s2DKW::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.645087171 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2FHG,
                       label: GHC.Word.$fBitsWord8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FHS; else goto c2FHT;
       c2FHS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FHT: // global
           I64[Sp - 16] = block_c2FHD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FHZ; else goto c2FHE;
       u2FHZ: // global
           call _c2FHD(R1) args: 0, res: 0, upd: 0;
       c2FHE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FHD() //  [R1]
         { info_tbl: [(c2FHD,
                       label: block_c2FHD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FHD: // global
           I64[Sp] = block_c2FHJ_info;
           _s2DL7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DL7::I64;
           if (R1 & 7 != 0) goto u2FHY; else goto c2FHK;
       u2FHY: // global
           call _c2FHJ(R1) args: 0, res: 0, upd: 0;
       c2FHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FHJ() //  [R1]
         { info_tbl: [(c2FHJ,
                       label: block_c2FHJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FHJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FHX; else goto c2FHW;
       c2FHX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FHW: // global
           _s2DLa::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.653175448 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2FIq,
                       label: GHC.Word.$fBitsWord8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FIC; else goto c2FID;
       c2FIC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FID: // global
           I64[Sp - 16] = block_c2FIn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FIJ; else goto c2FIo;
       u2FIJ: // global
           call _c2FIn(R1) args: 0, res: 0, upd: 0;
       c2FIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FIn() //  [R1]
         { info_tbl: [(c2FIn,
                       label: block_c2FIn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FIn: // global
           I64[Sp] = block_c2FIt_info;
           _s2DLe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLe::I64;
           if (R1 & 7 != 0) goto u2FII; else goto c2FIu;
       u2FII: // global
           call _c2FIt(R1) args: 0, res: 0, upd: 0;
       c2FIu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FIt() //  [R1]
         { info_tbl: [(c2FIt,
                       label: block_c2FIt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FIt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FIH; else goto c2FIG;
       c2FIH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FIG: // global
           _s2DLh::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.661217285 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2FJa,
                       label: GHC.Word.$fBitsWord8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FJm; else goto c2FJn;
       c2FJm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FJn: // global
           I64[Sp - 16] = block_c2FJ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FJt; else goto c2FJ8;
       u2FJt: // global
           call _c2FJ7(R1) args: 0, res: 0, upd: 0;
       c2FJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FJ7() //  [R1]
         { info_tbl: [(c2FJ7,
                       label: block_c2FJ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FJ7: // global
           I64[Sp] = block_c2FJd_info;
           _s2DLl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLl::I64;
           if (R1 & 7 != 0) goto u2FJs; else goto c2FJe;
       u2FJs: // global
           call _c2FJd(R1) args: 0, res: 0, upd: 0;
       c2FJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FJd() //  [R1]
         { info_tbl: [(c2FJd,
                       label: block_c2FJd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FJd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FJr; else goto c2FJq;
       c2FJr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FJq: // global
           _s2DLo::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.668953217 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2FJU,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FJU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FK5; else goto c2FK6;
       c2FK5: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FK6: // global
           I64[Sp - 8] = block_c2FJR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FKa; else goto c2FJS;
       u2FKa: // global
           call _c2FJR(R1) args: 0, res: 0, upd: 0;
       c2FJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FJR() //  [R1]
         { info_tbl: [(c2FJR,
                       label: block_c2FJR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FJR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FK9; else goto c2FK8;
       c2FK9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FK8: // global
           (_c2FJX::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FJX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.675230057 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2FKw,
                       label: GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FKw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FKH; else goto c2FKI;
       c2FKH: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FKI: // global
           I64[Sp - 8] = block_c2FKt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FKM; else goto c2FKu;
       u2FKM: // global
           call _c2FKt(R1) args: 0, res: 0, upd: 0;
       c2FKu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FKt() //  [R1]
         { info_tbl: [(c2FKt,
                       label: block_c2FKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FKt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FKL; else goto c2FKK;
       c2FKL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FKK: // global
           (_c2FKz::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FKz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.680662104 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.683075647 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2FL6,
                       label: GHC.Word.$fBitsWord8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FL6: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.686694573 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2FLk,
                       label: GHC.Word.$fNumWord16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FLk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FLr; else goto c2FLs;
       c2FLr: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FLs: // global
           I64[Sp - 8] = block_c2FLi_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2FLi() //  [R1]
         { info_tbl: [(c2FLi,
                       label: block_c2FLi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FLi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FLv; else goto c2FLu;
       c2FLv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FLu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.692150295 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { info_tbl: [(c2FLN,
                       label: GHC.Word.$fNumWord16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FLN: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.695665723 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { info_tbl: [(c2FM3,
                       label: GHC.Word.$fNumWord16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FM3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FMj; else goto c2FMk;
       c2FMj: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FMk: // global
           I64[Sp - 8] = block_c2FM0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FMo; else goto c2FM1;
       u2FMo: // global
           call _c2FM0(R1) args: 0, res: 0, upd: 0;
       c2FM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FM0() //  [R1]
         { info_tbl: [(c2FM0,
                       label: block_c2FM0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FM0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FMn; else goto c2FMm;
       c2FMn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FMm: // global
           _s2DLK::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DLK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.701880741 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2FMJ,
                       label: GHC.Word.$fNumWord16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FMY; else goto c2FMZ;
       c2FMY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FMZ: // global
           I64[Sp - 16] = block_c2FMG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FN5; else goto c2FMH;
       u2FN5: // global
           call _c2FMG(R1) args: 0, res: 0, upd: 0;
       c2FMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FMG() //  [R1]
         { info_tbl: [(c2FMG,
                       label: block_c2FMG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FMG: // global
           I64[Sp] = block_c2FMM_info;
           _s2DLO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLO::I64;
           if (R1 & 7 != 0) goto u2FN4; else goto c2FMN;
       u2FN4: // global
           call _c2FMM(R1) args: 0, res: 0, upd: 0;
       c2FMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FMM() //  [R1]
         { info_tbl: [(c2FMM,
                       label: block_c2FMM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FMM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FN3; else goto c2FN2;
       c2FN3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FN2: // global
           _s2DLS::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DLS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.710917109 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2FNx,
                       label: GHC.Word.$fNumWord16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FNM; else goto c2FNN;
       c2FNM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FNN: // global
           I64[Sp - 16] = block_c2FNu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FNT; else goto c2FNv;
       u2FNT: // global
           call _c2FNu(R1) args: 0, res: 0, upd: 0;
       c2FNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FNu() //  [R1]
         { info_tbl: [(c2FNu,
                       label: block_c2FNu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FNu: // global
           I64[Sp] = block_c2FNA_info;
           _s2DLW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLW::I64;
           if (R1 & 7 != 0) goto u2FNS; else goto c2FNB;
       u2FNS: // global
           call _c2FNA(R1) args: 0, res: 0, upd: 0;
       c2FNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FNA() //  [R1]
         { info_tbl: [(c2FNA,
                       label: block_c2FNA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FNA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FNR; else goto c2FNQ;
       c2FNR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FNQ: // global
           _s2DM0::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DM0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.719939439 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2FOl,
                       label: GHC.Word.$fNumWord16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FOA; else goto c2FOB;
       c2FOA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FOB: // global
           I64[Sp - 16] = block_c2FOi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FOH; else goto c2FOj;
       u2FOH: // global
           call _c2FOi(R1) args: 0, res: 0, upd: 0;
       c2FOj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FOi() //  [R1]
         { info_tbl: [(c2FOi,
                       label: block_c2FOi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FOi: // global
           I64[Sp] = block_c2FOo_info;
           _s2DM4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DM4::I64;
           if (R1 & 7 != 0) goto u2FOG; else goto c2FOp;
       u2FOG: // global
           call _c2FOo(R1) args: 0, res: 0, upd: 0;
       c2FOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FOo() //  [R1]
         { info_tbl: [(c2FOo,
                       label: block_c2FOo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FOo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FOF; else goto c2FOE;
       c2FOF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FOE: // global
           _s2DM8::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DM8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.727844396 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { info_tbl: [(c2FP9,
                       label: GHC.Word.$ctoInteger1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FP9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FPa; else goto c2FPb;
       c2FPa: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FPb: // global
           I64[Sp - 8] = block_c2FP6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FPg; else goto c2FP7;
       u2FPg: // global
           call _c2FP6(R1) args: 0, res: 0, upd: 0;
       c2FP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FP6() //  [R1]
         { info_tbl: [(c2FP6,
                       label: block_c2FP6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FP6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.733733775 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2FPy,
                       label: GHC.Word.$fBitsWord16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FPy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FPJ; else goto c2FPK;
       c2FPJ: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FPK: // global
           I64[Sp - 8] = block_c2FPv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FPO; else goto c2FPw;
       u2FPO: // global
           call _c2FPv(R1) args: 0, res: 0, upd: 0;
       c2FPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FPv() //  [R1]
         { info_tbl: [(c2FPv,
                       label: block_c2FPv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FPv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FPN; else goto c2FPM;
       c2FPN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FPM: // global
           (_c2FPB::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FPB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.74021452 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2FQ8,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FQk; else goto c2FQl;
       c2FQk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FQl: // global
           I64[Sp - 16] = block_c2FQ5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FQr; else goto c2FQ6;
       u2FQr: // global
           call _c2FQ5(R1) args: 0, res: 0, upd: 0;
       c2FQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FQ5() //  [R1]
         { info_tbl: [(c2FQ5,
                       label: block_c2FQ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQ5: // global
           I64[Sp] = block_c2FQb_info;
           _s2DMl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMl::I64;
           if (R1 & 7 != 0) goto u2FQq; else goto c2FQc;
       u2FQq: // global
           call _c2FQb(R1) args: 0, res: 0, upd: 0;
       c2FQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FQb() //  [R1]
         { info_tbl: [(c2FQb,
                       label: block_c2FQb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FQp; else goto c2FQo;
       c2FQp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FQo: // global
           _s2DMo::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DMo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.748404569 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2FQR,
                       label: GHC.Word.$fBitsWord16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FQV; else goto c2FQW;
       c2FQV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FQW: // global
           I64[Sp - 16] = block_c2FQO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FRg; else goto c2FQP;
       u2FRg: // global
           call _c2FQO(R1) args: 0, res: 0, upd: 0;
       c2FQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FQO() //  [R1]
         { info_tbl: [(c2FQO,
                       label: block_c2FQO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQO: // global
           I64[Sp] = block_c2FQU_info;
           _s2DMs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMs::I64;
           if (R1 & 7 != 0) goto u2FRf; else goto c2FQY;
       u2FRf: // global
           call _c2FQU(R1) args: 0, res: 0, upd: 0;
       c2FQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FQU() //  [R1]
         { info_tbl: [(c2FQU,
                       label: block_c2FQU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FQU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FR4; else goto c2FR3;
       c2FR4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FR3: // global
           _s2DMu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DMu::I64, 64)) goto c2FRd; else goto c2FRe;
       c2FRd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DMu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FRe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.757091674 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2FRH,
                       label: GHC.Word.$fBitsWord16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FRH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FRW; else goto c2FRX;
       c2FRW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FRX: // global
           I64[Sp - 16] = block_c2FRE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FS3; else goto c2FRF;
       u2FS3: // global
           call _c2FRE(R1) args: 0, res: 0, upd: 0;
       c2FRF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FRE() //  [R1]
         { info_tbl: [(c2FRE,
                       label: block_c2FRE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FRE: // global
           I64[Sp] = block_c2FRK_info;
           _s2DMA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMA::I64;
           if (R1 & 7 != 0) goto u2FS2; else goto c2FRL;
       u2FS2: // global
           call _c2FRK(R1) args: 0, res: 0, upd: 0;
       c2FRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FRK() //  [R1]
         { info_tbl: [(c2FRK,
                       label: block_c2FRK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FRK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FS1; else goto c2FS0;
       c2FS1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FS0: // global
           _s2DME::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DME::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.765789198 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2FSu,
                       label: GHC.Word.$fBitsWord16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FSy; else goto c2FSz;
       c2FSy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FSz: // global
           I64[Sp - 16] = block_c2FSr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FSW; else goto c2FSs;
       u2FSW: // global
           call _c2FSr(R1) args: 0, res: 0, upd: 0;
       c2FSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FSr() //  [R1]
         { info_tbl: [(c2FSr,
                       label: block_c2FSr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FSr: // global
           I64[Sp] = block_c2FSx_info;
           _s2DMI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMI::I64;
           if (R1 & 7 != 0) goto u2FSV; else goto c2FSB;
       u2FSV: // global
           call _c2FSx(R1) args: 0, res: 0, upd: 0;
       c2FSB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FSx() //  [R1]
         { info_tbl: [(c2FSx,
                       label: block_c2FSx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FSx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FSH; else goto c2FSG;
       c2FSH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FSG: // global
           _s2DMK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DMK::I64, 64)) goto c2FST; else goto c2FSU;
       c2FST: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2DMK::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FSU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.77378831 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { info_tbl: [(c2FTm,
                       label: GHC.Word.$fBitsWord16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.777720086 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2FTC,
                       label: GHC.Word.$fBitsWord16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FTG; else goto c2FTH;
       c2FTG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FTH: // global
           I64[Sp - 16] = block_c2FTz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FUu; else goto c2FTA;
       u2FUu: // global
           call _c2FTz(R1) args: 0, res: 0, upd: 0;
       c2FTA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FTz() //  [R1]
         { info_tbl: [(c2FTz,
                       label: block_c2FTz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTz: // global
           I64[Sp - 8] = block_c2FTF_info;
           _s2DMR::P64 = R1;
           _s2DMS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DMS::I64;
           P64[Sp + 8] = _s2DMR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FUt; else goto c2FTJ;
       u2FUt: // global
           call _c2FTF(R1) args: 0, res: 0, upd: 0;
       c2FTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FTF() //  [R1]
         { info_tbl: [(c2FTF,
                       label: block_c2FTF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTF: // global
           _s2DMX::I64 = I64[R1 + 7] & 15;
           if (_s2DMX::I64 != 0) goto u2FUr; else goto c2FUn;
       u2FUr: // global
           I64[Sp + 16] = _s2DMX::I64;
           Sp = Sp + 8;
           call _c2FTY() args: 0, res: 0, upd: 0;
       c2FUn: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FTY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTY: // global
           Hp = Hp + 16;
           _s2DMX::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2FUk; else goto c2FUj;
       c2FUk: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2FTX_info;
           R1 = _s2DMX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FUj: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2DMS::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2DMS::I64 << _s2DMX::I64) | (_s2DMS::I64 >> 16 - _s2DMX::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FTX() //  [R1]
         { info_tbl: [(c2FTX,
                       label: block_c2FTX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FTX: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2FTY() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.788905911 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2FVa,
                       label: GHC.Word.$fBitsWord16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FVe; else goto c2FVf;
       c2FVe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FVf: // global
           I64[Sp - 16] = block_c2FV7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FVW; else goto c2FV8;
       u2FVW: // global
           call _c2FV7(R1) args: 0, res: 0, upd: 0;
       c2FV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FV7() //  [R1]
         { info_tbl: [(c2FV7,
                       label: block_c2FV7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FV7: // global
           I64[Sp] = block_c2FVd_info;
           _s2DN6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DN6::I64;
           if (R1 & 7 != 0) goto u2FVV; else goto c2FVh;
       u2FVV: // global
           call _c2FVd(R1) args: 0, res: 0, upd: 0;
       c2FVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FVd() //  [R1]
         { info_tbl: [(c2FVd,
                       label: block_c2FVd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FVd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FVn; else goto c2FVm;
       c2FVn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FVm: // global
           _s2DN6::I64 = I64[Sp + 8];
           _s2DN8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DN8::I64, 0)) goto c2FVF; else goto c2FVU;
       c2FVF: // global
           _s2DNa::I64 = -_s2DN8::I64;
           if (%MO_S_Ge_W64(_s2DNa::I64, 64)) goto c2FVT; else goto c2FVC;
       c2FVC: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DN6::I64 >> _s2DNa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FVU: // global
           if (%MO_S_Ge_W64(_s2DN8::I64, 64)) goto c2FVT; else goto c2FVS;
       c2FVT: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FVS: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DN6::I64 << _s2DN8::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.798477735 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2FWs,
                       label: GHC.Word.$fBitsWord16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FWs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FWE; else goto c2FWF;
       c2FWE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FWF: // global
           I64[Sp - 16] = block_c2FWp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FWL; else goto c2FWq;
       u2FWL: // global
           call _c2FWp(R1) args: 0, res: 0, upd: 0;
       c2FWq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FWp() //  [R1]
         { info_tbl: [(c2FWp,
                       label: block_c2FWp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FWp: // global
           I64[Sp] = block_c2FWv_info;
           _s2DNj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNj::I64;
           if (R1 & 7 != 0) goto u2FWK; else goto c2FWw;
       u2FWK: // global
           call _c2FWv(R1) args: 0, res: 0, upd: 0;
       c2FWw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FWv() //  [R1]
         { info_tbl: [(c2FWv,
                       label: block_c2FWv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FWv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FWJ; else goto c2FWI;
       c2FWJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FWI: // global
           _s2DNm::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.806212728 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2FXc,
                       label: GHC.Word.$fBitsWord16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FXo; else goto c2FXp;
       c2FXo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FXp: // global
           I64[Sp - 16] = block_c2FX9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FXv; else goto c2FXa;
       u2FXv: // global
           call _c2FX9(R1) args: 0, res: 0, upd: 0;
       c2FXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FX9() //  [R1]
         { info_tbl: [(c2FX9,
                       label: block_c2FX9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FX9: // global
           I64[Sp] = block_c2FXf_info;
           _s2DNq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNq::I64;
           if (R1 & 7 != 0) goto u2FXu; else goto c2FXg;
       u2FXu: // global
           call _c2FXf(R1) args: 0, res: 0, upd: 0;
       c2FXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FXf() //  [R1]
         { info_tbl: [(c2FXf,
                       label: block_c2FXf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FXf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FXt; else goto c2FXs;
       c2FXt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FXs: // global
           _s2DNt::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNt::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.814153111 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2FXW,
                       label: GHC.Word.$fBitsWord16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FXW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FY8; else goto c2FY9;
       c2FY8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FY9: // global
           I64[Sp - 16] = block_c2FXT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FYf; else goto c2FXU;
       u2FYf: // global
           call _c2FXT(R1) args: 0, res: 0, upd: 0;
       c2FXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FXT() //  [R1]
         { info_tbl: [(c2FXT,
                       label: block_c2FXT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FXT: // global
           I64[Sp] = block_c2FXZ_info;
           _s2DNx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNx::I64;
           if (R1 & 7 != 0) goto u2FYe; else goto c2FY0;
       u2FYe: // global
           call _c2FXZ(R1) args: 0, res: 0, upd: 0;
       c2FY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FXZ() //  [R1]
         { info_tbl: [(c2FXZ,
                       label: block_c2FXZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FXZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FYd; else goto c2FYc;
       c2FYd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FYc: // global
           _s2DNA::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.822111853 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2FYG,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FYG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FYR; else goto c2FYS;
       c2FYR: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FYS: // global
           I64[Sp - 8] = block_c2FYD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FYW; else goto c2FYE;
       u2FYW: // global
           call _c2FYD(R1) args: 0, res: 0, upd: 0;
       c2FYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FYD() //  [R1]
         { info_tbl: [(c2FYD,
                       label: block_c2FYD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FYD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FYV; else goto c2FYU;
       c2FYV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FYU: // global
           (_c2FYJ::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FYJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.828119077 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2FZi,
                       label: GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FZi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FZt; else goto c2FZu;
       c2FZt: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FZu: // global
           I64[Sp - 8] = block_c2FZf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FZy; else goto c2FZg;
       u2FZy: // global
           call _c2FZf(R1) args: 0, res: 0, upd: 0;
       c2FZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2FZf() //  [R1]
         { info_tbl: [(c2FZf,
                       label: block_c2FZf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FZf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FZx; else goto c2FZw;
       c2FZx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FZw: // global
           (_c2FZl::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FZl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.834207589 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.836161489 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2FZS,
                       label: GHC.Word.$fBitsWord16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2FZS: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.839929954 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c2G06,
                       label: GHC.Word.$fNumWord32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G06: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G0d; else goto c2G0e;
       c2G0d: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G0e: // global
           I64[Sp - 8] = block_c2G04_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2G04() //  [R1]
         { info_tbl: [(c2G04,
                       label: block_c2G04_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G04: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G0h; else goto c2G0g;
       c2G0h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2G0g: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.845428898 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { info_tbl: [(c2G0y,
                       label: GHC.Word.$fNumWord32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G0y: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.848866161 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { info_tbl: [(c2G0O,
                       label: GHC.Word.$fNumWord32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G0O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G14; else goto c2G15;
       c2G14: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G15: // global
           I64[Sp - 8] = block_c2G0L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G19; else goto c2G0M;
       u2G19: // global
           call _c2G0L(R1) args: 0, res: 0, upd: 0;
       c2G0M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G0L() //  [R1]
         { info_tbl: [(c2G0L,
                       label: block_c2G0L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G0L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G18; else goto c2G17;
       c2G18: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G17: // global
           _s2DNW::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DNW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.855312657 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c2G1u,
                       label: GHC.Word.$fNumWord32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G1u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G1J; else goto c2G1K;
       c2G1J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G1K: // global
           I64[Sp - 16] = block_c2G1r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G1Q; else goto c2G1s;
       u2G1Q: // global
           call _c2G1r(R1) args: 0, res: 0, upd: 0;
       c2G1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G1r() //  [R1]
         { info_tbl: [(c2G1r,
                       label: block_c2G1r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G1r: // global
           I64[Sp] = block_c2G1x_info;
           _s2DO0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DO0::I64;
           if (R1 & 7 != 0) goto u2G1P; else goto c2G1y;
       u2G1P: // global
           call _c2G1x(R1) args: 0, res: 0, upd: 0;
       c2G1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G1x() //  [R1]
         { info_tbl: [(c2G1x,
                       label: block_c2G1x_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G1x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G1O; else goto c2G1N;
       c2G1O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G1N: // global
           _s2DO4::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DO4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.863604537 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c2G2i,
                       label: GHC.Word.$fNumWord32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G2x; else goto c2G2y;
       c2G2x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G2y: // global
           I64[Sp - 16] = block_c2G2f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G2E; else goto c2G2g;
       u2G2E: // global
           call _c2G2f(R1) args: 0, res: 0, upd: 0;
       c2G2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G2f() //  [R1]
         { info_tbl: [(c2G2f,
                       label: block_c2G2f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G2f: // global
           I64[Sp] = block_c2G2l_info;
           _s2DO8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DO8::I64;
           if (R1 & 7 != 0) goto u2G2D; else goto c2G2m;
       u2G2D: // global
           call _c2G2l(R1) args: 0, res: 0, upd: 0;
       c2G2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G2l() //  [R1]
         { info_tbl: [(c2G2l,
                       label: block_c2G2l_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G2C; else goto c2G2B;
       c2G2C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G2B: // global
           _s2DOc::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.871906872 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c2G36,
                       label: GHC.Word.$fNumWord32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G36: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G3l; else goto c2G3m;
       c2G3l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G3m: // global
           I64[Sp - 16] = block_c2G33_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G3s; else goto c2G34;
       u2G3s: // global
           call _c2G33(R1) args: 0, res: 0, upd: 0;
       c2G34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G33() //  [R1]
         { info_tbl: [(c2G33,
                       label: block_c2G33_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G33: // global
           I64[Sp] = block_c2G39_info;
           _s2DOg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOg::I64;
           if (R1 & 7 != 0) goto u2G3r; else goto c2G3a;
       u2G3r: // global
           call _c2G39(R1) args: 0, res: 0, upd: 0;
       c2G3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G39() //  [R1]
         { info_tbl: [(c2G39,
                       label: block_c2G39_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G39: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G3q; else goto c2G3p;
       c2G3q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G3p: // global
           _s2DOk::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.879587687 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { info_tbl: [(c2G3U,
                       label: GHC.Word.$ctoInteger2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G3U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G3V; else goto c2G3W;
       c2G3V: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G3W: // global
           I64[Sp - 8] = block_c2G3R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G41; else goto c2G3S;
       u2G41: // global
           call _c2G3R(R1) args: 0, res: 0, upd: 0;
       c2G3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G3R() //  [R1]
         { info_tbl: [(c2G3R,
                       label: block_c2G3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G3R: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.885106657 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2G4j,
                       label: GHC.Word.$fBitsWord32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G4j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G4u; else goto c2G4v;
       c2G4u: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G4v: // global
           I64[Sp - 8] = block_c2G4g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G4z; else goto c2G4h;
       u2G4z: // global
           call _c2G4g(R1) args: 0, res: 0, upd: 0;
       c2G4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G4g() //  [R1]
         { info_tbl: [(c2G4g,
                       label: block_c2G4g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G4g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G4y; else goto c2G4x;
       c2G4y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G4x: // global
           (_c2G4m::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2G4m::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.891246505 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2G4T,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G4T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G55; else goto c2G56;
       c2G55: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G56: // global
           I64[Sp - 16] = block_c2G4Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G5c; else goto c2G4R;
       u2G5c: // global
           call _c2G4Q(R1) args: 0, res: 0, upd: 0;
       c2G4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G4Q() //  [R1]
         { info_tbl: [(c2G4Q,
                       label: block_c2G4Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G4Q: // global
           I64[Sp] = block_c2G4W_info;
           _s2DOx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOx::I64;
           if (R1 & 7 != 0) goto u2G5b; else goto c2G4X;
       u2G5b: // global
           call _c2G4W(R1) args: 0, res: 0, upd: 0;
       c2G4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G4W() //  [R1]
         { info_tbl: [(c2G4W,
                       label: block_c2G4W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G4W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G5a; else goto c2G59;
       c2G5a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G59: // global
           _s2DOA::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.899042575 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2G5C,
                       label: GHC.Word.$fBitsWord32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G5G; else goto c2G5H;
       c2G5G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G5H: // global
           I64[Sp - 16] = block_c2G5z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G61; else goto c2G5A;
       u2G61: // global
           call _c2G5z(R1) args: 0, res: 0, upd: 0;
       c2G5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G5z() //  [R1]
         { info_tbl: [(c2G5z,
                       label: block_c2G5z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G5z: // global
           I64[Sp] = block_c2G5F_info;
           _s2DOE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOE::I64;
           if (R1 & 7 != 0) goto u2G60; else goto c2G5J;
       u2G60: // global
           call _c2G5F(R1) args: 0, res: 0, upd: 0;
       c2G5J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G5F() //  [R1]
         { info_tbl: [(c2G5F,
                       label: block_c2G5F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G5F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G5P; else goto c2G5O;
       c2G5P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G5O: // global
           _s2DOG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DOG::I64, 64)) goto c2G5Y; else goto c2G5Z;
       c2G5Y: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DOG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2G5Z: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.907835149 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2G6s,
                       label: GHC.Word.$fBitsWord32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G6s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G6H; else goto c2G6I;
       c2G6H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G6I: // global
           I64[Sp - 16] = block_c2G6p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G6O; else goto c2G6q;
       u2G6O: // global
           call _c2G6p(R1) args: 0, res: 0, upd: 0;
       c2G6q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G6p() //  [R1]
         { info_tbl: [(c2G6p,
                       label: block_c2G6p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G6p: // global
           I64[Sp] = block_c2G6v_info;
           _s2DOM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOM::I64;
           if (R1 & 7 != 0) goto u2G6N; else goto c2G6w;
       u2G6N: // global
           call _c2G6v(R1) args: 0, res: 0, upd: 0;
       c2G6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G6v() //  [R1]
         { info_tbl: [(c2G6v,
                       label: block_c2G6v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G6v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G6M; else goto c2G6L;
       c2G6M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G6L: // global
           _s2DOQ::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.915739237 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2G7e,
                       label: GHC.Word.$fBitsWord32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G7e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G7i; else goto c2G7j;
       c2G7i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G7j: // global
           I64[Sp - 16] = block_c2G7b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G7G; else goto c2G7c;
       u2G7G: // global
           call _c2G7b(R1) args: 0, res: 0, upd: 0;
       c2G7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G7b() //  [R1]
         { info_tbl: [(c2G7b,
                       label: block_c2G7b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G7b: // global
           I64[Sp] = block_c2G7h_info;
           _s2DOU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOU::I64;
           if (R1 & 7 != 0) goto u2G7F; else goto c2G7l;
       u2G7F: // global
           call _c2G7h(R1) args: 0, res: 0, upd: 0;
       c2G7l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G7h() //  [R1]
         { info_tbl: [(c2G7h,
                       label: block_c2G7h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G7h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G7r; else goto c2G7q;
       c2G7r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G7q: // global
           _s2DOW::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DOW::I64, 64)) goto c2G7D; else goto c2G7E;
       c2G7D: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2DOW::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2G7E: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.923691488 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { info_tbl: [(c2G85,
                       label: GHC.Word.$fBitsWord32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G85: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.927534802 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2G8l,
                       label: GHC.Word.$fBitsWord32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G8l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2G8p; else goto c2G8q;
       c2G8p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G8q: // global
           I64[Sp - 16] = block_c2G8i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G9d; else goto c2G8j;
       u2G9d: // global
           call _c2G8i(R1) args: 0, res: 0, upd: 0;
       c2G8j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G8i() //  [R1]
         { info_tbl: [(c2G8i,
                       label: block_c2G8i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G8i: // global
           I64[Sp - 8] = block_c2G8o_info;
           _s2DP3::P64 = R1;
           _s2DP4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DP4::I64;
           P64[Sp + 8] = _s2DP3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G9c; else goto c2G8s;
       u2G9c: // global
           call _c2G8o(R1) args: 0, res: 0, upd: 0;
       c2G8s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G8o() //  [R1]
         { info_tbl: [(c2G8o,
                       label: block_c2G8o_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G8o: // global
           _s2DP9::I64 = I64[R1 + 7] & 31;
           if (_s2DP9::I64 != 0) goto u2G9a; else goto c2G96;
       u2G9a: // global
           I64[Sp + 16] = _s2DP9::I64;
           Sp = Sp + 8;
           call _c2G8H() args: 0, res: 0, upd: 0;
       c2G96: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2G8H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G8H: // global
           Hp = Hp + 16;
           _s2DP9::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2G93; else goto c2G92;
       c2G93: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2G8G_info;
           R1 = _s2DP9::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2G92: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2DP4::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2DP4::I64 << _s2DP9::I64) | (_s2DP4::I64 >> 32 - _s2DP9::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2G8G() //  [R1]
         { info_tbl: [(c2G8G,
                       label: block_c2G8G_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G8G: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2G8H() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.938467576 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2G9T,
                       label: GHC.Word.$fBitsWord32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G9X; else goto c2G9Y;
       c2G9X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G9Y: // global
           I64[Sp - 16] = block_c2G9Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GaF; else goto c2G9R;
       u2GaF: // global
           call _c2G9Q(R1) args: 0, res: 0, upd: 0;
       c2G9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G9Q() //  [R1]
         { info_tbl: [(c2G9Q,
                       label: block_c2G9Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G9Q: // global
           I64[Sp] = block_c2G9W_info;
           _s2DPi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPi::I64;
           if (R1 & 7 != 0) goto u2GaE; else goto c2Ga0;
       u2GaE: // global
           call _c2G9W(R1) args: 0, res: 0, upd: 0;
       c2Ga0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2G9W() //  [R1]
         { info_tbl: [(c2G9W,
                       label: block_c2G9W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2G9W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ga6; else goto c2Ga5;
       c2Ga6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ga5: // global
           _s2DPi::I64 = I64[Sp + 8];
           _s2DPk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DPk::I64, 0)) goto c2Gao; else goto c2GaD;
       c2Gao: // global
           _s2DPm::I64 = -_s2DPk::I64;
           if (%MO_S_Ge_W64(_s2DPm::I64, 64)) goto c2GaC; else goto c2Gal;
       c2Gal: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPi::I64 >> _s2DPm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GaD: // global
           if (%MO_S_Ge_W64(_s2DPk::I64, 64)) goto c2GaC; else goto c2GaB;
       c2GaC: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GaB: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DPi::I64 << _s2DPk::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.947575999 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2Gba,
                       label: GHC.Word.$fBitsWord32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gbm; else goto c2Gbn;
       c2Gbm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gbn: // global
           I64[Sp - 16] = block_c2Gb7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gbt; else goto c2Gb8;
       u2Gbt: // global
           call _c2Gb7(R1) args: 0, res: 0, upd: 0;
       c2Gb8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gb7() //  [R1]
         { info_tbl: [(c2Gb7,
                       label: block_c2Gb7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gb7: // global
           I64[Sp] = block_c2Gbd_info;
           _s2DPv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPv::I64;
           if (R1 & 7 != 0) goto u2Gbs; else goto c2Gbe;
       u2Gbs: // global
           call _c2Gbd(R1) args: 0, res: 0, upd: 0;
       c2Gbe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gbd() //  [R1]
         { info_tbl: [(c2Gbd,
                       label: block_c2Gbd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gbd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gbr; else goto c2Gbq;
       c2Gbr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gbq: // global
           _s2DPy::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.95555407 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2GbU,
                       label: GHC.Word.$fBitsWord32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gc6; else goto c2Gc7;
       c2Gc6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gc7: // global
           I64[Sp - 16] = block_c2GbR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gcd; else goto c2GbS;
       u2Gcd: // global
           call _c2GbR(R1) args: 0, res: 0, upd: 0;
       c2GbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GbR() //  [R1]
         { info_tbl: [(c2GbR,
                       label: block_c2GbR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GbR: // global
           I64[Sp] = block_c2GbX_info;
           _s2DPC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPC::I64;
           if (R1 & 7 != 0) goto u2Gcc; else goto c2GbY;
       u2Gcc: // global
           call _c2GbX(R1) args: 0, res: 0, upd: 0;
       c2GbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GbX() //  [R1]
         { info_tbl: [(c2GbX,
                       label: block_c2GbX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GbX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gcb; else goto c2Gca;
       c2Gcb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gca: // global
           _s2DPF::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.96323826 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2GcE,
                       label: GHC.Word.$fBitsWord32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GcQ; else goto c2GcR;
       c2GcQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GcR: // global
           I64[Sp - 16] = block_c2GcB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GcX; else goto c2GcC;
       u2GcX: // global
           call _c2GcB(R1) args: 0, res: 0, upd: 0;
       c2GcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GcB() //  [R1]
         { info_tbl: [(c2GcB,
                       label: block_c2GcB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GcB: // global
           I64[Sp] = block_c2GcH_info;
           _s2DPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPJ::I64;
           if (R1 & 7 != 0) goto u2GcW; else goto c2GcI;
       u2GcW: // global
           call _c2GcH(R1) args: 0, res: 0, upd: 0;
       c2GcI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GcH() //  [R1]
         { info_tbl: [(c2GcH,
                       label: block_c2GcH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GcH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GcV; else goto c2GcU;
       c2GcV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GcU: // global
           _s2DPM::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.970795352 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2Gdo,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gdo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gdz; else goto c2GdA;
       c2Gdz: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GdA: // global
           I64[Sp - 8] = block_c2Gdl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GdE; else goto c2Gdm;
       u2GdE: // global
           call _c2Gdl(R1) args: 0, res: 0, upd: 0;
       c2Gdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gdl() //  [R1]
         { info_tbl: [(c2Gdl,
                       label: block_c2Gdl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gdl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GdD; else goto c2GdC;
       c2GdD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GdC: // global
           (_c2Gdr::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Gdr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.976971971 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2Ge0,
                       label: GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ge0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Geb; else goto c2Gec;
       c2Geb: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gec: // global
           I64[Sp - 8] = block_c2GdX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Geg; else goto c2GdY;
       u2Geg: // global
           call _c2GdX(R1) args: 0, res: 0, upd: 0;
       c2GdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GdX() //  [R1]
         { info_tbl: [(c2GdX,
                       label: block_c2GdX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GdX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gef; else goto c2Gee;
       c2Gef: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gee: // global
           (_c2Ge3::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Ge3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.983376179 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.98531728 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2GeA,
                       label: GHC.Word.$fBitsWord32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GeA: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.988767422 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c2GeP,
                       label: GHC.Word.$fBitsWord64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GeP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gf0; else goto c2Gf1;
       c2Gf0: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gf1: // global
           I64[Sp - 8] = block_c2GeM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gf5; else goto c2GeN;
       u2Gf5: // global
           call _c2GeM(R1) args: 0, res: 0, upd: 0;
       c2GeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GeM() //  [R1]
         { info_tbl: [(c2GeM,
                       label: block_c2GeM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GeM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gf4; else goto c2Gf3;
       c2Gf4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gf3: // global
           (_c2GeS::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2GeS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:23.994647234 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c2Gfp,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gfp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GfB; else goto c2GfC;
       c2GfB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GfC: // global
           I64[Sp - 16] = block_c2Gfm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GfI; else goto c2Gfn;
       u2GfI: // global
           call _c2Gfm(R1) args: 0, res: 0, upd: 0;
       c2Gfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gfm() //  [R1]
         { info_tbl: [(c2Gfm,
                       label: block_c2Gfm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gfm: // global
           I64[Sp] = block_c2Gfs_info;
           _s2DQ6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQ6::I64;
           if (R1 & 7 != 0) goto u2GfH; else goto c2Gft;
       u2GfH: // global
           call _c2Gfs(R1) args: 0, res: 0, upd: 0;
       c2Gft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gfs() //  [R1]
         { info_tbl: [(c2Gfs,
                       label: block_c2Gfs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gfs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GfG; else goto c2GfF;
       c2GfG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GfF: // global
           _s2DQ9::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQ9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.002599808 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c2Gg8,
                       label: GHC.Word.$fBitsWord64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gg8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ggc; else goto c2Ggd;
       c2Ggc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ggd: // global
           I64[Sp - 16] = block_c2Gg5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ggx; else goto c2Gg6;
       u2Ggx: // global
           call _c2Gg5(R1) args: 0, res: 0, upd: 0;
       c2Gg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gg5() //  [R1]
         { info_tbl: [(c2Gg5,
                       label: block_c2Gg5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gg5: // global
           I64[Sp] = block_c2Ggb_info;
           _s2DQd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQd::I64;
           if (R1 & 7 != 0) goto u2Ggw; else goto c2Ggf;
       u2Ggw: // global
           call _c2Ggb(R1) args: 0, res: 0, upd: 0;
       c2Ggf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ggb() //  [R1]
         { info_tbl: [(c2Ggb,
                       label: block_c2Ggb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ggb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ggl; else goto c2Ggk;
       c2Ggl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ggk: // global
           _s2DQf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQf::I64, 64)) goto c2Ggu; else goto c2Ggv;
       c2Ggu: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DQf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ggv: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.010934834 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c2GgY,
                       label: GHC.Word.$fBitsWord64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GgY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gha; else goto c2Ghb;
       c2Gha: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ghb: // global
           I64[Sp - 16] = block_c2GgV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ghh; else goto c2GgW;
       u2Ghh: // global
           call _c2GgV(R1) args: 0, res: 0, upd: 0;
       c2GgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GgV() //  [R1]
         { info_tbl: [(c2GgV,
                       label: block_c2GgV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GgV: // global
           I64[Sp] = block_c2Gh1_info;
           _s2DQl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQl::I64;
           if (R1 & 7 != 0) goto u2Ghg; else goto c2Gh2;
       u2Ghg: // global
           call _c2Gh1(R1) args: 0, res: 0, upd: 0;
       c2Gh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gh1() //  [R1]
         { info_tbl: [(c2Gh1,
                       label: block_c2Gh1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gh1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ghf; else goto c2Ghe;
       c2Ghf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ghe: // global
           _s2DQo::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.018579823 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c2GhH,
                       label: GHC.Word.$fBitsWord64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GhH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GhL; else goto c2GhM;
       c2GhL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GhM: // global
           I64[Sp - 16] = block_c2GhE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gi6; else goto c2GhF;
       u2Gi6: // global
           call _c2GhE(R1) args: 0, res: 0, upd: 0;
       c2GhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GhE() //  [R1]
         { info_tbl: [(c2GhE,
                       label: block_c2GhE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GhE: // global
           I64[Sp] = block_c2GhK_info;
           _s2DQs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQs::I64;
           if (R1 & 7 != 0) goto u2Gi5; else goto c2GhO;
       u2Gi5: // global
           call _c2GhK(R1) args: 0, res: 0, upd: 0;
       c2GhO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GhK() //  [R1]
         { info_tbl: [(c2GhK,
                       label: block_c2GhK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GhK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GhU; else goto c2GhT;
       c2GhU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GhT: // global
           _s2DQu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQu::I64, 64)) goto c2Gi3; else goto c2Gi4;
       c2Gi3: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2DQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gi4: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.026958326 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { info_tbl: [(c2Giu,
                       label: GHC.Word.$fBitsWord64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Giu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.030796266 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c2GiK,
                       label: GHC.Word.$fBitsWord64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GiK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GiO; else goto c2GiP;
       c2GiO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GiP: // global
           I64[Sp - 16] = block_c2GiH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gjz; else goto c2GiI;
       u2Gjz: // global
           call _c2GiH(R1) args: 0, res: 0, upd: 0;
       c2GiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GiH() //  [R1]
         { info_tbl: [(c2GiH,
                       label: block_c2GiH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GiH: // global
           I64[Sp - 8] = block_c2GiN_info;
           _s2DQA::P64 = R1;
           _s2DQB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DQB::I64;
           P64[Sp + 8] = _s2DQA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gjy; else goto c2GiR;
       u2Gjy: // global
           call _c2GiN(R1) args: 0, res: 0, upd: 0;
       c2GiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GiN() //  [R1]
         { info_tbl: [(c2GiN,
                       label: block_c2GiN_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GiN: // global
           _s2DQG::I64 = I64[R1 + 7] & 63;
           if (_s2DQG::I64 != 0) goto u2Gjw; else goto c2Gjs;
       u2Gjw: // global
           I64[Sp + 16] = _s2DQG::I64;
           Sp = Sp + 8;
           call _c2Gj6() args: 0, res: 0, upd: 0;
       c2Gjs: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gj6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gj6: // global
           Hp = Hp + 16;
           _s2DQG::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Gjp; else goto c2Gjo;
       c2Gjp: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Gj5_info;
           R1 = _s2DQG::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Gjo: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2DQB::I64 = I64[Sp];
           I64[Hp] = (_s2DQB::I64 << _s2DQG::I64) | (_s2DQB::I64 >> 64 - _s2DQG::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gj5() //  [R1]
         { info_tbl: [(c2Gj5,
                       label: block_c2Gj5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gj5: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Gj6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.042321044 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c2Gke,
                       label: GHC.Word.$fBitsWord64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gki; else goto c2Gkj;
       c2Gki: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gkj: // global
           I64[Sp - 16] = block_c2Gkb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GkX; else goto c2Gkc;
       u2GkX: // global
           call _c2Gkb(R1) args: 0, res: 0, upd: 0;
       c2Gkc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gkb() //  [R1]
         { info_tbl: [(c2Gkb,
                       label: block_c2Gkb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gkb: // global
           I64[Sp] = block_c2Gkh_info;
           _s2DQO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQO::I64;
           if (R1 & 7 != 0) goto u2GkW; else goto c2Gkl;
       u2GkW: // global
           call _c2Gkh(R1) args: 0, res: 0, upd: 0;
       c2Gkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gkh() //  [R1]
         { info_tbl: [(c2Gkh,
                       label: block_c2Gkh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gkh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gkr; else goto c2Gkq;
       c2Gkr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gkq: // global
           _s2DQO::I64 = I64[Sp + 8];
           _s2DQQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQQ::I64, 0)) goto c2GkJ; else goto c2GkV;
       c2GkJ: // global
           _s2DQS::I64 = -_s2DQQ::I64;
           if (%MO_S_Ge_W64(_s2DQS::I64, 64)) goto c2GkU; else goto c2GkG;
       c2GkG: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQO::I64 >> _s2DQS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GkV: // global
           if (%MO_S_Ge_W64(_s2DQQ::I64, 64)) goto c2GkU; else goto c2GkT;
       c2GkU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GkT: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQO::I64 << _s2DQQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.050903698 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c2Glr,
                       label: GHC.Word.$fBitsWord64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Glr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GlD; else goto c2GlE;
       c2GlD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GlE: // global
           I64[Sp - 16] = block_c2Glo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GlK; else goto c2Glp;
       u2GlK: // global
           call _c2Glo(R1) args: 0, res: 0, upd: 0;
       c2Glp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Glo() //  [R1]
         { info_tbl: [(c2Glo,
                       label: block_c2Glo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Glo: // global
           I64[Sp] = block_c2Glu_info;
           _s2DR0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DR0::I64;
           if (R1 & 7 != 0) goto u2GlJ; else goto c2Glv;
       u2GlJ: // global
           call _c2Glu(R1) args: 0, res: 0, upd: 0;
       c2Glv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Glu() //  [R1]
         { info_tbl: [(c2Glu,
                       label: block_c2Glu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Glu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GlI; else goto c2GlH;
       c2GlI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GlH: // global
           _s2DR3::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DR3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.059112997 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c2Gmb,
                       label: GHC.Word.$fBitsWord64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gmn; else goto c2Gmo;
       c2Gmn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gmo: // global
           I64[Sp - 16] = block_c2Gm8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gmu; else goto c2Gm9;
       u2Gmu: // global
           call _c2Gm8(R1) args: 0, res: 0, upd: 0;
       c2Gm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gm8() //  [R1]
         { info_tbl: [(c2Gm8,
                       label: block_c2Gm8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gm8: // global
           I64[Sp] = block_c2Gme_info;
           _s2DR7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DR7::I64;
           if (R1 & 7 != 0) goto u2Gmt; else goto c2Gmf;
       u2Gmt: // global
           call _c2Gme(R1) args: 0, res: 0, upd: 0;
       c2Gmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gme() //  [R1]
         { info_tbl: [(c2Gme,
                       label: block_c2Gme_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gme: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gms; else goto c2Gmr;
       c2Gms: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gmr: // global
           _s2DRa::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DRa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.067046413 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c2GmV,
                       label: GHC.Word.$fBitsWord64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GmV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gn7; else goto c2Gn8;
       c2Gn7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gn8: // global
           I64[Sp - 16] = block_c2GmS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gne; else goto c2GmT;
       u2Gne: // global
           call _c2GmS(R1) args: 0, res: 0, upd: 0;
       c2GmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GmS() //  [R1]
         { info_tbl: [(c2GmS,
                       label: block_c2GmS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GmS: // global
           I64[Sp] = block_c2GmY_info;
           _s2DRe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRe::I64;
           if (R1 & 7 != 0) goto u2Gnd; else goto c2GmZ;
       u2Gnd: // global
           call _c2GmY(R1) args: 0, res: 0, upd: 0;
       c2GmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GmY() //  [R1]
         { info_tbl: [(c2GmY,
                       label: block_c2GmY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GmY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gnc; else goto c2Gnb;
       c2Gnc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gnb: // global
           _s2DRh::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DRh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.074589741 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c2GnF,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GnF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GnQ; else goto c2GnR;
       c2GnQ: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GnR: // global
           I64[Sp - 8] = block_c2GnC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GnV; else goto c2GnD;
       u2GnV: // global
           call _c2GnC(R1) args: 0, res: 0, upd: 0;
       c2GnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GnC() //  [R1]
         { info_tbl: [(c2GnC,
                       label: block_c2GnC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GnC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GnU; else goto c2GnT;
       c2GnU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GnT: // global
           (_c2GnI::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2GnI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.080570414 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c2Goh,
                       label: GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Goh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gos; else goto c2Got;
       c2Gos: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Got: // global
           I64[Sp - 8] = block_c2Goe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gox; else goto c2Gof;
       u2Gox: // global
           call _c2Goe(R1) args: 0, res: 0, upd: 0;
       c2Gof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Goe() //  [R1]
         { info_tbl: [(c2Goe,
                       label: block_c2Goe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Goe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gow; else goto c2Gov;
       c2Gow: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gov: // global
           (_c2Gok::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Gok::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.086109767 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.087880663 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c2GoR,
                       label: GHC.Word.$fBitsWord64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GoR: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.091382223 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { info_tbl: [(c2Gp6,
                       label: GHC.Word.eqWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gp6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gpa; else goto c2Gpb;
       c2Gpa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gpb: // global
           I64[Sp - 16] = block_c2Gp3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gpk; else goto c2Gp4;
       u2Gpk: // global
           call _c2Gp3(R1) args: 0, res: 0, upd: 0;
       c2Gp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gp3() //  [R1]
         { info_tbl: [(c2Gp3,
                       label: block_c2Gp3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gp3: // global
           I64[Sp] = block_c2Gp9_info;
           _s2DRw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRw::I64;
           if (R1 & 7 != 0) goto u2Gpj; else goto c2Gpd;
       u2Gpj: // global
           call _c2Gp9(R1) args: 0, res: 0, upd: 0;
       c2Gpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gp9() //  [R1]
         { info_tbl: [(c2Gp9,
                       label: block_c2Gp9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gp9: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.099173525 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.100807573 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.102931154 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { info_tbl: [(c2GpO,
                       label: GHC.Word.$fNumWord8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GpO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GpP; else goto c2GpQ;
       c2GpP: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GpQ: // global
           I64[Sp - 8] = block_c2GpL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GpY; else goto c2GpM;
       u2GpY: // global
           call _c2GpL(R1) args: 0, res: 0, upd: 0;
       c2GpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GpL() //  [R1]
         { info_tbl: [(c2GpL,
                       label: block_c2GpL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GpL: // global
           if (I64[R1 + 7] == 0) goto c2GpX; else goto c2GpW;
       c2GpX: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GpW: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.10838504 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.11101844 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2Gqj,
                       label: GHC.Word.$fBitsWord8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gqj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gqq; else goto c2Gqr;
       c2Gqq: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gqr: // global
           I64[Sp - 8] = block_c2Gqg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gqv; else goto c2Gqh;
       u2Gqv: // global
           call _c2Gqg(R1) args: 0, res: 0, upd: 0;
       c2Gqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gqg() //  [R1]
         { info_tbl: [(c2Gqg,
                       label: block_c2Gqg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gqg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gqu; else goto c2Gqt;
       c2Gqu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gqt: // global
           _s2DRH::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DRH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.11647797 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.118597273 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2GqO,
                       label: GHC.Word.$fBitsWord8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GqO: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.122345148 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { info_tbl: [(c2Gr3,
                       label: GHC.Word.$fBitsWord8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gr3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gr4; else goto c2Gr5;
       c2Gr4: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gr5: // global
           I64[Sp - 8] = block_c2Gr0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gro; else goto c2Gr1;
       u2Gro: // global
           call _c2Gr0(R1) args: 0, res: 0, upd: 0;
       c2Gr1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gr0() //  [R1]
         { info_tbl: [(c2Gr0,
                       label: block_c2Gr0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gr0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gra; else goto c2Gr9;
       c2Gra: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gr9: // global
           _s2DRL::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DRL::I64, 64)) goto c2Grm; else goto c2Grn;
       c2Grm: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DRL::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Grn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.12960199 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2GrM,
                       label: GHC.Word.$fBitsWord8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GrQ; else goto c2GrR;
       c2GrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GrR: // global
           I64[Sp - 16] = block_c2GrJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gsq; else goto c2GrK;
       u2Gsq: // global
           call _c2GrJ(R1) args: 0, res: 0, upd: 0;
       c2GrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GrJ() //  [R1]
         { info_tbl: [(c2GrJ,
                       label: block_c2GrJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GrJ: // global
           I64[Sp] = block_c2GrP_info;
           _s2DRS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRS::I64;
           if (R1 & 7 != 0) goto u2Gsp; else goto c2GrT;
       u2Gsp: // global
           call _c2GrP(R1) args: 0, res: 0, upd: 0;
       c2GrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GrP() //  [R1]
         { info_tbl: [(c2GrP,
                       label: block_c2GrP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GrP: // global
           _s2DRU::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DRU::I64, 64)) goto c2Gso; else goto c2Gsn;
       c2Gsn: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DRU::I64)) == 0) goto c2Gso; else goto c2Gsc;
       c2Gso: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gsc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.137983561 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2GsW,
                       label: GHC.Word.$fBitsWord8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GsW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Gt0; else goto c2Gt1;
       c2Gt0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gt1: // global
           I64[Sp - 16] = block_c2GsT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GtR; else goto c2GsU;
       u2GtR: // global
           call _c2GsT(R1) args: 0, res: 0, upd: 0;
       c2GsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GsT() //  [R1]
         { info_tbl: [(c2GsT,
                       label: block_c2GsT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GsT: // global
           I64[Sp - 8] = block_c2GsZ_info;
           _s2DS1::P64 = R1;
           _s2DS2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DS2::I64;
           P64[Sp + 8] = _s2DS1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GtQ; else goto c2Gt3;
       u2GtQ: // global
           call _c2GsZ(R1) args: 0, res: 0, upd: 0;
       c2Gt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GsZ() //  [R1]
         { info_tbl: [(c2GsZ,
                       label: block_c2GsZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GsZ: // global
           _s2DS8::I64 = -I64[R1 + 7] & 7;
           if (_s2DS8::I64 != 0) goto u2GtO; else goto c2GtK;
       u2GtO: // global
           I64[Sp + 16] = _s2DS8::I64;
           Sp = Sp + 8;
           call _c2Gtl() args: 0, res: 0, upd: 0;
       c2GtK: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gtl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gtl: // global
           Hp = Hp + 16;
           _s2DS8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2GtH; else goto c2GtG;
       c2GtH: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Gtk_info;
           R1 = _s2DS8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2GtG: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2DS2::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2DS2::I64 << _s2DS8::I64) | (_s2DS2::I64 >> 8 - _s2DS8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gtk() //  [R1]
         { info_tbl: [(c2Gtk,
                       label: block_c2Gtk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gtk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Gtl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.148189615 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2Guu,
                       label: GHC.Word.$fBitsWord8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Guu: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.15225433 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2GuI,
                       label: GHC.Word.$fBitsWord8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GuI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GuM; else goto c2GuN;
       c2GuM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GuN: // global
           I64[Sp - 16] = block_c2GuF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gvd; else goto c2GuG;
       u2Gvd: // global
           call _c2GuF(R1) args: 0, res: 0, upd: 0;
       c2GuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GuF() //  [R1]
         { info_tbl: [(c2GuF,
                       label: block_c2GuF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GuF: // global
           I64[Sp - 8] = block_c2GuL_info;
           _s2DSg::P64 = R1;
           _s2DSh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DSh::I64;
           P64[Sp + 8] = _s2DSg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gvc; else goto c2GuP;
       u2Gvc: // global
           call _c2GuL(R1) args: 0, res: 0, upd: 0;
       c2GuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GuL() //  [R1]
         { info_tbl: [(c2GuL,
                       label: block_c2GuL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GuL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GuV; else goto c2GuU;
       c2GuV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GuU: // global
           _s2DSj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSj::I64, 64)) goto c2Gva; else goto c2Gvb;
       c2Gva: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSj::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gvb: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.160647803 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2GvJ,
                       label: GHC.Word.$fBitsWord8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GvN; else goto c2GvO;
       c2GvN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GvO: // global
           I64[Sp - 16] = block_c2GvG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gwm; else goto c2GvH;
       u2Gwm: // global
           call _c2GvG(R1) args: 0, res: 0, upd: 0;
       c2GvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GvG() //  [R1]
         { info_tbl: [(c2GvG,
                       label: block_c2GvG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GvG: // global
           I64[Sp] = block_c2GvM_info;
           _s2DSr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSr::I64;
           if (R1 & 7 != 0) goto u2Gwl; else goto c2GvQ;
       u2Gwl: // global
           call _c2GvM(R1) args: 0, res: 0, upd: 0;
       c2GvQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GvM() //  [R1]
         { info_tbl: [(c2GvM,
                       label: block_c2GvM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GvM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GvW; else goto c2GvV;
       c2GvW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GvV: // global
           _s2DSr::I64 = I64[Sp + 8];
           _s2DSt::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSt::I64, 64)) goto c2Gwe; else goto c2Gwk;
       c2Gwe: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DSr::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSt::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gwk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DSr::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.169607889 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2GwV,
                       label: GHC.Word.$fBitsWord8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GwV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GwZ; else goto c2Gx0;
       c2GwZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gx0: // global
           I64[Sp - 16] = block_c2GwS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gxq; else goto c2GwT;
       u2Gxq: // global
           call _c2GwS(R1) args: 0, res: 0, upd: 0;
       c2GwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GwS() //  [R1]
         { info_tbl: [(c2GwS,
                       label: block_c2GwS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GwS: // global
           I64[Sp - 8] = block_c2GwY_info;
           _s2DSC::P64 = R1;
           _s2DSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DSD::I64;
           P64[Sp + 8] = _s2DSC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gxp; else goto c2Gx2;
       u2Gxp: // global
           call _c2GwY(R1) args: 0, res: 0, upd: 0;
       c2Gx2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GwY() //  [R1]
         { info_tbl: [(c2GwY,
                       label: block_c2GwY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GwY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gx8; else goto c2Gx7;
       c2Gx8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gx7: // global
           _s2DSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSF::I64, 64)) goto c2Gxn; else goto c2Gxo;
       c2Gxn: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSF::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gxo: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.177701406 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.179834934 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.182491695 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2GxY,
                       label: GHC.Word.$fIntegralWord8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GxY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gy2; else goto c2Gy3;
       c2Gy2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gy3: // global
           I64[Sp - 16] = block_c2GxV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gym; else goto c2GxW;
       u2Gym: // global
           call _c2GxV(R1) args: 0, res: 0, upd: 0;
       c2GxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GxV() //  [R1]
         { info_tbl: [(c2GxV,
                       label: block_c2GxV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GxV: // global
           I64[Sp] = block_c2Gy1_info;
           _s2DSN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSN::I64;
           if (R1 & 7 != 0) goto u2Gyl; else goto c2Gy5;
       u2Gyl: // global
           call _c2Gy1(R1) args: 0, res: 0, upd: 0;
       c2Gy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gy1() //  [R1]
         { info_tbl: [(c2Gy1,
                       label: block_c2Gy1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gy1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gyb; else goto c2Gya;
       c2Gyb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gya: // global
           _s2DSQ::I64 = I64[R1 + 7];
           if (_s2DSQ::I64 != 0) goto c2Gyj; else goto c2Gyk;
       c2Gyj: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DSQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gyk: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.190804856 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2GyM,
                       label: GHC.Word.$fIntegralWord8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GyM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GyQ; else goto c2GyR;
       c2GyQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GyR: // global
           I64[Sp - 16] = block_c2GyJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gza; else goto c2GyK;
       u2Gza: // global
           call _c2GyJ(R1) args: 0, res: 0, upd: 0;
       c2GyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GyJ() //  [R1]
         { info_tbl: [(c2GyJ,
                       label: block_c2GyJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GyJ: // global
           I64[Sp] = block_c2GyP_info;
           _s2DSV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSV::I64;
           if (R1 & 7 != 0) goto u2Gz9; else goto c2GyT;
       u2Gz9: // global
           call _c2GyP(R1) args: 0, res: 0, upd: 0;
       c2GyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GyP() //  [R1]
         { info_tbl: [(c2GyP,
                       label: block_c2GyP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GyZ; else goto c2GyY;
       c2GyZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GyY: // global
           _s2DSY::I64 = I64[R1 + 7];
           if (_s2DSY::I64 != 0) goto c2Gz7; else goto c2Gz8;
       c2Gz7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DSY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gz8: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.199125325 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2GzA,
                       label: GHC.Word.$fIntegralWord8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GzE; else goto c2GzF;
       c2GzE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GzF: // global
           I64[Sp - 16] = block_c2Gzx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GzX; else goto c2Gzy;
       u2GzX: // global
           call _c2Gzx(R1) args: 0, res: 0, upd: 0;
       c2Gzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Gzx() //  [R1]
         { info_tbl: [(c2Gzx,
                       label: block_c2Gzx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Gzx: // global
           I64[Sp] = block_c2GzD_info;
           _s2DT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DT3::I64;
           if (R1 & 7 != 0) goto u2GzW; else goto c2GzH;
       u2GzW: // global
           call _c2GzD(R1) args: 0, res: 0, upd: 0;
       c2GzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GzD() //  [R1]
         { info_tbl: [(c2GzD,
                       label: block_c2GzD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GzD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2GzN; else goto c2GzM;
       c2GzN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GzM: // global
           _s2DT6::I64 = I64[R1 + 7];
           if (_s2DT6::I64 != 0) goto c2GzU; else goto c2GzV;
       c2GzU: // global
           (_s2DT8::I64, _s2DT9::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DT6::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2DT9::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2DT8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GzV: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.208627794 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2DTm_entry() //  [R1]
         { info_tbl: [(c2GAF,
                       label: sat_s2DTm_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GAF: // global
           _s2DTm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2GAI; else goto c2GAJ;
       c2GAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GAL; else goto c2GAK;
       c2GAL: // global
           HpAlloc = 16;
           goto c2GAI;
       c2GAI: // global
           R1 = _s2DTm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2GAK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DTm::P64;
           _s2DTl::I64 = I64[_s2DTm::P64 + 16] % I64[_s2DTm::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DTl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DTk_entry() //  [R1]
         { info_tbl: [(c2GAS,
                       label: sat_s2DTk_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GAS: // global
           _s2DTk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2GAV; else goto c2GAW;
       c2GAW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GAY; else goto c2GAX;
       c2GAY: // global
           HpAlloc = 16;
           goto c2GAV;
       c2GAV: // global
           R1 = _s2DTk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2GAX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DTk::P64;
           _s2DTj::I64 = I64[_s2DTk::P64 + 16] / I64[_s2DTk::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DTj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2GAZ,
                       label: GHC.Word.$fIntegralWord8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GB0; else goto c2GB1;
       c2GB0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GB1: // global
           I64[Sp - 16] = block_c2GAn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GBb; else goto c2GAo;
       u2GBb: // global
           call _c2GAn(R1) args: 0, res: 0, upd: 0;
       c2GAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GAn() //  [R1]
         { info_tbl: [(c2GAn,
                       label: block_c2GAn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GAn: // global
           I64[Sp] = block_c2GAs_info;
           _s2DTf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTf::I64;
           if (R1 & 7 != 0) goto u2GBa; else goto c2GAt;
       u2GBa: // global
           call _c2GAs(R1) args: 0, res: 0, upd: 0;
       c2GAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GAs() //  [R1]
         { info_tbl: [(c2GAs,
                       label: block_c2GAs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GAs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2GB5; else goto c2GB4;
       c2GB5: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GB4: // global
           _s2DTi::I64 = I64[R1 + 7];
           if (_s2DTi::I64 != 0) goto c2GB8; else goto c2GB9;
       c2GB8: // global
           I64[Hp - 80] = sat_s2DTm_info;
           _s2DTf::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DTf::I64;
           I64[Hp - 56] = _s2DTi::I64;
           I64[Hp - 48] = sat_s2DTk_info;
           I64[Hp - 32] = _s2DTf::I64;
           I64[Hp - 24] = _s2DTi::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GB9: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.221771592 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { info_tbl: [(c2GBS,
                       label: GHC.Word.gtWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GBS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GBW; else goto c2GBX;
       c2GBW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GBX: // global
           I64[Sp - 16] = block_c2GBP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GC6; else goto c2GBQ;
       u2GC6: // global
           call _c2GBP(R1) args: 0, res: 0, upd: 0;
       c2GBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GBP() //  [R1]
         { info_tbl: [(c2GBP,
                       label: block_c2GBP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GBP: // global
           I64[Sp] = block_c2GBV_info;
           _s2DTq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTq::I64;
           if (R1 & 7 != 0) goto u2GC5; else goto c2GBZ;
       u2GC5: // global
           call _c2GBV(R1) args: 0, res: 0, upd: 0;
       c2GBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GBV() //  [R1]
         { info_tbl: [(c2GBV,
                       label: block_c2GBV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GBV: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.229340809 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { info_tbl: [(c2GCy,
                       label: GHC.Word.geWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GCy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GCC; else goto c2GCD;
       c2GCC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GCD: // global
           I64[Sp - 16] = block_c2GCv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GCM; else goto c2GCw;
       u2GCM: // global
           call _c2GCv(R1) args: 0, res: 0, upd: 0;
       c2GCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GCv() //  [R1]
         { info_tbl: [(c2GCv,
                       label: block_c2GCv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GCv: // global
           I64[Sp] = block_c2GCB_info;
           _s2DTx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTx::I64;
           if (R1 & 7 != 0) goto u2GCL; else goto c2GCF;
       u2GCL: // global
           call _c2GCB(R1) args: 0, res: 0, upd: 0;
       c2GCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GCB() //  [R1]
         { info_tbl: [(c2GCB,
                       label: block_c2GCB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GCB: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.236706677 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { info_tbl: [(c2GDe,
                       label: GHC.Word.ltWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GDi; else goto c2GDj;
       c2GDi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GDj: // global
           I64[Sp - 16] = block_c2GDb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GDs; else goto c2GDc;
       u2GDs: // global
           call _c2GDb(R1) args: 0, res: 0, upd: 0;
       c2GDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GDb() //  [R1]
         { info_tbl: [(c2GDb,
                       label: block_c2GDb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDb: // global
           I64[Sp] = block_c2GDh_info;
           _s2DTE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTE::I64;
           if (R1 & 7 != 0) goto u2GDr; else goto c2GDl;
       u2GDr: // global
           call _c2GDh(R1) args: 0, res: 0, upd: 0;
       c2GDl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GDh() //  [R1]
         { info_tbl: [(c2GDh,
                       label: block_c2GDh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDh: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.245069707 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { info_tbl: [(c2GDU,
                       label: GHC.Word.leWord8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GDY; else goto c2GDZ;
       c2GDY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GDZ: // global
           I64[Sp - 16] = block_c2GDR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GE8; else goto c2GDS;
       u2GE8: // global
           call _c2GDR(R1) args: 0, res: 0, upd: 0;
       c2GDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GDR() //  [R1]
         { info_tbl: [(c2GDR,
                       label: block_c2GDR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDR: // global
           I64[Sp] = block_c2GDX_info;
           _s2DTL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTL::I64;
           if (R1 & 7 != 0) goto u2GE7; else goto c2GE1;
       u2GE7: // global
           call _c2GDX(R1) args: 0, res: 0, upd: 0;
       c2GE1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GDX() //  [R1]
         { info_tbl: [(c2GDX,
                       label: block_c2GDX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GDX: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.252580057 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2GEA,
                       label: GHC.Word.$fOrdWord8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GEA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GEE; else goto c2GEF;
       c2GEE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GEF: // global
           I64[Sp - 16] = block_c2GEx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GEY; else goto c2GEy;
       u2GEY: // global
           call _c2GEx(R1) args: 0, res: 0, upd: 0;
       c2GEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GEx() //  [R1]
         { info_tbl: [(c2GEx,
                       label: block_c2GEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GEx: // global
           I64[Sp] = block_c2GED_info;
           _s2DTS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTS::I64;
           if (R1 & 7 != 0) goto u2GEX; else goto c2GEH;
       u2GEX: // global
           call _c2GED(R1) args: 0, res: 0, upd: 0;
       c2GEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GED() //  [R1]
         { info_tbl: [(c2GED,
                       label: block_c2GED_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GED: // global
           _s2DTS::I64 = I64[Sp + 8];
           _s2DTU::I64 = I64[R1 + 7];
           if (_s2DTS::I64 == _s2DTU::I64) goto c2GEW; else goto c2GEV;
       c2GEW: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GEV: // global
           if (_s2DTS::I64 > _s2DTU::I64) goto c2GES; else goto c2GET;
       c2GES: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GET: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.260641875 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2GFr,
                       label: GHC.Word.$fOrdWord8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GFr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GFv; else goto c2GFw;
       c2GFv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GFw: // global
           I64[Sp - 16] = block_c2GFo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GFJ; else goto c2GFp;
       u2GFJ: // global
           call _c2GFo(R1) args: 0, res: 0, upd: 0;
       c2GFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GFo() //  [R1]
         { info_tbl: [(c2GFo,
                       label: block_c2GFo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GFo: // global
           I64[Sp - 8] = block_c2GFu_info;
           _s2DTZ::P64 = R1;
           _s2DU0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DU0::I64;
           P64[Sp + 8] = _s2DTZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GFI; else goto c2GFy;
       u2GFI: // global
           call _c2GFu(R1) args: 0, res: 0, upd: 0;
       c2GFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GFu() //  [R1]
         { info_tbl: [(c2GFu,
                       label: block_c2GFu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GFu: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2GFG; else goto c2GFH;
       c2GFG: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GFH: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.268581501 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2GGb,
                       label: GHC.Word.$fOrdWord8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GGb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GGf; else goto c2GGg;
       c2GGf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GGg: // global
           I64[Sp - 16] = block_c2GG8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GGt; else goto c2GG9;
       u2GGt: // global
           call _c2GG8(R1) args: 0, res: 0, upd: 0;
       c2GG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GG8() //  [R1]
         { info_tbl: [(c2GG8,
                       label: block_c2GG8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GG8: // global
           I64[Sp - 8] = block_c2GGe_info;
           _s2DU6::P64 = R1;
           _s2DU7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DU7::I64;
           P64[Sp + 8] = _s2DU6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GGs; else goto c2GGi;
       u2GGs: // global
           call _c2GGe(R1) args: 0, res: 0, upd: 0;
       c2GGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GGe() //  [R1]
         { info_tbl: [(c2GGe,
                       label: block_c2GGe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GGe: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2GGq; else goto c2GGr;
       c2GGq: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GGr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.275739001 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.27837426 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2GGW,
                       label: GHC.Word.$fIxWord8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GGW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GH5; else goto c2GH6;
       c2GH5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GH6: // global
           I64[Sp - 16] = block_c2GGT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GHt; else goto c2GGU;
       u2GHt: // global
           call _c2GGT(R1) args: 0, res: 0, upd: 0;
       c2GGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GGT() //  [R1]
         { info_tbl: [(c2GGT,
                       label: block_c2GGT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GGT: // global
           I64[Sp - 8] = block_c2GGZ_info;
           _s2DUf::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DUf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GHs; else goto c2GH0;
       u2GHs: // global
           call _c2GGZ(R1) args: 0, res: 0, upd: 0;
       c2GH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GGZ() //  [R1]
         { info_tbl: [(c2GGZ,
                       label: block_c2GGZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GGZ: // global
           I64[Sp] = block_c2GH4_info;
           _s2DUh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DUh::I64;
           if (R1 & 7 != 0) goto u2GHu; else goto c2GH9;
       u2GHu: // global
           call _c2GH4(R1) args: 0, res: 0, upd: 0;
       c2GH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GH4() //  [R1]
         { info_tbl: [(c2GH4,
                       label: block_c2GH4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GH4: // global
           _s2DUj::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DUj::I64) goto c2GHh; else goto c2GHl;
       c2GHh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GHl: // global
           _s2DUf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2GHk_info;
           R1 = _s2DUf::P64;
           I64[Sp + 16] = _s2DUj::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2GHv; else goto c2GHm;
       u2GHv: // global
           call _c2GHk(R1) args: 0, res: 0, upd: 0;
       c2GHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GHk() //  [R1]
         { info_tbl: [(c2GHk,
                       label: block_c2GHk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GHk: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.290456109 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2GI9,
                       label: GHC.Word.$fRealWord8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GI9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GIq; else goto c2GIr;
       c2GIq: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GIr: // global
           I64[Sp - 8] = block_c2GI6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GIy; else goto c2GI7;
       u2GIy: // global
           call _c2GI6(R1) args: 0, res: 0, upd: 0;
       c2GI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GI6() //  [R1]
         { info_tbl: [(c2GI6,
                       label: block_c2GI6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GI6: // global
           I64[Sp] = block_c2GIf_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2GIf() //  [R1]
         { info_tbl: [(c2GIf,
                       label: block_c2GIf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GIf: // global
           I64[Sp] = block_c2GIj_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2GIj() //  [R1]
         { info_tbl: [(c2GIj,
                       label: block_c2GIj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GIj: // global
           I64[Sp] = block_c2GIn_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2GIn() //  [R1, R2]
         { info_tbl: [(c2GIn,
                       label: block_c2GIn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GIn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2GIx; else goto c2GIw;
       c2GIx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2GIw: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.300842131 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.302678326 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.305384672 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2GJ6,
                       label: GHC.Word.$fIxWord8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GJt; else goto c2GJu;
       c2GJt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GJu: // global
           I64[Sp - 16] = block_c2GJ3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GJB; else goto c2GJ4;
       u2GJB: // global
           call _c2GJ3(R1) args: 0, res: 0, upd: 0;
       c2GJ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GJ3() //  [R1]
         { info_tbl: [(c2GJ3,
                       label: block_c2GJ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GJ3: // global
           I64[Sp] = block_c2GJ9_info;
           _s2DUA::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2DUA::P64;
           if (R1 & 7 != 0) goto u2GJA; else goto c2GJa;
       u2GJA: // global
           call _c2GJ9(R1) args: 0, res: 0, upd: 0;
       c2GJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GJ9() //  [R1]
         { info_tbl: [(c2GJ9,
                       label: block_c2GJ9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GJ9: // global
           I64[Sp] = block_c2GJe_info;
           _s2DUD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DUD::I64;
           if (R1 & 7 != 0) goto u2GJC; else goto c2GJf;
       u2GJC: // global
           call _c2GJe(R1) args: 0, res: 0, upd: 0;
       c2GJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GJe() //  [R1]
         { info_tbl: [(c2GJe,
                       label: block_c2GJe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GJe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GJz; else goto c2GJy;
       c2GJz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GJy: // global
           _s2DUI::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DUI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.31503808 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { info_tbl: [(c2GK9,
                       label: GHC.Word.$fIxWord8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GK9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GKa; else goto c2GKb;
       c2GKa: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GKb: // global
           I64[Sp - 8] = block_c2GK6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GKf; else goto c2GK7;
       u2GKf: // global
           call _c2GK6(R1) args: 0, res: 0, upd: 0;
       c2GK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GK6() //  [R1]
         { info_tbl: [(c2GK6,
                       label: block_c2GK6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GK6: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.320870714 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.323262221 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2GKy,
                       label: GHC.Word.$fIxWord8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GKH; else goto c2GKI;
       c2GKH: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GKI: // global
           I64[Sp - 8] = block_c2GKv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GLd; else goto c2GKw;
       u2GLd: // global
           call _c2GKv(R1) args: 0, res: 0, upd: 0;
       c2GKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GKv() //  [R1]
         { info_tbl: [(c2GKv,
                       label: block_c2GKv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GKv: // global
           I64[Sp - 8] = block_c2GKB_info;
           _s2DUQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DUQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GLc; else goto c2GKC;
       u2GLc: // global
           call _c2GKB(R1) args: 0, res: 0, upd: 0;
       c2GKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GKB() //  [R1]
         { info_tbl: [(c2GKB,
                       label: block_c2GKB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GKB: // global
           I64[Sp] = block_c2GKG_info;
           _s2DUS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DUS::I64;
           if (R1 & 7 != 0) goto u2GLe; else goto c2GKL;
       u2GLe: // global
           call _c2GKG(R1) args: 0, res: 0, upd: 0;
       c2GKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GKG() //  [R1]
         { info_tbl: [(c2GKG,
                       label: block_c2GKG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GKG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GKR; else goto c2GKQ;
       c2GKR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GKQ: // global
           _s2DUS::I64 = I64[Sp + 8];
           _s2DUU::I64 = I64[R1 + 7];
           if (_s2DUS::I64 > _s2DUU::I64) goto c2GKV; else goto c2GLb;
       c2GKV: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GLb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DUU::I64 - _s2DUS::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.333350779 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2GLN,
                       label: GHC.Word.$fIxWord8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GMd; else goto c2GMe;
       c2GMd: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GMe: // global
           I64[Sp - 8] = block_c2GLK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GMl; else goto c2GLL;
       u2GMl: // global
           call _c2GLK(R1) args: 0, res: 0, upd: 0;
       c2GLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GLK() //  [R1]
         { info_tbl: [(c2GLK,
                       label: block_c2GLK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GLK: // global
           I64[Sp - 8] = block_c2GLQ_info;
           _s2DV2::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2DV2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GMk; else goto c2GLR;
       u2GMk: // global
           call _c2GLQ(R1) args: 0, res: 0, upd: 0;
       c2GLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GLQ() //  [R1]
         { info_tbl: [(c2GLQ,
                       label: block_c2GLQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GLQ: // global
           I64[Sp] = block_c2GLV_info;
           _s2DV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DV5::I64;
           if (R1 & 7 != 0) goto u2GMm; else goto c2GLW;
       u2GMm: // global
           call _c2GLV(R1) args: 0, res: 0, upd: 0;
       c2GLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GLV() //  [R1]
         { info_tbl: [(c2GLV,
                       label: block_c2GLV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GLV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GMj; else goto c2GMi;
       c2GMj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GMi: // global
           _s2DVb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DVb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.343626965 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2GMU,
                       label: GHC.Word.$fIxWord8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GMU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GN3; else goto c2GN4;
       c2GN3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GN4: // global
           I64[Sp - 16] = block_c2GMR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GNJ; else goto c2GMS;
       u2GNJ: // global
           call _c2GMR(R1) args: 0, res: 0, upd: 0;
       c2GMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GMR() //  [R1]
         { info_tbl: [(c2GMR,
                       label: block_c2GMR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GMR: // global
           I64[Sp - 8] = block_c2GMX_info;
           _s2DVg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DVg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GNI; else goto c2GMY;
       u2GNI: // global
           call _c2GMX(R1) args: 0, res: 0, upd: 0;
       c2GMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GMX() //  [R1]
         { info_tbl: [(c2GMX,
                       label: block_c2GMX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GMX: // global
           I64[Sp] = block_c2GN2_info;
           _s2DVi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DVi::I64;
           if (R1 & 7 != 0) goto u2GNK; else goto c2GN7;
       u2GNK: // global
           call _c2GN2(R1) args: 0, res: 0, upd: 0;
       c2GN7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GN2() //  [R1]
         { info_tbl: [(c2GN2,
                       label: block_c2GN2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GN2: // global
           _s2DVk::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DVk::I64) goto c2GNf; else goto c2GNj;
       c2GNf: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GNj: // global
           I64[Sp] = block_c2GNi_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVk::I64;
           if (R1 & 7 != 0) goto u2GNL; else goto c2GNk;
       u2GNL: // global
           call _c2GNi(R1) args: 0, res: 0, upd: 0;
       c2GNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GNi() //  [R1]
         { info_tbl: [(c2GNi,
                       label: block_c2GNi_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GNi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GNq; else goto c2GNp;
       c2GNq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GNp: // global
           _s2DVk::I64 = I64[Sp + 8];
           if (_s2DVk::I64 > I64[R1 + 7]) goto c2GNu; else goto c2GNH;
       c2GNu: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GNH: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DVk::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.355113001 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.358031092 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { info_tbl: [(c2GOq,
                       label: GHC.Word.eqWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GOq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GOu; else goto c2GOv;
       c2GOu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GOv: // global
           I64[Sp - 16] = block_c2GOn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GOE; else goto c2GOo;
       u2GOE: // global
           call _c2GOn(R1) args: 0, res: 0, upd: 0;
       c2GOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GOn() //  [R1]
         { info_tbl: [(c2GOn,
                       label: block_c2GOn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GOn: // global
           I64[Sp] = block_c2GOt_info;
           _s2DVv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVv::I64;
           if (R1 & 7 != 0) goto u2GOD; else goto c2GOx;
       u2GOD: // global
           call _c2GOt(R1) args: 0, res: 0, upd: 0;
       c2GOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GOt() //  [R1]
         { info_tbl: [(c2GOt,
                       label: block_c2GOt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GOt: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.364984197 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.366783117 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.368799702 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { info_tbl: [(c2GP8,
                       label: GHC.Word.$fNumWord16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GP8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GP9; else goto c2GPa;
       c2GP9: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GPa: // global
           I64[Sp - 8] = block_c2GP5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GPi; else goto c2GP6;
       u2GPi: // global
           call _c2GP5(R1) args: 0, res: 0, upd: 0;
       c2GP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GP5() //  [R1]
         { info_tbl: [(c2GP5,
                       label: block_c2GP5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GP5: // global
           if (I64[R1 + 7] == 0) goto c2GPh; else goto c2GPg;
       c2GPh: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GPg: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.374865575 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.377071496 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2GPD,
                       label: GHC.Word.$fBitsWord16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GPD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GPK; else goto c2GPL;
       c2GPK: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GPL: // global
           I64[Sp - 8] = block_c2GPA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GPP; else goto c2GPB;
       u2GPP: // global
           call _c2GPA(R1) args: 0, res: 0, upd: 0;
       c2GPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GPA() //  [R1]
         { info_tbl: [(c2GPA,
                       label: block_c2GPA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GPA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GPO; else goto c2GPN;
       c2GPO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GPN: // global
           _s2DVG::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DVG::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.382776429 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.384719011 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2GQ8,
                       label: GHC.Word.$fBitsWord16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GQ8: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.389001162 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { info_tbl: [(c2GQn,
                       label: GHC.Word.$fBitsWord16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GQn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GQo; else goto c2GQp;
       c2GQo: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GQp: // global
           I64[Sp - 8] = block_c2GQk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GQI; else goto c2GQl;
       u2GQI: // global
           call _c2GQk(R1) args: 0, res: 0, upd: 0;
       c2GQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GQk() //  [R1]
         { info_tbl: [(c2GQk,
                       label: block_c2GQk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GQk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GQu; else goto c2GQt;
       c2GQu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GQt: // global
           _s2DVK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DVK::I64, 64)) goto c2GQG; else goto c2GQH;
       c2GQG: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DVK::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GQH: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.396344643 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2GR6,
                       label: GHC.Word.$fBitsWord16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GRa; else goto c2GRb;
       c2GRa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GRb: // global
           I64[Sp - 16] = block_c2GR3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GRK; else goto c2GR4;
       u2GRK: // global
           call _c2GR3(R1) args: 0, res: 0, upd: 0;
       c2GR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GR3() //  [R1]
         { info_tbl: [(c2GR3,
                       label: block_c2GR3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GR3: // global
           I64[Sp] = block_c2GR9_info;
           _s2DVR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVR::I64;
           if (R1 & 7 != 0) goto u2GRJ; else goto c2GRd;
       u2GRJ: // global
           call _c2GR9(R1) args: 0, res: 0, upd: 0;
       c2GRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GR9() //  [R1]
         { info_tbl: [(c2GR9,
                       label: block_c2GR9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GR9: // global
           _s2DVT::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DVT::I64, 64)) goto c2GRI; else goto c2GRH;
       c2GRH: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DVT::I64)) == 0) goto c2GRI; else goto c2GRw;
       c2GRI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GRw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.404645299 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2GSg,
                       label: GHC.Word.$fBitsWord16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GSg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GSk; else goto c2GSl;
       c2GSk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GSl: // global
           I64[Sp - 16] = block_c2GSd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GTb; else goto c2GSe;
       u2GTb: // global
           call _c2GSd(R1) args: 0, res: 0, upd: 0;
       c2GSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GSd() //  [R1]
         { info_tbl: [(c2GSd,
                       label: block_c2GSd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GSd: // global
           I64[Sp - 8] = block_c2GSj_info;
           _s2DW0::P64 = R1;
           _s2DW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DW1::I64;
           P64[Sp + 8] = _s2DW0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GTa; else goto c2GSn;
       u2GTa: // global
           call _c2GSj(R1) args: 0, res: 0, upd: 0;
       c2GSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GSj() //  [R1]
         { info_tbl: [(c2GSj,
                       label: block_c2GSj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GSj: // global
           _s2DW7::I64 = -I64[R1 + 7] & 15;
           if (_s2DW7::I64 != 0) goto u2GT8; else goto c2GT4;
       u2GT8: // global
           I64[Sp + 16] = _s2DW7::I64;
           Sp = Sp + 8;
           call _c2GSF() args: 0, res: 0, upd: 0;
       c2GT4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2GSF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GSF: // global
           Hp = Hp + 16;
           _s2DW7::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2GT1; else goto c2GT0;
       c2GT1: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2GSE_info;
           R1 = _s2DW7::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2GT0: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2DW1::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2DW1::I64 << _s2DW7::I64) | (_s2DW1::I64 >> 16 - _s2DW7::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2GSE() //  [R1]
         { info_tbl: [(c2GSE,
                       label: block_c2GSE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GSE: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2GSF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.415623711 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2GTO,
                       label: GHC.Word.$fBitsWord16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GTO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.419545367 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2GU2,
                       label: GHC.Word.$fBitsWord16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GU2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GU6; else goto c2GU7;
       c2GU6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GU7: // global
           I64[Sp - 16] = block_c2GTZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GUx; else goto c2GU0;
       u2GUx: // global
           call _c2GTZ(R1) args: 0, res: 0, upd: 0;
       c2GU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GTZ() //  [R1]
         { info_tbl: [(c2GTZ,
                       label: block_c2GTZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GTZ: // global
           I64[Sp - 8] = block_c2GU5_info;
           _s2DWf::P64 = R1;
           _s2DWg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DWg::I64;
           P64[Sp + 8] = _s2DWf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GUw; else goto c2GU9;
       u2GUw: // global
           call _c2GU5(R1) args: 0, res: 0, upd: 0;
       c2GU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GU5() //  [R1]
         { info_tbl: [(c2GU5,
                       label: block_c2GU5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GU5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GUf; else goto c2GUe;
       c2GUf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GUe: // global
           _s2DWi::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWi::I64, 64)) goto c2GUu; else goto c2GUv;
       c2GUu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWi::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GUv: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.428182804 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2GV3,
                       label: GHC.Word.$fBitsWord16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GV7; else goto c2GV8;
       c2GV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GV8: // global
           I64[Sp - 16] = block_c2GV0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GVG; else goto c2GV1;
       u2GVG: // global
           call _c2GV0(R1) args: 0, res: 0, upd: 0;
       c2GV1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GV0() //  [R1]
         { info_tbl: [(c2GV0,
                       label: block_c2GV0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GV0: // global
           I64[Sp] = block_c2GV6_info;
           _s2DWq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWq::I64;
           if (R1 & 7 != 0) goto u2GVF; else goto c2GVa;
       u2GVF: // global
           call _c2GV6(R1) args: 0, res: 0, upd: 0;
       c2GVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GV6() //  [R1]
         { info_tbl: [(c2GV6,
                       label: block_c2GV6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GV6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GVg; else goto c2GVf;
       c2GVg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GVf: // global
           _s2DWq::I64 = I64[Sp + 8];
           _s2DWs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWs::I64, 64)) goto c2GVy; else goto c2GVE;
       c2GVy: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DWq::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWs::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GVE: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DWq::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.437208808 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2GWf,
                       label: GHC.Word.$fBitsWord16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GWf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GWj; else goto c2GWk;
       c2GWj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GWk: // global
           I64[Sp - 16] = block_c2GWc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GWK; else goto c2GWd;
       u2GWK: // global
           call _c2GWc(R1) args: 0, res: 0, upd: 0;
       c2GWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GWc() //  [R1]
         { info_tbl: [(c2GWc,
                       label: block_c2GWc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GWc: // global
           I64[Sp - 8] = block_c2GWi_info;
           _s2DWB::P64 = R1;
           _s2DWC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DWC::I64;
           P64[Sp + 8] = _s2DWB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GWJ; else goto c2GWm;
       u2GWJ: // global
           call _c2GWi(R1) args: 0, res: 0, upd: 0;
       c2GWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GWi() //  [R1]
         { info_tbl: [(c2GWi,
                       label: block_c2GWi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GWi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GWs; else goto c2GWr;
       c2GWs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GWr: // global
           _s2DWE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWE::I64, 64)) goto c2GWH; else goto c2GWI;
       c2GWH: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWE::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GWI: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.445084462 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.447275253 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.449777887 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2GXi,
                       label: GHC.Word.$fIntegralWord16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GXm; else goto c2GXn;
       c2GXm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GXn: // global
           I64[Sp - 16] = block_c2GXf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GXG; else goto c2GXg;
       u2GXG: // global
           call _c2GXf(R1) args: 0, res: 0, upd: 0;
       c2GXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GXf() //  [R1]
         { info_tbl: [(c2GXf,
                       label: block_c2GXf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GXf: // global
           I64[Sp] = block_c2GXl_info;
           _s2DWM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWM::I64;
           if (R1 & 7 != 0) goto u2GXF; else goto c2GXp;
       u2GXF: // global
           call _c2GXl(R1) args: 0, res: 0, upd: 0;
       c2GXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GXl() //  [R1]
         { info_tbl: [(c2GXl,
                       label: block_c2GXl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GXl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GXv; else goto c2GXu;
       c2GXv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GXu: // global
           _s2DWP::I64 = I64[R1 + 7];
           if (_s2DWP::I64 != 0) goto c2GXD; else goto c2GXE;
       c2GXD: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DWP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GXE: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.458523253 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2GY6,
                       label: GHC.Word.$fIntegralWord16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GY6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GYa; else goto c2GYb;
       c2GYa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GYb: // global
           I64[Sp - 16] = block_c2GY3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GYu; else goto c2GY4;
       u2GYu: // global
           call _c2GY3(R1) args: 0, res: 0, upd: 0;
       c2GY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GY3() //  [R1]
         { info_tbl: [(c2GY3,
                       label: block_c2GY3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GY3: // global
           I64[Sp] = block_c2GY9_info;
           _s2DWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWU::I64;
           if (R1 & 7 != 0) goto u2GYt; else goto c2GYd;
       u2GYt: // global
           call _c2GY9(R1) args: 0, res: 0, upd: 0;
       c2GYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GY9() //  [R1]
         { info_tbl: [(c2GY9,
                       label: block_c2GY9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GY9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GYj; else goto c2GYi;
       c2GYj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GYi: // global
           _s2DWX::I64 = I64[R1 + 7];
           if (_s2DWX::I64 != 0) goto c2GYr; else goto c2GYs;
       c2GYr: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GYs: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.466715023 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2GYU,
                       label: GHC.Word.$fIntegralWord16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GYY; else goto c2GYZ;
       c2GYY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GYZ: // global
           I64[Sp - 16] = block_c2GYR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GZh; else goto c2GYS;
       u2GZh: // global
           call _c2GYR(R1) args: 0, res: 0, upd: 0;
       c2GYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GYR() //  [R1]
         { info_tbl: [(c2GYR,
                       label: block_c2GYR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GYR: // global
           I64[Sp] = block_c2GYX_info;
           _s2DX2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DX2::I64;
           if (R1 & 7 != 0) goto u2GZg; else goto c2GZ1;
       u2GZg: // global
           call _c2GYX(R1) args: 0, res: 0, upd: 0;
       c2GZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GYX() //  [R1]
         { info_tbl: [(c2GYX,
                       label: block_c2GYX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GYX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2GZ7; else goto c2GZ6;
       c2GZ7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GZ6: // global
           _s2DX5::I64 = I64[R1 + 7];
           if (_s2DX5::I64 != 0) goto c2GZe; else goto c2GZf;
       c2GZe: // global
           (_s2DX7::I64, _s2DX8::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DX5::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2DX8::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2DX7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GZf: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.476580194 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2DXl_entry() //  [R1]
         { info_tbl: [(c2GZZ,
                       label: sat_s2DXl_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GZZ: // global
           _s2DXl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2H02; else goto c2H03;
       c2H03: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H05; else goto c2H04;
       c2H05: // global
           HpAlloc = 16;
           goto c2H02;
       c2H02: // global
           R1 = _s2DXl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2H04: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DXl::P64;
           _s2DXk::I64 = I64[_s2DXl::P64 + 16] % I64[_s2DXl::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DXk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2DXj_entry() //  [R1]
         { info_tbl: [(c2H0c,
                       label: sat_s2DXj_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H0c: // global
           _s2DXj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2H0f; else goto c2H0g;
       c2H0g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H0i; else goto c2H0h;
       c2H0i: // global
           HpAlloc = 16;
           goto c2H0f;
       c2H0f: // global
           R1 = _s2DXj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2H0h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DXj::P64;
           _s2DXi::I64 = I64[_s2DXj::P64 + 16] / I64[_s2DXj::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DXi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2H0j,
                       label: GHC.Word.$fIntegralWord16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H0j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H0k; else goto c2H0l;
       c2H0k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H0l: // global
           I64[Sp - 16] = block_c2GZH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H0v; else goto c2GZI;
       u2H0v: // global
           call _c2GZH(R1) args: 0, res: 0, upd: 0;
       c2GZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GZH() //  [R1]
         { info_tbl: [(c2GZH,
                       label: block_c2GZH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GZH: // global
           I64[Sp] = block_c2GZM_info;
           _s2DXe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXe::I64;
           if (R1 & 7 != 0) goto u2H0u; else goto c2GZN;
       u2H0u: // global
           call _c2GZM(R1) args: 0, res: 0, upd: 0;
       c2GZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2GZM() //  [R1]
         { info_tbl: [(c2GZM,
                       label: block_c2GZM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2GZM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2H0p; else goto c2H0o;
       c2H0p: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2H0o: // global
           _s2DXh::I64 = I64[R1 + 7];
           if (_s2DXh::I64 != 0) goto c2H0s; else goto c2H0t;
       c2H0s: // global
           I64[Hp - 80] = sat_s2DXl_info;
           _s2DXe::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DXe::I64;
           I64[Hp - 56] = _s2DXh::I64;
           I64[Hp - 48] = sat_s2DXj_info;
           I64[Hp - 32] = _s2DXe::I64;
           I64[Hp - 24] = _s2DXh::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H0t: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.489853396 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { info_tbl: [(c2H1c,
                       label: GHC.Word.gtWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H1g; else goto c2H1h;
       c2H1g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H1h: // global
           I64[Sp - 16] = block_c2H19_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H1q; else goto c2H1a;
       u2H1q: // global
           call _c2H19(R1) args: 0, res: 0, upd: 0;
       c2H1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H19() //  [R1]
         { info_tbl: [(c2H19,
                       label: block_c2H19_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H19: // global
           I64[Sp] = block_c2H1f_info;
           _s2DXp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXp::I64;
           if (R1 & 7 != 0) goto u2H1p; else goto c2H1j;
       u2H1p: // global
           call _c2H1f(R1) args: 0, res: 0, upd: 0;
       c2H1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H1f() //  [R1]
         { info_tbl: [(c2H1f,
                       label: block_c2H1f_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H1f: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.497428006 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { info_tbl: [(c2H1S,
                       label: GHC.Word.geWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H1S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H1W; else goto c2H1X;
       c2H1W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H1X: // global
           I64[Sp - 16] = block_c2H1P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H26; else goto c2H1Q;
       u2H26: // global
           call _c2H1P(R1) args: 0, res: 0, upd: 0;
       c2H1Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H1P() //  [R1]
         { info_tbl: [(c2H1P,
                       label: block_c2H1P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H1P: // global
           I64[Sp] = block_c2H1V_info;
           _s2DXw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXw::I64;
           if (R1 & 7 != 0) goto u2H25; else goto c2H1Z;
       u2H25: // global
           call _c2H1V(R1) args: 0, res: 0, upd: 0;
       c2H1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H1V() //  [R1]
         { info_tbl: [(c2H1V,
                       label: block_c2H1V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H1V: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.50508612 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { info_tbl: [(c2H2y,
                       label: GHC.Word.ltWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H2y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H2C; else goto c2H2D;
       c2H2C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H2D: // global
           I64[Sp - 16] = block_c2H2v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H2M; else goto c2H2w;
       u2H2M: // global
           call _c2H2v(R1) args: 0, res: 0, upd: 0;
       c2H2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H2v() //  [R1]
         { info_tbl: [(c2H2v,
                       label: block_c2H2v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H2v: // global
           I64[Sp] = block_c2H2B_info;
           _s2DXD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXD::I64;
           if (R1 & 7 != 0) goto u2H2L; else goto c2H2F;
       u2H2L: // global
           call _c2H2B(R1) args: 0, res: 0, upd: 0;
       c2H2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H2B() //  [R1]
         { info_tbl: [(c2H2B,
                       label: block_c2H2B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H2B: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.513599129 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { info_tbl: [(c2H3e,
                       label: GHC.Word.leWord16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H3i; else goto c2H3j;
       c2H3i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H3j: // global
           I64[Sp - 16] = block_c2H3b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H3s; else goto c2H3c;
       u2H3s: // global
           call _c2H3b(R1) args: 0, res: 0, upd: 0;
       c2H3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H3b() //  [R1]
         { info_tbl: [(c2H3b,
                       label: block_c2H3b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3b: // global
           I64[Sp] = block_c2H3h_info;
           _s2DXK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXK::I64;
           if (R1 & 7 != 0) goto u2H3r; else goto c2H3l;
       u2H3r: // global
           call _c2H3h(R1) args: 0, res: 0, upd: 0;
       c2H3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H3h() //  [R1]
         { info_tbl: [(c2H3h,
                       label: block_c2H3h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3h: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.521066274 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2H3U,
                       label: GHC.Word.$fOrdWord16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H3Y; else goto c2H3Z;
       c2H3Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H3Z: // global
           I64[Sp - 16] = block_c2H3R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H4i; else goto c2H3S;
       u2H4i: // global
           call _c2H3R(R1) args: 0, res: 0, upd: 0;
       c2H3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H3R() //  [R1]
         { info_tbl: [(c2H3R,
                       label: block_c2H3R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3R: // global
           I64[Sp] = block_c2H3X_info;
           _s2DXR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXR::I64;
           if (R1 & 7 != 0) goto u2H4h; else goto c2H41;
       u2H4h: // global
           call _c2H3X(R1) args: 0, res: 0, upd: 0;
       c2H41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H3X() //  [R1]
         { info_tbl: [(c2H3X,
                       label: block_c2H3X_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H3X: // global
           _s2DXR::I64 = I64[Sp + 8];
           _s2DXT::I64 = I64[R1 + 7];
           if (_s2DXR::I64 == _s2DXT::I64) goto c2H4g; else goto c2H4f;
       c2H4g: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H4f: // global
           if (_s2DXR::I64 > _s2DXT::I64) goto c2H4c; else goto c2H4d;
       c2H4c: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H4d: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.529405381 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2H4L,
                       label: GHC.Word.$fOrdWord16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H4L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H4P; else goto c2H4Q;
       c2H4P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H4Q: // global
           I64[Sp - 16] = block_c2H4I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H53; else goto c2H4J;
       u2H53: // global
           call _c2H4I(R1) args: 0, res: 0, upd: 0;
       c2H4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H4I() //  [R1]
         { info_tbl: [(c2H4I,
                       label: block_c2H4I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H4I: // global
           I64[Sp - 8] = block_c2H4O_info;
           _s2DXY::P64 = R1;
           _s2DXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DXZ::I64;
           P64[Sp + 8] = _s2DXY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H52; else goto c2H4S;
       u2H52: // global
           call _c2H4O(R1) args: 0, res: 0, upd: 0;
       c2H4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H4O() //  [R1]
         { info_tbl: [(c2H4O,
                       label: block_c2H4O_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H4O: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2H50; else goto c2H51;
       c2H50: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2H51: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.537119158 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2H5v,
                       label: GHC.Word.$fOrdWord16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H5v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H5z; else goto c2H5A;
       c2H5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H5A: // global
           I64[Sp - 16] = block_c2H5s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H5N; else goto c2H5t;
       u2H5N: // global
           call _c2H5s(R1) args: 0, res: 0, upd: 0;
       c2H5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H5s() //  [R1]
         { info_tbl: [(c2H5s,
                       label: block_c2H5s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H5s: // global
           I64[Sp - 8] = block_c2H5y_info;
           _s2DY5::P64 = R1;
           _s2DY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DY6::I64;
           P64[Sp + 8] = _s2DY5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H5M; else goto c2H5C;
       u2H5M: // global
           call _c2H5y(R1) args: 0, res: 0, upd: 0;
       c2H5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H5y() //  [R1]
         { info_tbl: [(c2H5y,
                       label: block_c2H5y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H5y: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2H5K; else goto c2H5L;
       c2H5K: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2H5L: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.544825807 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.54782595 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2H6g,
                       label: GHC.Word.$fIxWord16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H6g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H6p; else goto c2H6q;
       c2H6p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H6q: // global
           I64[Sp - 16] = block_c2H6d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H6N; else goto c2H6e;
       u2H6N: // global
           call _c2H6d(R1) args: 0, res: 0, upd: 0;
       c2H6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H6d() //  [R1]
         { info_tbl: [(c2H6d,
                       label: block_c2H6d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H6d: // global
           I64[Sp - 8] = block_c2H6j_info;
           _s2DYe::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DYe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H6M; else goto c2H6k;
       u2H6M: // global
           call _c2H6j(R1) args: 0, res: 0, upd: 0;
       c2H6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H6j() //  [R1]
         { info_tbl: [(c2H6j,
                       label: block_c2H6j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H6j: // global
           I64[Sp] = block_c2H6o_info;
           _s2DYg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DYg::I64;
           if (R1 & 7 != 0) goto u2H6O; else goto c2H6t;
       u2H6O: // global
           call _c2H6o(R1) args: 0, res: 0, upd: 0;
       c2H6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H6o() //  [R1]
         { info_tbl: [(c2H6o,
                       label: block_c2H6o_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H6o: // global
           _s2DYi::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DYi::I64) goto c2H6B; else goto c2H6F;
       c2H6B: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H6F: // global
           _s2DYe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2H6E_info;
           R1 = _s2DYe::P64;
           I64[Sp + 16] = _s2DYi::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2H6P; else goto c2H6G;
       u2H6P: // global
           call _c2H6E(R1) args: 0, res: 0, upd: 0;
       c2H6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H6E() //  [R1]
         { info_tbl: [(c2H6E,
                       label: block_c2H6E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H6E: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.559236451 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2H7t,
                       label: GHC.Word.$fRealWord16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H7t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2H7K; else goto c2H7L;
       c2H7K: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2H7L: // global
           I64[Sp - 8] = block_c2H7q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H7S; else goto c2H7r;
       u2H7S: // global
           call _c2H7q(R1) args: 0, res: 0, upd: 0;
       c2H7r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H7q() //  [R1]
         { info_tbl: [(c2H7q,
                       label: block_c2H7q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H7q: // global
           I64[Sp] = block_c2H7z_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2H7z() //  [R1]
         { info_tbl: [(c2H7z,
                       label: block_c2H7z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H7z: // global
           I64[Sp] = block_c2H7D_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2H7D() //  [R1]
         { info_tbl: [(c2H7D,
                       label: block_c2H7D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H7D: // global
           I64[Sp] = block_c2H7H_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2H7H() //  [R1, R2]
         { info_tbl: [(c2H7H,
                       label: block_c2H7H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H7H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2H7R; else goto c2H7Q;
       c2H7R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2H7Q: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.569812861 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.571552261 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.574065016 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2H8q,
                       label: GHC.Word.$fIxWord16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H8q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H8N; else goto c2H8O;
       c2H8N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H8O: // global
           I64[Sp - 16] = block_c2H8n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H8V; else goto c2H8o;
       u2H8V: // global
           call _c2H8n(R1) args: 0, res: 0, upd: 0;
       c2H8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H8n() //  [R1]
         { info_tbl: [(c2H8n,
                       label: block_c2H8n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H8n: // global
           I64[Sp] = block_c2H8t_info;
           _s2DYz::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2DYz::P64;
           if (R1 & 7 != 0) goto u2H8U; else goto c2H8u;
       u2H8U: // global
           call _c2H8t(R1) args: 0, res: 0, upd: 0;
       c2H8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H8t() //  [R1]
         { info_tbl: [(c2H8t,
                       label: block_c2H8t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H8t: // global
           I64[Sp] = block_c2H8y_info;
           _s2DYC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DYC::I64;
           if (R1 & 7 != 0) goto u2H8W; else goto c2H8z;
       u2H8W: // global
           call _c2H8y(R1) args: 0, res: 0, upd: 0;
       c2H8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H8y() //  [R1]
         { info_tbl: [(c2H8y,
                       label: block_c2H8y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H8y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H8T; else goto c2H8S;
       c2H8T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2H8S: // global
           _s2DYH::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DYH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.584469656 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { info_tbl: [(c2H9t,
                       label: GHC.Word.$fIxWord16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2H9u; else goto c2H9v;
       c2H9u: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2H9v: // global
           I64[Sp - 8] = block_c2H9q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H9z; else goto c2H9r;
       u2H9z: // global
           call _c2H9q(R1) args: 0, res: 0, upd: 0;
       c2H9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H9q() //  [R1]
         { info_tbl: [(c2H9q,
                       label: block_c2H9q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9q: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.590484657 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2H9R,
                       label: GHC.Word.$fIxWord16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ha0; else goto c2Ha1;
       c2Ha0: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ha1: // global
           I64[Sp - 8] = block_c2H9O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Haw; else goto c2H9P;
       u2Haw: // global
           call _c2H9O(R1) args: 0, res: 0, upd: 0;
       c2H9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H9O() //  [R1]
         { info_tbl: [(c2H9O,
                       label: block_c2H9O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9O: // global
           I64[Sp - 8] = block_c2H9U_info;
           _s2DYP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DYP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hav; else goto c2H9V;
       u2Hav: // global
           call _c2H9U(R1) args: 0, res: 0, upd: 0;
       c2H9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H9U() //  [R1]
         { info_tbl: [(c2H9U,
                       label: block_c2H9U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9U: // global
           I64[Sp] = block_c2H9Z_info;
           _s2DYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DYR::I64;
           if (R1 & 7 != 0) goto u2Hax; else goto c2Ha4;
       u2Hax: // global
           call _c2H9Z(R1) args: 0, res: 0, upd: 0;
       c2Ha4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2H9Z() //  [R1]
         { info_tbl: [(c2H9Z,
                       label: block_c2H9Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2H9Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Haa; else goto c2Ha9;
       c2Haa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ha9: // global
           _s2DYR::I64 = I64[Sp + 8];
           _s2DYT::I64 = I64[R1 + 7];
           if (_s2DYR::I64 > _s2DYT::I64) goto c2Hae; else goto c2Hau;
       c2Hae: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hau: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DYT::I64 - _s2DYR::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.600638542 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2Hb6,
                       label: GHC.Word.$fIxWord16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hb6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hbw; else goto c2Hbx;
       c2Hbw: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hbx: // global
           I64[Sp - 8] = block_c2Hb3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HbE; else goto c2Hb4;
       u2HbE: // global
           call _c2Hb3(R1) args: 0, res: 0, upd: 0;
       c2Hb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hb3() //  [R1]
         { info_tbl: [(c2Hb3,
                       label: block_c2Hb3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hb3: // global
           I64[Sp - 8] = block_c2Hb9_info;
           _s2DZ1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2DZ1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HbD; else goto c2Hba;
       u2HbD: // global
           call _c2Hb9(R1) args: 0, res: 0, upd: 0;
       c2Hba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hb9() //  [R1]
         { info_tbl: [(c2Hb9,
                       label: block_c2Hb9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hb9: // global
           I64[Sp] = block_c2Hbe_info;
           _s2DZ4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZ4::I64;
           if (R1 & 7 != 0) goto u2HbF; else goto c2Hbf;
       u2HbF: // global
           call _c2Hbe(R1) args: 0, res: 0, upd: 0;
       c2Hbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hbe() //  [R1]
         { info_tbl: [(c2Hbe,
                       label: block_c2Hbe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hbe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HbC; else goto c2HbB;
       c2HbC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HbB: // global
           _s2DZa::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DZa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.611066087 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2Hcd,
                       label: GHC.Word.$fIxWord16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hcd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hcm; else goto c2Hcn;
       c2Hcm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hcn: // global
           I64[Sp - 16] = block_c2Hca_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hd2; else goto c2Hcb;
       u2Hd2: // global
           call _c2Hca(R1) args: 0, res: 0, upd: 0;
       c2Hcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hca() //  [R1]
         { info_tbl: [(c2Hca,
                       label: block_c2Hca_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hca: // global
           I64[Sp - 8] = block_c2Hcg_info;
           _s2DZf::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DZf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hd1; else goto c2Hch;
       u2Hd1: // global
           call _c2Hcg(R1) args: 0, res: 0, upd: 0;
       c2Hch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hcg() //  [R1]
         { info_tbl: [(c2Hcg,
                       label: block_c2Hcg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hcg: // global
           I64[Sp] = block_c2Hcl_info;
           _s2DZh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DZh::I64;
           if (R1 & 7 != 0) goto u2Hd3; else goto c2Hcq;
       u2Hd3: // global
           call _c2Hcl(R1) args: 0, res: 0, upd: 0;
       c2Hcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hcl() //  [R1]
         { info_tbl: [(c2Hcl,
                       label: block_c2Hcl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hcl: // global
           _s2DZj::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DZj::I64) goto c2Hcy; else goto c2HcC;
       c2Hcy: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HcC: // global
           I64[Sp] = block_c2HcB_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZj::I64;
           if (R1 & 7 != 0) goto u2Hd4; else goto c2HcD;
       u2Hd4: // global
           call _c2HcB(R1) args: 0, res: 0, upd: 0;
       c2HcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HcB() //  [R1]
         { info_tbl: [(c2HcB,
                       label: block_c2HcB_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HcB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HcJ; else goto c2HcI;
       c2HcJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HcI: // global
           _s2DZj::I64 = I64[Sp + 8];
           if (_s2DZj::I64 > I64[R1 + 7]) goto c2HcN; else goto c2Hd0;
       c2HcN: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Hd0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DZj::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.623289208 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.625664732 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { info_tbl: [(c2HdJ,
                       label: GHC.Word.byteSwap16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HdJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HdU; else goto c2HdV;
       c2HdU: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HdV: // global
           I64[Sp - 8] = block_c2HdG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HdZ; else goto c2HdH;
       u2HdZ: // global
           call _c2HdG(R1) args: 0, res: 0, upd: 0;
       c2HdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HdG() //  [R1]
         { info_tbl: [(c2HdG,
                       label: block_c2HdG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HdG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HdY; else goto c2HdX;
       c2HdY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HdX: // global
           (_c2HdM::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2HdM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.631827068 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { info_tbl: [(c2Hel,
                       label: GHC.Word.eqWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hel: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hep; else goto c2Heq;
       c2Hep: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Heq: // global
           I64[Sp - 16] = block_c2Hei_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hez; else goto c2Hej;
       u2Hez: // global
           call _c2Hei(R1) args: 0, res: 0, upd: 0;
       c2Hej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hei() //  [R1]
         { info_tbl: [(c2Hei,
                       label: block_c2Hei_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hei: // global
           I64[Sp] = block_c2Heo_info;
           _s2DZz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZz::I64;
           if (R1 & 7 != 0) goto u2Hey; else goto c2Hes;
       u2Hey: // global
           call _c2Heo(R1) args: 0, res: 0, upd: 0;
       c2Hes: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Heo() //  [R1]
         { info_tbl: [(c2Heo,
                       label: block_c2Heo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Heo: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.639489461 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.641282326 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.643379312 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { info_tbl: [(c2Hf3,
                       label: GHC.Word.$fNumWord32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hf3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hf4; else goto c2Hf5;
       c2Hf4: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hf5: // global
           I64[Sp - 8] = block_c2Hf0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hfd; else goto c2Hf1;
       u2Hfd: // global
           call _c2Hf0(R1) args: 0, res: 0, upd: 0;
       c2Hf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hf0() //  [R1]
         { info_tbl: [(c2Hf0,
                       label: block_c2Hf0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hf0: // global
           if (I64[R1 + 7] == 0) goto c2Hfc; else goto c2Hfb;
       c2Hfc: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hfb: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.648835209 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.651157421 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2Hfy,
                       label: GHC.Word.$fBitsWord32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hfy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HfF; else goto c2HfG;
       c2HfF: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HfG: // global
           I64[Sp - 8] = block_c2Hfv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HfK; else goto c2Hfw;
       u2HfK: // global
           call _c2Hfv(R1) args: 0, res: 0, upd: 0;
       c2Hfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hfv() //  [R1]
         { info_tbl: [(c2Hfv,
                       label: block_c2Hfv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hfv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HfJ; else goto c2HfI;
       c2HfJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HfI: // global
           _s2DZK::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DZK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.657553511 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.659597448 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2Hg4,
                       label: GHC.Word.$fBitsWord32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hg4: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.663229371 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { info_tbl: [(c2Hgj,
                       label: GHC.Word.$fBitsWord32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hgj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hgk; else goto c2Hgl;
       c2Hgk: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hgl: // global
           I64[Sp - 8] = block_c2Hgg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HgE; else goto c2Hgh;
       u2HgE: // global
           call _c2Hgg(R1) args: 0, res: 0, upd: 0;
       c2Hgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hgg() //  [R1]
         { info_tbl: [(c2Hgg,
                       label: block_c2Hgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hgg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hgq; else goto c2Hgp;
       c2Hgq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hgp: // global
           _s2DZO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DZO::I64, 64)) goto c2HgC; else goto c2HgD;
       c2HgC: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2DZO::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HgD: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.669598111 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2Hh1,
                       label: GHC.Word.$fBitsWord32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hh1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hh5; else goto c2Hh6;
       c2Hh5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hh6: // global
           I64[Sp - 16] = block_c2HgY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HhF; else goto c2HgZ;
       u2HhF: // global
           call _c2HgY(R1) args: 0, res: 0, upd: 0;
       c2HgZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HgY() //  [R1]
         { info_tbl: [(c2HgY,
                       label: block_c2HgY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HgY: // global
           I64[Sp] = block_c2Hh4_info;
           _s2DZV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZV::I64;
           if (R1 & 7 != 0) goto u2HhE; else goto c2Hh8;
       u2HhE: // global
           call _c2Hh4(R1) args: 0, res: 0, upd: 0;
       c2Hh8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hh4() //  [R1]
         { info_tbl: [(c2Hh4,
                       label: block_c2Hh4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hh4: // global
           _s2DZX::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DZX::I64, 64)) goto c2HhD; else goto c2HhC;
       c2HhC: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2DZX::I64)) == 0) goto c2HhD; else goto c2Hhr;
       c2HhD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hhr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.678204992 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2Hia,
                       label: GHC.Word.$fBitsWord32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hia: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hie; else goto c2Hif;
       c2Hie: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hif: // global
           I64[Sp - 16] = block_c2Hi7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hj5; else goto c2Hi8;
       u2Hj5: // global
           call _c2Hi7(R1) args: 0, res: 0, upd: 0;
       c2Hi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hi7() //  [R1]
         { info_tbl: [(c2Hi7,
                       label: block_c2Hi7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hi7: // global
           I64[Sp - 8] = block_c2Hid_info;
           _s2E04::P64 = R1;
           _s2E05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E05::I64;
           P64[Sp + 8] = _s2E04::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hj4; else goto c2Hih;
       u2Hj4: // global
           call _c2Hid(R1) args: 0, res: 0, upd: 0;
       c2Hih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hid() //  [R1]
         { info_tbl: [(c2Hid,
                       label: block_c2Hid_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hid: // global
           _s2E0b::I64 = -I64[R1 + 7] & 31;
           if (_s2E0b::I64 != 0) goto u2Hj2; else goto c2HiY;
       u2Hj2: // global
           I64[Sp + 16] = _s2E0b::I64;
           Sp = Sp + 8;
           call _c2Hiz() args: 0, res: 0, upd: 0;
       c2HiY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Hiz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hiz: // global
           Hp = Hp + 16;
           _s2E0b::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2HiV; else goto c2HiU;
       c2HiV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Hiy_info;
           R1 = _s2E0b::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2HiU: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2E05::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2E05::I64 << _s2E0b::I64) | (_s2E05::I64 >> 32 - _s2E0b::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Hiy() //  [R1]
         { info_tbl: [(c2Hiy,
                       label: block_c2Hiy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hiy: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Hiz() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.689336502 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2HjL,
                       label: GHC.Word.$fBitsWord32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HjL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HjP; else goto c2HjQ;
       c2HjP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HjQ: // global
           I64[Sp - 16] = block_c2HjI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hkg; else goto c2HjJ;
       u2Hkg: // global
           call _c2HjI(R1) args: 0, res: 0, upd: 0;
       c2HjJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HjI() //  [R1]
         { info_tbl: [(c2HjI,
                       label: block_c2HjI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HjI: // global
           I64[Sp - 8] = block_c2HjO_info;
           _s2E0j::P64 = R1;
           _s2E0k::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E0k::I64;
           P64[Sp + 8] = _s2E0j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hkf; else goto c2HjS;
       u2Hkf: // global
           call _c2HjO(R1) args: 0, res: 0, upd: 0;
       c2HjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HjO() //  [R1]
         { info_tbl: [(c2HjO,
                       label: block_c2HjO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HjY; else goto c2HjX;
       c2HjY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HjX: // global
           _s2E0m::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0m::I64, 64)) goto c2Hkd; else goto c2Hke;
       c2Hkd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0m::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hke: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.69839763 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2HkL,
                       label: GHC.Word.$fBitsWord32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HkL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HkP; else goto c2HkQ;
       c2HkP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HkQ: // global
           I64[Sp - 16] = block_c2HkI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hlo; else goto c2HkJ;
       u2Hlo: // global
           call _c2HkI(R1) args: 0, res: 0, upd: 0;
       c2HkJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HkI() //  [R1]
         { info_tbl: [(c2HkI,
                       label: block_c2HkI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HkI: // global
           I64[Sp] = block_c2HkO_info;
           _s2E0u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0u::I64;
           if (R1 & 7 != 0) goto u2Hln; else goto c2HkS;
       u2Hln: // global
           call _c2HkO(R1) args: 0, res: 0, upd: 0;
       c2HkS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HkO() //  [R1]
         { info_tbl: [(c2HkO,
                       label: block_c2HkO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HkO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HkY; else goto c2HkX;
       c2HkY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HkX: // global
           _s2E0u::I64 = I64[Sp + 8];
           _s2E0w::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0w::I64, 64)) goto c2Hlg; else goto c2Hlm;
       c2Hlg: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E0u::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0w::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hlm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E0u::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.707044666 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2HlY,
                       label: GHC.Word.$fBitsWord32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HlY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hm2; else goto c2Hm3;
       c2Hm2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hm3: // global
           I64[Sp - 16] = block_c2HlV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hmt; else goto c2HlW;
       u2Hmt: // global
           call _c2HlV(R1) args: 0, res: 0, upd: 0;
       c2HlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HlV() //  [R1]
         { info_tbl: [(c2HlV,
                       label: block_c2HlV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HlV: // global
           I64[Sp - 8] = block_c2Hm1_info;
           _s2E0F::P64 = R1;
           _s2E0G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E0G::I64;
           P64[Sp + 8] = _s2E0F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hms; else goto c2Hm5;
       u2Hms: // global
           call _c2Hm1(R1) args: 0, res: 0, upd: 0;
       c2Hm5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hm1() //  [R1]
         { info_tbl: [(c2Hm1,
                       label: block_c2Hm1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hm1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hmb; else goto c2Hma;
       c2Hmb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hma: // global
           _s2E0I::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0I::I64, 64)) goto c2Hmq; else goto c2Hmr;
       c2Hmq: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0I::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hmr: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.715096719 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2HmV,
                       label: GHC.Word.$fBitsWord32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HmV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.718382506 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.720578756 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.722985311 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c2Hnb,
                       label: GHC.Word.$fIntegralWord32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hnb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hnf; else goto c2Hng;
       c2Hnf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hng: // global
           I64[Sp - 16] = block_c2Hn8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hnz; else goto c2Hn9;
       u2Hnz: // global
           call _c2Hn8(R1) args: 0, res: 0, upd: 0;
       c2Hn9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hn8() //  [R1]
         { info_tbl: [(c2Hn8,
                       label: block_c2Hn8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hn8: // global
           I64[Sp] = block_c2Hne_info;
           _s2E0Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0Q::I64;
           if (R1 & 7 != 0) goto u2Hny; else goto c2Hni;
       u2Hny: // global
           call _c2Hne(R1) args: 0, res: 0, upd: 0;
       c2Hni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hne() //  [R1]
         { info_tbl: [(c2Hne,
                       label: block_c2Hne_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hne: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hno; else goto c2Hnn;
       c2Hno: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hnn: // global
           _s2E0T::I64 = I64[R1 + 7];
           if (_s2E0T::I64 != 0) goto c2Hnw; else goto c2Hnx;
       c2Hnw: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2E0T::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hnx: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.731800993 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c2HnZ,
                       label: GHC.Word.$fIntegralWord32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HnZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ho3; else goto c2Ho4;
       c2Ho3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ho4: // global
           I64[Sp - 16] = block_c2HnW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hon; else goto c2HnX;
       u2Hon: // global
           call _c2HnW(R1) args: 0, res: 0, upd: 0;
       c2HnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HnW() //  [R1]
         { info_tbl: [(c2HnW,
                       label: block_c2HnW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HnW: // global
           I64[Sp] = block_c2Ho2_info;
           _s2E0Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0Y::I64;
           if (R1 & 7 != 0) goto u2Hom; else goto c2Ho6;
       u2Hom: // global
           call _c2Ho2(R1) args: 0, res: 0, upd: 0;
       c2Ho6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ho2() //  [R1]
         { info_tbl: [(c2Ho2,
                       label: block_c2Ho2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ho2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hoc; else goto c2Hob;
       c2Hoc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hob: // global
           _s2E11::I64 = I64[R1 + 7];
           if (_s2E11::I64 != 0) goto c2Hok; else goto c2Hol;
       c2Hok: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2E11::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hol: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.740688897 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c2HoN,
                       label: GHC.Word.$fIntegralWord32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HoR; else goto c2HoS;
       c2HoR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HoS: // global
           I64[Sp - 16] = block_c2HoK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hpa; else goto c2HoL;
       u2Hpa: // global
           call _c2HoK(R1) args: 0, res: 0, upd: 0;
       c2HoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HoK() //  [R1]
         { info_tbl: [(c2HoK,
                       label: block_c2HoK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HoK: // global
           I64[Sp] = block_c2HoQ_info;
           _s2E16::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E16::I64;
           if (R1 & 7 != 0) goto u2Hp9; else goto c2HoU;
       u2Hp9: // global
           call _c2HoQ(R1) args: 0, res: 0, upd: 0;
       c2HoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HoQ() //  [R1]
         { info_tbl: [(c2HoQ,
                       label: block_c2HoQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HoQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2Hp0; else goto c2HoZ;
       c2Hp0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HoZ: // global
           _s2E19::I64 = I64[R1 + 7];
           if (_s2E19::I64 != 0) goto c2Hp7; else goto c2Hp8;
       c2Hp7: // global
           (_s2E1b::I64, _s2E1c::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2E19::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2E1c::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2E1b::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hp8: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.750111855 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2E1p_entry() //  [R1]
         { info_tbl: [(c2HpS,
                       label: sat_s2E1p_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HpS: // global
           _s2E1p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2HpV; else goto c2HpW;
       c2HpW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HpY; else goto c2HpX;
       c2HpY: // global
           HpAlloc = 16;
           goto c2HpV;
       c2HpV: // global
           R1 = _s2E1p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2HpX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2E1p::P64;
           _s2E1o::I64 = I64[_s2E1p::P64 + 16] % I64[_s2E1p::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E1o::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s2E1n_entry() //  [R1]
         { info_tbl: [(c2Hq5,
                       label: sat_s2E1n_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hq5: // global
           _s2E1n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hq8; else goto c2Hq9;
       c2Hq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hqb; else goto c2Hqa;
       c2Hqb: // global
           HpAlloc = 16;
           goto c2Hq8;
       c2Hq8: // global
           R1 = _s2E1n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Hqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2E1n::P64;
           _s2E1m::I64 = I64[_s2E1n::P64 + 16] / I64[_s2E1n::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E1m::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c2Hqc,
                       label: GHC.Word.$fIntegralWord32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hqc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hqd; else goto c2Hqe;
       c2Hqd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hqe: // global
           I64[Sp - 16] = block_c2HpA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hqo; else goto c2HpB;
       u2Hqo: // global
           call _c2HpA(R1) args: 0, res: 0, upd: 0;
       c2HpB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HpA() //  [R1]
         { info_tbl: [(c2HpA,
                       label: block_c2HpA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HpA: // global
           I64[Sp] = block_c2HpF_info;
           _s2E1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1i::I64;
           if (R1 & 7 != 0) goto u2Hqn; else goto c2HpG;
       u2Hqn: // global
           call _c2HpF(R1) args: 0, res: 0, upd: 0;
       c2HpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HpF() //  [R1]
         { info_tbl: [(c2HpF,
                       label: block_c2HpF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HpF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Hqi; else goto c2Hqh;
       c2Hqi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hqh: // global
           _s2E1l::I64 = I64[R1 + 7];
           if (_s2E1l::I64 != 0) goto c2Hql; else goto c2Hqm;
       c2Hql: // global
           I64[Hp - 80] = sat_s2E1p_info;
           _s2E1i::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2E1i::I64;
           I64[Hp - 56] = _s2E1l::I64;
           I64[Hp - 48] = sat_s2E1n_info;
           I64[Hp - 32] = _s2E1i::I64;
           I64[Hp - 24] = _s2E1l::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hqm: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.762919727 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { info_tbl: [(c2Hr5,
                       label: GHC.Word.gtWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hr5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hr9; else goto c2Hra;
       c2Hr9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hra: // global
           I64[Sp - 16] = block_c2Hr2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hrj; else goto c2Hr3;
       u2Hrj: // global
           call _c2Hr2(R1) args: 0, res: 0, upd: 0;
       c2Hr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hr2() //  [R1]
         { info_tbl: [(c2Hr2,
                       label: block_c2Hr2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hr2: // global
           I64[Sp] = block_c2Hr8_info;
           _s2E1t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1t::I64;
           if (R1 & 7 != 0) goto u2Hri; else goto c2Hrc;
       u2Hri: // global
           call _c2Hr8(R1) args: 0, res: 0, upd: 0;
       c2Hrc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hr8() //  [R1]
         { info_tbl: [(c2Hr8,
                       label: block_c2Hr8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hr8: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.770556958 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { info_tbl: [(c2HrL,
                       label: GHC.Word.geWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HrL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HrP; else goto c2HrQ;
       c2HrP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HrQ: // global
           I64[Sp - 16] = block_c2HrI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HrZ; else goto c2HrJ;
       u2HrZ: // global
           call _c2HrI(R1) args: 0, res: 0, upd: 0;
       c2HrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HrI() //  [R1]
         { info_tbl: [(c2HrI,
                       label: block_c2HrI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HrI: // global
           I64[Sp] = block_c2HrO_info;
           _s2E1A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1A::I64;
           if (R1 & 7 != 0) goto u2HrY; else goto c2HrS;
       u2HrY: // global
           call _c2HrO(R1) args: 0, res: 0, upd: 0;
       c2HrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HrO() //  [R1]
         { info_tbl: [(c2HrO,
                       label: block_c2HrO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HrO: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.778850004 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { info_tbl: [(c2Hsr,
                       label: GHC.Word.ltWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hsr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hsv; else goto c2Hsw;
       c2Hsv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hsw: // global
           I64[Sp - 16] = block_c2Hso_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HsF; else goto c2Hsp;
       u2HsF: // global
           call _c2Hso(R1) args: 0, res: 0, upd: 0;
       c2Hsp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hso() //  [R1]
         { info_tbl: [(c2Hso,
                       label: block_c2Hso_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hso: // global
           I64[Sp] = block_c2Hsu_info;
           _s2E1H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1H::I64;
           if (R1 & 7 != 0) goto u2HsE; else goto c2Hsy;
       u2HsE: // global
           call _c2Hsu(R1) args: 0, res: 0, upd: 0;
       c2Hsy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hsu() //  [R1]
         { info_tbl: [(c2Hsu,
                       label: block_c2Hsu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hsu: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.786780325 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { info_tbl: [(c2Ht7,
                       label: GHC.Word.leWord32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ht7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Htb; else goto c2Htc;
       c2Htb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Htc: // global
           I64[Sp - 16] = block_c2Ht4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Htl; else goto c2Ht5;
       u2Htl: // global
           call _c2Ht4(R1) args: 0, res: 0, upd: 0;
       c2Ht5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Ht4() //  [R1]
         { info_tbl: [(c2Ht4,
                       label: block_c2Ht4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Ht4: // global
           I64[Sp] = block_c2Hta_info;
           _s2E1O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1O::I64;
           if (R1 & 7 != 0) goto u2Htk; else goto c2Hte;
       u2Htk: // global
           call _c2Hta(R1) args: 0, res: 0, upd: 0;
       c2Hte: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hta() //  [R1]
         { info_tbl: [(c2Hta,
                       label: block_c2Hta_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hta: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.794629017 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c2HtN,
                       label: GHC.Word.$fOrdWord32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HtN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HtR; else goto c2HtS;
       c2HtR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HtS: // global
           I64[Sp - 16] = block_c2HtK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hub; else goto c2HtL;
       u2Hub: // global
           call _c2HtK(R1) args: 0, res: 0, upd: 0;
       c2HtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HtK() //  [R1]
         { info_tbl: [(c2HtK,
                       label: block_c2HtK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HtK: // global
           I64[Sp] = block_c2HtQ_info;
           _s2E1V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1V::I64;
           if (R1 & 7 != 0) goto u2Hua; else goto c2HtU;
       u2Hua: // global
           call _c2HtQ(R1) args: 0, res: 0, upd: 0;
       c2HtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HtQ() //  [R1]
         { info_tbl: [(c2HtQ,
                       label: block_c2HtQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HtQ: // global
           _s2E1V::I64 = I64[Sp + 8];
           _s2E1X::I64 = I64[R1 + 7];
           if (_s2E1V::I64 == _s2E1X::I64) goto c2Hu9; else goto c2Hu8;
       c2Hu9: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hu8: // global
           if (_s2E1V::I64 > _s2E1X::I64) goto c2Hu5; else goto c2Hu6;
       c2Hu5: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hu6: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.803275334 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c2HuE,
                       label: GHC.Word.$fOrdWord32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HuE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HuI; else goto c2HuJ;
       c2HuI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HuJ: // global
           I64[Sp - 16] = block_c2HuB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HuW; else goto c2HuC;
       u2HuW: // global
           call _c2HuB(R1) args: 0, res: 0, upd: 0;
       c2HuC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HuB() //  [R1]
         { info_tbl: [(c2HuB,
                       label: block_c2HuB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HuB: // global
           I64[Sp - 8] = block_c2HuH_info;
           _s2E22::P64 = R1;
           _s2E23::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E23::I64;
           P64[Sp + 8] = _s2E22::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HuV; else goto c2HuL;
       u2HuV: // global
           call _c2HuH(R1) args: 0, res: 0, upd: 0;
       c2HuL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HuH() //  [R1]
         { info_tbl: [(c2HuH,
                       label: block_c2HuH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HuH: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2HuT; else goto c2HuU;
       c2HuT: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HuU: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.811300643 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c2Hvo,
                       label: GHC.Word.$fOrdWord32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hvo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hvs; else goto c2Hvt;
       c2Hvs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hvt: // global
           I64[Sp - 16] = block_c2Hvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HvG; else goto c2Hvm;
       u2HvG: // global
           call _c2Hvl(R1) args: 0, res: 0, upd: 0;
       c2Hvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hvl() //  [R1]
         { info_tbl: [(c2Hvl,
                       label: block_c2Hvl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hvl: // global
           I64[Sp - 8] = block_c2Hvr_info;
           _s2E29::P64 = R1;
           _s2E2a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E2a::I64;
           P64[Sp + 8] = _s2E29::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HvF; else goto c2Hvv;
       u2HvF: // global
           call _c2Hvr(R1) args: 0, res: 0, upd: 0;
       c2Hvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hvr() //  [R1]
         { info_tbl: [(c2Hvr,
                       label: block_c2Hvr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hvr: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2HvD; else goto c2HvE;
       c2HvD: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HvE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.819764033 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.82239715 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2Hw9,
                       label: GHC.Word.$fIxWord32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hw9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hwi; else goto c2Hwj;
       c2Hwi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hwj: // global
           I64[Sp - 16] = block_c2Hw6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HwG; else goto c2Hw7;
       u2HwG: // global
           call _c2Hw6(R1) args: 0, res: 0, upd: 0;
       c2Hw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hw6() //  [R1]
         { info_tbl: [(c2Hw6,
                       label: block_c2Hw6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hw6: // global
           I64[Sp - 8] = block_c2Hwc_info;
           _s2E2i::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HwF; else goto c2Hwd;
       u2HwF: // global
           call _c2Hwc(R1) args: 0, res: 0, upd: 0;
       c2Hwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hwc() //  [R1]
         { info_tbl: [(c2Hwc,
                       label: block_c2Hwc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hwc: // global
           I64[Sp] = block_c2Hwh_info;
           _s2E2k::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E2k::I64;
           if (R1 & 7 != 0) goto u2HwH; else goto c2Hwm;
       u2HwH: // global
           call _c2Hwh(R1) args: 0, res: 0, upd: 0;
       c2Hwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hwh() //  [R1]
         { info_tbl: [(c2Hwh,
                       label: block_c2Hwh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hwh: // global
           _s2E2m::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E2m::I64) goto c2Hwu; else goto c2Hwy;
       c2Hwu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hwy: // global
           _s2E2i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Hwx_info;
           R1 = _s2E2i::P64;
           I64[Sp + 16] = _s2E2m::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2HwI; else goto c2Hwz;
       u2HwI: // global
           call _c2Hwx(R1) args: 0, res: 0, upd: 0;
       c2Hwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hwx() //  [R1]
         { info_tbl: [(c2Hwx,
                       label: block_c2Hwx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hwx: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.833759122 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c2Hxm,
                       label: GHC.Word.$fRealWord32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hxm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HxD; else goto c2HxE;
       c2HxD: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HxE: // global
           I64[Sp - 8] = block_c2Hxj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HxL; else goto c2Hxk;
       u2HxL: // global
           call _c2Hxj(R1) args: 0, res: 0, upd: 0;
       c2Hxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hxj() //  [R1]
         { info_tbl: [(c2Hxj,
                       label: block_c2Hxj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hxj: // global
           I64[Sp] = block_c2Hxs_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hxs() //  [R1]
         { info_tbl: [(c2Hxs,
                       label: block_c2Hxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hxs: // global
           I64[Sp] = block_c2Hxw_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hxw() //  [R1]
         { info_tbl: [(c2Hxw,
                       label: block_c2Hxw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hxw: // global
           I64[Sp] = block_c2HxA_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c2HxA() //  [R1, R2]
         { info_tbl: [(c2HxA,
                       label: block_c2HxA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HxA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2HxK; else goto c2HxJ;
       c2HxK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2HxJ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.8439519 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.845752226 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.848195163 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2Hyj,
                       label: GHC.Word.$fIxWord32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hyj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HyG; else goto c2HyH;
       c2HyG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HyH: // global
           I64[Sp - 16] = block_c2Hyg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HyO; else goto c2Hyh;
       u2HyO: // global
           call _c2Hyg(R1) args: 0, res: 0, upd: 0;
       c2Hyh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hyg() //  [R1]
         { info_tbl: [(c2Hyg,
                       label: block_c2Hyg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hyg: // global
           I64[Sp] = block_c2Hym_info;
           _s2E2D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2E2D::P64;
           if (R1 & 7 != 0) goto u2HyN; else goto c2Hyn;
       u2HyN: // global
           call _c2Hym(R1) args: 0, res: 0, upd: 0;
       c2Hyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hym() //  [R1]
         { info_tbl: [(c2Hym,
                       label: block_c2Hym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hym: // global
           I64[Sp] = block_c2Hyr_info;
           _s2E2G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E2G::I64;
           if (R1 & 7 != 0) goto u2HyP; else goto c2Hys;
       u2HyP: // global
           call _c2Hyr(R1) args: 0, res: 0, upd: 0;
       c2Hys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hyr() //  [R1]
         { info_tbl: [(c2Hyr,
                       label: block_c2Hyr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hyr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HyM; else goto c2HyL;
       c2HyM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HyL: // global
           _s2E2L::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E2L::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.858541563 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { info_tbl: [(c2Hzm,
                       label: GHC.Word.$fIxWord32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hzm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hzn; else goto c2Hzo;
       c2Hzn: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hzo: // global
           I64[Sp - 8] = block_c2Hzj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hzs; else goto c2Hzk;
       u2Hzs: // global
           call _c2Hzj(R1) args: 0, res: 0, upd: 0;
       c2Hzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2Hzj() //  [R1]
         { info_tbl: [(c2Hzj,
                       label: block_c2Hzj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2Hzj: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.864682878 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2HzK,
                       label: GHC.Word.$fIxWord32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HzT; else goto c2HzU;
       c2HzT: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HzU: // global
           I64[Sp - 8] = block_c2HzH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HAp; else goto c2HzI;
       u2HAp: // global
           call _c2HzH(R1) args: 0, res: 0, upd: 0;
       c2HzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HzH() //  [R1]
         { info_tbl: [(c2HzH,
                       label: block_c2HzH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HzH: // global
           I64[Sp - 8] = block_c2HzN_info;
           _s2E2T::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E2T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HAo; else goto c2HzO;
       u2HAo: // global
           call _c2HzN(R1) args: 0, res: 0, upd: 0;
       c2HzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HzN() //  [R1]
         { info_tbl: [(c2HzN,
                       label: block_c2HzN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HzN: // global
           I64[Sp] = block_c2HzS_info;
           _s2E2V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E2V::I64;
           if (R1 & 7 != 0) goto u2HAq; else goto c2HzX;
       u2HAq: // global
           call _c2HzS(R1) args: 0, res: 0, upd: 0;
       c2HzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HzS() //  [R1]
         { info_tbl: [(c2HzS,
                       label: block_c2HzS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HzS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HA3; else goto c2HA2;
       c2HA3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HA2: // global
           _s2E2V::I64 = I64[Sp + 8];
           _s2E2X::I64 = I64[R1 + 7];
           if (_s2E2V::I64 > _s2E2X::I64) goto c2HA7; else goto c2HAn;
       c2HA7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HAn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2E2X::I64 - _s2E2V::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.875256942 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2HAZ,
                       label: GHC.Word.$fIxWord32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HBp; else goto c2HBq;
       c2HBp: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HBq: // global
           I64[Sp - 8] = block_c2HAW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HBx; else goto c2HAX;
       u2HBx: // global
           call _c2HAW(R1) args: 0, res: 0, upd: 0;
       c2HAX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HAW() //  [R1]
         { info_tbl: [(c2HAW,
                       label: block_c2HAW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HAW: // global
           I64[Sp - 8] = block_c2HB2_info;
           _s2E35::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2E35::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HBw; else goto c2HB3;
       u2HBw: // global
           call _c2HB2(R1) args: 0, res: 0, upd: 0;
       c2HB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HB2() //  [R1]
         { info_tbl: [(c2HB2,
                       label: block_c2HB2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HB2: // global
           I64[Sp] = block_c2HB7_info;
           _s2E38::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E38::I64;
           if (R1 & 7 != 0) goto u2HBy; else goto c2HB8;
       u2HBy: // global
           call _c2HB7(R1) args: 0, res: 0, upd: 0;
       c2HB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HB7() //  [R1]
         { info_tbl: [(c2HB7,
                       label: block_c2HB7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HB7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HBv; else goto c2HBu;
       c2HBv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HBu: // global
           _s2E3e::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E3e::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.885215934 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2HC6,
                       label: GHC.Word.$fIxWord32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HC6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HCf; else goto c2HCg;
       c2HCf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HCg: // global
           I64[Sp - 16] = block_c2HC3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HCV; else goto c2HC4;
       u2HCV: // global
           call _c2HC3(R1) args: 0, res: 0, upd: 0;
       c2HC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HC3() //  [R1]
         { info_tbl: [(c2HC3,
                       label: block_c2HC3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HC3: // global
           I64[Sp - 8] = block_c2HC9_info;
           _s2E3j::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E3j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HCU; else goto c2HCa;
       u2HCU: // global
           call _c2HC9(R1) args: 0, res: 0, upd: 0;
       c2HCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HC9() //  [R1]
         { info_tbl: [(c2HC9,
                       label: block_c2HC9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HC9: // global
           I64[Sp] = block_c2HCe_info;
           _s2E3l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E3l::I64;
           if (R1 & 7 != 0) goto u2HCW; else goto c2HCj;
       u2HCW: // global
           call _c2HCe(R1) args: 0, res: 0, upd: 0;
       c2HCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HCe() //  [R1]
         { info_tbl: [(c2HCe,
                       label: block_c2HCe_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HCe: // global
           _s2E3n::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E3n::I64) goto c2HCr; else goto c2HCv;
       c2HCr: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HCv: // global
           I64[Sp] = block_c2HCu_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E3n::I64;
           if (R1 & 7 != 0) goto u2HCX; else goto c2HCw;
       u2HCX: // global
           call _c2HCu(R1) args: 0, res: 0, upd: 0;
       c2HCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HCu() //  [R1]
         { info_tbl: [(c2HCu,
                       label: block_c2HCu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HCu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HCC; else goto c2HCB;
       c2HCC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HCB: // global
           _s2E3n::I64 = I64[Sp + 8];
           if (_s2E3n::I64 > I64[R1 + 7]) goto c2HCG; else goto c2HCT;
       c2HCG: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HCT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2E3n::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.897528867 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.899874217 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { info_tbl: [(c2HDC,
                       label: GHC.Word.byteSwap32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HDC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HDN; else goto c2HDO;
       c2HDN: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HDO: // global
           I64[Sp - 8] = block_c2HDz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HDS; else goto c2HDA;
       u2HDS: // global
           call _c2HDz(R1) args: 0, res: 0, upd: 0;
       c2HDA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HDz() //  [R1]
         { info_tbl: [(c2HDz,
                       label: block_c2HDz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HDz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HDR; else goto c2HDQ;
       c2HDR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HDQ: // global
           (_c2HDF::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2HDF::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.905859657 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c2HEd,
                       label: GHC.Word.$fBitsWord64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HEd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HEk; else goto c2HEl;
       c2HEk: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HEl: // global
           I64[Sp - 8] = block_c2HEa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HEp; else goto c2HEb;
       u2HEp: // global
           call _c2HEa(R1) args: 0, res: 0, upd: 0;
       c2HEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HEa() //  [R1]
         { info_tbl: [(c2HEa,
                       label: block_c2HEa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HEa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HEo; else goto c2HEn;
       c2HEo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HEn: // global
           _s2E3D::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E3D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.911422186 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.914415932 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c2HEI,
                       label: GHC.Word.$fBitsWord64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HEI: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.918198811 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { info_tbl: [(c2HEX,
                       label: GHC.Word.$fBitsWord64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HEX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HEY; else goto c2HEZ;
       c2HEY: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HEZ: // global
           I64[Sp - 8] = block_c2HEU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HFf; else goto c2HEV;
       u2HFf: // global
           call _c2HEU(R1) args: 0, res: 0, upd: 0;
       c2HEV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HEU() //  [R1]
         { info_tbl: [(c2HEU,
                       label: block_c2HEU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HEU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HF4; else goto c2HF3;
       c2HF4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HF3: // global
           _s2E3H::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E3H::I64, 64)) goto c2HFd; else goto c2HFe;
       c2HFd: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2E3H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HFe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.924604679 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c2HFB,
                       label: GHC.Word.$fBitsWord64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HFB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HFF; else goto c2HFG;
       c2HFF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HFG: // global
           I64[Sp - 16] = block_c2HFy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HGc; else goto c2HFz;
       u2HGc: // global
           call _c2HFy(R1) args: 0, res: 0, upd: 0;
       c2HFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HFy() //  [R1]
         { info_tbl: [(c2HFy,
                       label: block_c2HFy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HFy: // global
           I64[Sp] = block_c2HFE_info;
           _s2E3N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E3N::I64;
           if (R1 & 7 != 0) goto u2HGb; else goto c2HFI;
       u2HGb: // global
           call _c2HFE(R1) args: 0, res: 0, upd: 0;
       c2HFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HFE() //  [R1]
         { info_tbl: [(c2HFE,
                       label: block_c2HFE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HFE: // global
           _s2E3P::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2E3P::I64, 64)) goto c2HGa; else goto c2HG9;
       c2HG9: // global
           if (I64[Sp + 8] & (1 << _s2E3P::I64) == 0) goto c2HGa; else goto c2HFY;
       c2HGa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HFY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.933557303 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c2HGG,
                       label: GHC.Word.$fBitsWord64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HGG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HGK; else goto c2HGL;
       c2HGK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HGL: // global
           I64[Sp - 16] = block_c2HGD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HHy; else goto c2HGE;
       u2HHy: // global
           call _c2HGD(R1) args: 0, res: 0, upd: 0;
       c2HGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HGD() //  [R1]
         { info_tbl: [(c2HGD,
                       label: block_c2HGD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HGD: // global
           I64[Sp - 8] = block_c2HGJ_info;
           _s2E3V::P64 = R1;
           _s2E3W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E3W::I64;
           P64[Sp + 8] = _s2E3V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HHx; else goto c2HGN;
       u2HHx: // global
           call _c2HGJ(R1) args: 0, res: 0, upd: 0;
       c2HGN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HGJ() //  [R1]
         { info_tbl: [(c2HGJ,
                       label: block_c2HGJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HGJ: // global
           _s2E42::I64 = -I64[R1 + 7] & 63;
           if (_s2E42::I64 != 0) goto u2HHv; else goto c2HHr;
       u2HHv: // global
           I64[Sp + 16] = _s2E42::I64;
           Sp = Sp + 8;
           call _c2HH5() args: 0, res: 0, upd: 0;
       c2HHr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2HH5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HH5: // global
           Hp = Hp + 16;
           _s2E42::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2HHo; else goto c2HHn;
       c2HHo: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2HH4_info;
           R1 = _s2E42::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2HHn: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2E3W::I64 = I64[Sp];
           I64[Hp] = (_s2E3W::I64 << _s2E42::I64) | (_s2E3W::I64 >> 64 - _s2E42::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2HH4() //  [R1]
         { info_tbl: [(c2HH4,
                       label: block_c2HH4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HH4: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2HH5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.94447461 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c2HId,
                       label: GHC.Word.$fBitsWord64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HId: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HIh; else goto c2HIi;
       c2HIh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HIi: // global
           I64[Sp - 16] = block_c2HIa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HIF; else goto c2HIb;
       u2HIF: // global
           call _c2HIa(R1) args: 0, res: 0, upd: 0;
       c2HIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HIa() //  [R1]
         { info_tbl: [(c2HIa,
                       label: block_c2HIa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HIa: // global
           I64[Sp - 8] = block_c2HIg_info;
           _s2E49::P64 = R1;
           _s2E4a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E4a::I64;
           P64[Sp + 8] = _s2E49::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HIE; else goto c2HIk;
       u2HIE: // global
           call _c2HIg(R1) args: 0, res: 0, upd: 0;
       c2HIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HIg() //  [R1]
         { info_tbl: [(c2HIg,
                       label: block_c2HIg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HIg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HIq; else goto c2HIp;
       c2HIq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HIp: // global
           _s2E4c::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4c::I64, 64)) goto c2HIC; else goto c2HID;
       c2HIC: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2E4c::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HID: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.952703277 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c2HJ9,
                       label: GHC.Word.$fBitsWord64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HJd; else goto c2HJe;
       c2HJd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HJe: // global
           I64[Sp - 16] = block_c2HJ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HJJ; else goto c2HJ7;
       u2HJJ: // global
           call _c2HJ6(R1) args: 0, res: 0, upd: 0;
       c2HJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HJ6() //  [R1]
         { info_tbl: [(c2HJ6,
                       label: block_c2HJ6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HJ6: // global
           I64[Sp] = block_c2HJc_info;
           _s2E4j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E4j::I64;
           if (R1 & 7 != 0) goto u2HJI; else goto c2HJg;
       u2HJI: // global
           call _c2HJc(R1) args: 0, res: 0, upd: 0;
       c2HJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HJc() //  [R1]
         { info_tbl: [(c2HJc,
                       label: block_c2HJc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HJm; else goto c2HJl;
       c2HJm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HJl: // global
           _s2E4j::I64 = I64[Sp + 8];
           _s2E4l::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4l::I64, 64)) goto c2HJB; else goto c2HJH;
       c2HJB: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E4j::I64 & (1 << _s2E4l::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HJH: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E4j::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.96176607 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c2HKh,
                       label: GHC.Word.$fBitsWord64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HKh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HKl; else goto c2HKm;
       c2HKl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HKm: // global
           I64[Sp - 16] = block_c2HKe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HKJ; else goto c2HKf;
       u2HKJ: // global
           call _c2HKe(R1) args: 0, res: 0, upd: 0;
       c2HKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HKe() //  [R1]
         { info_tbl: [(c2HKe,
                       label: block_c2HKe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HKe: // global
           I64[Sp - 8] = block_c2HKk_info;
           _s2E4t::P64 = R1;
           _s2E4u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E4u::I64;
           P64[Sp + 8] = _s2E4t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HKI; else goto c2HKo;
       u2HKI: // global
           call _c2HKk(R1) args: 0, res: 0, upd: 0;
       c2HKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HKk() //  [R1]
         { info_tbl: [(c2HKk,
                       label: block_c2HKk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HKk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HKu; else goto c2HKt;
       c2HKu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HKt: // global
           _s2E4w::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4w::I64, 64)) goto c2HKG; else goto c2HKH;
       c2HKG: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2E4w::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HKH: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.970723769 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c2HLa,
                       label: GHC.Word.$fBitsWord64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLa: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.973971344 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.976088598 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.978715062 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c2HLq,
                       label: GHC.Word.$fIxWord64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HLz; else goto c2HLA;
       c2HLz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HLA: // global
           I64[Sp - 16] = block_c2HLn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HLX; else goto c2HLo;
       u2HLX: // global
           call _c2HLn(R1) args: 0, res: 0, upd: 0;
       c2HLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HLn() //  [R1]
         { info_tbl: [(c2HLn,
                       label: block_c2HLn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLn: // global
           I64[Sp - 8] = block_c2HLt_info;
           _s2E4E::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E4E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HLW; else goto c2HLu;
       u2HLW: // global
           call _c2HLt(R1) args: 0, res: 0, upd: 0;
       c2HLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HLt() //  [R1]
         { info_tbl: [(c2HLt,
                       label: block_c2HLt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLt: // global
           I64[Sp] = block_c2HLy_info;
           _s2E4G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E4G::I64;
           if (R1 & 7 != 0) goto u2HLY; else goto c2HLD;
       u2HLY: // global
           call _c2HLy(R1) args: 0, res: 0, upd: 0;
       c2HLD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HLy() //  [R1]
         { info_tbl: [(c2HLy,
                       label: block_c2HLy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLy: // global
           _s2E4I::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E4I::I64) goto c2HLL; else goto c2HLP;
       c2HLL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HLP: // global
           _s2E4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2HLO_info;
           R1 = _s2E4E::P64;
           I64[Sp + 16] = _s2E4I::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2HLZ; else goto c2HLQ;
       u2HLZ: // global
           call _c2HLO(R1) args: 0, res: 0, upd: 0;
       c2HLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HLO() //  [R1]
         { info_tbl: [(c2HLO,
                       label: block_c2HLO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HLO: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.989912635 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { info_tbl: [(c2HMD,
                       label: GHC.Word.$fIxWord64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HMD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HME; else goto c2HMF;
       c2HME: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HMF: // global
           I64[Sp - 8] = block_c2HMA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HMJ; else goto c2HMB;
       u2HMJ: // global
           call _c2HMA(R1) args: 0, res: 0, upd: 0;
       c2HMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HMA() //  [R1]
         { info_tbl: [(c2HMA,
                       label: block_c2HMA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HMA: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:24.995499795 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c2HN1,
                       label: GHC.Word.$fIxWord64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HNl; else goto c2HNm;
       c2HNl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HNm: // global
           I64[Sp - 16] = block_c2HMY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HNt; else goto c2HMZ;
       u2HNt: // global
           call _c2HMY(R1) args: 0, res: 0, upd: 0;
       c2HMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HMY() //  [R1]
         { info_tbl: [(c2HMY,
                       label: block_c2HMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HMY: // global
           I64[Sp] = block_c2HN4_info;
           _s2E4U::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2E4U::P64;
           if (R1 & 7 != 0) goto u2HNs; else goto c2HN5;
       u2HNs: // global
           call _c2HN4(R1) args: 0, res: 0, upd: 0;
       c2HN5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HN4() //  [R1]
         { info_tbl: [(c2HN4,
                       label: block_c2HN4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HN4: // global
           I64[Sp] = block_c2HN9_info;
           _s2E4X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E4X::I64;
           if (R1 & 7 != 0) goto u2HNu; else goto c2HNa;
       u2HNu: // global
           call _c2HN9(R1) args: 0, res: 0, upd: 0;
       c2HNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HN9() //  [R1]
         { info_tbl: [(c2HN9,
                       label: block_c2HN9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HN9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HNr; else goto c2HNq;
       c2HNr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HNq: // global
           _s2E51::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E51::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.005168755 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c2HO0,
                       label: GHC.Word.$fIxWord64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HO9; else goto c2HOa;
       c2HO9: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HOa: // global
           I64[Sp - 8] = block_c2HNX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HOC; else goto c2HNY;
       u2HOC: // global
           call _c2HNX(R1) args: 0, res: 0, upd: 0;
       c2HNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HNX() //  [R1]
         { info_tbl: [(c2HNX,
                       label: block_c2HNX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HNX: // global
           I64[Sp - 8] = block_c2HO3_info;
           _s2E55::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E55::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HOB; else goto c2HO4;
       u2HOB: // global
           call _c2HO3(R1) args: 0, res: 0, upd: 0;
       c2HO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HO3() //  [R1]
         { info_tbl: [(c2HO3,
                       label: block_c2HO3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HO3: // global
           I64[Sp] = block_c2HO8_info;
           _s2E57::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E57::I64;
           if (R1 & 7 != 0) goto u2HOD; else goto c2HOd;
       u2HOD: // global
           call _c2HO8(R1) args: 0, res: 0, upd: 0;
       c2HOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HO8() //  [R1]
         { info_tbl: [(c2HO8,
                       label: block_c2HO8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HO8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HOj; else goto c2HOi;
       c2HOj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HOi: // global
           _s2E57::I64 = I64[Sp + 8];
           _s2E59::I64 = I64[R1 + 7];
           if (_s2E57::I64 > _s2E59::I64) goto c2HOn; else goto c2HOA;
       c2HOn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HOA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E59::I64 - _s2E57::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.014992033 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c2HPb,
                       label: GHC.Word.$fIxWord64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HPb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HPy; else goto c2HPz;
       c2HPy: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HPz: // global
           I64[Sp - 8] = block_c2HP8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HPG; else goto c2HP9;
       u2HPG: // global
           call _c2HP8(R1) args: 0, res: 0, upd: 0;
       c2HP9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HP8() //  [R1]
         { info_tbl: [(c2HP8,
                       label: block_c2HP8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HP8: // global
           I64[Sp - 8] = block_c2HPe_info;
           _s2E5g::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2E5g::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HPF; else goto c2HPf;
       u2HPF: // global
           call _c2HPe(R1) args: 0, res: 0, upd: 0;
       c2HPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HPe() //  [R1]
         { info_tbl: [(c2HPe,
                       label: block_c2HPe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HPe: // global
           I64[Sp] = block_c2HPj_info;
           _s2E5j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E5j::I64;
           if (R1 & 7 != 0) goto u2HPH; else goto c2HPk;
       u2HPH: // global
           call _c2HPj(R1) args: 0, res: 0, upd: 0;
       c2HPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HPj() //  [R1]
         { info_tbl: [(c2HPj,
                       label: block_c2HPj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HPj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HPE; else goto c2HPD;
       c2HPE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HPD: // global
           _s2E5o::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E5o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.024924446 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c2HQe,
                       label: GHC.Word.$fIxWord64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HQe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HQn; else goto c2HQo;
       c2HQn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HQo: // global
           I64[Sp - 16] = block_c2HQb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HR0; else goto c2HQc;
       u2HR0: // global
           call _c2HQb(R1) args: 0, res: 0, upd: 0;
       c2HQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HQb() //  [R1]
         { info_tbl: [(c2HQb,
                       label: block_c2HQb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HQb: // global
           I64[Sp - 8] = block_c2HQh_info;
           _s2E5t::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E5t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HQZ; else goto c2HQi;
       u2HQZ: // global
           call _c2HQh(R1) args: 0, res: 0, upd: 0;
       c2HQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HQh() //  [R1]
         { info_tbl: [(c2HQh,
                       label: block_c2HQh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HQh: // global
           I64[Sp] = block_c2HQm_info;
           _s2E5v::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E5v::I64;
           if (R1 & 7 != 0) goto u2HR1; else goto c2HQr;
       u2HR1: // global
           call _c2HQm(R1) args: 0, res: 0, upd: 0;
       c2HQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HQm() //  [R1]
         { info_tbl: [(c2HQm,
                       label: block_c2HQm_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HQm: // global
           _s2E5x::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E5x::I64) goto c2HQz; else goto c2HQD;
       c2HQz: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HQD: // global
           I64[Sp] = block_c2HQC_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E5x::I64;
           if (R1 & 7 != 0) goto u2HR2; else goto c2HQE;
       u2HR2: // global
           call _c2HQC(R1) args: 0, res: 0, upd: 0;
       c2HQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HQC() //  [R1]
         { info_tbl: [(c2HQC,
                       label: block_c2HQC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HQC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HQK; else goto c2HQJ;
       c2HQK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HQJ: // global
           _s2E5x::I64 = I64[Sp + 8];
           if (_s2E5x::I64 > I64[R1 + 7]) goto c2HQO; else goto c2HQY;
       c2HQO: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HQY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E5x::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.036233562 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.038540361 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c2HRE,
                       label: GHC.Word.uncheckedShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HRE: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.042630502 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { info_tbl: [(c2HRS,
                       label: GHC.Word.uncheckedShiftRL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HRS: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.046037826 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { info_tbl: [(c2HS8,
                       label: GHC.Word.byteSwap64_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HS8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HSg; else goto c2HSh;
       c2HSg: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HSh: // global
           I64[Sp - 8] = block_c2HS5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HSl; else goto c2HS6;
       u2HSl: // global
           call _c2HS5(R1) args: 0, res: 0, upd: 0;
       c2HS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2HS5() //  [R1]
         { info_tbl: [(c2HS5,
                       label: block_c2HS5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HS5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HSk; else goto c2HSj;
       c2HSk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HSj: // global
           (_c2HSb::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2HSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.051545392 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.053131248 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.055084955 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.056647557 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.058385995 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.060077973 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.061817626 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.063405794 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.065122963 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.06722179 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.069082603 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.070986471 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.072619258 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.074429292 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.076009251 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.07780678 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.079497937 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.08117143 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.083007733 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.084610431 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.086437425 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.088082577 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.089893211 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.091528624 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.094327901 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.095898107 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.097616284 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.099443179 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.101120733 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.102939978 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.104653724 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.106392345 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.107969241 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.109679895 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.111751778 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { info_tbl: [(c2HTb,
                       label: GHC.Word.W8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HTb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTf; else goto c2HTe;
       c2HTf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTe: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.115585983 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { info_tbl: [(c2HTr,
                       label: GHC.Word.W16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HTr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTv; else goto c2HTu;
       c2HTv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.119886538 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { info_tbl: [(c2HTH,
                       label: GHC.Word.W32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HTH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTL; else goto c2HTK;
       c2HTL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTK: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.124433219 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { info_tbl: [(c2HTX,
                       label: GHC.Word.W64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HTX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HU1; else goto c2HU0;
       c2HU1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HU0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.128243447 UTC

[GHC.Word.W8#_con_entry() //  [R1]
         { info_tbl: [(c2HU8,
                       label: GHC.Word.W8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HU8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.132152933 UTC

[GHC.Word.W16#_con_entry() //  [R1]
         { info_tbl: [(c2HUf,
                       label: GHC.Word.W16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HUf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.135276096 UTC

[GHC.Word.W32#_con_entry() //  [R1]
         { info_tbl: [(c2HUm,
                       label: GHC.Word.W32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HUm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.138398299 UTC

[GHC.Word.W64#_con_entry() //  [R1]
         { info_tbl: [(c2HUt,
                       label: GHC.Word.W64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2HUt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:25.141558053 UTC

[section ""relreadonly" . S2Ecg_srt" {
     S2Ecg_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2DyV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]

