
==================== Tidy Core ====================
2018-03-16 15:57:09.254670016 UTC

Result size of Tidy Core
  = {terms: 5,850, types: 3,186, coercions: 0, joins: 0/53}

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$cfromEnum :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pCO [Occ=Once!] :: Word8) ->
                 case ds_d2pCO of { W8# x#_a2o1l [Occ=Once] ->
                 GHC.Types.I# (word2Int# x#_a2o1l)
                 }}]
GHC.Word.$fEnumWord8_$cfromEnum
  = \ (ds_d2pCO :: Word8) ->
      case ds_d2pCO of { W8# x#_a2o1l ->
      GHC.Types.I# (word2Int# x#_a2o1l)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$cfromEnum :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pz0 [Occ=Once!] :: Word16) ->
                 case ds_d2pz0 of { W16# x#_a2o0c [Occ=Once] ->
                 GHC.Types.I# (word2Int# x#_a2o0c)
                 }}]
GHC.Word.$fEnumWord16_$cfromEnum
  = \ (ds_d2pz0 :: Word16) ->
      case ds_d2pz0 of { W16# x#_a2o0c ->
      GHC.Types.I# (word2Int# x#_a2o0c)
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$cfromEnum :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2puo [Occ=Once!] :: Word32) ->
                 case ds_d2puo of { W32# x#_a2nZ6 [Occ=Once] ->
                 GHC.Types.I# (word2Int# x#_a2nZ6)
                 }}]
GHC.Word.$fEnumWord32_$cfromEnum
  = \ (ds_d2puo :: Word32) ->
      case ds_d2puo of { W32# x#_a2nZ6 ->
      GHC.Types.I# (word2Int# x#_a2nZ6)
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$cfromInteger :: Integer -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2nY6 [Occ=Once] :: Integer) ->
                 case integerToWord i_a2nY6 of wild_X6I { __DEFAULT ->
                 GHC.Word.W64# wild_X6I
                 }}]
GHC.Word.$fNumWord64_$cfromInteger
  = \ (i_a2nY6 :: Integer) ->
      case integerToWord i_a2nY6 of wild_X6I { __DEFAULT ->
      GHC.Word.W64# wild_X6I
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$cabs :: Word64 -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a2nY5 [Occ=Once] :: Word64) -> x_a2nY5}]
GHC.Word.$fNumWord64_$cabs = \ (x_a2nY5 :: Word64) -> x_a2nY5

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$cnegate :: Word64 -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pr1 [Occ=Once!] :: Word64) ->
                 case ds_d2pr1 of { W64# x#_a2nY4 [Occ=Once] ->
                 GHC.Word.W64# (int2Word# (negateInt# (word2Int# x#_a2nY4)))
                 }}]
GHC.Word.$fNumWord64_$cnegate
  = \ (ds_d2pr1 :: Word64) ->
      case ds_d2pr1 of { W64# x#_a2nY4 ->
      GHC.Word.W64# (int2Word# (negateInt# (word2Int# x#_a2nY4)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$c* :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pqU [Occ=Once!] :: Word64)
                 (ds1_d2pqV [Occ=Once!] :: Word64) ->
                 case ds_d2pqU of { W64# x#_a2nY2 [Occ=Once] ->
                 case ds1_d2pqV of { W64# y#_a2nY3 [Occ=Once] ->
                 GHC.Word.W64# (timesWord# x#_a2nY2 y#_a2nY3)
                 }
                 }}]
GHC.Word.$fNumWord64_$c*
  = \ (ds_d2pqU :: Word64) (ds1_d2pqV :: Word64) ->
      case ds_d2pqU of { W64# x#_a2nY2 ->
      case ds1_d2pqV of { W64# y#_a2nY3 ->
      GHC.Word.W64# (timesWord# x#_a2nY2 y#_a2nY3)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$c- :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pqN [Occ=Once!] :: Word64)
                 (ds1_d2pqO [Occ=Once!] :: Word64) ->
                 case ds_d2pqN of { W64# x#_a2nY0 [Occ=Once] ->
                 case ds1_d2pqO of { W64# y#_a2nY1 [Occ=Once] ->
                 GHC.Word.W64# (minusWord# x#_a2nY0 y#_a2nY1)
                 }
                 }}]
GHC.Word.$fNumWord64_$c-
  = \ (ds_d2pqN :: Word64) (ds1_d2pqO :: Word64) ->
      case ds_d2pqN of { W64# x#_a2nY0 ->
      case ds1_d2pqO of { W64# y#_a2nY1 ->
      GHC.Word.W64# (minusWord# x#_a2nY0 y#_a2nY1)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$c+ :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pqG [Occ=Once!] :: Word64)
                 (ds1_d2pqH [Occ=Once!] :: Word64) ->
                 case ds_d2pqG of { W64# x#_a2nXY [Occ=Once] ->
                 case ds1_d2pqH of { W64# y#_a2nXZ [Occ=Once] ->
                 GHC.Word.W64# (plusWord# x#_a2nXY y#_a2nXZ)
                 }
                 }}]
GHC.Word.$fNumWord64_$c+
  = \ (ds_d2pqG :: Word64) (ds1_d2pqH :: Word64) ->
      case ds_d2pqG of { W64# x#_a2nXY ->
      case ds1_d2pqH of { W64# y#_a2nXZ ->
      GHC.Word.W64# (plusWord# x#_a2nXY y#_a2nXZ)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tcWord6 = "Word64"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_r2uFF :: [Char]
[GblId]
lvl_r2uFF = unpackCString# GHC.Word.$tcWord6

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/1}
GHC.Word.$fIntegralWord64_$ctoInteger :: Word64 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ppi [Occ=Once!] :: Word64) ->
                 case ds_d2ppi of { W64# x#_a2nXQ ->
                 let {
                   i#_s2qgg :: Int#
                   [LclId]
                   i#_s2qgg = word2Int# x#_a2nXQ } in
                 case >=# i#_s2qgg 0# of {
                   __DEFAULT -> wordToInteger x#_a2nXQ;
                   1# -> smallInteger i#_s2qgg
                 }
                 }}]
GHC.Word.$fIntegralWord64_$ctoInteger
  = \ (ds_d2ppi :: Word64) ->
      case ds_d2ppi of { W64# x#_a2nXQ ->
      let {
        i#_s2qgg [Dmd=<S,U>] :: Int#
        [LclId]
        i#_s2qgg = word2Int# x#_a2nXQ } in
      case >=# i#_s2qgg 0# of {
        __DEFAULT -> wordToInteger x#_a2nXQ;
        1# -> smallInteger i#_s2qgg
      }
      }

-- RHS size: {terms: 28, types: 17, coercions: 0, joins: 0/2}
GHC.Word.$fShowWord3 :: Word64 -> ShowS
[GblId,
 Arity=1,
 Str=<L,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 151 60}]
GHC.Word.$fShowWord3
  = \ (x_a2nX5 :: Word64) ->
      let {
        w1_i2pQf :: Integer
        [LclId]
        w1_i2pQf
          = case x_a2nX5 of { W64# x#_a2nXQ ->
            let {
              i#_s2qgg [Dmd=<S,U>] :: Int#
              [LclId]
              i#_s2qgg = word2Int# x#_a2nXQ } in
            case >=# i#_s2qgg 0# of {
              __DEFAULT -> wordToInteger x#_a2nXQ;
              1# -> smallInteger i#_s2qgg
            }
            } } in
      \ (w2_i2pQg :: String) ->
        case GHC.Show.$w$cshowsPrec4 0# w1_i2pQf w2_i2pQg of
        { (# ww3_i2pQo, ww4_i2pQp #) ->
        GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
        }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord64_$cshowList :: [Word64] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Word64])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Word64 GHC.Word.$fShowWord3 ls_i1Mix s_i1Miy}]
GHC.Word.$fShowWord64_$cshowList
  = \ (ls_i1Mix :: [Word64]) (s_i1Miy :: String) ->
      showList__ @ Word64 GHC.Word.$fShowWord3 ls_i1Mix s_i1Miy

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/1}
GHC.Word.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: Word# -> (# Char, [Char] #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 141 0}]
GHC.Word.$w$cshow
  = \ (ww_s2sPq :: Word#) ->
      let {
        i#_s2qgg [Dmd=<S,U>] :: Int#
        [LclId]
        i#_s2qgg = word2Int# ww_s2sPq } in
      case >=# i#_s2qgg 0# of {
        __DEFAULT ->
          GHC.Show.$w$cshowsPrec4
            0# (wordToInteger ww_s2sPq) (GHC.Types.[] @ Char);
        1# ->
          GHC.Show.$w$cshowsPrec4
            0# (smallInteger i#_s2qgg) (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord64_$cshow [InlPrag=NOUSERINLINE[0]]
  :: Word64 -> String
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sPn [Occ=Once!] :: Word64) ->
                 case w_s2sPn of { W64# ww1_s2sPq [Occ=Once] ->
                 case GHC.Word.$w$cshow ww1_s2sPq of
                 { (# ww3_s2sSZ [Occ=Once], ww4_s2sT0 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww3_s2sSZ ww4_s2sT0
                 }
                 }}]
GHC.Word.$fShowWord64_$cshow
  = \ (w_s2sPn :: Word64) ->
      case w_s2sPn of { W64# ww1_s2sPq ->
      case GHC.Word.$w$cshow ww1_s2sPq of { (# ww3_s2sSZ, ww4_s2sT0 #) ->
      GHC.Types.: @ Char ww3_s2sSZ ww4_s2sT0
      }
      }

-- RHS size: {terms: 32, types: 20, coercions: 0, joins: 0/2}
GHC.Word.$fShowWord64_$cshowsPrec :: Int -> Word64 -> ShowS
[GblId,
 Arity=2,
 Str=<L,U(U)><L,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 20] 161 60}]
GHC.Word.$fShowWord64_$cshowsPrec
  = \ (p_a2nX4 :: Int) (x_a2nX5 :: Word64) ->
      let {
        w1_i2pQf :: Integer
        [LclId]
        w1_i2pQf
          = case x_a2nX5 of { W64# x#_a2nXQ ->
            let {
              i#_s2qgg [Dmd=<S,U>] :: Int#
              [LclId]
              i#_s2qgg = word2Int# x#_a2nXQ } in
            case >=# i#_s2qgg 0# of {
              __DEFAULT -> wordToInteger x#_a2nXQ;
              1# -> smallInteger i#_s2qgg
            }
            } } in
      \ (w2_i2pQg :: String) ->
        case p_a2nX4 of { I# ww1_i2pQk ->
        case GHC.Show.$w$cshowsPrec4 ww1_i2pQk w1_i2pQf w2_i2pQg of
        { (# ww3_i2pQo, ww4_i2pQp #) ->
        GHC.Types.: @ Char ww3_i2pQo ww4_i2pQp
        }
        }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Show Word64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Word64
                       GHC.Word.$fShowWord64_$cshowsPrec
                       GHC.Word.$fShowWord64_$cshow
                       GHC.Word.$fShowWord64_$cshowList]
GHC.Word.$fShowWord64
  = GHC.Show.C:Show
      @ Word64
      GHC.Word.$fShowWord64_$cshowsPrec
      GHC.Word.$fShowWord64_$cshow
      GHC.Word.$fShowWord64_$cshowList

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord5 :: Word64 -> Int
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Word.$fEnumWord5
  = \ (x_a2nXW :: Word64) ->
      fromEnumError
        @ Word64 @ Int GHC.Word.$fShowWord64 lvl_r2uFF x_a2nXW

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Word.$fRealWord1 = 1

-- RHS size: {terms: 22, types: 3, coercions: 0, joins: 0/1}
GHC.Word.$w$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word# -> (# Integer, Integer #)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 181 0}]
GHC.Word.$w$ctoRational
  = \ (ww_s2sPH :: Word#) ->
      let {
        i#_s2qgg [Dmd=<S,U>] :: Int#
        [LclId]
        i#_s2qgg = word2Int# ww_s2sPH } in
      case >=# i#_s2qgg 0# of {
        __DEFAULT ->
          GHC.Real.$w$sreduce
            (timesInteger (wordToInteger ww_s2sPH) GHC.Word.$fRealWord1)
            GHC.Word.$fRealWord1;
        1# ->
          GHC.Real.$w$sreduce
            (timesInteger (smallInteger i#_s2qgg) GHC.Word.$fRealWord1)
            GHC.Word.$fRealWord1
      }

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord64_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word64 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sPE [Occ=Once!] :: Word64) ->
                 case w_s2sPE of { W64# ww1_s2sPH [Occ=Once] ->
                 case GHC.Word.$w$ctoRational ww1_s2sPH of
                 { (# ww3_s2sT2 [Occ=Once], ww4_s2sT3 [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2sT2 ww4_s2sT3
                 }
                 }}]
GHC.Word.$fRealWord64_$ctoRational
  = \ (w_s2sPE :: Word64) ->
      case w_s2sPE of { W64# ww1_s2sPH ->
      case GHC.Word.$w$ctoRational ww1_s2sPH of
      { (# ww3_s2sT2, ww4_s2sT3 #) ->
      GHC.Real.:% @ Integer ww3_s2sT2 ww4_s2sT3
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tcWord9 = "Word8"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord10 :: Word8
[GblId, Str=x]
GHC.Word.$fEnumWord10
  = predError @ Word8 (unpackCString# GHC.Word.$tcWord9)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord11 :: Word8
[GblId, Str=x]
GHC.Word.$fEnumWord11
  = succError @ Word8 (unpackCString# GHC.Word.$tcWord9)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pm0 [Occ=Once!] :: Word8)
                 (ds1_d2pm1 [Occ=Once!] :: Word8) ->
                 case ds_d2pm0 of { W8# x_a2o1A [Occ=Once] ->
                 case ds1_d2pm1 of { W8# y_a2o1B [Occ=Once] ->
                 tagToEnum# @ Bool (neWord# x_a2o1A y_a2o1B)
                 }
                 }}]
neWord8
  = \ (ds_d2pm0 :: Word8) (ds1_d2pm1 :: Word8) ->
      case ds_d2pm0 of { W8# x_a2o1A ->
      case ds1_d2pm1 of { W8# y_a2o1B ->
      tagToEnum# @ Bool (neWord# x_a2o1A y_a2o1B)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_r2uFH :: [Char]
[GblId]
lvl2_r2uFH = unpackCString# GHC.Word.$tcWord9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cminBound :: Word8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord8_$cminBound = GHC.Word.W8# 0##

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$cpred :: Word8 -> Word8
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o1i [Occ=Once!] :: Word8) ->
                 case x_a2o1i of { W8# x1_a2o1A [Occ=Once!] ->
                 case x1_a2o1A of wild1_X8o {
                   __DEFAULT ->
                     GHC.Word.W8# (narrow8Word# (minusWord# wild1_X8o 1##));
                   0## -> GHC.Word.$fEnumWord10
                 }
                 }}]
GHC.Word.$fEnumWord8_$cpred
  = \ (x_a2o1i :: Word8) ->
      case x_a2o1i of { W8# x1_a2o1A ->
      case x1_a2o1A of wild1_X8o {
        __DEFAULT ->
          GHC.Word.W8# (narrow8Word# (minusWord# wild1_X8o 1##));
        0## -> GHC.Word.$fEnumWord10
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord8_$cmaxBound :: Word8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBoundedWord8_$cmaxBound = GHC.Word.W8# 255##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Word8
                          GHC.Word.$fBitsWord8_$cminBound
                          GHC.Word.$fBoundedWord8_$cmaxBound]
GHC.Word.$fBoundedWord8
  = GHC.Enum.C:Bounded
      @ Word8
      GHC.Word.$fBitsWord8_$cminBound
      GHC.Word.$fBoundedWord8_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$csucc :: Word8 -> Word8
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o1h [Occ=Once!] :: Word8) ->
                 case x_a2o1h of { W8# x1_a2o1A [Occ=Once!] ->
                 case x1_a2o1A of wild1_X8s {
                   __DEFAULT -> GHC.Word.W8# (narrow8Word# (plusWord# wild1_X8s 1##));
                   255## -> GHC.Word.$fEnumWord11
                 }
                 }}]
GHC.Word.$fEnumWord8_$csucc
  = \ (x_a2o1h :: Word8) ->
      case x_a2o1h of { W8# x1_a2o1A ->
      case x1_a2o1A of wild1_X8s {
        __DEFAULT -> GHC.Word.W8# (narrow8Word# (plusWord# wild1_X8s 1##));
        255## -> GHC.Word.$fEnumWord11
      }
      }

-- RHS size: {terms: 19, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord8_$cshowsPrec :: Int -> Word8 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a2o1w [Occ=Once!] :: Int)
                 (x_a2o1x [Occ=Once!] :: Word8)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a2o1x of { W8# x#_a2o2T [Occ=Once] ->
                 case p_a2o1w of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2T) eta_B1
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Word.$fShowWord8_$cshowsPrec
  = \ (p_a2o1w :: Int) (x_a2o1x :: Word8) (eta_B1 :: String) ->
      case x_a2o1x of { W8# x#_a2o2T ->
      case p_a2o1w of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2T) eta_B1
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord8_$cshow :: Word8 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Word8) ->
                 case x_i1Jj2 of { W8# x#_a2o2T [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt
                        0# (word2Int# x#_a2o2T) (GHC.Types.[] @ Char)
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord8_$cshow
  = \ (x_i1Jj2 :: Word8) ->
      case x_i1Jj2 of { W8# x#_a2o2T ->
      case GHC.Show.$wshowSignedInt
             0# (word2Int# x#_a2o2T) (GHC.Types.[] @ Char)
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord4 :: Word8 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o1x [Occ=Once!] :: Word8)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a2o1x of { W8# x#_a2o2T [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2T) eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord4
  = \ (x_a2o1x :: Word8) (eta_B1 [OS=OneShot] :: String) ->
      case x_a2o1x of { W8# x#_a2o2T ->
      case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2T) eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord8_$cshowList :: [Word8] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Word8])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Word8 GHC.Word.$fShowWord4 ls_i1Mix s_i1Miy}]
GHC.Word.$fShowWord8_$cshowList
  = \ (ls_i1Mix :: [Word8]) (s_i1Miy :: String) ->
      showList__ @ Word8 GHC.Word.$fShowWord4 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Show Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Word8
                       GHC.Word.$fShowWord8_$cshowsPrec
                       GHC.Word.$fShowWord8_$cshow
                       GHC.Word.$fShowWord8_$cshowList]
GHC.Word.$fShowWord8
  = GHC.Show.C:Show
      @ Word8
      GHC.Word.$fShowWord8_$cshowsPrec
      GHC.Word.$fShowWord8_$cshow
      GHC.Word.$fShowWord8_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$wlvl3 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word8
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Word.$wlvl3
  = \ (ww_s2sPQ :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Word8
        @ Word8
        GHC.Word.$fShowWord8
        lvl2_r2uFH
        ww_s2sPQ
        GHC.Word.$fBitsWord8_$cminBound
        GHC.Word.$fBoundedWord8_$cmaxBound

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Word.$w$ctoEnum2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Word.$w$ctoEnum2
  = \ (ww_s2sPW :: Int#) ->
      case >=# ww_s2sPW 0# of {
        __DEFAULT -> case GHC.Word.$wlvl3 ww_s2sPW of wild_00 { };
        1# ->
          case <=# ww_s2sPW 255# of {
            __DEFAULT -> case GHC.Word.$wlvl3 ww_s2sPW of wild_00 { };
            1# -> int2Word# ww_s2sPW
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Word8
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sPT [Occ=Once!] :: Int) ->
                 case w_s2sPT of { I# ww1_s2sPW [Occ=Once] ->
                 case GHC.Word.$w$ctoEnum2 ww1_s2sPW of ww2_s2sQ0 { __DEFAULT ->
                 GHC.Word.W8# ww2_s2sQ0
                 }
                 }}]
GHC.Word.$fEnumWord8_$ctoEnum
  = \ (w_s2sPT :: Int) ->
      case w_s2sPT of { I# ww1_s2sPW ->
      case GHC.Word.$w$ctoEnum2 ww1_s2sPW of ww2_s2sQ0 { __DEFAULT ->
      GHC.Word.W8# ww2_s2sQ0
      }
      }

-- RHS size: {terms: 255, types: 56, coercions: 0, joins: 0/10}
GHC.Word.$w$cenumFromThenTo2 [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> Word# -> [Word8]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Word.$w$cenumFromThenTo2
  = \ (ww_s2sQ9 :: Word#)
      (ww1_s2sQd :: Word#)
      (ww2_s2sQh :: Word#) ->
      let {
        x1_i2hRg [Dmd=<S,U>] :: Int#
        [LclId]
        x1_i2hRg = word2Int# ww_s2sQ9 } in
      let {
        x2_i2hRh [Dmd=<S,U>] :: Int#
        [LclId]
        x2_i2hRh = word2Int# ww1_s2sQd } in
      case >=# x2_i2hRh x1_i2hRg of {
        __DEFAULT ->
          let {
            y_i2ioF [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioF = word2Int# ww2_s2sQh } in
          case ># y_i2ioF x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word8
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 255# of {
                       __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                       1# -> GHC.Word.W8# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# y_i2ioF delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Word8]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word8
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl3 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 255# of {
                                      __DEFAULT -> GHC.Word.$wlvl3 x_i2ioK;
                                      1# -> GHC.Word.W8# (int2Word# x_i2ioK)
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Word8
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl3 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 255# of {
                                      __DEFAULT -> GHC.Word.$wlvl3 x_i2ioK;
                                      1# -> GHC.Word.W8# (int2Word# x_i2ioK)
                                    }
                                })
                               (GHC.Types.[] @ Word8)
                         }; } in
                 go_dn_i2ioJ x2_i2hRh);
            1# ->
              case ># y_i2ioF x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word8
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 255# of {
                           __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                           1# -> GHC.Word.W8# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word8);
                1# -> GHC.Types.[] @ Word8
              }
          };
        1# ->
          let {
            y_i2ioV [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioV = word2Int# ww2_s2sQh } in
          case <# y_i2ioV x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word8
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 255# of {
                       __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                       1# -> GHC.Word.W8# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# y_i2ioV delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Word8]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word8
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl3 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 255# of {
                                      __DEFAULT -> GHC.Word.$wlvl3 x_i2ip0;
                                      1# -> GHC.Word.W8# (int2Word# x_i2ip0)
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Word8
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl3 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 255# of {
                                      __DEFAULT -> GHC.Word.$wlvl3 x_i2ip0;
                                      1# -> GHC.Word.W8# (int2Word# x_i2ip0)
                                    }
                                })
                               (GHC.Types.[] @ Word8)
                         }; } in
                 go_up_i2ioZ x2_i2hRh);
            1# ->
              case <# y_i2ioV x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word8
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 255# of {
                           __DEFAULT -> GHC.Word.$wlvl3 x1_i2hRg;
                           1# -> GHC.Word.W8# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word8);
                1# -> GHC.Types.[] @ Word8
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Word8 -> Word8 -> Word8 -> [Word8]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sQ4 [Occ=Once!] :: Word8)
                 (w1_s2sQ5 [Occ=Once!] :: Word8)
                 (w2_s2sQ6 [Occ=Once!] :: Word8) ->
                 case w_s2sQ4 of { W8# ww1_s2sQ9 [Occ=Once] ->
                 case w1_s2sQ5 of { W8# ww3_s2sQd [Occ=Once] ->
                 case w2_s2sQ6 of { W8# ww5_s2sQh [Occ=Once] ->
                 GHC.Word.$w$cenumFromThenTo2 ww1_s2sQ9 ww3_s2sQd ww5_s2sQh
                 }
                 }
                 }}]
GHC.Word.$fEnumWord8_$cenumFromThenTo
  = \ (w_s2sQ4 :: Word8) (w1_s2sQ5 :: Word8) (w2_s2sQ6 :: Word8) ->
      case w_s2sQ4 of { W8# ww1_s2sQ9 ->
      case w1_s2sQ5 of { W8# ww3_s2sQd ->
      case w2_s2sQ6 of { W8# ww5_s2sQh ->
      GHC.Word.$w$cenumFromThenTo2 ww1_s2sQ9 ww3_s2sQd ww5_s2sQh
      }
      }
      }

-- RHS size: {terms: 50, types: 15, coercions: 0, joins: 0/3}
GHC.Word.$w$cenumFromTo2 [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> [Word8]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Word.$w$cenumFromTo2
  = \ (ww_s2sQp :: Word#) (ww1_s2sQt :: Word#) ->
      let {
        x0_i1MGz [Dmd=<S,U>] :: Int#
        [LclId]
        x0_i1MGz = word2Int# ww_s2sQp } in
      let {
        y_i1MGA [Dmd=<S,U>] :: Int#
        [LclId]
        y_i1MGA = word2Int# ww1_s2sQt } in
      case ># x0_i1MGz y_i1MGA of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Word8]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Word8
                    (case >=# x_i1MGD 0# of {
                       __DEFAULT -> GHC.Word.$wlvl3 x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 255# of {
                           __DEFAULT -> GHC.Word.$wlvl3 x_i1MGD;
                           1# -> GHC.Word.W8# (int2Word# x_i1MGD)
                         }
                     })
                    (case ==# x_i1MGD y_i1MGA of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Word8
                     }); } in
          go_i1MGC x0_i1MGz;
        1# -> GHC.Types.[] @ Word8
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Word8 -> Word8 -> [Word8]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sQl [Occ=Once!] :: Word8)
                 (w1_s2sQm [Occ=Once!] :: Word8) ->
                 case w_s2sQl of { W8# ww1_s2sQp [Occ=Once] ->
                 case w1_s2sQm of { W8# ww3_s2sQt [Occ=Once] ->
                 GHC.Word.$w$cenumFromTo2 ww1_s2sQp ww3_s2sQt
                 }
                 }}]
GHC.Word.$fEnumWord8_$cenumFromTo
  = \ (w_s2sQl :: Word8) (w1_s2sQm :: Word8) ->
      case w_s2sQl of { W8# ww1_s2sQp ->
      case w1_s2sQm of { W8# ww3_s2sQt ->
      GHC.Word.$w$cenumFromTo2 ww1_s2sQp ww3_s2sQt
      }
      }

Rec {
-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/0}
GHC.Word.$wgo2 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Word8, [Word8] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Word.$wgo2
  = \ (w_s2sQw :: Int#) ->
      (# case >=# w_s2sQw 0# of {
           __DEFAULT -> GHC.Word.$wlvl3 w_s2sQw;
           1# ->
             case <=# w_s2sQw 255# of {
               __DEFAULT -> GHC.Word.$wlvl3 w_s2sQw;
               1# -> GHC.Word.W8# (int2Word# w_s2sQw)
             }
         },
         case w_s2sQw of wild_X82 {
           __DEFAULT ->
             case GHC.Word.$wgo2 (+# wild_X82 1#) of
             { (# ww1_s2sT5, ww2_s2sT6 #) ->
             GHC.Types.: @ Word8 ww1_s2sT5 ww2_s2sT6
             };
           255# -> GHC.Types.[] @ Word8
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_go [InlPrag=NOUSERINLINE[0]]
  :: Int# -> [Word8]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sQw [Occ=Once] :: Int#) ->
                 case GHC.Word.$wgo2 w_s2sQw of
                 { (# ww1_s2sT5 [Occ=Once], ww2_s2sT6 [Occ=Once] #) ->
                 GHC.Types.: @ Word8 ww1_s2sT5 ww2_s2sT6
                 }}]
GHC.Word.$fEnumWord8_go
  = \ (w_s2sQw :: Int#) ->
      case GHC.Word.$wgo2 w_s2sQw of { (# ww1_s2sT5, ww2_s2sT6 #) ->
      GHC.Types.: @ Word8 ww1_s2sT5 ww2_s2sT6
      }

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/1}
GHC.Word.$fEnumWord8_$cenumFrom :: Word8 -> [Word8]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Word8) ->
                 case n_i2puv of { W8# x#_a2o1l [Occ=Once] ->
                 let {
                   x_i2puy :: Int#
                   [LclId]
                   x_i2puy = word2Int# x#_a2o1l } in
                 case ># x_i2puy 255# of {
                   __DEFAULT -> GHC.Word.$fEnumWord8_go x_i2puy;
                   1# -> GHC.Types.[] @ Word8
                 }
                 }}]
GHC.Word.$fEnumWord8_$cenumFrom
  = \ (n_i2puv :: Word8) ->
      case n_i2puv of { W8# x#_a2o1l ->
      let {
        x_i2puy [Dmd=<S,U>] :: Int#
        [LclId]
        x_i2puy = word2Int# x#_a2o1l } in
      case ># x_i2puy 255# of {
        __DEFAULT -> GHC.Word.$fEnumWord8_go x_i2puy;
        1# -> GHC.Types.[] @ Word8
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Word8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Word8
                       GHC.Word.$fEnumWord8_$csucc
                       GHC.Word.$fEnumWord8_$cpred
                       GHC.Word.$fEnumWord8_$ctoEnum
                       GHC.Word.$fEnumWord8_$cfromEnum
                       GHC.Word.$fEnumWord8_$cenumFrom
                       GHC.Word.$fEnumWord8_$cenumFromThen
                       GHC.Word.$fEnumWord8_$cenumFromTo
                       GHC.Word.$fEnumWord8_$cenumFromThenTo]
GHC.Word.$fEnumWord8
  = GHC.Enum.C:Enum
      @ Word8
      GHC.Word.$fEnumWord8_$csucc
      GHC.Word.$fEnumWord8_$cpred
      GHC.Word.$fEnumWord8_$ctoEnum
      GHC.Word.$fEnumWord8_$cfromEnum
      GHC.Word.$fEnumWord8_$cenumFrom
      GHC.Word.$fEnumWord8_$cenumFromThen
      GHC.Word.$fEnumWord8_$cenumFromTo
      GHC.Word.$fEnumWord8_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord8_$cenumFromThen [Occ=LoopBreaker]
  :: Word8 -> Word8 -> [Word8]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Word.$fEnumWord8_$cenumFromThen
  = boundedEnumFromThen
      @ Word8 GHC.Word.$fEnumWord8 GHC.Word.$fBoundedWord8
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tcWord2 = "Word16"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord1 :: Word16
[GblId, Str=x]
GHC.Word.$fEnumWord1
  = predError @ Word16 (unpackCString# GHC.Word.$tcWord2)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord2 :: Word16
[GblId, Str=x]
GHC.Word.$fEnumWord2
  = succError @ Word16 (unpackCString# GHC.Word.$tcWord2)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2plk [Occ=Once!] :: Word16)
                 (ds1_d2pll [Occ=Once!] :: Word16) ->
                 case ds_d2plk of { W16# x_a2o1M [Occ=Once] ->
                 case ds1_d2pll of { W16# y_a2o1N [Occ=Once] ->
                 tagToEnum# @ Bool (neWord# x_a2o1M y_a2o1N)
                 }
                 }}]
neWord16
  = \ (ds_d2plk :: Word16) (ds1_d2pll :: Word16) ->
      case ds_d2plk of { W16# x_a2o1M ->
      case ds1_d2pll of { W16# y_a2o1N ->
      tagToEnum# @ Bool (neWord# x_a2o1M y_a2o1N)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl4_r2uFJ :: [Char]
[GblId]
lvl4_r2uFJ = unpackCString# GHC.Word.$tcWord2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cminBound :: Word16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord16_$cminBound = GHC.Word.W16# 0##

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$cpred :: Word16 -> Word16
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o09 [Occ=Once!] :: Word16) ->
                 case x_a2o09 of { W16# x1_a2o1M [Occ=Once!] ->
                 case x1_a2o1M of wild1_X8S {
                   __DEFAULT ->
                     GHC.Word.W16# (narrow16Word# (minusWord# wild1_X8S 1##));
                   0## -> GHC.Word.$fEnumWord1
                 }
                 }}]
GHC.Word.$fEnumWord16_$cpred
  = \ (x_a2o09 :: Word16) ->
      case x_a2o09 of { W16# x1_a2o1M ->
      case x1_a2o1M of wild1_X8S {
        __DEFAULT ->
          GHC.Word.W16# (narrow16Word# (minusWord# wild1_X8S 1##));
        0## -> GHC.Word.$fEnumWord1
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord16_$cmaxBound :: Word16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBoundedWord16_$cmaxBound = GHC.Word.W16# 65535##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Word16
                          GHC.Word.$fBitsWord16_$cminBound
                          GHC.Word.$fBoundedWord16_$cmaxBound]
GHC.Word.$fBoundedWord16
  = GHC.Enum.C:Bounded
      @ Word16
      GHC.Word.$fBitsWord16_$cminBound
      GHC.Word.$fBoundedWord16_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$csucc :: Word16 -> Word16
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o08 [Occ=Once!] :: Word16) ->
                 case x_a2o08 of { W16# x1_a2o1M [Occ=Once!] ->
                 case x1_a2o1M of wild1_X8W {
                   __DEFAULT ->
                     GHC.Word.W16# (narrow16Word# (plusWord# wild1_X8W 1##));
                   65535## -> GHC.Word.$fEnumWord2
                 }
                 }}]
GHC.Word.$fEnumWord16_$csucc
  = \ (x_a2o08 :: Word16) ->
      case x_a2o08 of { W16# x1_a2o1M ->
      case x1_a2o1M of wild1_X8W {
        __DEFAULT ->
          GHC.Word.W16# (narrow16Word# (plusWord# wild1_X8W 1##));
        65535## -> GHC.Word.$fEnumWord2
      }
      }

-- RHS size: {terms: 19, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord16_$cshowsPrec :: Int -> Word16 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a2o0n [Occ=Once!] :: Int)
                 (x_a2o0o [Occ=Once!] :: Word16)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a2o0o of { W16# x#_a2o2K [Occ=Once] ->
                 case p_a2o0n of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2K) eta_B1
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Word.$fShowWord16_$cshowsPrec
  = \ (p_a2o0n :: Int) (x_a2o0o :: Word16) (eta_B1 :: String) ->
      case x_a2o0o of { W16# x#_a2o2K ->
      case p_a2o0n of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2K) eta_B1
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord16_$cshow :: Word16 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Word16) ->
                 case x_i1Jj2 of { W16# x#_a2o2K [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt
                        0# (word2Int# x#_a2o2K) (GHC.Types.[] @ Char)
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord16_$cshow
  = \ (x_i1Jj2 :: Word16) ->
      case x_i1Jj2 of { W16# x#_a2o2K ->
      case GHC.Show.$wshowSignedInt
             0# (word2Int# x#_a2o2K) (GHC.Types.[] @ Char)
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord1 :: Word16 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2o0o [Occ=Once!] :: Word16)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a2o0o of { W16# x#_a2o2K [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2K) eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord1
  = \ (x_a2o0o :: Word16) (eta_B1 [OS=OneShot] :: String) ->
      case x_a2o0o of { W16# x#_a2o2K ->
      case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2K) eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord16_$cshowList :: [Word16] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Word16])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Word16 GHC.Word.$fShowWord1 ls_i1Mix s_i1Miy}]
GHC.Word.$fShowWord16_$cshowList
  = \ (ls_i1Mix :: [Word16]) (s_i1Miy :: String) ->
      showList__ @ Word16 GHC.Word.$fShowWord1 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Show Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Word16
                       GHC.Word.$fShowWord16_$cshowsPrec
                       GHC.Word.$fShowWord16_$cshow
                       GHC.Word.$fShowWord16_$cshowList]
GHC.Word.$fShowWord16
  = GHC.Show.C:Show
      @ Word16
      GHC.Word.$fShowWord16_$cshowsPrec
      GHC.Word.$fShowWord16_$cshow
      GHC.Word.$fShowWord16_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$wlvl [InlPrag=NOUSERINLINE[0]] :: Int# -> Word16
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Word.$wlvl
  = \ (ww_s2sQJ :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Word16
        @ Word16
        GHC.Word.$fShowWord16
        lvl4_r2uFJ
        ww_s2sQJ
        GHC.Word.$fBitsWord16_$cminBound
        GHC.Word.$fBoundedWord16_$cmaxBound

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Word.$w$ctoEnum [InlPrag=NOUSERINLINE[0]] :: Int# -> Word#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Word.$w$ctoEnum
  = \ (ww_s2sQP :: Int#) ->
      case >=# ww_s2sQP 0# of {
        __DEFAULT -> case GHC.Word.$wlvl ww_s2sQP of wild_00 { };
        1# ->
          case <=# ww_s2sQP 65535# of {
            __DEFAULT -> case GHC.Word.$wlvl ww_s2sQP of wild_00 { };
            1# -> int2Word# ww_s2sQP
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Word16
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sQM [Occ=Once!] :: Int) ->
                 case w_s2sQM of { I# ww1_s2sQP [Occ=Once] ->
                 case GHC.Word.$w$ctoEnum ww1_s2sQP of ww2_s2sQT { __DEFAULT ->
                 GHC.Word.W16# ww2_s2sQT
                 }
                 }}]
GHC.Word.$fEnumWord16_$ctoEnum
  = \ (w_s2sQM :: Int) ->
      case w_s2sQM of { I# ww1_s2sQP ->
      case GHC.Word.$w$ctoEnum ww1_s2sQP of ww2_s2sQT { __DEFAULT ->
      GHC.Word.W16# ww2_s2sQT
      }
      }

-- RHS size: {terms: 255, types: 56, coercions: 0, joins: 0/10}
GHC.Word.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> Word# -> [Word16]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Word.$w$cenumFromThenTo
  = \ (ww_s2sR2 :: Word#)
      (ww1_s2sR6 :: Word#)
      (ww2_s2sRa :: Word#) ->
      let {
        x1_i2hRg [Dmd=<S,U>] :: Int#
        [LclId]
        x1_i2hRg = word2Int# ww_s2sR2 } in
      let {
        x2_i2hRh [Dmd=<S,U>] :: Int#
        [LclId]
        x2_i2hRh = word2Int# ww1_s2sR6 } in
      case >=# x2_i2hRh x1_i2hRg of {
        __DEFAULT ->
          let {
            y_i2ioF [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioF = word2Int# ww2_s2sRa } in
          case ># y_i2ioF x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word16
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 65535# of {
                       __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                       1# -> GHC.Word.W16# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# y_i2ioF delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Word16]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word16
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 65535# of {
                                      __DEFAULT -> GHC.Word.$wlvl x_i2ioK;
                                      1# -> GHC.Word.W16# (int2Word# x_i2ioK)
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Word16
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 65535# of {
                                      __DEFAULT -> GHC.Word.$wlvl x_i2ioK;
                                      1# -> GHC.Word.W16# (int2Word# x_i2ioK)
                                    }
                                })
                               (GHC.Types.[] @ Word16)
                         }; } in
                 go_dn_i2ioJ x2_i2hRh);
            1# ->
              case ># y_i2ioF x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word16
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 65535# of {
                           __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                           1# -> GHC.Word.W16# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word16);
                1# -> GHC.Types.[] @ Word16
              }
          };
        1# ->
          let {
            y_i2ioV [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioV = word2Int# ww2_s2sRa } in
          case <# y_i2ioV x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word16
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 65535# of {
                       __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                       1# -> GHC.Word.W16# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# y_i2ioV delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Word16]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word16
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 65535# of {
                                      __DEFAULT -> GHC.Word.$wlvl x_i2ip0;
                                      1# -> GHC.Word.W16# (int2Word# x_i2ip0)
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Word16
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 65535# of {
                                      __DEFAULT -> GHC.Word.$wlvl x_i2ip0;
                                      1# -> GHC.Word.W16# (int2Word# x_i2ip0)
                                    }
                                })
                               (GHC.Types.[] @ Word16)
                         }; } in
                 go_up_i2ioZ x2_i2hRh);
            1# ->
              case <# y_i2ioV x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word16
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 65535# of {
                           __DEFAULT -> GHC.Word.$wlvl x1_i2hRg;
                           1# -> GHC.Word.W16# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word16);
                1# -> GHC.Types.[] @ Word16
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Word16 -> Word16 -> Word16 -> [Word16]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sQX [Occ=Once!] :: Word16)
                 (w1_s2sQY [Occ=Once!] :: Word16)
                 (w2_s2sQZ [Occ=Once!] :: Word16) ->
                 case w_s2sQX of { W16# ww1_s2sR2 [Occ=Once] ->
                 case w1_s2sQY of { W16# ww3_s2sR6 [Occ=Once] ->
                 case w2_s2sQZ of { W16# ww5_s2sRa [Occ=Once] ->
                 GHC.Word.$w$cenumFromThenTo ww1_s2sR2 ww3_s2sR6 ww5_s2sRa
                 }
                 }
                 }}]
GHC.Word.$fEnumWord16_$cenumFromThenTo
  = \ (w_s2sQX :: Word16)
      (w1_s2sQY :: Word16)
      (w2_s2sQZ :: Word16) ->
      case w_s2sQX of { W16# ww1_s2sR2 ->
      case w1_s2sQY of { W16# ww3_s2sR6 ->
      case w2_s2sQZ of { W16# ww5_s2sRa ->
      GHC.Word.$w$cenumFromThenTo ww1_s2sR2 ww3_s2sR6 ww5_s2sRa
      }
      }
      }

-- RHS size: {terms: 50, types: 15, coercions: 0, joins: 0/3}
GHC.Word.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> [Word16]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Word.$w$cenumFromTo
  = \ (ww_s2sRi :: Word#) (ww1_s2sRm :: Word#) ->
      let {
        x0_i1MGz [Dmd=<S,U>] :: Int#
        [LclId]
        x0_i1MGz = word2Int# ww_s2sRi } in
      let {
        y_i1MGA [Dmd=<S,U>] :: Int#
        [LclId]
        y_i1MGA = word2Int# ww1_s2sRm } in
      case ># x0_i1MGz y_i1MGA of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Word16]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Word16
                    (case >=# x_i1MGD 0# of {
                       __DEFAULT -> GHC.Word.$wlvl x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 65535# of {
                           __DEFAULT -> GHC.Word.$wlvl x_i1MGD;
                           1# -> GHC.Word.W16# (int2Word# x_i1MGD)
                         }
                     })
                    (case ==# x_i1MGD y_i1MGA of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Word16
                     }); } in
          go_i1MGC x0_i1MGz;
        1# -> GHC.Types.[] @ Word16
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Word16 -> Word16 -> [Word16]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sRe [Occ=Once!] :: Word16)
                 (w1_s2sRf [Occ=Once!] :: Word16) ->
                 case w_s2sRe of { W16# ww1_s2sRi [Occ=Once] ->
                 case w1_s2sRf of { W16# ww3_s2sRm [Occ=Once] ->
                 GHC.Word.$w$cenumFromTo ww1_s2sRi ww3_s2sRm
                 }
                 }}]
GHC.Word.$fEnumWord16_$cenumFromTo
  = \ (w_s2sRe :: Word16) (w1_s2sRf :: Word16) ->
      case w_s2sRe of { W16# ww1_s2sRi ->
      case w1_s2sRf of { W16# ww3_s2sRm ->
      GHC.Word.$w$cenumFromTo ww1_s2sRi ww3_s2sRm
      }
      }

Rec {
-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/0}
GHC.Word.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Word16, [Word16] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Word.$wgo
  = \ (w_s2sRp :: Int#) ->
      (# case >=# w_s2sRp 0# of {
           __DEFAULT -> GHC.Word.$wlvl w_s2sRp;
           1# ->
             case <=# w_s2sRp 65535# of {
               __DEFAULT -> GHC.Word.$wlvl w_s2sRp;
               1# -> GHC.Word.W16# (int2Word# w_s2sRp)
             }
         },
         case w_s2sRp of wild_X8Z {
           __DEFAULT ->
             case GHC.Word.$wgo (+# wild_X8Z 1#) of
             { (# ww1_s2sT8, ww2_s2sT9 #) ->
             GHC.Types.: @ Word16 ww1_s2sT8 ww2_s2sT9
             };
           65535# -> GHC.Types.[] @ Word16
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_go [InlPrag=NOUSERINLINE[0]]
  :: Int# -> [Word16]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sRp [Occ=Once] :: Int#) ->
                 case GHC.Word.$wgo w_s2sRp of
                 { (# ww1_s2sT8 [Occ=Once], ww2_s2sT9 [Occ=Once] #) ->
                 GHC.Types.: @ Word16 ww1_s2sT8 ww2_s2sT9
                 }}]
GHC.Word.$fEnumWord16_go
  = \ (w_s2sRp :: Int#) ->
      case GHC.Word.$wgo w_s2sRp of { (# ww1_s2sT8, ww2_s2sT9 #) ->
      GHC.Types.: @ Word16 ww1_s2sT8 ww2_s2sT9
      }

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/1}
GHC.Word.$fEnumWord16_$cenumFrom :: Word16 -> [Word16]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Word16) ->
                 case n_i2puv of { W16# x#_a2o0c [Occ=Once] ->
                 let {
                   x_i2puy :: Int#
                   [LclId]
                   x_i2puy = word2Int# x#_a2o0c } in
                 case ># x_i2puy 65535# of {
                   __DEFAULT -> GHC.Word.$fEnumWord16_go x_i2puy;
                   1# -> GHC.Types.[] @ Word16
                 }
                 }}]
GHC.Word.$fEnumWord16_$cenumFrom
  = \ (n_i2puv :: Word16) ->
      case n_i2puv of { W16# x#_a2o0c ->
      let {
        x_i2puy [Dmd=<S,U>] :: Int#
        [LclId]
        x_i2puy = word2Int# x#_a2o0c } in
      case ># x_i2puy 65535# of {
        __DEFAULT -> GHC.Word.$fEnumWord16_go x_i2puy;
        1# -> GHC.Types.[] @ Word16
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Word16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Word16
                       GHC.Word.$fEnumWord16_$csucc
                       GHC.Word.$fEnumWord16_$cpred
                       GHC.Word.$fEnumWord16_$ctoEnum
                       GHC.Word.$fEnumWord16_$cfromEnum
                       GHC.Word.$fEnumWord16_$cenumFrom
                       GHC.Word.$fEnumWord16_$cenumFromThen
                       GHC.Word.$fEnumWord16_$cenumFromTo
                       GHC.Word.$fEnumWord16_$cenumFromThenTo]
GHC.Word.$fEnumWord16
  = GHC.Enum.C:Enum
      @ Word16
      GHC.Word.$fEnumWord16_$csucc
      GHC.Word.$fEnumWord16_$cpred
      GHC.Word.$fEnumWord16_$ctoEnum
      GHC.Word.$fEnumWord16_$cfromEnum
      GHC.Word.$fEnumWord16_$cenumFrom
      GHC.Word.$fEnumWord16_$cenumFromThen
      GHC.Word.$fEnumWord16_$cenumFromTo
      GHC.Word.$fEnumWord16_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord16_$cenumFromThen [Occ=LoopBreaker]
  :: Word16 -> Word16 -> [Word16]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Word.$fEnumWord16_$cenumFromThen
  = boundedEnumFromThen
      @ Word16 GHC.Word.$fEnumWord16 GHC.Word.$fBoundedWord16
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tcWord4 = "Word32"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord3 :: Word32
[GblId, Str=x]
GHC.Word.$fEnumWord3
  = predError @ Word32 (unpackCString# GHC.Word.$tcWord4)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord4 :: Word32
[GblId, Str=x]
GHC.Word.$fEnumWord4
  = succError @ Word32 (unpackCString# GHC.Word.$tcWord4)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkA [Occ=Once!] :: Word32)
                 (ds1_d2pkB [Occ=Once!] :: Word32) ->
                 case ds_d2pkA of { W32# x_a2o1Z [Occ=Once] ->
                 case ds1_d2pkB of { W32# y_a2o20 [Occ=Once] ->
                 tagToEnum# @ Bool (neWord# x_a2o1Z y_a2o20)
                 }
                 }}]
neWord32
  = \ (ds_d2pkA :: Word32) (ds1_d2pkB :: Word32) ->
      case ds_d2pkA of { W32# x_a2o1Z ->
      case ds1_d2pkB of { W32# y_a2o20 ->
      tagToEnum# @ Bool (neWord# x_a2o1Z y_a2o20)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl6_r2uFL :: [Char]
[GblId]
lvl6_r2uFL = unpackCString# GHC.Word.$tcWord4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cminBound :: Word32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord32_$cminBound = GHC.Word.W32# 0##

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$cpred :: Word32 -> Word32
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nZ3 [Occ=Once!] :: Word32) ->
                 case x_a2nZ3 of { W32# x1_a2o1Z [Occ=Once!] ->
                 case x1_a2o1Z of wild1_X9m {
                   __DEFAULT ->
                     GHC.Word.W32# (narrow32Word# (minusWord# wild1_X9m 1##));
                   0## -> GHC.Word.$fEnumWord3
                 }
                 }}]
GHC.Word.$fEnumWord32_$cpred
  = \ (x_a2nZ3 :: Word32) ->
      case x_a2nZ3 of { W32# x1_a2o1Z ->
      case x1_a2o1Z of wild1_X9m {
        __DEFAULT ->
          GHC.Word.W32# (narrow32Word# (minusWord# wild1_X9m 1##));
        0## -> GHC.Word.$fEnumWord3
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord32_$cmaxBound :: Word32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBoundedWord32_$cmaxBound = GHC.Word.W32# 4294967295##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Word32
                          GHC.Word.$fBitsWord32_$cminBound
                          GHC.Word.$fBoundedWord32_$cmaxBound]
GHC.Word.$fBoundedWord32
  = GHC.Enum.C:Bounded
      @ Word32
      GHC.Word.$fBitsWord32_$cminBound
      GHC.Word.$fBoundedWord32_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$csucc :: Word32 -> Word32
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nZ2 [Occ=Once!] :: Word32) ->
                 case x_a2nZ2 of { W32# x1_a2o1Z [Occ=Once!] ->
                 case x1_a2o1Z of wild1_X9q {
                   __DEFAULT ->
                     GHC.Word.W32# (narrow32Word# (plusWord# wild1_X9q 1##));
                   4294967295## -> GHC.Word.$fEnumWord4
                 }
                 }}]
GHC.Word.$fEnumWord32_$csucc
  = \ (x_a2nZ2 :: Word32) ->
      case x_a2nZ2 of { W32# x1_a2o1Z ->
      case x1_a2o1Z of wild1_X9q {
        __DEFAULT ->
          GHC.Word.W32# (narrow32Word# (plusWord# wild1_X9q 1##));
        4294967295## -> GHC.Word.$fEnumWord4
      }
      }

-- RHS size: {terms: 19, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord32_$cshowsPrec :: Int -> Word32 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a2nYf [Occ=Once!] :: Int)
                 (x_a2nYg [Occ=Once!] :: Word32)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a2nYg of { W32# x#_a2o2u [Occ=Once] ->
                 case p_a2nYf of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2u) eta_B1
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Word.$fShowWord32_$cshowsPrec
  = \ (p_a2nYf :: Int) (x_a2nYg :: Word32) (eta_B1 :: String) ->
      case x_a2nYg of { W32# x#_a2o2u ->
      case p_a2nYf of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV (word2Int# x#_a2o2u) eta_B1
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord32_$cshow :: Word32 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Word32) ->
                 case x_i1Jj2 of { W32# x#_a2o2u [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt
                        0# (word2Int# x#_a2o2u) (GHC.Types.[] @ Char)
                 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord32_$cshow
  = \ (x_i1Jj2 :: Word32) ->
      case x_i1Jj2 of { W32# x#_a2o2u ->
      case GHC.Show.$wshowSignedInt
             0# (word2Int# x#_a2o2u) (GHC.Types.[] @ Char)
      of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord2 :: Word32 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nYg [Occ=Once!] :: Word32)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a2nYg of { W32# x#_a2o2u [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2u) eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Word.$fShowWord2
  = \ (x_a2nYg :: Word32) (eta_B1 [OS=OneShot] :: String) ->
      case x_a2nYg of { W32# x#_a2o2u ->
      case GHC.Show.$wshowSignedInt 0# (word2Int# x#_a2o2u) eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord32_$cshowList :: [Word32] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Word32])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Word32 GHC.Word.$fShowWord2 ls_i1Mix s_i1Miy}]
GHC.Word.$fShowWord32_$cshowList
  = \ (ls_i1Mix :: [Word32]) (s_i1Miy :: String) ->
      showList__ @ Word32 GHC.Word.$fShowWord2 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fShowWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Show Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Word32
                       GHC.Word.$fShowWord32_$cshowsPrec
                       GHC.Word.$fShowWord32_$cshow
                       GHC.Word.$fShowWord32_$cshowList]
GHC.Word.$fShowWord32
  = GHC.Show.C:Show
      @ Word32
      GHC.Word.$fShowWord32_$cshowsPrec
      GHC.Word.$fShowWord32_$cshow
      GHC.Word.$fShowWord32_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$wlvl1 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word32
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Word.$wlvl1
  = \ (ww_s2sRC :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Word32
        @ Word32
        GHC.Word.$fShowWord32
        lvl6_r2uFL
        ww_s2sRC
        GHC.Word.$fBitsWord32_$cminBound
        GHC.Word.$fBoundedWord32_$cmaxBound

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Word.$w$ctoEnum1 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Word.$w$ctoEnum1
  = \ (ww_s2sRI :: Int#) ->
      case >=# ww_s2sRI 0# of {
        __DEFAULT -> case GHC.Word.$wlvl1 ww_s2sRI of wild_00 { };
        1# ->
          case <=# ww_s2sRI 4294967295# of {
            __DEFAULT -> case GHC.Word.$wlvl1 ww_s2sRI of wild_00 { };
            1# -> int2Word# ww_s2sRI
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Word32
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sRF [Occ=Once!] :: Int) ->
                 case w_s2sRF of { I# ww1_s2sRI [Occ=Once] ->
                 case GHC.Word.$w$ctoEnum1 ww1_s2sRI of ww2_s2sRM { __DEFAULT ->
                 GHC.Word.W32# ww2_s2sRM
                 }
                 }}]
GHC.Word.$fEnumWord32_$ctoEnum
  = \ (w_s2sRF :: Int) ->
      case w_s2sRF of { I# ww1_s2sRI ->
      case GHC.Word.$w$ctoEnum1 ww1_s2sRI of ww2_s2sRM { __DEFAULT ->
      GHC.Word.W32# ww2_s2sRM
      }
      }

-- RHS size: {terms: 255, types: 56, coercions: 0, joins: 0/10}
GHC.Word.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> Word# -> [Word32]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Word.$w$cenumFromThenTo1
  = \ (ww_s2sRV :: Word#)
      (ww1_s2sRZ :: Word#)
      (ww2_s2sS3 :: Word#) ->
      let {
        x1_i2hRg [Dmd=<S,U>] :: Int#
        [LclId]
        x1_i2hRg = word2Int# ww_s2sRV } in
      let {
        x2_i2hRh [Dmd=<S,U>] :: Int#
        [LclId]
        x2_i2hRh = word2Int# ww1_s2sRZ } in
      case >=# x2_i2hRh x1_i2hRg of {
        __DEFAULT ->
          let {
            y_i2ioF [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioF = word2Int# ww2_s2sS3 } in
          case ># y_i2ioF x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word32
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 4294967295# of {
                       __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                       1# -> GHC.Word.W32# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# y_i2ioF delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Word32]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word32
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl1 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 4294967295# of {
                                      __DEFAULT -> GHC.Word.$wlvl1 x_i2ioK;
                                      1# -> GHC.Word.W32# (int2Word# x_i2ioK)
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Word32
                               (case >=# x_i2ioK 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl1 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 4294967295# of {
                                      __DEFAULT -> GHC.Word.$wlvl1 x_i2ioK;
                                      1# -> GHC.Word.W32# (int2Word# x_i2ioK)
                                    }
                                })
                               (GHC.Types.[] @ Word32)
                         }; } in
                 go_dn_i2ioJ x2_i2hRh);
            1# ->
              case ># y_i2ioF x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word32
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 4294967295# of {
                           __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                           1# -> GHC.Word.W32# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word32);
                1# -> GHC.Types.[] @ Word32
              }
          };
        1# ->
          let {
            y_i2ioV [Dmd=<S,U>] :: Int#
            [LclId]
            y_i2ioV = word2Int# ww2_s2sS3 } in
          case <# y_i2ioV x2_i2hRh of {
            __DEFAULT ->
              GHC.Types.:
                @ Word32
                (case >=# x1_i2hRg 0# of {
                   __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                   1# ->
                     case <=# x1_i2hRg 4294967295# of {
                       __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                       1# -> GHC.Word.W32# (int2Word# x1_i2hRg)
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# x2_i2hRh x1_i2hRg } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# y_i2ioV delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Word32]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Word32
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl1 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 4294967295# of {
                                      __DEFAULT -> GHC.Word.$wlvl1 x_i2ip0;
                                      1# -> GHC.Word.W32# (int2Word# x_i2ip0)
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Word32
                               (case >=# x_i2ip0 0# of {
                                  __DEFAULT -> GHC.Word.$wlvl1 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 4294967295# of {
                                      __DEFAULT -> GHC.Word.$wlvl1 x_i2ip0;
                                      1# -> GHC.Word.W32# (int2Word# x_i2ip0)
                                    }
                                })
                               (GHC.Types.[] @ Word32)
                         }; } in
                 go_up_i2ioZ x2_i2hRh);
            1# ->
              case <# y_i2ioV x1_i2hRg of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Word32
                    (case >=# x1_i2hRg 0# of {
                       __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                       1# ->
                         case <=# x1_i2hRg 4294967295# of {
                           __DEFAULT -> GHC.Word.$wlvl1 x1_i2hRg;
                           1# -> GHC.Word.W32# (int2Word# x1_i2hRg)
                         }
                     })
                    (GHC.Types.[] @ Word32);
                1# -> GHC.Types.[] @ Word32
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Word32 -> Word32 -> Word32 -> [Word32]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sRQ [Occ=Once!] :: Word32)
                 (w1_s2sRR [Occ=Once!] :: Word32)
                 (w2_s2sRS [Occ=Once!] :: Word32) ->
                 case w_s2sRQ of { W32# ww1_s2sRV [Occ=Once] ->
                 case w1_s2sRR of { W32# ww3_s2sRZ [Occ=Once] ->
                 case w2_s2sRS of { W32# ww5_s2sS3 [Occ=Once] ->
                 GHC.Word.$w$cenumFromThenTo1 ww1_s2sRV ww3_s2sRZ ww5_s2sS3
                 }
                 }
                 }}]
GHC.Word.$fEnumWord32_$cenumFromThenTo
  = \ (w_s2sRQ :: Word32)
      (w1_s2sRR :: Word32)
      (w2_s2sRS :: Word32) ->
      case w_s2sRQ of { W32# ww1_s2sRV ->
      case w1_s2sRR of { W32# ww3_s2sRZ ->
      case w2_s2sRS of { W32# ww5_s2sS3 ->
      GHC.Word.$w$cenumFromThenTo1 ww1_s2sRV ww3_s2sRZ ww5_s2sS3
      }
      }
      }

-- RHS size: {terms: 50, types: 15, coercions: 0, joins: 0/3}
GHC.Word.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: Word# -> Word# -> [Word32]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Word.$w$cenumFromTo1
  = \ (ww_s2sSb :: Word#) (ww1_s2sSf :: Word#) ->
      let {
        x0_i1MGz [Dmd=<S,U>] :: Int#
        [LclId]
        x0_i1MGz = word2Int# ww_s2sSb } in
      let {
        y_i1MGA [Dmd=<S,U>] :: Int#
        [LclId]
        y_i1MGA = word2Int# ww1_s2sSf } in
      case ># x0_i1MGz y_i1MGA of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Word32]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Word32
                    (case >=# x_i1MGD 0# of {
                       __DEFAULT -> GHC.Word.$wlvl1 x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 4294967295# of {
                           __DEFAULT -> GHC.Word.$wlvl1 x_i1MGD;
                           1# -> GHC.Word.W32# (int2Word# x_i1MGD)
                         }
                     })
                    (case ==# x_i1MGD y_i1MGA of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Word32
                     }); } in
          go_i1MGC x0_i1MGz;
        1# -> GHC.Types.[] @ Word32
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Word32 -> Word32 -> [Word32]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sS7 [Occ=Once!] :: Word32)
                 (w1_s2sS8 [Occ=Once!] :: Word32) ->
                 case w_s2sS7 of { W32# ww1_s2sSb [Occ=Once] ->
                 case w1_s2sS8 of { W32# ww3_s2sSf [Occ=Once] ->
                 GHC.Word.$w$cenumFromTo1 ww1_s2sSb ww3_s2sSf
                 }
                 }}]
GHC.Word.$fEnumWord32_$cenumFromTo
  = \ (w_s2sS7 :: Word32) (w1_s2sS8 :: Word32) ->
      case w_s2sS7 of { W32# ww1_s2sSb ->
      case w1_s2sS8 of { W32# ww3_s2sSf ->
      GHC.Word.$w$cenumFromTo1 ww1_s2sSb ww3_s2sSf
      }
      }

Rec {
-- RHS size: {terms: 35, types: 20, coercions: 0, joins: 0/0}
GHC.Word.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Word32, [Word32] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Word.$wgo1
  = \ (w_s2sSi :: Int#) ->
      (# case >=# w_s2sSi 0# of {
           __DEFAULT -> GHC.Word.$wlvl1 w_s2sSi;
           1# ->
             case <=# w_s2sSi 4294967295# of {
               __DEFAULT -> GHC.Word.$wlvl1 w_s2sSi;
               1# -> GHC.Word.W32# (int2Word# w_s2sSi)
             }
         },
         case w_s2sSi of wild_X9X {
           __DEFAULT ->
             case GHC.Word.$wgo1 (+# wild_X9X 1#) of
             { (# ww1_s2sTb, ww2_s2sTc #) ->
             GHC.Types.: @ Word32 ww1_s2sTb ww2_s2sTc
             };
           4294967295# -> GHC.Types.[] @ Word32
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_go [InlPrag=NOUSERINLINE[0]]
  :: Int# -> [Word32]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sSi [Occ=Once] :: Int#) ->
                 case GHC.Word.$wgo1 w_s2sSi of
                 { (# ww1_s2sTb [Occ=Once], ww2_s2sTc [Occ=Once] #) ->
                 GHC.Types.: @ Word32 ww1_s2sTb ww2_s2sTc
                 }}]
GHC.Word.$fEnumWord32_go
  = \ (w_s2sSi :: Int#) ->
      case GHC.Word.$wgo1 w_s2sSi of { (# ww1_s2sTb, ww2_s2sTc #) ->
      GHC.Types.: @ Word32 ww1_s2sTb ww2_s2sTc
      }

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/1}
GHC.Word.$fEnumWord32_$cenumFrom :: Word32 -> [Word32]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Word32) ->
                 case n_i2puv of { W32# x#_a2nZ6 [Occ=Once] ->
                 let {
                   x_i2puy :: Int#
                   [LclId]
                   x_i2puy = word2Int# x#_a2nZ6 } in
                 case ># x_i2puy 4294967295# of {
                   __DEFAULT -> GHC.Word.$fEnumWord32_go x_i2puy;
                   1# -> GHC.Types.[] @ Word32
                 }
                 }}]
GHC.Word.$fEnumWord32_$cenumFrom
  = \ (n_i2puv :: Word32) ->
      case n_i2puv of { W32# x#_a2nZ6 ->
      let {
        x_i2puy [Dmd=<S,U>] :: Int#
        [LclId]
        x_i2puy = word2Int# x#_a2nZ6 } in
      case ># x_i2puy 4294967295# of {
        __DEFAULT -> GHC.Word.$fEnumWord32_go x_i2puy;
        1# -> GHC.Types.[] @ Word32
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Word32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Word32
                       GHC.Word.$fEnumWord32_$csucc
                       GHC.Word.$fEnumWord32_$cpred
                       GHC.Word.$fEnumWord32_$ctoEnum
                       GHC.Word.$fEnumWord32_$cfromEnum
                       GHC.Word.$fEnumWord32_$cenumFrom
                       GHC.Word.$fEnumWord32_$cenumFromThen
                       GHC.Word.$fEnumWord32_$cenumFromTo
                       GHC.Word.$fEnumWord32_$cenumFromThenTo]
GHC.Word.$fEnumWord32
  = GHC.Enum.C:Enum
      @ Word32
      GHC.Word.$fEnumWord32_$csucc
      GHC.Word.$fEnumWord32_$cpred
      GHC.Word.$fEnumWord32_$ctoEnum
      GHC.Word.$fEnumWord32_$cfromEnum
      GHC.Word.$fEnumWord32_$cenumFrom
      GHC.Word.$fEnumWord32_$cenumFromThen
      GHC.Word.$fEnumWord32_$cenumFromTo
      GHC.Word.$fEnumWord32_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord32_$cenumFromThen [Occ=LoopBreaker]
  :: Word32 -> Word32 -> [Word32]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Word.$fEnumWord32_$cenumFromThen
  = boundedEnumFromThen
      @ Word32 GHC.Word.$fEnumWord32 GHC.Word.$fBoundedWord32
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord7 :: Word64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord7 = GHC.Word.W64# 0##

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord3 :: Word64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fNumWord3 = GHC.Word.W64# 1##

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjX [Occ=Once!] :: Word64)
                 (ds1_d2pjY [Occ=Once!] :: Word64) ->
                 case ds_d2pjX of { W64# x_a2o2a [Occ=Once] ->
                 case ds1_d2pjY of { W64# y_a2o2b [Occ=Once] ->
                 tagToEnum# @ Bool (eqWord# x_a2o2a y_a2o2b)
                 }
                 }}]
eqWord64
  = \ (ds_d2pjX :: Word64) (ds1_d2pjY :: Word64) ->
      case ds_d2pjX of { W64# x_a2o2a ->
      case ds1_d2pjY of { W64# y_a2o2b ->
      tagToEnum# @ Bool (eqWord# x_a2o2a y_a2o2b)
      }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64_$csignum :: Word64 -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pr6 [Occ=Once!] :: Word64) ->
                 case ds_d2pr6 of { W64# x_a2o2a [Occ=Once!] ->
                 case x_a2o2a of {
                   __DEFAULT -> GHC.Word.$fNumWord3;
                   0## -> GHC.Word.$fBitsWord7
                 }
                 }}]
GHC.Word.$fNumWord64_$csignum
  = \ (ds_d2pr6 :: Word64) ->
      case ds_d2pr6 of { W64# x_a2o2a ->
      case x_a2o2a of {
        __DEFAULT -> GHC.Word.$fNumWord3;
        0## -> GHC.Word.$fBitsWord7
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Num Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Word64
                     GHC.Word.$fNumWord64_$c+
                     GHC.Word.$fNumWord64_$c-
                     GHC.Word.$fNumWord64_$c*
                     GHC.Word.$fNumWord64_$cnegate
                     GHC.Word.$fNumWord64_$cabs
                     GHC.Word.$fNumWord64_$csignum
                     GHC.Word.$fNumWord64_$cfromInteger]
GHC.Word.$fNumWord64
  = GHC.Num.C:Num
      @ Word64
      GHC.Word.$fNumWord64_$c+
      GHC.Word.$fNumWord64_$c-
      GHC.Word.$fNumWord64_$c*
      GHC.Word.$fNumWord64_$cnegate
      GHC.Word.$fNumWord64_$cabs
      GHC.Word.$fNumWord64_$csignum
      GHC.Word.$fNumWord64_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord7 :: Word64
[GblId, Str=x]
GHC.Word.$fEnumWord7 = predError @ Word64 lvl_r2uFF

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord9 :: Word64
[GblId, Str=x]
GHC.Word.$fEnumWord9 = succError @ Word64 lvl_r2uFF

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjQ [Occ=Once!] :: Word64)
                 (ds1_d2pjR [Occ=Once!] :: Word64) ->
                 case ds_d2pjQ of { W64# x_a2o2c [Occ=Once] ->
                 case ds1_d2pjR of { W64# y_a2o2d [Occ=Once] ->
                 tagToEnum# @ Bool (neWord# x_a2o2c y_a2o2d)
                 }
                 }}]
neWord64
  = \ (ds_d2pjQ :: Word64) (ds1_d2pjR :: Word64) ->
      case ds_d2pjQ of { W64# x_a2o2c ->
      case ds1_d2pjR of { W64# y_a2o2d ->
      tagToEnum# @ Bool (neWord# x_a2o2c y_a2o2d)
      }
      }

-- RHS size: {terms: 28, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord64_$cdivMod
  :: Word64 -> Word64 -> (Word64, Word64)
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pp9 [Occ=Once!] :: Word64)
                 (y_a2nXO [Occ=Once!] :: Word64) ->
                 case ds_d2pp9 of { W64# x#_a2nXN ->
                 case y_a2nXO of { W64# y#_a2nXP [Occ=Once!] ->
                 case y#_a2nXP of wild2_Xa5 {
                   __DEFAULT ->
                     (case quotWord# x#_a2nXN wild2_Xa5 of wild3_X4U { __DEFAULT ->
                      GHC.Word.W64# wild3_X4U
                      },
                      case remWord# x#_a2nXN wild2_Xa5 of wild3_X4U { __DEFAULT ->
                      GHC.Word.W64# wild3_X4U
                      });
                   0## -> divZeroError @ (Word64, Word64)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord64_$cdivMod
  = \ (ds_d2pp9 :: Word64) (y_a2nXO :: Word64) ->
      case ds_d2pp9 of { W64# x#_a2nXN ->
      case y_a2nXO of { W64# y#_a2nXP ->
      case y#_a2nXP of wild2_Xa5 {
        __DEFAULT ->
          (case quotWord# x#_a2nXN wild2_Xa5 of wild3_X4U { __DEFAULT ->
           GHC.Word.W64# wild3_X4U
           },
           case remWord# x#_a2nXN wild2_Xa5 of wild3_X4U { __DEFAULT ->
           GHC.Word.W64# wild3_X4U
           });
        0## -> divZeroError @ (Word64, Word64)
      }
      }
      }

-- RHS size: {terms: 23, types: 19, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord64_$cquotRem
  :: Word64 -> Word64 -> (Word64, Word64)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2poV [Occ=Once!] :: Word64)
                 (y_a2nXJ [Occ=Once!] :: Word64) ->
                 case ds_d2poV of { W64# x#_a2nXI [Occ=Once] ->
                 case y_a2nXJ of { W64# y#_a2nXK [Occ=Once!] ->
                 case y#_a2nXK of wild2_Xa6 {
                   __DEFAULT ->
                     case quotRemWord# x#_a2nXI wild2_Xa6 of
                     { (# ipv_s2pPC [Occ=Once], ipv1_s2pPD [Occ=Once] #) ->
                     (GHC.Word.W64# ipv_s2pPC, GHC.Word.W64# ipv1_s2pPD)
                     };
                   0## -> divZeroError @ (Word64, Word64)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord64_$cquotRem
  = \ (ds_d2poV :: Word64) (y_a2nXJ :: Word64) ->
      case ds_d2poV of { W64# x#_a2nXI ->
      case y_a2nXJ of { W64# y#_a2nXK ->
      case y#_a2nXK of wild2_Xa6 {
        __DEFAULT ->
          case quotRemWord# x#_a2nXI wild2_Xa6 of
          { (# ipv_s2pPC, ipv1_s2pPD #) ->
          (GHC.Word.W64# ipv_s2pPC, GHC.Word.W64# ipv1_s2pPD)
          };
        0## -> divZeroError @ (Word64, Word64)
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord64_$cmod :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2poM [Occ=Once!] :: Word64)
                 (y_a2nXG [Occ=Once!] :: Word64) ->
                 case ds_d2poM of { W64# x#_a2nXF [Occ=Once] ->
                 case y_a2nXG of { W64# y#_a2nXH [Occ=Once!] ->
                 case y#_a2nXH of wild2_Xa7 {
                   __DEFAULT ->
                     case remWord# x#_a2nXF wild2_Xa7 of wild3_X4S { __DEFAULT ->
                     GHC.Word.W64# wild3_X4S
                     };
                   0## -> divZeroError @ Word64
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord64_$cmod
  = \ (ds_d2poM :: Word64) (y_a2nXG :: Word64) ->
      case ds_d2poM of { W64# x#_a2nXF ->
      case y_a2nXG of { W64# y#_a2nXH ->
      case y#_a2nXH of wild2_Xa7 {
        __DEFAULT ->
          case remWord# x#_a2nXF wild2_Xa7 of wild3_X4S { __DEFAULT ->
          GHC.Word.W64# wild3_X4S
          };
        0## -> divZeroError @ Word64
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord64_$cdiv :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2poD [Occ=Once!] :: Word64)
                 (y_a2nXD [Occ=Once!] :: Word64) ->
                 case ds_d2poD of { W64# x#_a2nXC [Occ=Once] ->
                 case y_a2nXD of { W64# y#_a2nXE [Occ=Once!] ->
                 case y#_a2nXE of wild2_Xa8 {
                   __DEFAULT ->
                     case quotWord# x#_a2nXC wild2_Xa8 of wild3_X4R { __DEFAULT ->
                     GHC.Word.W64# wild3_X4R
                     };
                   0## -> divZeroError @ Word64
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord64_$cdiv
  = \ (ds_d2poD :: Word64) (y_a2nXD :: Word64) ->
      case ds_d2poD of { W64# x#_a2nXC ->
      case y_a2nXD of { W64# y#_a2nXE ->
      case y#_a2nXE of wild2_Xa8 {
        __DEFAULT ->
          case quotWord# x#_a2nXC wild2_Xa8 of wild3_X4R { __DEFAULT ->
          GHC.Word.W64# wild3_X4R
          };
        0## -> divZeroError @ Word64
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEqWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Word64 eqWord64 neWord64]
GHC.Word.$fEqWord64 = GHC.Classes.C:Eq @ Word64 eqWord64 neWord64

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cpred :: Word64 -> Word64
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nXT [Occ=Once!] :: Word64) ->
                 case x_a2nXT of { W64# x1_a2o2c [Occ=Once!] ->
                 case x1_a2o2c of wild1_Xa5 {
                   __DEFAULT -> GHC.Word.W64# (minusWord# wild1_Xa5 1##);
                   0## -> GHC.Word.$fEnumWord7
                 }
                 }}]
GHC.Word.$fEnumWord64_$cpred
  = \ (x_a2nXT :: Word64) ->
      case x_a2nXT of { W64# x1_a2o2c ->
      case x1_a2o2c of wild1_Xa5 {
        __DEFAULT -> GHC.Word.W64# (minusWord# wild1_Xa5 1##);
        0## -> GHC.Word.$fEnumWord7
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord64_$cmaxBound :: Word64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBoundedWord64_$cmaxBound
  = GHC.Word.W64# 18446744073709551615##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBoundedWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Word64
                          GHC.Word.$fBitsWord7
                          GHC.Word.$fBoundedWord64_$cmaxBound]
GHC.Word.$fBoundedWord64
  = GHC.Enum.C:Bounded
      @ Word64 GHC.Word.$fBitsWord7 GHC.Word.$fBoundedWord64_$cmaxBound

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$csucc :: Word64 -> Word64
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nXS [Occ=Once!] :: Word64) ->
                 case x_a2nXS of { W64# x1_a2o2c [Occ=Once!] ->
                 case x1_a2o2c of wild1_Xa8 {
                   __DEFAULT -> GHC.Word.W64# (plusWord# wild1_Xa8 1##);
                   18446744073709551615## -> GHC.Word.$fEnumWord9
                 }
                 }}]
GHC.Word.$fEnumWord64_$csucc
  = \ (x_a2nXS :: Word64) ->
      case x_a2nXS of { W64# x1_a2o2c ->
      case x1_a2o2c of wild1_Xa8 {
        __DEFAULT -> GHC.Word.W64# (plusWord# wild1_Xa8 1##);
        18446744073709551615## -> GHC.Word.$fEnumWord9
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$wlvl2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word64
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Word.$wlvl2
  = \ (ww_s2sSv :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Word64
        @ Word64
        GHC.Word.$fShowWord64
        lvl_r2uFF
        ww_s2sSv
        GHC.Word.$fBitsWord7
        GHC.Word.$fBoundedWord64_$cmaxBound

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord6 [InlPrag=NOUSERINLINE[0]] :: Int -> Word64
[GblId,
 Arity=1,
 Str=<B,1*U(U)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sSs [Occ=Once!] :: Int) ->
                 case w_s2sSs of { I# ww1_s2sSv [Occ=Once] ->
                 GHC.Word.$wlvl2 ww1_s2sSv
                 }}]
GHC.Word.$fEnumWord6
  = \ (w_s2sSs :: Int) ->
      case w_s2sSs of { I# ww1_s2sSv -> GHC.Word.$wlvl2 ww1_s2sSv }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$ctoEnum :: Int -> Word64
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2nXU [Occ=Once!] :: Int) ->
                 case i_a2nXU of wild_XaI { I# i#_a2nXV ->
                 case >=# i#_a2nXV 0# of {
                   __DEFAULT -> GHC.Word.$fEnumWord6 wild_XaI;
                   1# -> GHC.Word.W64# (int2Word# i#_a2nXV)
                 }
                 }}]
GHC.Word.$fEnumWord64_$ctoEnum
  = \ (i_a2nXU :: Int) ->
      case i_a2nXU of { I# i#_a2nXV ->
      case >=# i#_a2nXV 0# of {
        __DEFAULT -> GHC.Word.$wlvl2 i#_a2nXV;
        1# -> GHC.Word.W64# (int2Word# i#_a2nXV)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjJ [Occ=Once!] :: Word64)
                 (ds1_d2pjK [Occ=Once!] :: Word64) ->
                 case ds_d2pjJ of { W64# x_a2o2e [Occ=Once] ->
                 case ds1_d2pjK of { W64# y_a2o2f [Occ=Once] ->
                 tagToEnum# @ Bool (gtWord# x_a2o2e y_a2o2f)
                 }
                 }}]
gtWord64
  = \ (ds_d2pjJ :: Word64) (ds1_d2pjK :: Word64) ->
      case ds_d2pjJ of { W64# x_a2o2e ->
      case ds1_d2pjK of { W64# y_a2o2f ->
      tagToEnum# @ Bool (gtWord# x_a2o2e y_a2o2f)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjC [Occ=Once!] :: Word64)
                 (ds1_d2pjD [Occ=Once!] :: Word64) ->
                 case ds_d2pjC of { W64# x_a2o2g [Occ=Once] ->
                 case ds1_d2pjD of { W64# y_a2o2h [Occ=Once] ->
                 tagToEnum# @ Bool (geWord# x_a2o2g y_a2o2h)
                 }
                 }}]
geWord64
  = \ (ds_d2pjC :: Word64) (ds1_d2pjD :: Word64) ->
      case ds_d2pjC of { W64# x_a2o2g ->
      case ds1_d2pjD of { W64# y_a2o2h ->
      tagToEnum# @ Bool (geWord# x_a2o2g y_a2o2h)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjv [Occ=Once!] :: Word64)
                 (ds1_d2pjw [Occ=Once!] :: Word64) ->
                 case ds_d2pjv of { W64# x_a2o2i [Occ=Once] ->
                 case ds1_d2pjw of { W64# y_a2o2j [Occ=Once] ->
                 tagToEnum# @ Bool (ltWord# x_a2o2i y_a2o2j)
                 }
                 }}]
ltWord64
  = \ (ds_d2pjv :: Word64) (ds1_d2pjw :: Word64) ->
      case ds_d2pjv of { W64# x_a2o2i ->
      case ds1_d2pjw of { W64# y_a2o2j ->
      tagToEnum# @ Bool (ltWord# x_a2o2i y_a2o2j)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leWord64 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word64 -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pjo [Occ=Once!] :: Word64)
                 (ds1_d2pjp [Occ=Once!] :: Word64) ->
                 case ds_d2pjo of { W64# x_a2o2k [Occ=Once] ->
                 case ds1_d2pjp of { W64# y_a2o2l [Occ=Once] ->
                 tagToEnum# @ Bool (leWord# x_a2o2k y_a2o2l)
                 }
                 }}]
leWord64
  = \ (ds_d2pjo :: Word64) (ds1_d2pjp :: Word64) ->
      case ds_d2pjo of { W64# x_a2o2k ->
      case ds1_d2pjp of { W64# y_a2o2l ->
      tagToEnum# @ Bool (leWord# x_a2o2k y_a2o2l)
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord64_$cmin :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Word64)
                 (y_a55n [Occ=Once!] :: Word64) ->
                 case x_a55m of wild_Xau { W64# x1_a2o2k [Occ=Once] ->
                 case y_a55n of wild1_X5 { W64# y1_a2o2l [Occ=Once] ->
                 case leWord# x1_a2o2k y1_a2o2l of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_Xau
                 }
                 }
                 }}]
GHC.Word.$fOrdWord64_$cmin
  = \ (x_a55m :: Word64) (y_a55n :: Word64) ->
      case x_a55m of wild_Xau { W64# x1_a2o2k ->
      case y_a55n of wild1_X5 { W64# y1_a2o2l ->
      case leWord# x1_a2o2k y1_a2o2l of {
        __DEFAULT -> wild1_X5;
        1# -> wild_Xau
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord64_$cmax :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Word64)
                 (y_a55e [Occ=Once!] :: Word64) ->
                 case x_a55d of wild_Xau { W64# x1_a2o2k [Occ=Once] ->
                 case y_a55e of wild1_X5 { W64# y1_a2o2l [Occ=Once] ->
                 case leWord# x1_a2o2k y1_a2o2l of {
                   __DEFAULT -> wild_Xau;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Word.$fOrdWord64_$cmax
  = \ (x_a55d :: Word64) (y_a55e :: Word64) ->
      case x_a55d of wild_Xau { W64# x1_a2o2k ->
      case y_a55e of wild1_X5 { W64# y1_a2o2l ->
      case leWord# x1_a2o2k y1_a2o2l of {
        __DEFAULT -> wild_Xau;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord64_$ccompare :: Word64 -> Word64 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Word64)
                 (y_a1fi3 [Occ=Once!] :: Word64) ->
                 case x_a1fi2 of { W64# x1_a2o2a ->
                 case y_a1fi3 of { W64# y1_a2o2b ->
                 case eqWord# x1_a2o2a y1_a2o2b of {
                   __DEFAULT ->
                     case leWord# x1_a2o2a y1_a2o2b of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Word.$fOrdWord64_$ccompare
  = \ (x_a1fi2 :: Word64) (y_a1fi3 :: Word64) ->
      case x_a1fi2 of { W64# x1_a2o2a ->
      case y_a1fi3 of { W64# y1_a2o2b ->
      case eqWord# x1_a2o2a y1_a2o2b of {
        __DEFAULT ->
          case leWord# x1_a2o2a y1_a2o2b of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Word64
                         GHC.Word.$fEqWord64
                         GHC.Word.$fOrdWord64_$ccompare
                         ltWord64
                         leWord64
                         gtWord64
                         geWord64
                         GHC.Word.$fOrdWord64_$cmax
                         GHC.Word.$fOrdWord64_$cmin]
GHC.Word.$fOrdWord64
  = GHC.Classes.C:Ord
      @ Word64
      GHC.Word.$fEqWord64
      GHC.Word.$fOrdWord64_$ccompare
      ltWord64
      leWord64
      gtWord64
      geWord64
      GHC.Word.$fOrdWord64_$cmax
      GHC.Word.$fOrdWord64_$cmin

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Real Word64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Word64
                       GHC.Word.$fNumWord64
                       GHC.Word.$fOrdWord64
                       GHC.Word.$fRealWord64_$ctoRational]
GHC.Word.$fRealWord64
  = GHC.Real.C:Real
      @ Word64
      GHC.Word.$fNumWord64
      GHC.Word.$fOrdWord64
      GHC.Word.$fRealWord64_$ctoRational

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cfromEnum :: Word64 -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a2nXW [Occ=Once!] :: Word64) ->
                 case x_a2nXW of wild_XaF { W64# x#_a2nXX ->
                 case leWord# x#_a2nXX 9223372036854775807## of {
                   __DEFAULT -> GHC.Word.$fEnumWord5 wild_XaF;
                   1# -> GHC.Types.I# (word2Int# x#_a2nXX)
                 }
                 }}]
GHC.Word.$fEnumWord64_$cfromEnum
  = \ (x_a2nXW :: Word64) ->
      case x_a2nXW of wild_XaF { W64# x#_a2nXX ->
      case leWord# x#_a2nXX 9223372036854775807## of {
        __DEFAULT -> GHC.Word.$fEnumWord5 wild_XaF;
        1# -> GHC.Types.I# (word2Int# x#_a2nXX)
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Word64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Word64
                       GHC.Word.$fEnumWord64_$csucc
                       GHC.Word.$fEnumWord64_$cpred
                       GHC.Word.$fEnumWord64_$ctoEnum
                       GHC.Word.$fEnumWord64_$cfromEnum
                       GHC.Word.$fEnumWord64_$cenumFrom
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       GHC.Word.$fEnumWord64_$cenumFromThenTo]
GHC.Word.$fEnumWord64
  = GHC.Enum.C:Enum
      @ Word64
      GHC.Word.$fEnumWord64_$csucc
      GHC.Word.$fEnumWord64_$cpred
      GHC.Word.$fEnumWord64_$ctoEnum
      GHC.Word.$fEnumWord64_$cfromEnum
      GHC.Word.$fEnumWord64_$cenumFrom
      GHC.Word.$fEnumWord64_$cenumFromThen
      GHC.Word.$fEnumWord64_$cenumFromTo
      GHC.Word.$fEnumWord64_$cenumFromThenTo

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Word64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Word64
                           GHC.Word.$fRealWord64
                           GHC.Word.$fEnumWord64
                           GHC.Word.$fIntegralWord64_$cdiv
                           GHC.Word.$fIntegralWord64_$cmod
                           GHC.Word.$fIntegralWord64_$cdiv
                           GHC.Word.$fIntegralWord64_$cmod
                           GHC.Word.$fIntegralWord64_$cquotRem
                           GHC.Word.$fIntegralWord64_$cdivMod
                           GHC.Word.$fIntegralWord64_$ctoInteger]
GHC.Word.$fIntegralWord64
  = GHC.Real.C:Integral
      @ Word64
      GHC.Word.$fRealWord64
      GHC.Word.$fEnumWord64
      GHC.Word.$fIntegralWord64_$cdiv
      GHC.Word.$fIntegralWord64_$cmod
      GHC.Word.$fIntegralWord64_$cdiv
      GHC.Word.$fIntegralWord64_$cmod
      GHC.Word.$fIntegralWord64_$cquotRem
      GHC.Word.$fIntegralWord64_$cdivMod
      GHC.Word.$fIntegralWord64_$ctoInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cenumFromThenTo [Occ=LoopBreaker]
  :: Word64 -> Word64 -> Word64 -> [Word64]
[GblId, Arity=3, Unf=OtherCon []]
GHC.Word.$fEnumWord64_$cenumFromThenTo
  = integralEnumFromThenTo @ Word64 GHC.Word.$fIntegralWord64

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cenumFromTo [Occ=LoopBreaker]
  :: Word64 -> Word64 -> [Word64]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Word.$fEnumWord64_$cenumFromTo
  = integralEnumFromTo @ Word64 GHC.Word.$fIntegralWord64

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cenumFrom [Occ=LoopBreaker]
  :: Word64 -> [Word64]
[GblId, Arity=1, Unf=OtherCon []]
GHC.Word.$fEnumWord64_$cenumFrom
  = integralEnumFrom
      @ Word64 GHC.Word.$fIntegralWord64 GHC.Word.$fBoundedWord64

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEnumWord64_$cenumFromThen [Occ=LoopBreaker]
  :: Word64 -> Word64 -> [Word64]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Word.$fEnumWord64_$cenumFromThen
  = integralEnumFromThen
      @ Word64 GHC.Word.$fIntegralWord64 GHC.Word.$fBoundedWord64
end Rec }

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$cfromInteger :: Integer -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2o1v [Occ=Once] :: Integer) ->
                 case integerToWord i_a2o1v of wild_X5E { __DEFAULT ->
                 GHC.Word.W8# (narrow8Word# wild_X5E)
                 }}]
GHC.Word.$fNumWord8_$cfromInteger
  = \ (i_a2o1v :: Integer) ->
      case integerToWord i_a2o1v of wild_X5E { __DEFAULT ->
      GHC.Word.W8# (narrow8Word# wild_X5E)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$cabs :: Word8 -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a2o1u [Occ=Once] :: Word8) -> x_a2o1u}]
GHC.Word.$fNumWord8_$cabs = \ (x_a2o1u :: Word8) -> x_a2o1u

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$cnegate :: Word8 -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pDg [Occ=Once!] :: Word8) ->
                 case ds_d2pDg of { W8# x#_a2o1t [Occ=Once] ->
                 GHC.Word.W8#
                   (narrow8Word# (int2Word# (negateInt# (word2Int# x#_a2o1t))))
                 }}]
GHC.Word.$fNumWord8_$cnegate
  = \ (ds_d2pDg :: Word8) ->
      case ds_d2pDg of { W8# x#_a2o1t ->
      GHC.Word.W8#
        (narrow8Word# (int2Word# (negateInt# (word2Int# x#_a2o1t))))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$c* :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pD9 [Occ=Once!] :: Word8)
                 (ds1_d2pDa [Occ=Once!] :: Word8) ->
                 case ds_d2pD9 of { W8# x#_a2o1r [Occ=Once] ->
                 case ds1_d2pDa of { W8# y#_a2o1s [Occ=Once] ->
                 GHC.Word.W8# (narrow8Word# (timesWord# x#_a2o1r y#_a2o1s))
                 }
                 }}]
GHC.Word.$fNumWord8_$c*
  = \ (ds_d2pD9 :: Word8) (ds1_d2pDa :: Word8) ->
      case ds_d2pD9 of { W8# x#_a2o1r ->
      case ds1_d2pDa of { W8# y#_a2o1s ->
      GHC.Word.W8# (narrow8Word# (timesWord# x#_a2o1r y#_a2o1s))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$c- :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pD2 [Occ=Once!] :: Word8)
                 (ds1_d2pD3 [Occ=Once!] :: Word8) ->
                 case ds_d2pD2 of { W8# x#_a2o1p [Occ=Once] ->
                 case ds1_d2pD3 of { W8# y#_a2o1q [Occ=Once] ->
                 GHC.Word.W8# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q))
                 }
                 }}]
GHC.Word.$fNumWord8_$c-
  = \ (ds_d2pD2 :: Word8) (ds1_d2pD3 :: Word8) ->
      case ds_d2pD2 of { W8# x#_a2o1p ->
      case ds1_d2pD3 of { W8# y#_a2o1q ->
      GHC.Word.W8# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$c+ :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pCV [Occ=Once!] :: Word8)
                 (ds1_d2pCW [Occ=Once!] :: Word8) ->
                 case ds_d2pCV of { W8# x#_a2o1n [Occ=Once] ->
                 case ds1_d2pCW of { W8# y#_a2o1o [Occ=Once] ->
                 GHC.Word.W8# (narrow8Word# (plusWord# x#_a2o1n y#_a2o1o))
                 }
                 }}]
GHC.Word.$fNumWord8_$c+
  = \ (ds_d2pCV :: Word8) (ds1_d2pCW :: Word8) ->
      case ds_d2pCV of { W8# x#_a2o1n ->
      case ds1_d2pCW of { W8# y#_a2o1o ->
      GHC.Word.W8# (narrow8Word# (plusWord# x#_a2o1n y#_a2o1o))
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$ctoInteger :: Word8 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pCy [Occ=Once!] :: Word8) ->
                 case ds_d2pCy of { W8# x#_a2o1g [Occ=Once] ->
                 smallInteger (word2Int# x#_a2o1g)
                 }}]
GHC.Word.$ctoInteger
  = \ (ds_d2pCy :: Word8) ->
      case ds_d2pCy of { W8# x#_a2o1g ->
      smallInteger (word2Int# x#_a2o1g)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cpopCount :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBe [Occ=Once!] :: Word8) ->
                 case ds_d2pBe of { W8# x#_a2o0O [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt8# x#_a2o0O))
                 }}]
GHC.Word.$fBitsWord8_$cpopCount
  = \ (ds_d2pBe :: Word8) ->
      case ds_d2pBe of { W8# x#_a2o0O ->
      GHC.Types.I# (word2Int# (popCnt8# x#_a2o0O))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cunsafeShiftR :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pB7 [Occ=Once!] :: Word8)
                 (ds1_d2pB8 [Occ=Once!] :: Int) ->
                 case ds_d2pB7 of { W8# x#_a2o0H [Occ=Once] ->
                 case ds1_d2pB8 of { I# i#_a2o0I [Occ=Once] ->
                 GHC.Word.W8# (uncheckedShiftRL# x#_a2o0H i#_a2o0I)
                 }
                 }}]
GHC.Word.$fBitsWord8_$cunsafeShiftR
  = \ (ds_d2pB7 :: Word8) (ds1_d2pB8 :: Int) ->
      case ds_d2pB7 of { W8# x#_a2o0H ->
      case ds1_d2pB8 of { I# i#_a2o0I ->
      GHC.Word.W8# (uncheckedShiftRL# x#_a2o0H i#_a2o0I)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cshiftR :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pB0 [Occ=Once!] :: Word8)
                 (ds1_d2pB1 [Occ=Once!] :: Int) ->
                 case ds_d2pB0 of { W8# x#_a2o0F [Occ=Once] ->
                 case ds1_d2pB1 of { I# i#_a2o0G ->
                 case >=# i#_a2o0G 64# of {
                   __DEFAULT -> GHC.Word.W8# (uncheckedShiftRL# x#_a2o0F i#_a2o0G);
                   1# -> GHC.Word.W8# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$cshiftR
  = \ (ds_d2pB0 :: Word8) (ds1_d2pB1 :: Int) ->
      case ds_d2pB0 of { W8# x#_a2o0F ->
      case ds1_d2pB1 of { I# i#_a2o0G ->
      case >=# i#_a2o0G 64# of {
        __DEFAULT -> GHC.Word.W8# (uncheckedShiftRL# x#_a2o0F i#_a2o0G);
        1# -> GHC.Word.$fBitsWord8_$cminBound
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cunsafeShiftL :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pAT [Occ=Once!] :: Word8)
                 (ds1_d2pAU [Occ=Once!] :: Int) ->
                 case ds_d2pAT of { W8# x#_a2o0D [Occ=Once] ->
                 case ds1_d2pAU of { I# i#_a2o0E [Occ=Once] ->
                 GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0D i#_a2o0E))
                 }
                 }}]
GHC.Word.$fBitsWord8_$cunsafeShiftL
  = \ (ds_d2pAT :: Word8) (ds1_d2pAU :: Int) ->
      case ds_d2pAT of { W8# x#_a2o0D ->
      case ds1_d2pAU of { I# i#_a2o0E ->
      GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0D i#_a2o0E))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cshiftL :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pAM [Occ=Once!] :: Word8)
                 (ds1_d2pAN [Occ=Once!] :: Int) ->
                 case ds_d2pAM of { W8# x#_a2o0B [Occ=Once] ->
                 case ds1_d2pAN of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0B i#_a2o0C));
                   1# -> GHC.Word.W8# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$cshiftL
  = \ (ds_d2pAM :: Word8) (ds1_d2pAN :: Int) ->
      case ds_d2pAM of { W8# x#_a2o0B ->
      case ds1_d2pAN of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0B i#_a2o0C));
        1# -> GHC.Word.$fBitsWord8_$cminBound
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cisSigned :: Word8 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
GHC.Word.$fBitsWord8_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 28, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$crotate :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pAv [Occ=Once!] :: Word8)
                 (ds1_d2pAw [Occ=Once!] :: Int) ->
                 case ds_d2pAv of { W8# x#_a2o0J ->
                 case ds1_d2pAw of { I# i#_a2o0K [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a2o0K) 7##) of wild2_X65 {
                   __DEFAULT ->
                     GHC.Word.W8#
                       (narrow8Word#
                          (or#
                             (uncheckedShiftL# x#_a2o0J wild2_X65)
                             (uncheckedShiftRL# x#_a2o0J (-# 8# wild2_X65))));
                   0# -> GHC.Word.W8# x#_a2o0J
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$crotate
  = \ (ds_d2pAv :: Word8) (ds1_d2pAw :: Int) ->
      case ds_d2pAv of wild_X5T { W8# x#_a2o0J ->
      case ds1_d2pAw of { I# i#_a2o0K ->
      case word2Int# (and# (int2Word# i#_a2o0K) 7##) of wild2_X65 {
        __DEFAULT ->
          GHC.Word.W8#
            (narrow8Word#
               (or#
                  (uncheckedShiftL# x#_a2o0J wild2_X65)
                  (uncheckedShiftRL# x#_a2o0J (-# 8# wild2_X65))));
        0# -> wild_X5T
      }
      }
      }

-- RHS size: {terms: 40, types: 10, coercions: 0, joins: 0/1}
GHC.Word.$fBitsWord8_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pAm [Occ=Once!] :: Word8)
                 (ds1_d2pAn [Occ=Once!] :: Int) ->
                 case ds_d2pAm of { W8# x#_a2o0z [Occ=Once*] ->
                 case ds1_d2pAn of { I# i#_a2o0A ->
                 case >=# i#_a2o0A 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AGn :: Int#
                       [LclId]
                       b_i1AGn = negateInt# i#_a2o0A } in
                     case >=# b_i1AGn 64# of {
                       __DEFAULT -> GHC.Word.W8# (uncheckedShiftRL# x#_a2o0z b_i1AGn);
                       1# -> GHC.Word.W8# 0##
                     };
                   1# ->
                     case >=# i#_a2o0A 64# of {
                       __DEFAULT ->
                         GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0z i#_a2o0A));
                       1# -> GHC.Word.W8# 0##
                     }
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$cshift
  = \ (ds_d2pAm :: Word8) (ds1_d2pAn :: Int) ->
      case ds_d2pAm of { W8# x#_a2o0z ->
      case ds1_d2pAn of { I# i#_a2o0A ->
      case >=# i#_a2o0A 0# of {
        __DEFAULT ->
          let {
            b_s2qgq [Dmd=<S,U>] :: Int#
            [LclId]
            b_s2qgq = negateInt# i#_a2o0A } in
          case >=# b_s2qgq 64# of {
            __DEFAULT -> GHC.Word.W8# (uncheckedShiftRL# x#_a2o0z b_s2qgq);
            1# -> GHC.Word.$fBitsWord8_$cminBound
          };
        1# ->
          case >=# i#_a2o0A 64# of {
            __DEFAULT ->
              GHC.Word.W8# (narrow8Word# (uncheckedShiftL# x#_a2o0z i#_a2o0A));
            1# -> GHC.Word.$fBitsWord8_$cminBound
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cxor :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pA9 [Occ=Once!] :: Word8)
                 (ds1_d2pAa [Occ=Once!] :: Word8) ->
                 case ds_d2pA9 of { W8# x#_a2o0v [Occ=Once] ->
                 case ds1_d2pAa of { W8# y#_a2o0w [Occ=Once] ->
                 GHC.Word.W8# (xor# x#_a2o0v y#_a2o0w)
                 }
                 }}]
GHC.Word.$fBitsWord8_$cxor
  = \ (ds_d2pA9 :: Word8) (ds1_d2pAa :: Word8) ->
      case ds_d2pA9 of { W8# x#_a2o0v ->
      case ds1_d2pAa of { W8# y#_a2o0w ->
      GHC.Word.W8# (xor# x#_a2o0v y#_a2o0w)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$c.|. :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pA2 [Occ=Once!] :: Word8)
                 (ds1_d2pA3 [Occ=Once!] :: Word8) ->
                 case ds_d2pA2 of { W8# x#_a2o0t [Occ=Once] ->
                 case ds1_d2pA3 of { W8# y#_a2o0u [Occ=Once] ->
                 GHC.Word.W8# (or# x#_a2o0t y#_a2o0u)
                 }
                 }}]
GHC.Word.$fBitsWord8_$c.|.
  = \ (ds_d2pA2 :: Word8) (ds1_d2pA3 :: Word8) ->
      case ds_d2pA2 of { W8# x#_a2o0t ->
      case ds1_d2pA3 of { W8# y#_a2o0u ->
      GHC.Word.W8# (or# x#_a2o0t y#_a2o0u)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$c.&. :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzV [Occ=Once!] :: Word8)
                 (ds1_d2pzW [Occ=Once!] :: Word8) ->
                 case ds_d2pzV of { W8# x#_a2o0r [Occ=Once] ->
                 case ds1_d2pzW of { W8# y#_a2o0s [Occ=Once] ->
                 GHC.Word.W8# (and# x#_a2o0r y#_a2o0s)
                 }
                 }}]
GHC.Word.$fBitsWord8_$c.&.
  = \ (ds_d2pzV :: Word8) (ds1_d2pzW :: Word8) ->
      case ds_d2pzV of { W8# x#_a2o0r ->
      case ds1_d2pzW of { W8# y#_a2o0s ->
      GHC.Word.W8# (and# x#_a2o0r y#_a2o0s)
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzR [Occ=Once!] :: Word8) ->
                 case ds_d2pzR of { W8# x#_a2o0q [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz8# x#_a2o0q))
                 }}]
GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros
  = \ (ds_d2pzR :: Word8) ->
      case ds_d2pzR of { W8# x#_a2o0q ->
      GHC.Types.I# (word2Int# (ctz8# x#_a2o0q))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzN [Occ=Once!] :: Word8) ->
                 case ds_d2pzN of { W8# x#_a2o0p [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz8# x#_a2o0p))
                 }}]
GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
  = \ (ds_d2pzN :: Word8) ->
      case ds_d2pzN of { W8# x#_a2o0p ->
      GHC.Types.I# (word2Int# (clz8# x#_a2o0p))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord9 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord9 = GHC.Types.I# 8#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cfiniteBitSize :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord9}]
GHC.Word.$fBitsWord8_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord9

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$cfromInteger :: Integer -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2o0m [Occ=Once] :: Integer) ->
                 case integerToWord i_a2o0m of wild_X60 { __DEFAULT ->
                 GHC.Word.W16# (narrow16Word# wild_X60)
                 }}]
GHC.Word.$fNumWord16_$cfromInteger
  = \ (i_a2o0m :: Integer) ->
      case integerToWord i_a2o0m of wild_X60 { __DEFAULT ->
      GHC.Word.W16# (narrow16Word# wild_X60)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$cabs :: Word16 -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a2o0l [Occ=Once] :: Word16) -> x_a2o0l}]
GHC.Word.$fNumWord16_$cabs = \ (x_a2o0l :: Word16) -> x_a2o0l

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$cnegate :: Word16 -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzs [Occ=Once!] :: Word16) ->
                 case ds_d2pzs of { W16# x#_a2o0k [Occ=Once] ->
                 GHC.Word.W16#
                   (narrow16Word# (int2Word# (negateInt# (word2Int# x#_a2o0k))))
                 }}]
GHC.Word.$fNumWord16_$cnegate
  = \ (ds_d2pzs :: Word16) ->
      case ds_d2pzs of { W16# x#_a2o0k ->
      GHC.Word.W16#
        (narrow16Word# (int2Word# (negateInt# (word2Int# x#_a2o0k))))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$c* :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzl [Occ=Once!] :: Word16)
                 (ds1_d2pzm [Occ=Once!] :: Word16) ->
                 case ds_d2pzl of { W16# x#_a2o0i [Occ=Once] ->
                 case ds1_d2pzm of { W16# y#_a2o0j [Occ=Once] ->
                 GHC.Word.W16# (narrow16Word# (timesWord# x#_a2o0i y#_a2o0j))
                 }
                 }}]
GHC.Word.$fNumWord16_$c*
  = \ (ds_d2pzl :: Word16) (ds1_d2pzm :: Word16) ->
      case ds_d2pzl of { W16# x#_a2o0i ->
      case ds1_d2pzm of { W16# y#_a2o0j ->
      GHC.Word.W16# (narrow16Word# (timesWord# x#_a2o0i y#_a2o0j))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$c- :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pze [Occ=Once!] :: Word16)
                 (ds1_d2pzf [Occ=Once!] :: Word16) ->
                 case ds_d2pze of { W16# x#_a2o0g [Occ=Once] ->
                 case ds1_d2pzf of { W16# y#_a2o0h [Occ=Once] ->
                 GHC.Word.W16# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h))
                 }
                 }}]
GHC.Word.$fNumWord16_$c-
  = \ (ds_d2pze :: Word16) (ds1_d2pzf :: Word16) ->
      case ds_d2pze of { W16# x#_a2o0g ->
      case ds1_d2pzf of { W16# y#_a2o0h ->
      GHC.Word.W16# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$c+ :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pz7 [Occ=Once!] :: Word16)
                 (ds1_d2pz8 [Occ=Once!] :: Word16) ->
                 case ds_d2pz7 of { W16# x#_a2o0e [Occ=Once] ->
                 case ds1_d2pz8 of { W16# y#_a2o0f [Occ=Once] ->
                 GHC.Word.W16# (narrow16Word# (plusWord# x#_a2o0e y#_a2o0f))
                 }
                 }}]
GHC.Word.$fNumWord16_$c+
  = \ (ds_d2pz7 :: Word16) (ds1_d2pz8 :: Word16) ->
      case ds_d2pz7 of { W16# x#_a2o0e ->
      case ds1_d2pz8 of { W16# y#_a2o0f ->
      GHC.Word.W16# (narrow16Word# (plusWord# x#_a2o0e y#_a2o0f))
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$ctoInteger1 :: Word16 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pyK [Occ=Once!] :: Word16) ->
                 case ds_d2pyK of { W16# x#_a2o07 [Occ=Once] ->
                 smallInteger (word2Int# x#_a2o07)
                 }}]
GHC.Word.$ctoInteger1
  = \ (ds_d2pyK :: Word16) ->
      case ds_d2pyK of { W16# x#_a2o07 ->
      smallInteger (word2Int# x#_a2o07)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cpopCount :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxq [Occ=Once!] :: Word16) ->
                 case ds_d2pxq of { W16# x#_a2nZF [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt16# x#_a2nZF))
                 }}]
GHC.Word.$fBitsWord16_$cpopCount
  = \ (ds_d2pxq :: Word16) ->
      case ds_d2pxq of { W16# x#_a2nZF ->
      GHC.Types.I# (word2Int# (popCnt16# x#_a2nZF))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cunsafeShiftR :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxj [Occ=Once!] :: Word16)
                 (ds1_d2pxk [Occ=Once!] :: Int) ->
                 case ds_d2pxj of { W16# x#_a2nZy [Occ=Once] ->
                 case ds1_d2pxk of { I# i#_a2nZz [Occ=Once] ->
                 GHC.Word.W16# (uncheckedShiftRL# x#_a2nZy i#_a2nZz)
                 }
                 }}]
GHC.Word.$fBitsWord16_$cunsafeShiftR
  = \ (ds_d2pxj :: Word16) (ds1_d2pxk :: Int) ->
      case ds_d2pxj of { W16# x#_a2nZy ->
      case ds1_d2pxk of { I# i#_a2nZz ->
      GHC.Word.W16# (uncheckedShiftRL# x#_a2nZy i#_a2nZz)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cshiftR :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxc [Occ=Once!] :: Word16)
                 (ds1_d2pxd [Occ=Once!] :: Int) ->
                 case ds_d2pxc of { W16# x#_a2nZw [Occ=Once] ->
                 case ds1_d2pxd of { I# i#_a2nZx ->
                 case >=# i#_a2nZx 64# of {
                   __DEFAULT -> GHC.Word.W16# (uncheckedShiftRL# x#_a2nZw i#_a2nZx);
                   1# -> GHC.Word.W16# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$cshiftR
  = \ (ds_d2pxc :: Word16) (ds1_d2pxd :: Int) ->
      case ds_d2pxc of { W16# x#_a2nZw ->
      case ds1_d2pxd of { I# i#_a2nZx ->
      case >=# i#_a2nZx 64# of {
        __DEFAULT -> GHC.Word.W16# (uncheckedShiftRL# x#_a2nZw i#_a2nZx);
        1# -> GHC.Word.$fBitsWord16_$cminBound
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cunsafeShiftL :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2px5 [Occ=Once!] :: Word16)
                 (ds1_d2px6 [Occ=Once!] :: Int) ->
                 case ds_d2px5 of { W16# x#_a2nZu [Occ=Once] ->
                 case ds1_d2px6 of { I# i#_a2nZv [Occ=Once] ->
                 GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZu i#_a2nZv))
                 }
                 }}]
GHC.Word.$fBitsWord16_$cunsafeShiftL
  = \ (ds_d2px5 :: Word16) (ds1_d2px6 :: Int) ->
      case ds_d2px5 of { W16# x#_a2nZu ->
      case ds1_d2px6 of { I# i#_a2nZv ->
      GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZu i#_a2nZv))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cshiftL :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pwY [Occ=Once!] :: Word16)
                 (ds1_d2pwZ [Occ=Once!] :: Int) ->
                 case ds_d2pwY of { W16# x#_a2nZs [Occ=Once] ->
                 case ds1_d2pwZ of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZs i#_a2nZt));
                   1# -> GHC.Word.W16# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$cshiftL
  = \ (ds_d2pwY :: Word16) (ds1_d2pwZ :: Int) ->
      case ds_d2pwY of { W16# x#_a2nZs ->
      case ds1_d2pwZ of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZs i#_a2nZt));
        1# -> GHC.Word.$fBitsWord16_$cminBound
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cisSigned :: Word16 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
GHC.Word.$fBitsWord16_$cisSigned
  = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 28, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$crotate :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pwH [Occ=Once!] :: Word16)
                 (ds1_d2pwI [Occ=Once!] :: Int) ->
                 case ds_d2pwH of { W16# x#_a2nZA ->
                 case ds1_d2pwI of { I# i#_a2nZB [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a2nZB) 15##) of wild2_X6r {
                   __DEFAULT ->
                     GHC.Word.W16#
                       (narrow16Word#
                          (or#
                             (uncheckedShiftL# x#_a2nZA wild2_X6r)
                             (uncheckedShiftRL# x#_a2nZA (-# 16# wild2_X6r))));
                   0# -> GHC.Word.W16# x#_a2nZA
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$crotate
  = \ (ds_d2pwH :: Word16) (ds1_d2pwI :: Int) ->
      case ds_d2pwH of wild_X6f { W16# x#_a2nZA ->
      case ds1_d2pwI of { I# i#_a2nZB ->
      case word2Int# (and# (int2Word# i#_a2nZB) 15##) of wild2_X6r {
        __DEFAULT ->
          GHC.Word.W16#
            (narrow16Word#
               (or#
                  (uncheckedShiftL# x#_a2nZA wild2_X6r)
                  (uncheckedShiftRL# x#_a2nZA (-# 16# wild2_X6r))));
        0# -> wild_X6f
      }
      }
      }

-- RHS size: {terms: 40, types: 10, coercions: 0, joins: 0/1}
GHC.Word.$fBitsWord16_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pwy [Occ=Once!] :: Word16)
                 (ds1_d2pwz [Occ=Once!] :: Int) ->
                 case ds_d2pwy of { W16# x#_a2nZq [Occ=Once*] ->
                 case ds1_d2pwz of { I# i#_a2nZr ->
                 case >=# i#_a2nZr 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AGn :: Int#
                       [LclId]
                       b_i1AGn = negateInt# i#_a2nZr } in
                     case >=# b_i1AGn 64# of {
                       __DEFAULT -> GHC.Word.W16# (uncheckedShiftRL# x#_a2nZq b_i1AGn);
                       1# -> GHC.Word.W16# 0##
                     };
                   1# ->
                     case >=# i#_a2nZr 64# of {
                       __DEFAULT ->
                         GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZq i#_a2nZr));
                       1# -> GHC.Word.W16# 0##
                     }
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$cshift
  = \ (ds_d2pwy :: Word16) (ds1_d2pwz :: Int) ->
      case ds_d2pwy of { W16# x#_a2nZq ->
      case ds1_d2pwz of { I# i#_a2nZr ->
      case >=# i#_a2nZr 0# of {
        __DEFAULT ->
          let {
            b_s2qgm [Dmd=<S,U>] :: Int#
            [LclId]
            b_s2qgm = negateInt# i#_a2nZr } in
          case >=# b_s2qgm 64# of {
            __DEFAULT -> GHC.Word.W16# (uncheckedShiftRL# x#_a2nZq b_s2qgm);
            1# -> GHC.Word.$fBitsWord16_$cminBound
          };
        1# ->
          case >=# i#_a2nZr 64# of {
            __DEFAULT ->
              GHC.Word.W16# (narrow16Word# (uncheckedShiftL# x#_a2nZq i#_a2nZr));
            1# -> GHC.Word.$fBitsWord16_$cminBound
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cxor :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pwl [Occ=Once!] :: Word16)
                 (ds1_d2pwm [Occ=Once!] :: Word16) ->
                 case ds_d2pwl of { W16# x#_a2nZm [Occ=Once] ->
                 case ds1_d2pwm of { W16# y#_a2nZn [Occ=Once] ->
                 GHC.Word.W16# (xor# x#_a2nZm y#_a2nZn)
                 }
                 }}]
GHC.Word.$fBitsWord16_$cxor
  = \ (ds_d2pwl :: Word16) (ds1_d2pwm :: Word16) ->
      case ds_d2pwl of { W16# x#_a2nZm ->
      case ds1_d2pwm of { W16# y#_a2nZn ->
      GHC.Word.W16# (xor# x#_a2nZm y#_a2nZn)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$c.|. :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pwe [Occ=Once!] :: Word16)
                 (ds1_d2pwf [Occ=Once!] :: Word16) ->
                 case ds_d2pwe of { W16# x#_a2nZk [Occ=Once] ->
                 case ds1_d2pwf of { W16# y#_a2nZl [Occ=Once] ->
                 GHC.Word.W16# (or# x#_a2nZk y#_a2nZl)
                 }
                 }}]
GHC.Word.$fBitsWord16_$c.|.
  = \ (ds_d2pwe :: Word16) (ds1_d2pwf :: Word16) ->
      case ds_d2pwe of { W16# x#_a2nZk ->
      case ds1_d2pwf of { W16# y#_a2nZl ->
      GHC.Word.W16# (or# x#_a2nZk y#_a2nZl)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$c.&. :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pw7 [Occ=Once!] :: Word16)
                 (ds1_d2pw8 [Occ=Once!] :: Word16) ->
                 case ds_d2pw7 of { W16# x#_a2nZi [Occ=Once] ->
                 case ds1_d2pw8 of { W16# y#_a2nZj [Occ=Once] ->
                 GHC.Word.W16# (and# x#_a2nZi y#_a2nZj)
                 }
                 }}]
GHC.Word.$fBitsWord16_$c.&.
  = \ (ds_d2pw7 :: Word16) (ds1_d2pw8 :: Word16) ->
      case ds_d2pw7 of { W16# x#_a2nZi ->
      case ds1_d2pw8 of { W16# y#_a2nZj ->
      GHC.Word.W16# (and# x#_a2nZi y#_a2nZj)
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pw3 [Occ=Once!] :: Word16) ->
                 case ds_d2pw3 of { W16# x#_a2nZh [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz16# x#_a2nZh))
                 }}]
GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros
  = \ (ds_d2pw3 :: Word16) ->
      case ds_d2pw3 of { W16# x#_a2nZh ->
      GHC.Types.I# (word2Int# (ctz16# x#_a2nZh))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvZ [Occ=Once!] :: Word16) ->
                 case ds_d2pvZ of { W16# x#_a2nZg [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz16# x#_a2nZg))
                 }}]
GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros
  = \ (ds_d2pvZ :: Word16) ->
      case ds_d2pvZ of { W16# x#_a2nZg ->
      GHC.Types.I# (word2Int# (clz16# x#_a2nZg))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord1 = GHC.Types.I# 16#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cfiniteBitSize :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord1}]
GHC.Word.$fBitsWord16_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord1

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$cfromInteger :: Integer -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a2nZf [Occ=Once] :: Integer) ->
                 case integerToWord i_a2nZf of wild_X6m { __DEFAULT ->
                 GHC.Word.W32# (narrow32Word# wild_X6m)
                 }}]
GHC.Word.$fNumWord32_$cfromInteger
  = \ (i_a2nZf :: Integer) ->
      case integerToWord i_a2nZf of wild_X6m { __DEFAULT ->
      GHC.Word.W32# (narrow32Word# wild_X6m)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$cabs :: Word32 -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_a2nZe [Occ=Once] :: Word32) -> x_a2nZe}]
GHC.Word.$fNumWord32_$cabs = \ (x_a2nZe :: Word32) -> x_a2nZe

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$cnegate :: Word32 -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvF [Occ=Once!] :: Word32) ->
                 case ds_d2pvF of { W32# x#_a2nZd [Occ=Once] ->
                 GHC.Word.W32#
                   (narrow32Word# (int2Word# (negateInt# (word2Int# x#_a2nZd))))
                 }}]
GHC.Word.$fNumWord32_$cnegate
  = \ (ds_d2pvF :: Word32) ->
      case ds_d2pvF of { W32# x#_a2nZd ->
      GHC.Word.W32#
        (narrow32Word# (int2Word# (negateInt# (word2Int# x#_a2nZd))))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$c* :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvy [Occ=Once!] :: Word32)
                 (ds1_d2pvz [Occ=Once!] :: Word32) ->
                 case ds_d2pvy of { W32# x#_a2nZb [Occ=Once] ->
                 case ds1_d2pvz of { W32# y#_a2nZc [Occ=Once] ->
                 GHC.Word.W32# (narrow32Word# (timesWord# x#_a2nZb y#_a2nZc))
                 }
                 }}]
GHC.Word.$fNumWord32_$c*
  = \ (ds_d2pvy :: Word32) (ds1_d2pvz :: Word32) ->
      case ds_d2pvy of { W32# x#_a2nZb ->
      case ds1_d2pvz of { W32# y#_a2nZc ->
      GHC.Word.W32# (narrow32Word# (timesWord# x#_a2nZb y#_a2nZc))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$c- :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvr [Occ=Once!] :: Word32)
                 (ds1_d2pvs [Occ=Once!] :: Word32) ->
                 case ds_d2pvr of { W32# x#_a2nZ9 [Occ=Once] ->
                 case ds1_d2pvs of { W32# y#_a2nZa [Occ=Once] ->
                 GHC.Word.W32# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa))
                 }
                 }}]
GHC.Word.$fNumWord32_$c-
  = \ (ds_d2pvr :: Word32) (ds1_d2pvs :: Word32) ->
      case ds_d2pvr of { W32# x#_a2nZ9 ->
      case ds1_d2pvs of { W32# y#_a2nZa ->
      GHC.Word.W32# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$c+ :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvk [Occ=Once!] :: Word32)
                 (ds1_d2pvl [Occ=Once!] :: Word32) ->
                 case ds_d2pvk of { W32# x#_a2nZ7 [Occ=Once] ->
                 case ds1_d2pvl of { W32# y#_a2nZ8 [Occ=Once] ->
                 GHC.Word.W32# (narrow32Word# (plusWord# x#_a2nZ7 y#_a2nZ8))
                 }
                 }}]
GHC.Word.$fNumWord32_$c+
  = \ (ds_d2pvk :: Word32) (ds1_d2pvl :: Word32) ->
      case ds_d2pvk of { W32# x#_a2nZ7 ->
      case ds1_d2pvl of { W32# y#_a2nZ8 ->
      GHC.Word.W32# (narrow32Word# (plusWord# x#_a2nZ7 y#_a2nZ8))
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$ctoInteger2 :: Word32 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pu8 [Occ=Once!] :: Word32) ->
                 case ds_d2pu8 of { W32# x#_a2nZ1 [Occ=Once] ->
                 smallInteger (word2Int# x#_a2nZ1)
                 }}]
GHC.Word.$ctoInteger2
  = \ (ds_d2pu8 :: Word32) ->
      case ds_d2pu8 of { W32# x#_a2nZ1 ->
      smallInteger (word2Int# x#_a2nZ1)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cpopCount :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pt7 [Occ=Once!] :: Word32) ->
                 case ds_d2pt7 of { W32# x#_a2nYG [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt32# x#_a2nYG))
                 }}]
GHC.Word.$fBitsWord32_$cpopCount
  = \ (ds_d2pt7 :: Word32) ->
      case ds_d2pt7 of { W32# x#_a2nYG ->
      GHC.Types.I# (word2Int# (popCnt32# x#_a2nYG))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cunsafeShiftR :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pt0 [Occ=Once!] :: Word32)
                 (ds1_d2pt1 [Occ=Once!] :: Int) ->
                 case ds_d2pt0 of { W32# x#_a2nYz [Occ=Once] ->
                 case ds1_d2pt1 of { I# i#_a2nYA [Occ=Once] ->
                 GHC.Word.W32# (uncheckedShiftRL# x#_a2nYz i#_a2nYA)
                 }
                 }}]
GHC.Word.$fBitsWord32_$cunsafeShiftR
  = \ (ds_d2pt0 :: Word32) (ds1_d2pt1 :: Int) ->
      case ds_d2pt0 of { W32# x#_a2nYz ->
      case ds1_d2pt1 of { I# i#_a2nYA ->
      GHC.Word.W32# (uncheckedShiftRL# x#_a2nYz i#_a2nYA)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cshiftR :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2psT [Occ=Once!] :: Word32)
                 (ds1_d2psU [Occ=Once!] :: Int) ->
                 case ds_d2psT of { W32# x#_a2nYx [Occ=Once] ->
                 case ds1_d2psU of { I# i#_a2nYy ->
                 case >=# i#_a2nYy 64# of {
                   __DEFAULT -> GHC.Word.W32# (uncheckedShiftRL# x#_a2nYx i#_a2nYy);
                   1# -> GHC.Word.W32# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$cshiftR
  = \ (ds_d2psT :: Word32) (ds1_d2psU :: Int) ->
      case ds_d2psT of { W32# x#_a2nYx ->
      case ds1_d2psU of { I# i#_a2nYy ->
      case >=# i#_a2nYy 64# of {
        __DEFAULT -> GHC.Word.W32# (uncheckedShiftRL# x#_a2nYx i#_a2nYy);
        1# -> GHC.Word.$fBitsWord32_$cminBound
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cunsafeShiftL :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2psM [Occ=Once!] :: Word32)
                 (ds1_d2psN [Occ=Once!] :: Int) ->
                 case ds_d2psM of { W32# x#_a2nYv [Occ=Once] ->
                 case ds1_d2psN of { I# i#_a2nYw [Occ=Once] ->
                 GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYv i#_a2nYw))
                 }
                 }}]
GHC.Word.$fBitsWord32_$cunsafeShiftL
  = \ (ds_d2psM :: Word32) (ds1_d2psN :: Int) ->
      case ds_d2psM of { W32# x#_a2nYv ->
      case ds1_d2psN of { I# i#_a2nYw ->
      GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYv i#_a2nYw))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cshiftL :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2psF [Occ=Once!] :: Word32)
                 (ds1_d2psG [Occ=Once!] :: Int) ->
                 case ds_d2psF of { W32# x#_a2nYt [Occ=Once] ->
                 case ds1_d2psG of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYt i#_a2nYu));
                   1# -> GHC.Word.W32# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$cshiftL
  = \ (ds_d2psF :: Word32) (ds1_d2psG :: Int) ->
      case ds_d2psF of { W32# x#_a2nYt ->
      case ds1_d2psG of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYt i#_a2nYu));
        1# -> GHC.Word.$fBitsWord32_$cminBound
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cisSigned :: Word32 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
GHC.Word.$fBitsWord32_$cisSigned
  = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 28, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$crotate :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pso [Occ=Once!] :: Word32)
                 (ds1_d2psp [Occ=Once!] :: Int) ->
                 case ds_d2pso of { W32# x#_a2nYB ->
                 case ds1_d2psp of { I# i#_a2nYC [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a2nYC) 31##) of wild2_X6N {
                   __DEFAULT ->
                     GHC.Word.W32#
                       (narrow32Word#
                          (or#
                             (uncheckedShiftL# x#_a2nYB wild2_X6N)
                             (uncheckedShiftRL# x#_a2nYB (-# 32# wild2_X6N))));
                   0# -> GHC.Word.W32# x#_a2nYB
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$crotate
  = \ (ds_d2pso :: Word32) (ds1_d2psp :: Int) ->
      case ds_d2pso of wild_X6B { W32# x#_a2nYB ->
      case ds1_d2psp of { I# i#_a2nYC ->
      case word2Int# (and# (int2Word# i#_a2nYC) 31##) of wild2_X6N {
        __DEFAULT ->
          GHC.Word.W32#
            (narrow32Word#
               (or#
                  (uncheckedShiftL# x#_a2nYB wild2_X6N)
                  (uncheckedShiftRL# x#_a2nYB (-# 32# wild2_X6N))));
        0# -> wild_X6B
      }
      }
      }

-- RHS size: {terms: 40, types: 10, coercions: 0, joins: 0/1}
GHC.Word.$fBitsWord32_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2psf [Occ=Once!] :: Word32)
                 (ds1_d2psg [Occ=Once!] :: Int) ->
                 case ds_d2psf of { W32# x#_a2nYr [Occ=Once*] ->
                 case ds1_d2psg of { I# i#_a2nYs ->
                 case >=# i#_a2nYs 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AGn :: Int#
                       [LclId]
                       b_i1AGn = negateInt# i#_a2nYs } in
                     case >=# b_i1AGn 64# of {
                       __DEFAULT -> GHC.Word.W32# (uncheckedShiftRL# x#_a2nYr b_i1AGn);
                       1# -> GHC.Word.W32# 0##
                     };
                   1# ->
                     case >=# i#_a2nYs 64# of {
                       __DEFAULT ->
                         GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYr i#_a2nYs));
                       1# -> GHC.Word.W32# 0##
                     }
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$cshift
  = \ (ds_d2psf :: Word32) (ds1_d2psg :: Int) ->
      case ds_d2psf of { W32# x#_a2nYr ->
      case ds1_d2psg of { I# i#_a2nYs ->
      case >=# i#_a2nYs 0# of {
        __DEFAULT ->
          let {
            b_s2qgi [Dmd=<S,U>] :: Int#
            [LclId]
            b_s2qgi = negateInt# i#_a2nYs } in
          case >=# b_s2qgi 64# of {
            __DEFAULT -> GHC.Word.W32# (uncheckedShiftRL# x#_a2nYr b_s2qgi);
            1# -> GHC.Word.$fBitsWord32_$cminBound
          };
        1# ->
          case >=# i#_a2nYs 64# of {
            __DEFAULT ->
              GHC.Word.W32# (narrow32Word# (uncheckedShiftL# x#_a2nYr i#_a2nYs));
            1# -> GHC.Word.$fBitsWord32_$cminBound
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cxor :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ps2 [Occ=Once!] :: Word32)
                 (ds1_d2ps3 [Occ=Once!] :: Word32) ->
                 case ds_d2ps2 of { W32# x#_a2nYn [Occ=Once] ->
                 case ds1_d2ps3 of { W32# y#_a2nYo [Occ=Once] ->
                 GHC.Word.W32# (xor# x#_a2nYn y#_a2nYo)
                 }
                 }}]
GHC.Word.$fBitsWord32_$cxor
  = \ (ds_d2ps2 :: Word32) (ds1_d2ps3 :: Word32) ->
      case ds_d2ps2 of { W32# x#_a2nYn ->
      case ds1_d2ps3 of { W32# y#_a2nYo ->
      GHC.Word.W32# (xor# x#_a2nYn y#_a2nYo)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$c.|. :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2prV [Occ=Once!] :: Word32)
                 (ds1_d2prW [Occ=Once!] :: Word32) ->
                 case ds_d2prV of { W32# x#_a2nYl [Occ=Once] ->
                 case ds1_d2prW of { W32# y#_a2nYm [Occ=Once] ->
                 GHC.Word.W32# (or# x#_a2nYl y#_a2nYm)
                 }
                 }}]
GHC.Word.$fBitsWord32_$c.|.
  = \ (ds_d2prV :: Word32) (ds1_d2prW :: Word32) ->
      case ds_d2prV of { W32# x#_a2nYl ->
      case ds1_d2prW of { W32# y#_a2nYm ->
      GHC.Word.W32# (or# x#_a2nYl y#_a2nYm)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$c.&. :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2prO [Occ=Once!] :: Word32)
                 (ds1_d2prP [Occ=Once!] :: Word32) ->
                 case ds_d2prO of { W32# x#_a2nYj [Occ=Once] ->
                 case ds1_d2prP of { W32# y#_a2nYk [Occ=Once] ->
                 GHC.Word.W32# (and# x#_a2nYj y#_a2nYk)
                 }
                 }}]
GHC.Word.$fBitsWord32_$c.&.
  = \ (ds_d2prO :: Word32) (ds1_d2prP :: Word32) ->
      case ds_d2prO of { W32# x#_a2nYj ->
      case ds1_d2prP of { W32# y#_a2nYk ->
      GHC.Word.W32# (and# x#_a2nYj y#_a2nYk)
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2prK [Occ=Once!] :: Word32) ->
                 case ds_d2prK of { W32# x#_a2nYi [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz32# x#_a2nYi))
                 }}]
GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros
  = \ (ds_d2prK :: Word32) ->
      case ds_d2prK of { W32# x#_a2nYi ->
      GHC.Types.I# (word2Int# (ctz32# x#_a2nYi))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2prG [Occ=Once!] :: Word32) ->
                 case ds_d2prG of { W32# x#_a2nYh [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz32# x#_a2nYh))
                 }}]
GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros
  = \ (ds_d2prG :: Word32) ->
      case ds_d2prG of { W32# x#_a2nYh ->
      GHC.Types.I# (word2Int# (clz32# x#_a2nYh))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord3 = GHC.Types.I# 32#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cfiniteBitSize :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord3}]
GHC.Word.$fBitsWord32_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord3

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cpopCount :: Word64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2poh [Occ=Once!] :: Word64) ->
                 case ds_d2poh of { W64# x#_a2nXv [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt64# x#_a2nXv))
                 }}]
GHC.Word.$fBitsWord64_$cpopCount
  = \ (ds_d2poh :: Word64) ->
      case ds_d2poh of { W64# x#_a2nXv ->
      GHC.Types.I# (word2Int# (popCnt64# x#_a2nXv))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cunsafeShiftR :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2poa [Occ=Once!] :: Word64)
                 (ds1_d2pob [Occ=Once!] :: Int) ->
                 case ds_d2poa of { W64# x#_a2nXo [Occ=Once] ->
                 case ds1_d2pob of { I# i#_a2nXp [Occ=Once] ->
                 GHC.Word.W64# (uncheckedShiftRL# x#_a2nXo i#_a2nXp)
                 }
                 }}]
GHC.Word.$fBitsWord64_$cunsafeShiftR
  = \ (ds_d2poa :: Word64) (ds1_d2pob :: Int) ->
      case ds_d2poa of { W64# x#_a2nXo ->
      case ds1_d2pob of { I# i#_a2nXp ->
      GHC.Word.W64# (uncheckedShiftRL# x#_a2nXo i#_a2nXp)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cshiftR :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2po3 [Occ=Once!] :: Word64)
                 (ds1_d2po4 [Occ=Once!] :: Int) ->
                 case ds_d2po3 of { W64# x#_a2nXm [Occ=Once] ->
                 case ds1_d2po4 of { I# i#_a2nXn ->
                 case >=# i#_a2nXn 64# of {
                   __DEFAULT -> GHC.Word.W64# (uncheckedShiftRL# x#_a2nXm i#_a2nXn);
                   1# -> GHC.Word.W64# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$cshiftR
  = \ (ds_d2po3 :: Word64) (ds1_d2po4 :: Int) ->
      case ds_d2po3 of { W64# x#_a2nXm ->
      case ds1_d2po4 of { I# i#_a2nXn ->
      case >=# i#_a2nXn 64# of {
        __DEFAULT -> GHC.Word.W64# (uncheckedShiftRL# x#_a2nXm i#_a2nXn);
        1# -> GHC.Word.$fBitsWord7
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cunsafeShiftL :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pnW [Occ=Once!] :: Word64)
                 (ds1_d2pnX [Occ=Once!] :: Int) ->
                 case ds_d2pnW of { W64# x#_a2nXk [Occ=Once] ->
                 case ds1_d2pnX of { I# i#_a2nXl [Occ=Once] ->
                 GHC.Word.W64# (uncheckedShiftL# x#_a2nXk i#_a2nXl)
                 }
                 }}]
GHC.Word.$fBitsWord64_$cunsafeShiftL
  = \ (ds_d2pnW :: Word64) (ds1_d2pnX :: Int) ->
      case ds_d2pnW of { W64# x#_a2nXk ->
      case ds1_d2pnX of { I# i#_a2nXl ->
      GHC.Word.W64# (uncheckedShiftL# x#_a2nXk i#_a2nXl)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cshiftL :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pnP [Occ=Once!] :: Word64)
                 (ds1_d2pnQ [Occ=Once!] :: Int) ->
                 case ds_d2pnP of { W64# x#_a2nXi [Occ=Once] ->
                 case ds1_d2pnQ of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# x#_a2nXi i#_a2nXj);
                   1# -> GHC.Word.W64# 0##
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$cshiftL
  = \ (ds_d2pnP :: Word64) (ds1_d2pnQ :: Int) ->
      case ds_d2pnP of { W64# x#_a2nXi ->
      case ds1_d2pnQ of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# x#_a2nXi i#_a2nXj);
        1# -> GHC.Word.$fBitsWord7
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cisSigned :: Word64 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.False}]
GHC.Word.$fBitsWord64_$cisSigned
  = \ _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 27, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$crotate :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pny [Occ=Once!] :: Word64)
                 (ds1_d2pnz [Occ=Once!] :: Int) ->
                 case ds_d2pny of { W64# x#_a2nXq ->
                 case ds1_d2pnz of { I# i#_a2nXr [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a2nXr) 63##) of wild2_X78 {
                   __DEFAULT ->
                     GHC.Word.W64#
                       (or#
                          (uncheckedShiftL# x#_a2nXq wild2_X78)
                          (uncheckedShiftRL# x#_a2nXq (-# 64# wild2_X78)));
                   0# -> GHC.Word.W64# x#_a2nXq
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$crotate
  = \ (ds_d2pny :: Word64) (ds1_d2pnz :: Int) ->
      case ds_d2pny of wild_X6W { W64# x#_a2nXq ->
      case ds1_d2pnz of { I# i#_a2nXr ->
      case word2Int# (and# (int2Word# i#_a2nXr) 63##) of wild2_X78 {
        __DEFAULT ->
          GHC.Word.W64#
            (or#
               (uncheckedShiftL# x#_a2nXq wild2_X78)
               (uncheckedShiftRL# x#_a2nXq (-# 64# wild2_X78)));
        0# -> wild_X6W
      }
      }
      }

-- RHS size: {terms: 39, types: 10, coercions: 0, joins: 0/1}
GHC.Word.$fBitsWord64_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pnp [Occ=Once!] :: Word64)
                 (ds1_d2pnq [Occ=Once!] :: Int) ->
                 case ds_d2pnp of { W64# x#_a2nXg [Occ=Once*] ->
                 case ds1_d2pnq of { I# i#_a2nXh ->
                 case >=# i#_a2nXh 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AGn :: Int#
                       [LclId]
                       b_i1AGn = negateInt# i#_a2nXh } in
                     case >=# b_i1AGn 64# of {
                       __DEFAULT -> GHC.Word.W64# (uncheckedShiftRL# x#_a2nXg b_i1AGn);
                       1# -> GHC.Word.W64# 0##
                     };
                   1# ->
                     case >=# i#_a2nXh 64# of {
                       __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# x#_a2nXg i#_a2nXh);
                       1# -> GHC.Word.W64# 0##
                     }
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$cshift
  = \ (ds_d2pnp :: Word64) (ds1_d2pnq :: Int) ->
      case ds_d2pnp of { W64# x#_a2nXg ->
      case ds1_d2pnq of { I# i#_a2nXh ->
      case >=# i#_a2nXh 0# of {
        __DEFAULT ->
          let {
            b_s2qgc [Dmd=<S,U>] :: Int#
            [LclId]
            b_s2qgc = negateInt# i#_a2nXh } in
          case >=# b_s2qgc 64# of {
            __DEFAULT -> GHC.Word.W64# (uncheckedShiftRL# x#_a2nXg b_s2qgc);
            1# -> GHC.Word.$fBitsWord7
          };
        1# ->
          case >=# i#_a2nXh 64# of {
            __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# x#_a2nXg i#_a2nXh);
            1# -> GHC.Word.$fBitsWord7
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cxor :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pnc [Occ=Once!] :: Word64)
                 (ds1_d2pnd [Occ=Once!] :: Word64) ->
                 case ds_d2pnc of { W64# x#_a2nXc [Occ=Once] ->
                 case ds1_d2pnd of { W64# y#_a2nXd [Occ=Once] ->
                 GHC.Word.W64# (xor# x#_a2nXc y#_a2nXd)
                 }
                 }}]
GHC.Word.$fBitsWord64_$cxor
  = \ (ds_d2pnc :: Word64) (ds1_d2pnd :: Word64) ->
      case ds_d2pnc of { W64# x#_a2nXc ->
      case ds1_d2pnd of { W64# y#_a2nXd ->
      GHC.Word.W64# (xor# x#_a2nXc y#_a2nXd)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$c.|. :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pn5 [Occ=Once!] :: Word64)
                 (ds1_d2pn6 [Occ=Once!] :: Word64) ->
                 case ds_d2pn5 of { W64# x#_a2nXa [Occ=Once] ->
                 case ds1_d2pn6 of { W64# y#_a2nXb [Occ=Once] ->
                 GHC.Word.W64# (or# x#_a2nXa y#_a2nXb)
                 }
                 }}]
GHC.Word.$fBitsWord64_$c.|.
  = \ (ds_d2pn5 :: Word64) (ds1_d2pn6 :: Word64) ->
      case ds_d2pn5 of { W64# x#_a2nXa ->
      case ds1_d2pn6 of { W64# y#_a2nXb ->
      GHC.Word.W64# (or# x#_a2nXa y#_a2nXb)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$c.&. :: Word64 -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pmY [Occ=Once!] :: Word64)
                 (ds1_d2pmZ [Occ=Once!] :: Word64) ->
                 case ds_d2pmY of { W64# x#_a2nX8 [Occ=Once] ->
                 case ds1_d2pmZ of { W64# y#_a2nX9 [Occ=Once] ->
                 GHC.Word.W64# (and# x#_a2nX8 y#_a2nX9)
                 }
                 }}]
GHC.Word.$fBitsWord64_$c.&.
  = \ (ds_d2pmY :: Word64) (ds1_d2pmZ :: Word64) ->
      case ds_d2pmY of { W64# x#_a2nX8 ->
      case ds1_d2pmZ of { W64# y#_a2nX9 ->
      GHC.Word.W64# (and# x#_a2nX8 y#_a2nX9)
      }
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros :: Word64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pmU [Occ=Once!] :: Word64) ->
                 case ds_d2pmU of { W64# x#_a2nX7 [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz64# x#_a2nX7))
                 }}]
GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
  = \ (ds_d2pmU :: Word64) ->
      case ds_d2pmU of { W64# x#_a2nX7 ->
      GHC.Types.I# (word2Int# (ctz64# x#_a2nX7))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros :: Word64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pmQ [Occ=Once!] :: Word64) ->
                 case ds_d2pmQ of { W64# x#_a2nX6 [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz64# x#_a2nX6))
                 }}]
GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
  = \ (ds_d2pmQ :: Word64) ->
      case ds_d2pmQ of { W64# x#_a2nX6 ->
      GHC.Types.I# (word2Int# (clz64# x#_a2nX6))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord5 = GHC.Types.I# 64#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cfiniteBitSize :: Word64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord5}]
GHC.Word.$fBitsWord64_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord5

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pm7 [Occ=Once!] :: Word8)
                 (ds1_d2pm8 [Occ=Once!] :: Word8) ->
                 case ds_d2pm7 of { W8# x_a2o1y [Occ=Once] ->
                 case ds1_d2pm8 of { W8# y_a2o1z [Occ=Once] ->
                 tagToEnum# @ Bool (eqWord# x_a2o1y y_a2o1z)
                 }
                 }}]
eqWord8
  = \ (ds_d2pm7 :: Word8) (ds1_d2pm8 :: Word8) ->
      case ds_d2pm7 of { W8# x_a2o1y ->
      case ds1_d2pm8 of { W8# y_a2o1z ->
      tagToEnum# @ Bool (eqWord# x_a2o1y y_a2o1z)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEqWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Word8 eqWord8 neWord8]
GHC.Word.$fEqWord8 = GHC.Classes.C:Eq @ Word8 eqWord8 neWord8

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord4 :: Word8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fNumWord4 = GHC.Word.W8# 1##

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8_$csignum :: Word8 -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pDl [Occ=Once!] :: Word8) ->
                 case ds_d2pDl of { W8# x_a2o1y [Occ=Once!] ->
                 case x_a2o1y of {
                   __DEFAULT -> GHC.Word.$fNumWord4;
                   0## -> GHC.Word.$fBitsWord8_$cminBound
                 }
                 }}]
GHC.Word.$fNumWord8_$csignum
  = \ (ds_d2pDl :: Word8) ->
      case ds_d2pDl of { W8# x_a2o1y ->
      case x_a2o1y of {
        __DEFAULT -> GHC.Word.$fNumWord4;
        0## -> GHC.Word.$fBitsWord8_$cminBound
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Num Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Word8
                     GHC.Word.$fNumWord8_$c+
                     GHC.Word.$fNumWord8_$c-
                     GHC.Word.$fNumWord8_$c*
                     GHC.Word.$fNumWord8_$cnegate
                     GHC.Word.$fNumWord8_$cabs
                     GHC.Word.$fNumWord8_$csignum
                     GHC.Word.$fNumWord8_$cfromInteger]
GHC.Word.$fNumWord8
  = GHC.Num.C:Num
      @ Word8
      GHC.Word.$fNumWord8_$c+
      GHC.Word.$fNumWord8_$c-
      GHC.Word.$fNumWord8_$c*
      GHC.Word.$fNumWord8_$cnegate
      GHC.Word.$fNumWord8_$cabs
      GHC.Word.$fNumWord8_$csignum
      GHC.Word.$fNumWord8_$cfromInteger

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$ccomplement :: Word8 -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pAg [Occ=Once!] :: Word8) ->
                 case ds_d2pAg of { W8# x#_a2o0x [Occ=Once] ->
                 GHC.Word.W8# (xor# x#_a2o0x 255##)
                 }}]
GHC.Word.$fBitsWord8_$ccomplement
  = \ (ds_d2pAg :: Word8) ->
      case ds_d2pAg of { W8# x#_a2o0x ->
      GHC.Word.W8# (xor# x#_a2o0x 255##)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord10 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord10 = GHC.Base.Just @ Int GHC.Word.$fBitsWord9

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cbitSizeMaybe :: Word8 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord10}]
GHC.Word.$fBitsWord8_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord10

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Word8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     GHC.Word.W8# (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C));
                   1# -> GHC.Word.W8# 0##
                 }
                 }}]
GHC.Word.$fBitsWord8_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          GHC.Word.W8# (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C));
        1# -> GHC.Word.$fBitsWord8_$cminBound
      }
      }

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Word8 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Word8)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { W8# x#_a2o0r [Occ=Once] ->
                 case i_a1A6i of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     neWord8
                       (GHC.Word.W8#
                          (and# x#_a2o0r (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C))))
                       (GHC.Word.W8# 0##);
                   1# -> neWord8 (GHC.Word.W8# 0##) (GHC.Word.W8# 0##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$ctestBit
  = \ (x_a1A6h :: Word8) (i_a1A6i :: Int) ->
      case x_a1A6h of { W8# x#_a2o0r ->
      case i_a1A6i of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          case and# x#_a2o0r (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C))
          of {
            __DEFAULT -> GHC.Types.True;
            0## -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Word8)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { W8# x#_a2o0J ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 7##)
                 of wild2_X65 {
                   __DEFAULT ->
                     GHC.Word.W8#
                       (narrow8Word#
                          (or#
                             (uncheckedShiftL# x#_a2o0J wild2_X65)
                             (uncheckedShiftRL# x#_a2o0J (-# 8# wild2_X65))));
                   0# -> GHC.Word.W8# x#_a2o0J
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$crotateR
  = \ (eta_B2 :: Word8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X5T { W8# x#_a2o0J ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 7##)
      of wild2_X65 {
        __DEFAULT ->
          GHC.Word.W8#
            (narrow8Word#
               (or#
                  (uncheckedShiftL# x#_a2o0J wild2_X65)
                  (uncheckedShiftRL# x#_a2o0J (-# 8# wild2_X65))));
        0# -> wild_X5T
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Word.$fBitsWord8_$crotate}]
GHC.Word.$fBitsWord8_$crotateL = GHC.Word.$fBitsWord8_$crotate

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Word8)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { W8# x#_a2o0v [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     GHC.Word.W8#
                       (xor# x#_a2o0v (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)));
                   1# -> GHC.Word.W8# x#_a2o0v
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$ccomplementBit
  = \ (eta_B2 :: Word8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X5V { W8# x#_a2o0v ->
      case eta1_B1 of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          GHC.Word.W8#
            (xor# x#_a2o0v (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)));
        1# -> wild_X5V
      }
      }
      }

-- RHS size: {terms: 27, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Word8)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { W8# x#_a2o0r [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     GHC.Word.W8#
                       (and#
                          x#_a2o0r
                          (xor# (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)) 255##));
                   1# -> GHC.Word.W8# (and# x#_a2o0r 255##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$cclearBit
  = \ (eta_B2 :: Word8) (eta1_B1 :: Int) ->
      case eta_B2 of { W8# x#_a2o0r ->
      case eta1_B1 of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          GHC.Word.W8#
            (and#
               x#_a2o0r
               (xor# (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)) 255##));
        1# -> GHC.Word.W8# (and# x#_a2o0r 255##)
      }
      }
      }

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Word8 -> Int -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Word8)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { W8# x#_a2o0t [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a2o0C ->
                 case >=# i#_a2o0C 64# of {
                   __DEFAULT ->
                     GHC.Word.W8#
                       (or# x#_a2o0t (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)));
                   1# -> GHC.Word.W8# x#_a2o0t
                 }
                 }
                 }}]
GHC.Word.$fBitsWord8_$csetBit
  = \ (eta_B2 :: Word8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X5W { W8# x#_a2o0t ->
      case eta1_B1 of { I# i#_a2o0C ->
      case >=# i#_a2o0C 64# of {
        __DEFAULT ->
          GHC.Word.W8#
            (or# x#_a2o0t (narrow8Word# (uncheckedShiftL# 1## i#_a2o0C)));
        1# -> wild_X5W
      }
      }
      }

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Word8
                        GHC.Word.$fEqWord8
                        GHC.Word.$fBitsWord8_$c.&.
                        GHC.Word.$fBitsWord8_$c.|.
                        GHC.Word.$fBitsWord8_$cxor
                        GHC.Word.$fBitsWord8_$ccomplement
                        GHC.Word.$fBitsWord8_$cshift
                        GHC.Word.$fBitsWord8_$crotate
                        GHC.Word.$fBitsWord8_$cminBound
                        GHC.Word.$fBitsWord8_$cbit
                        GHC.Word.$fBitsWord8_$csetBit
                        GHC.Word.$fBitsWord8_$cclearBit
                        GHC.Word.$fBitsWord8_$ccomplementBit
                        GHC.Word.$fBitsWord8_$ctestBit
                        GHC.Word.$fBitsWord8_$cbitSizeMaybe
                        GHC.Word.$fBitsWord8_$cfiniteBitSize
                        GHC.Word.$fBitsWord8_$cisSigned
                        GHC.Word.$fBitsWord8_$cshiftL
                        GHC.Word.$fBitsWord8_$cunsafeShiftL
                        GHC.Word.$fBitsWord8_$cshiftR
                        GHC.Word.$fBitsWord8_$cunsafeShiftR
                        GHC.Word.$fBitsWord8_$crotateL
                        GHC.Word.$fBitsWord8_$crotateR
                        GHC.Word.$fBitsWord8_$cpopCount]
GHC.Word.$fBitsWord8
  = Data.Bits.C:Bits
      @ Word8
      GHC.Word.$fEqWord8
      GHC.Word.$fBitsWord8_$c.&.
      GHC.Word.$fBitsWord8_$c.|.
      GHC.Word.$fBitsWord8_$cxor
      GHC.Word.$fBitsWord8_$ccomplement
      GHC.Word.$fBitsWord8_$cshift
      GHC.Word.$fBitsWord8_$crotate
      GHC.Word.$fBitsWord8_$cminBound
      GHC.Word.$fBitsWord8_$cbit
      GHC.Word.$fBitsWord8_$csetBit
      GHC.Word.$fBitsWord8_$cclearBit
      GHC.Word.$fBitsWord8_$ccomplementBit
      GHC.Word.$fBitsWord8_$ctestBit
      GHC.Word.$fBitsWord8_$cbitSizeMaybe
      GHC.Word.$fBitsWord8_$cfiniteBitSize
      GHC.Word.$fBitsWord8_$cisSigned
      GHC.Word.$fBitsWord8_$cshiftL
      GHC.Word.$fBitsWord8_$cunsafeShiftL
      GHC.Word.$fBitsWord8_$cshiftR
      GHC.Word.$fBitsWord8_$cunsafeShiftR
      GHC.Word.$fBitsWord8_$crotateL
      GHC.Word.$fBitsWord8_$crotateR
      GHC.Word.$fBitsWord8_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Word8
                              GHC.Word.$fBitsWord8
                              GHC.Word.$fBitsWord8_$cfiniteBitSize
                              GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
                              GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros]
GHC.Word.$fFiniteBitsWord8
  = Data.Bits.C:FiniteBits
      @ Word8
      GHC.Word.$fBitsWord8
      GHC.Word.$fBitsWord8_$cfiniteBitSize
      GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
      GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord8_$cquot :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBB [Occ=Once!] :: Word8)
                 (y_a2o0X [Occ=Once!] :: Word8) ->
                 case ds_d2pBB of { W8# x#_a2o0W [Occ=Once] ->
                 case y_a2o0X of { W8# y#_a2o0Y [Occ=Once!] ->
                 case y#_a2o0Y of wild2_Xci {
                   __DEFAULT ->
                     case quotWord# x#_a2o0W wild2_Xci of wild3_X1T { __DEFAULT ->
                     GHC.Word.W8# wild3_X1T
                     };
                   0## -> divZeroError @ Word8
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord8_$cquot
  = \ (ds_d2pBB :: Word8) (y_a2o0X :: Word8) ->
      case ds_d2pBB of { W8# x#_a2o0W ->
      case y_a2o0X of { W8# y#_a2o0Y ->
      case y#_a2o0Y of wild2_Xci {
        __DEFAULT ->
          case quotWord# x#_a2o0W wild2_Xci of wild3_X1T { __DEFAULT ->
          GHC.Word.W8# wild3_X1T
          };
        0## -> divZeroError @ Word8
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord8_$crem :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBK [Occ=Once!] :: Word8)
                 (y_a2o10 [Occ=Once!] :: Word8) ->
                 case ds_d2pBK of { W8# x#_a2o0Z [Occ=Once] ->
                 case y_a2o10 of { W8# y#_a2o11 [Occ=Once!] ->
                 case y#_a2o11 of wild2_Xck {
                   __DEFAULT ->
                     case remWord# x#_a2o0Z wild2_Xck of wild3_X1U { __DEFAULT ->
                     GHC.Word.W8# wild3_X1U
                     };
                   0## -> divZeroError @ Word8
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord8_$crem
  = \ (ds_d2pBK :: Word8) (y_a2o10 :: Word8) ->
      case ds_d2pBK of { W8# x#_a2o0Z ->
      case y_a2o10 of { W8# y#_a2o11 ->
      case y#_a2o11 of wild2_Xck {
        __DEFAULT ->
          case remWord# x#_a2o0Z wild2_Xck of wild3_X1U { __DEFAULT ->
          GHC.Word.W8# wild3_X1U
          };
        0## -> divZeroError @ Word8
      }
      }
      }

-- RHS size: {terms: 23, types: 19, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord8_$cquotRem
  :: Word8 -> Word8 -> (Word8, Word8)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pCb [Occ=Once!] :: Word8)
                 (y_a2o19 [Occ=Once!] :: Word8) ->
                 case ds_d2pCb of { W8# x#_a2o18 [Occ=Once] ->
                 case y_a2o19 of { W8# y#_a2o1a [Occ=Once!] ->
                 case y#_a2o1a of wild2_Xcq {
                   __DEFAULT ->
                     case quotRemWord# x#_a2o18 wild2_Xcq of
                     { (# ipv_s2pJ7 [Occ=Once], ipv1_s2pJ8 [Occ=Once] #) ->
                     (GHC.Word.W8# ipv_s2pJ7, GHC.Word.W8# ipv1_s2pJ8)
                     };
                   0## -> divZeroError @ (Word8, Word8)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord8_$cquotRem
  = \ (ds_d2pCb :: Word8) (y_a2o19 :: Word8) ->
      case ds_d2pCb of { W8# x#_a2o18 ->
      case y_a2o19 of { W8# y#_a2o1a ->
      case y#_a2o1a of wild2_Xcq {
        __DEFAULT ->
          case quotRemWord# x#_a2o18 wild2_Xcq of
          { (# ipv_s2pJ7, ipv1_s2pJ8 #) ->
          (GHC.Word.W8# ipv_s2pJ7, GHC.Word.W8# ipv1_s2pJ8)
          };
        0## -> divZeroError @ (Word8, Word8)
      }
      }
      }

-- RHS size: {terms: 28, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord8_$cdivMod
  :: Word8 -> Word8 -> (Word8, Word8)
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pCp [Occ=Once!] :: Word8)
                 (y_a2o1e [Occ=Once!] :: Word8) ->
                 case ds_d2pCp of { W8# x#_a2o1d ->
                 case y_a2o1e of { W8# y#_a2o1f [Occ=Once!] ->
                 case y#_a2o1f of wild2_Xcs {
                   __DEFAULT ->
                     (case quotWord# x#_a2o1d wild2_Xcs of wild3_X1Y { __DEFAULT ->
                      GHC.Word.W8# wild3_X1Y
                      },
                      case remWord# x#_a2o1d wild2_Xcs of wild3_X1Y { __DEFAULT ->
                      GHC.Word.W8# wild3_X1Y
                      });
                   0## -> divZeroError @ (Word8, Word8)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord8_$cdivMod
  = \ (ds_d2pCp :: Word8) (y_a2o1e :: Word8) ->
      case ds_d2pCp of { W8# x#_a2o1d ->
      case y_a2o1e of { W8# y#_a2o1f ->
      case y#_a2o1f of wild2_Xcs {
        __DEFAULT ->
          (case quotWord# x#_a2o1d wild2_Xcs of wild3_X1Y { __DEFAULT ->
           GHC.Word.W8# wild3_X1Y
           },
           case remWord# x#_a2o1d wild2_Xcs of wild3_X1Y { __DEFAULT ->
           GHC.Word.W8# wild3_X1Y
           });
        0## -> divZeroError @ (Word8, Word8)
      }
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2plT [Occ=Once!] :: Word8)
                 (ds1_d2plU [Occ=Once!] :: Word8) ->
                 case ds_d2plT of { W8# x_a2o1C [Occ=Once] ->
                 case ds1_d2plU of { W8# y_a2o1D [Occ=Once] ->
                 tagToEnum# @ Bool (gtWord# x_a2o1C y_a2o1D)
                 }
                 }}]
gtWord8
  = \ (ds_d2plT :: Word8) (ds1_d2plU :: Word8) ->
      case ds_d2plT of { W8# x_a2o1C ->
      case ds1_d2plU of { W8# y_a2o1D ->
      tagToEnum# @ Bool (gtWord# x_a2o1C y_a2o1D)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2plM [Occ=Once!] :: Word8)
                 (ds1_d2plN [Occ=Once!] :: Word8) ->
                 case ds_d2plM of { W8# x_a2o1E [Occ=Once] ->
                 case ds1_d2plN of { W8# y_a2o1F [Occ=Once] ->
                 tagToEnum# @ Bool (geWord# x_a2o1E y_a2o1F)
                 }
                 }}]
geWord8
  = \ (ds_d2plM :: Word8) (ds1_d2plN :: Word8) ->
      case ds_d2plM of { W8# x_a2o1E ->
      case ds1_d2plN of { W8# y_a2o1F ->
      tagToEnum# @ Bool (geWord# x_a2o1E y_a2o1F)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2plF [Occ=Once!] :: Word8)
                 (ds1_d2plG [Occ=Once!] :: Word8) ->
                 case ds_d2plF of { W8# x_a2o1G [Occ=Once] ->
                 case ds1_d2plG of { W8# y_a2o1H [Occ=Once] ->
                 tagToEnum# @ Bool (ltWord# x_a2o1G y_a2o1H)
                 }
                 }}]
ltWord8
  = \ (ds_d2plF :: Word8) (ds1_d2plG :: Word8) ->
      case ds_d2plF of { W8# x_a2o1G ->
      case ds1_d2plG of { W8# y_a2o1H ->
      tagToEnum# @ Bool (ltWord# x_a2o1G y_a2o1H)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leWord8 [InlPrag=INLINE[1] (sat-args=2)] :: Word8 -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2ply [Occ=Once!] :: Word8)
                 (ds1_d2plz [Occ=Once!] :: Word8) ->
                 case ds_d2ply of { W8# x_a2o1I [Occ=Once] ->
                 case ds1_d2plz of { W8# y_a2o1J [Occ=Once] ->
                 tagToEnum# @ Bool (leWord# x_a2o1I y_a2o1J)
                 }
                 }}]
leWord8
  = \ (ds_d2ply :: Word8) (ds1_d2plz :: Word8) ->
      case ds_d2ply of { W8# x_a2o1I ->
      case ds1_d2plz of { W8# y_a2o1J ->
      tagToEnum# @ Bool (leWord# x_a2o1I y_a2o1J)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord8_$ccompare :: Word8 -> Word8 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Word8)
                 (y_a1fi3 [Occ=Once!] :: Word8) ->
                 case x_a1fi2 of { W8# x1_a2o1y ->
                 case y_a1fi3 of { W8# y1_a2o1z ->
                 case eqWord# x1_a2o1y y1_a2o1z of {
                   __DEFAULT ->
                     case leWord# x1_a2o1y y1_a2o1z of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Word.$fOrdWord8_$ccompare
  = \ (x_a1fi2 :: Word8) (y_a1fi3 :: Word8) ->
      case x_a1fi2 of { W8# x1_a2o1y ->
      case y_a1fi3 of { W8# y1_a2o1z ->
      case eqWord# x1_a2o1y y1_a2o1z of {
        __DEFAULT ->
          case leWord# x1_a2o1y y1_a2o1z of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord8_$cmax :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Word8)
                 (y_a55e [Occ=Once!] :: Word8) ->
                 case x_a55d of wild_X7B { W8# x1_a2o1I [Occ=Once] ->
                 case y_a55e of wild1_X5 { W8# y1_a2o1J [Occ=Once] ->
                 case leWord# x1_a2o1I y1_a2o1J of {
                   __DEFAULT -> wild_X7B;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Word.$fOrdWord8_$cmax
  = \ (x_a55d :: Word8) (y_a55e :: Word8) ->
      case x_a55d of wild_X7B { W8# x1_a2o1I ->
      case y_a55e of wild1_X5 { W8# y1_a2o1J ->
      case leWord# x1_a2o1I y1_a2o1J of {
        __DEFAULT -> wild_X7B;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord8_$cmin :: Word8 -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Word8)
                 (y_a55n [Occ=Once!] :: Word8) ->
                 case x_a55m of wild_X7B { W8# x1_a2o1I [Occ=Once] ->
                 case y_a55n of wild1_X5 { W8# y1_a2o1J [Occ=Once] ->
                 case leWord# x1_a2o1I y1_a2o1J of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X7B
                 }
                 }
                 }}]
GHC.Word.$fOrdWord8_$cmin
  = \ (x_a55m :: Word8) (y_a55n :: Word8) ->
      case x_a55m of wild_X7B { W8# x1_a2o1I ->
      case y_a55n of wild1_X5 { W8# y1_a2o1J ->
      case leWord# x1_a2o1I y1_a2o1J of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X7B
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Word8
                         GHC.Word.$fEqWord8
                         GHC.Word.$fOrdWord8_$ccompare
                         ltWord8
                         leWord8
                         gtWord8
                         geWord8
                         GHC.Word.$fOrdWord8_$cmax
                         GHC.Word.$fOrdWord8_$cmin]
GHC.Word.$fOrdWord8
  = GHC.Classes.C:Ord
      @ Word8
      GHC.Word.$fEqWord8
      GHC.Word.$fOrdWord8_$ccompare
      ltWord8
      leWord8
      gtWord8
      geWord8
      GHC.Word.$fOrdWord8_$cmax
      GHC.Word.$fOrdWord8_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$cinRange :: (Word8, Word8) -> Word8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBu [Occ=Once!] :: (Word8, Word8))
                 (i_a2o0V [Occ=Once!] :: Word8) ->
                 case ds_d2pBu of { (m_a2o0T [Occ=Once!], n_a2o0U [Occ=Once!]) ->
                 case m_a2o0T of { W8# x_a2o1I [Occ=Once] ->
                 case i_a2o0V of { W8# y_a2o1J ->
                 case leWord# x_a2o1I y_a2o1J of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a2o0U of { W8# y1_X2oet [Occ=Once] ->
                     tagToEnum# @ Bool (leWord# y_a2o1J y1_X2oet)
                     }
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord8_$cinRange
  = \ (ds_d2pBu :: (Word8, Word8)) (i_a2o0V :: Word8) ->
      case ds_d2pBu of { (m_a2o0T, n_a2o0U) ->
      case m_a2o0T of { W8# x_a2o1I ->
      case i_a2o0V of { W8# y_a2o1J ->
      case leWord# x_a2o1I y_a2o1J of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a2o0U of { W8# y1_X2oet ->
          tagToEnum# @ Bool (leWord# y_a2o1J y1_X2oet)
          }
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord8_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word8 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sSy [Occ=Once!] :: Word8) ->
                 case w_s2sSy of { W8# ww1_s2sSB [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger
                           (smallInteger (word2Int# ww1_s2sSB)) GHC.Word.$fRealWord1)
                        GHC.Word.$fRealWord1
                 of
                 { (# ww3_s2sTe [Occ=Once], ww4_s2sTf [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2sTe ww4_s2sTf
                 }
                 }}]
GHC.Word.$fRealWord8_$ctoRational
  = \ (w_s2sSy :: Word8) ->
      case w_s2sSy of { W8# ww1_s2sSB ->
      case GHC.Real.$w$sreduce
             (timesInteger
                (smallInteger (word2Int# ww1_s2sSB)) GHC.Word.$fRealWord1)
             GHC.Word.$fRealWord1
      of
      { (# ww3_s2sTe, ww4_s2sTf #) ->
      GHC.Real.:% @ Integer ww3_s2sTe ww4_s2sTf
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Real Word8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Word8
                       GHC.Word.$fNumWord8
                       GHC.Word.$fOrdWord8
                       GHC.Word.$fRealWord8_$ctoRational]
GHC.Word.$fRealWord8
  = GHC.Real.C:Real
      @ Word8
      GHC.Word.$fNumWord8
      GHC.Word.$fOrdWord8
      GHC.Word.$fRealWord8_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Word8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Word8
                           GHC.Word.$fRealWord8
                           GHC.Word.$fEnumWord8
                           GHC.Word.$fIntegralWord8_$cquot
                           GHC.Word.$fIntegralWord8_$crem
                           GHC.Word.$fIntegralWord8_$cquot
                           GHC.Word.$fIntegralWord8_$crem
                           GHC.Word.$fIntegralWord8_$cquotRem
                           GHC.Word.$fIntegralWord8_$cdivMod
                           GHC.Word.$ctoInteger]
GHC.Word.$fIntegralWord8
  = GHC.Real.C:Integral
      @ Word8
      GHC.Word.$fRealWord8
      GHC.Word.$fEnumWord8
      GHC.Word.$fIntegralWord8_$cquot
      GHC.Word.$fIntegralWord8_$crem
      GHC.Word.$fIntegralWord8_$cquot
      GHC.Word.$fIntegralWord8_$crem
      GHC.Word.$fIntegralWord8_$cquotRem
      GHC.Word.$fIntegralWord8_$cdivMod
      GHC.Word.$ctoInteger

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$cunsafeIndex :: (Word8, Word8) -> Word8 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBn [Occ=Once!] :: (Word8, Word8))
                 (i_a2o0S [Occ=Once!] :: Word8) ->
                 case ds_d2pBn of { (m_a2o0R [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a2o0S of { W8# x#_a2o1p [Occ=Once] ->
                 case m_a2o0R of { W8# y#_a2o1q [Occ=Once] ->
                 GHC.Types.I#
                   (word2Int# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q)))
                 }
                 }
                 }}]
GHC.Word.$fIxWord8_$cunsafeIndex
  = \ (ds_d2pBn :: (Word8, Word8)) (i_a2o0S :: Word8) ->
      case ds_d2pBn of { (m_a2o0R, ds1_d2pBt) ->
      case i_a2o0S of { W8# x#_a2o1p ->
      case m_a2o0R of { W8# y#_a2o1q ->
      GHC.Types.I#
        (word2Int# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q)))
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$crange :: (Word8, Word8) -> [Word8]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pBi [Occ=Once!] :: (Word8, Word8)) ->
                 case ds_d2pBi of { (m_a2o0P [Occ=Once], n_a2o0Q [Occ=Once]) ->
                 GHC.Word.$fEnumWord8_$cenumFromTo m_a2o0P n_a2o0Q
                 }}]
GHC.Word.$fIxWord8_$crange
  = \ (ds_d2pBi :: (Word8, Word8)) ->
      case ds_d2pBi of { (m_a2o0P, n_a2o0Q) ->
      GHC.Word.$fEnumWord8_$cenumFromTo m_a2o0P n_a2o0Q
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fIxWord1 = GHC.Types.I# 0#

-- RHS size: {terms: 25, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$crangeSize :: (Word8, Word8) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Word8, Word8)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { W8# x_a2o1I ->
                 case h_a1KRn of { W8# y_a2o1J ->
                 case leWord# x_a2o1I y_a2o1J of {
                   __DEFAULT -> GHC.Word.$fIxWord1;
                   1# ->
                     GHC.Types.I#
                       (+# (word2Int# (narrow8Word# (minusWord# y_a2o1J x_a2o1I))) 1#)
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord8_$crangeSize
  = \ (b_a1KRl :: (Word8, Word8)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { W8# x_a2o1I ->
      case h_a1KRn of { W8# y_a2o1J ->
      case leWord# x_a2o1I y_a2o1J of {
        __DEFAULT -> GHC.Word.$fIxWord1;
        1# ->
          GHC.Types.I#
            (+# (word2Int# (narrow8Word# (minusWord# y_a2o1J x_a2o1I))) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 12, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$cunsafeRangeSize :: (Word8, Word8) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Word8, Word8)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { W8# x#_a2o1p [Occ=Once] ->
                 case _l_a1KRp of { W8# y#_a2o1q [Occ=Once] ->
                 GHC.Types.I#
                   (+# (word2Int# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q))) 1#)
                 }
                 }
                 }}]
GHC.Word.$fIxWord8_$cunsafeRangeSize
  = \ (b_a1KRo :: (Word8, Word8)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { W8# x#_a2o1p ->
      case _l_a1KRp of { W8# y#_a2o1q ->
      GHC.Types.I#
        (+# (word2Int# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q))) 1#)
      }
      }
      }

-- RHS size: {terms: 34, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Word8, Word8) -> Word8 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Word8, Word8))
                 (i_a1KRi :: Word8) ->
                 case b_a1KRh of { (m_a2o0T, n_a2o0U [Occ=Once]) ->
                 case leWord8 m_a2o0T i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leWord8 i_a1KRi n_a2o0U of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { W8# x#_a2o1p [Occ=Once] ->
                         case m_a2o0T of { W8# y#_a2o1q [Occ=Once] ->
                         GHC.Types.I#
                           (word2Int# (narrow8Word# (minusWord# x#_a2o1p y#_a2o1q)))
                         }
                         }
                     }
                 }
                 }}]
GHC.Word.$fIxWord8_$cindex
  = \ (eta_B2 :: (Word8, Word8)) (eta1_B1 :: Word8) ->
      case eta_B2 of { (m_a2o0T, n_a2o0U) ->
      case m_a2o0T of { W8# x_a2o1I ->
      case eta1_B1 of { W8# y_a2o1J ->
      case leWord# x_a2o1I y_a2o1J of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a2o0U of { W8# y1_X2oeD ->
          case leWord# y_a2o1J y1_X2oeD of {
            __DEFAULT -> hopelessIndexError;
            1# ->
              GHC.Types.I#
                (word2Int# (narrow8Word# (minusWord# y_a2o1J x_a2o1I)))
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Word8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Word8
                    GHC.Word.$fOrdWord8
                    GHC.Word.$fIxWord8_$crange
                    GHC.Word.$fIxWord8_$cindex
                    GHC.Word.$fIxWord8_$cunsafeIndex
                    GHC.Word.$fIxWord8_$cinRange
                    GHC.Word.$fIxWord8_$crangeSize
                    GHC.Word.$fIxWord8_$cunsafeRangeSize]
GHC.Word.$fIxWord8
  = GHC.Arr.C:Ix
      @ Word8
      GHC.Word.$fOrdWord8
      GHC.Word.$fIxWord8_$crange
      GHC.Word.$fIxWord8_$cindex
      GHC.Word.$fIxWord8_$cunsafeIndex
      GHC.Word.$fIxWord8_$cinRange
      GHC.Word.$fIxWord8_$crangeSize
      GHC.Word.$fIxWord8_$cunsafeRangeSize

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2plr [Occ=Once!] :: Word16)
                 (ds1_d2pls [Occ=Once!] :: Word16) ->
                 case ds_d2plr of { W16# x_a2o1K [Occ=Once] ->
                 case ds1_d2pls of { W16# y_a2o1L [Occ=Once] ->
                 tagToEnum# @ Bool (eqWord# x_a2o1K y_a2o1L)
                 }
                 }}]
eqWord16
  = \ (ds_d2plr :: Word16) (ds1_d2pls :: Word16) ->
      case ds_d2plr of { W16# x_a2o1K ->
      case ds1_d2pls of { W16# y_a2o1L ->
      tagToEnum# @ Bool (eqWord# x_a2o1K y_a2o1L)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEqWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Word16 eqWord16 neWord16]
GHC.Word.$fEqWord16 = GHC.Classes.C:Eq @ Word16 eqWord16 neWord16

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord1 :: Word16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fNumWord1 = GHC.Word.W16# 1##

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16_$csignum :: Word16 -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pzx [Occ=Once!] :: Word16) ->
                 case ds_d2pzx of { W16# x_a2o1K [Occ=Once!] ->
                 case x_a2o1K of {
                   __DEFAULT -> GHC.Word.$fNumWord1;
                   0## -> GHC.Word.$fBitsWord16_$cminBound
                 }
                 }}]
GHC.Word.$fNumWord16_$csignum
  = \ (ds_d2pzx :: Word16) ->
      case ds_d2pzx of { W16# x_a2o1K ->
      case x_a2o1K of {
        __DEFAULT -> GHC.Word.$fNumWord1;
        0## -> GHC.Word.$fBitsWord16_$cminBound
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Num Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Word16
                     GHC.Word.$fNumWord16_$c+
                     GHC.Word.$fNumWord16_$c-
                     GHC.Word.$fNumWord16_$c*
                     GHC.Word.$fNumWord16_$cnegate
                     GHC.Word.$fNumWord16_$cabs
                     GHC.Word.$fNumWord16_$csignum
                     GHC.Word.$fNumWord16_$cfromInteger]
GHC.Word.$fNumWord16
  = GHC.Num.C:Num
      @ Word16
      GHC.Word.$fNumWord16_$c+
      GHC.Word.$fNumWord16_$c-
      GHC.Word.$fNumWord16_$c*
      GHC.Word.$fNumWord16_$cnegate
      GHC.Word.$fNumWord16_$cabs
      GHC.Word.$fNumWord16_$csignum
      GHC.Word.$fNumWord16_$cfromInteger

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$ccomplement :: Word16 -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pws [Occ=Once!] :: Word16) ->
                 case ds_d2pws of { W16# x#_a2nZo [Occ=Once] ->
                 GHC.Word.W16# (xor# x#_a2nZo 65535##)
                 }}]
GHC.Word.$fBitsWord16_$ccomplement
  = \ (ds_d2pws :: Word16) ->
      case ds_d2pws of { W16# x#_a2nZo ->
      GHC.Word.W16# (xor# x#_a2nZo 65535##)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord2 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord2 = GHC.Base.Just @ Int GHC.Word.$fBitsWord1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cbitSizeMaybe :: Word16 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord2}]
GHC.Word.$fBitsWord16_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord2

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     GHC.Word.W16# (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt));
                   1# -> GHC.Word.W16# 0##
                 }
                 }}]
GHC.Word.$fBitsWord16_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          GHC.Word.W16# (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt));
        1# -> GHC.Word.$fBitsWord16_$cminBound
      }
      }

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Word16 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Word16)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { W16# x#_a2nZi [Occ=Once] ->
                 case i_a1A6i of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     neWord16
                       (GHC.Word.W16#
                          (and# x#_a2nZi (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt))))
                       (GHC.Word.W16# 0##);
                   1# -> neWord16 (GHC.Word.W16# 0##) (GHC.Word.W16# 0##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$ctestBit
  = \ (x_a1A6h :: Word16) (i_a1A6i :: Int) ->
      case x_a1A6h of { W16# x#_a2nZi ->
      case i_a1A6i of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          case and# x#_a2nZi (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt))
          of {
            __DEFAULT -> GHC.Types.True;
            0## -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Word16)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { W16# x#_a2nZA ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 15##)
                 of wild2_X6r {
                   __DEFAULT ->
                     GHC.Word.W16#
                       (narrow16Word#
                          (or#
                             (uncheckedShiftL# x#_a2nZA wild2_X6r)
                             (uncheckedShiftRL# x#_a2nZA (-# 16# wild2_X6r))));
                   0# -> GHC.Word.W16# x#_a2nZA
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$crotateR
  = \ (eta_B2 :: Word16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6f { W16# x#_a2nZA ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 15##)
      of wild2_X6r {
        __DEFAULT ->
          GHC.Word.W16#
            (narrow16Word#
               (or#
                  (uncheckedShiftL# x#_a2nZA wild2_X6r)
                  (uncheckedShiftRL# x#_a2nZA (-# 16# wild2_X6r))));
        0# -> wild_X6f
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Word.$fBitsWord16_$crotate}]
GHC.Word.$fBitsWord16_$crotateL = GHC.Word.$fBitsWord16_$crotate

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Word16)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { W16# x#_a2nZm [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     GHC.Word.W16#
                       (xor# x#_a2nZm (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)));
                   1# -> GHC.Word.W16# x#_a2nZm
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$ccomplementBit
  = \ (eta_B2 :: Word16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6h { W16# x#_a2nZm ->
      case eta1_B1 of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          GHC.Word.W16#
            (xor# x#_a2nZm (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)));
        1# -> wild_X6h
      }
      }
      }

-- RHS size: {terms: 27, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Word16)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { W16# x#_a2nZi [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     GHC.Word.W16#
                       (and#
                          x#_a2nZi
                          (xor# (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)) 65535##));
                   1# -> GHC.Word.W16# (and# x#_a2nZi 65535##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$cclearBit
  = \ (eta_B2 :: Word16) (eta1_B1 :: Int) ->
      case eta_B2 of { W16# x#_a2nZi ->
      case eta1_B1 of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          GHC.Word.W16#
            (and#
               x#_a2nZi
               (xor# (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)) 65535##));
        1# -> GHC.Word.W16# (and# x#_a2nZi 65535##)
      }
      }
      }

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Word16 -> Int -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Word16)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { W16# x#_a2nZk [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a2nZt ->
                 case >=# i#_a2nZt 64# of {
                   __DEFAULT ->
                     GHC.Word.W16#
                       (or# x#_a2nZk (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)));
                   1# -> GHC.Word.W16# x#_a2nZk
                 }
                 }
                 }}]
GHC.Word.$fBitsWord16_$csetBit
  = \ (eta_B2 :: Word16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6i { W16# x#_a2nZk ->
      case eta1_B1 of { I# i#_a2nZt ->
      case >=# i#_a2nZt 64# of {
        __DEFAULT ->
          GHC.Word.W16#
            (or# x#_a2nZk (narrow16Word# (uncheckedShiftL# 1## i#_a2nZt)));
        1# -> wild_X6i
      }
      }
      }

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Word16
                        GHC.Word.$fEqWord16
                        GHC.Word.$fBitsWord16_$c.&.
                        GHC.Word.$fBitsWord16_$c.|.
                        GHC.Word.$fBitsWord16_$cxor
                        GHC.Word.$fBitsWord16_$ccomplement
                        GHC.Word.$fBitsWord16_$cshift
                        GHC.Word.$fBitsWord16_$crotate
                        GHC.Word.$fBitsWord16_$cminBound
                        GHC.Word.$fBitsWord16_$cbit
                        GHC.Word.$fBitsWord16_$csetBit
                        GHC.Word.$fBitsWord16_$cclearBit
                        GHC.Word.$fBitsWord16_$ccomplementBit
                        GHC.Word.$fBitsWord16_$ctestBit
                        GHC.Word.$fBitsWord16_$cbitSizeMaybe
                        GHC.Word.$fBitsWord16_$cfiniteBitSize
                        GHC.Word.$fBitsWord16_$cisSigned
                        GHC.Word.$fBitsWord16_$cshiftL
                        GHC.Word.$fBitsWord16_$cunsafeShiftL
                        GHC.Word.$fBitsWord16_$cshiftR
                        GHC.Word.$fBitsWord16_$cunsafeShiftR
                        GHC.Word.$fBitsWord16_$crotateL
                        GHC.Word.$fBitsWord16_$crotateR
                        GHC.Word.$fBitsWord16_$cpopCount]
GHC.Word.$fBitsWord16
  = Data.Bits.C:Bits
      @ Word16
      GHC.Word.$fEqWord16
      GHC.Word.$fBitsWord16_$c.&.
      GHC.Word.$fBitsWord16_$c.|.
      GHC.Word.$fBitsWord16_$cxor
      GHC.Word.$fBitsWord16_$ccomplement
      GHC.Word.$fBitsWord16_$cshift
      GHC.Word.$fBitsWord16_$crotate
      GHC.Word.$fBitsWord16_$cminBound
      GHC.Word.$fBitsWord16_$cbit
      GHC.Word.$fBitsWord16_$csetBit
      GHC.Word.$fBitsWord16_$cclearBit
      GHC.Word.$fBitsWord16_$ccomplementBit
      GHC.Word.$fBitsWord16_$ctestBit
      GHC.Word.$fBitsWord16_$cbitSizeMaybe
      GHC.Word.$fBitsWord16_$cfiniteBitSize
      GHC.Word.$fBitsWord16_$cisSigned
      GHC.Word.$fBitsWord16_$cshiftL
      GHC.Word.$fBitsWord16_$cunsafeShiftL
      GHC.Word.$fBitsWord16_$cshiftR
      GHC.Word.$fBitsWord16_$cunsafeShiftR
      GHC.Word.$fBitsWord16_$crotateL
      GHC.Word.$fBitsWord16_$crotateR
      GHC.Word.$fBitsWord16_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Word16
                              GHC.Word.$fBitsWord16
                              GHC.Word.$fBitsWord16_$cfiniteBitSize
                              GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros
                              GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros]
GHC.Word.$fFiniteBitsWord16
  = Data.Bits.C:FiniteBits
      @ Word16
      GHC.Word.$fBitsWord16
      GHC.Word.$fBitsWord16_$cfiniteBitSize
      GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros
      GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord16_$cquot :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxN [Occ=Once!] :: Word16)
                 (y_a2nZO [Occ=Once!] :: Word16) ->
                 case ds_d2pxN of { W16# x#_a2nZN [Occ=Once] ->
                 case y_a2nZO of { W16# y#_a2nZP [Occ=Once!] ->
                 case y#_a2nZP of wild2_Xdc {
                   __DEFAULT ->
                     case quotWord# x#_a2nZN wild2_Xdc of wild3_X2R { __DEFAULT ->
                     GHC.Word.W16# wild3_X2R
                     };
                   0## -> divZeroError @ Word16
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord16_$cquot
  = \ (ds_d2pxN :: Word16) (y_a2nZO :: Word16) ->
      case ds_d2pxN of { W16# x#_a2nZN ->
      case y_a2nZO of { W16# y#_a2nZP ->
      case y#_a2nZP of wild2_Xdc {
        __DEFAULT ->
          case quotWord# x#_a2nZN wild2_Xdc of wild3_X2R { __DEFAULT ->
          GHC.Word.W16# wild3_X2R
          };
        0## -> divZeroError @ Word16
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord16_$crem :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxW [Occ=Once!] :: Word16)
                 (y_a2nZR [Occ=Once!] :: Word16) ->
                 case ds_d2pxW of { W16# x#_a2nZQ [Occ=Once] ->
                 case y_a2nZR of { W16# y#_a2nZS [Occ=Once!] ->
                 case y#_a2nZS of wild2_Xde {
                   __DEFAULT ->
                     case remWord# x#_a2nZQ wild2_Xde of wild3_X2S { __DEFAULT ->
                     GHC.Word.W16# wild3_X2S
                     };
                   0## -> divZeroError @ Word16
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord16_$crem
  = \ (ds_d2pxW :: Word16) (y_a2nZR :: Word16) ->
      case ds_d2pxW of { W16# x#_a2nZQ ->
      case y_a2nZR of { W16# y#_a2nZS ->
      case y#_a2nZS of wild2_Xde {
        __DEFAULT ->
          case remWord# x#_a2nZQ wild2_Xde of wild3_X2S { __DEFAULT ->
          GHC.Word.W16# wild3_X2S
          };
        0## -> divZeroError @ Word16
      }
      }
      }

-- RHS size: {terms: 23, types: 19, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord16_$cquotRem
  :: Word16 -> Word16 -> (Word16, Word16)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pyn [Occ=Once!] :: Word16)
                 (y_a2o00 [Occ=Once!] :: Word16) ->
                 case ds_d2pyn of { W16# x#_a2nZZ [Occ=Once] ->
                 case y_a2o00 of { W16# y#_a2o01 [Occ=Once!] ->
                 case y#_a2o01 of wild2_Xdk {
                   __DEFAULT ->
                     case quotRemWord# x#_a2nZZ wild2_Xdk of
                     { (# ipv_s2pLs [Occ=Once], ipv1_s2pLt [Occ=Once] #) ->
                     (GHC.Word.W16# ipv_s2pLs, GHC.Word.W16# ipv1_s2pLt)
                     };
                   0## -> divZeroError @ (Word16, Word16)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord16_$cquotRem
  = \ (ds_d2pyn :: Word16) (y_a2o00 :: Word16) ->
      case ds_d2pyn of { W16# x#_a2nZZ ->
      case y_a2o00 of { W16# y#_a2o01 ->
      case y#_a2o01 of wild2_Xdk {
        __DEFAULT ->
          case quotRemWord# x#_a2nZZ wild2_Xdk of
          { (# ipv_s2pLs, ipv1_s2pLt #) ->
          (GHC.Word.W16# ipv_s2pLs, GHC.Word.W16# ipv1_s2pLt)
          };
        0## -> divZeroError @ (Word16, Word16)
      }
      }
      }

-- RHS size: {terms: 28, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord16_$cdivMod
  :: Word16 -> Word16 -> (Word16, Word16)
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pyB [Occ=Once!] :: Word16)
                 (y_a2o05 [Occ=Once!] :: Word16) ->
                 case ds_d2pyB of { W16# x#_a2o04 ->
                 case y_a2o05 of { W16# y#_a2o06 [Occ=Once!] ->
                 case y#_a2o06 of wild2_Xdm {
                   __DEFAULT ->
                     (case quotWord# x#_a2o04 wild2_Xdm of wild3_X2W { __DEFAULT ->
                      GHC.Word.W16# wild3_X2W
                      },
                      case remWord# x#_a2o04 wild2_Xdm of wild3_X2W { __DEFAULT ->
                      GHC.Word.W16# wild3_X2W
                      });
                   0## -> divZeroError @ (Word16, Word16)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord16_$cdivMod
  = \ (ds_d2pyB :: Word16) (y_a2o05 :: Word16) ->
      case ds_d2pyB of { W16# x#_a2o04 ->
      case y_a2o05 of { W16# y#_a2o06 ->
      case y#_a2o06 of wild2_Xdm {
        __DEFAULT ->
          (case quotWord# x#_a2o04 wild2_Xdm of wild3_X2W { __DEFAULT ->
           GHC.Word.W16# wild3_X2W
           },
           case remWord# x#_a2o04 wild2_Xdm of wild3_X2W { __DEFAULT ->
           GHC.Word.W16# wild3_X2W
           });
        0## -> divZeroError @ (Word16, Word16)
      }
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pld [Occ=Once!] :: Word16)
                 (ds1_d2ple [Occ=Once!] :: Word16) ->
                 case ds_d2pld of { W16# x_a2o1O [Occ=Once] ->
                 case ds1_d2ple of { W16# y_a2o1P [Occ=Once] ->
                 tagToEnum# @ Bool (gtWord# x_a2o1O y_a2o1P)
                 }
                 }}]
gtWord16
  = \ (ds_d2pld :: Word16) (ds1_d2ple :: Word16) ->
      case ds_d2pld of { W16# x_a2o1O ->
      case ds1_d2ple of { W16# y_a2o1P ->
      tagToEnum# @ Bool (gtWord# x_a2o1O y_a2o1P)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pl6 [Occ=Once!] :: Word16)
                 (ds1_d2pl7 [Occ=Once!] :: Word16) ->
                 case ds_d2pl6 of { W16# x_a2o1Q [Occ=Once] ->
                 case ds1_d2pl7 of { W16# y_a2o1R [Occ=Once] ->
                 tagToEnum# @ Bool (geWord# x_a2o1Q y_a2o1R)
                 }
                 }}]
geWord16
  = \ (ds_d2pl6 :: Word16) (ds1_d2pl7 :: Word16) ->
      case ds_d2pl6 of { W16# x_a2o1Q ->
      case ds1_d2pl7 of { W16# y_a2o1R ->
      tagToEnum# @ Bool (geWord# x_a2o1Q y_a2o1R)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkZ [Occ=Once!] :: Word16)
                 (ds1_d2pl0 [Occ=Once!] :: Word16) ->
                 case ds_d2pkZ of { W16# x_a2o1S [Occ=Once] ->
                 case ds1_d2pl0 of { W16# y_a2o1T [Occ=Once] ->
                 tagToEnum# @ Bool (ltWord# x_a2o1S y_a2o1T)
                 }
                 }}]
ltWord16
  = \ (ds_d2pkZ :: Word16) (ds1_d2pl0 :: Word16) ->
      case ds_d2pkZ of { W16# x_a2o1S ->
      case ds1_d2pl0 of { W16# y_a2o1T ->
      tagToEnum# @ Bool (ltWord# x_a2o1S y_a2o1T)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leWord16 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word16 -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkS [Occ=Once!] :: Word16)
                 (ds1_d2pkT [Occ=Once!] :: Word16) ->
                 case ds_d2pkS of { W16# x_a2o1U [Occ=Once] ->
                 case ds1_d2pkT of { W16# y_a2o1V [Occ=Once] ->
                 tagToEnum# @ Bool (leWord# x_a2o1U y_a2o1V)
                 }
                 }}]
leWord16
  = \ (ds_d2pkS :: Word16) (ds1_d2pkT :: Word16) ->
      case ds_d2pkS of { W16# x_a2o1U ->
      case ds1_d2pkT of { W16# y_a2o1V ->
      tagToEnum# @ Bool (leWord# x_a2o1U y_a2o1V)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord16_$ccompare :: Word16 -> Word16 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Word16)
                 (y_a1fi3 [Occ=Once!] :: Word16) ->
                 case x_a1fi2 of { W16# x1_a2o1K ->
                 case y_a1fi3 of { W16# y1_a2o1L ->
                 case eqWord# x1_a2o1K y1_a2o1L of {
                   __DEFAULT ->
                     case leWord# x1_a2o1K y1_a2o1L of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Word.$fOrdWord16_$ccompare
  = \ (x_a1fi2 :: Word16) (y_a1fi3 :: Word16) ->
      case x_a1fi2 of { W16# x1_a2o1K ->
      case y_a1fi3 of { W16# y1_a2o1L ->
      case eqWord# x1_a2o1K y1_a2o1L of {
        __DEFAULT ->
          case leWord# x1_a2o1K y1_a2o1L of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord16_$cmax :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Word16)
                 (y_a55e [Occ=Once!] :: Word16) ->
                 case x_a55d of wild_X8y { W16# x1_a2o1U [Occ=Once] ->
                 case y_a55e of wild1_X5 { W16# y1_a2o1V [Occ=Once] ->
                 case leWord# x1_a2o1U y1_a2o1V of {
                   __DEFAULT -> wild_X8y;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Word.$fOrdWord16_$cmax
  = \ (x_a55d :: Word16) (y_a55e :: Word16) ->
      case x_a55d of wild_X8y { W16# x1_a2o1U ->
      case y_a55e of wild1_X5 { W16# y1_a2o1V ->
      case leWord# x1_a2o1U y1_a2o1V of {
        __DEFAULT -> wild_X8y;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord16_$cmin :: Word16 -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Word16)
                 (y_a55n [Occ=Once!] :: Word16) ->
                 case x_a55m of wild_X8y { W16# x1_a2o1U [Occ=Once] ->
                 case y_a55n of wild1_X5 { W16# y1_a2o1V [Occ=Once] ->
                 case leWord# x1_a2o1U y1_a2o1V of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X8y
                 }
                 }
                 }}]
GHC.Word.$fOrdWord16_$cmin
  = \ (x_a55m :: Word16) (y_a55n :: Word16) ->
      case x_a55m of wild_X8y { W16# x1_a2o1U ->
      case y_a55n of wild1_X5 { W16# y1_a2o1V ->
      case leWord# x1_a2o1U y1_a2o1V of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X8y
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Word16
                         GHC.Word.$fEqWord16
                         GHC.Word.$fOrdWord16_$ccompare
                         ltWord16
                         leWord16
                         gtWord16
                         geWord16
                         GHC.Word.$fOrdWord16_$cmax
                         GHC.Word.$fOrdWord16_$cmin]
GHC.Word.$fOrdWord16
  = GHC.Classes.C:Ord
      @ Word16
      GHC.Word.$fEqWord16
      GHC.Word.$fOrdWord16_$ccompare
      ltWord16
      leWord16
      gtWord16
      geWord16
      GHC.Word.$fOrdWord16_$cmax
      GHC.Word.$fOrdWord16_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$cinRange :: (Word16, Word16) -> Word16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxG [Occ=Once!] :: (Word16, Word16))
                 (i_a2nZM [Occ=Once!] :: Word16) ->
                 case ds_d2pxG of { (m_a2nZK [Occ=Once!], n_a2nZL [Occ=Once!]) ->
                 case m_a2nZK of { W16# x_a2o1U [Occ=Once] ->
                 case i_a2nZM of { W16# y_a2o1V ->
                 case leWord# x_a2o1U y_a2o1V of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a2nZL of { W16# y1_X2ofz [Occ=Once] ->
                     tagToEnum# @ Bool (leWord# y_a2o1V y1_X2ofz)
                     }
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord16_$cinRange
  = \ (ds_d2pxG :: (Word16, Word16)) (i_a2nZM :: Word16) ->
      case ds_d2pxG of { (m_a2nZK, n_a2nZL) ->
      case m_a2nZK of { W16# x_a2o1U ->
      case i_a2nZM of { W16# y_a2o1V ->
      case leWord# x_a2o1U y_a2o1V of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a2nZL of { W16# y1_X2ofz ->
          tagToEnum# @ Bool (leWord# y_a2o1V y1_X2ofz)
          }
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord16_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word16 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sSH [Occ=Once!] :: Word16) ->
                 case w_s2sSH of { W16# ww1_s2sSK [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger
                           (smallInteger (word2Int# ww1_s2sSK)) GHC.Word.$fRealWord1)
                        GHC.Word.$fRealWord1
                 of
                 { (# ww3_s2sTh [Occ=Once], ww4_s2sTi [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2sTh ww4_s2sTi
                 }
                 }}]
GHC.Word.$fRealWord16_$ctoRational
  = \ (w_s2sSH :: Word16) ->
      case w_s2sSH of { W16# ww1_s2sSK ->
      case GHC.Real.$w$sreduce
             (timesInteger
                (smallInteger (word2Int# ww1_s2sSK)) GHC.Word.$fRealWord1)
             GHC.Word.$fRealWord1
      of
      { (# ww3_s2sTh, ww4_s2sTi #) ->
      GHC.Real.:% @ Integer ww3_s2sTh ww4_s2sTi
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Real Word16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Word16
                       GHC.Word.$fNumWord16
                       GHC.Word.$fOrdWord16
                       GHC.Word.$fRealWord16_$ctoRational]
GHC.Word.$fRealWord16
  = GHC.Real.C:Real
      @ Word16
      GHC.Word.$fNumWord16
      GHC.Word.$fOrdWord16
      GHC.Word.$fRealWord16_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Word16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Word16
                           GHC.Word.$fRealWord16
                           GHC.Word.$fEnumWord16
                           GHC.Word.$fIntegralWord16_$cquot
                           GHC.Word.$fIntegralWord16_$crem
                           GHC.Word.$fIntegralWord16_$cquot
                           GHC.Word.$fIntegralWord16_$crem
                           GHC.Word.$fIntegralWord16_$cquotRem
                           GHC.Word.$fIntegralWord16_$cdivMod
                           GHC.Word.$ctoInteger1]
GHC.Word.$fIntegralWord16
  = GHC.Real.C:Integral
      @ Word16
      GHC.Word.$fRealWord16
      GHC.Word.$fEnumWord16
      GHC.Word.$fIntegralWord16_$cquot
      GHC.Word.$fIntegralWord16_$crem
      GHC.Word.$fIntegralWord16_$cquot
      GHC.Word.$fIntegralWord16_$crem
      GHC.Word.$fIntegralWord16_$cquotRem
      GHC.Word.$fIntegralWord16_$cdivMod
      GHC.Word.$ctoInteger1

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$cunsafeIndex
  :: (Word16, Word16) -> Word16 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxz [Occ=Once!] :: (Word16, Word16))
                 (i_a2nZJ [Occ=Once!] :: Word16) ->
                 case ds_d2pxz of { (m_a2nZI [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a2nZJ of { W16# x#_a2o0g [Occ=Once] ->
                 case m_a2nZI of { W16# y#_a2o0h [Occ=Once] ->
                 GHC.Types.I#
                   (word2Int# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h)))
                 }
                 }
                 }}]
GHC.Word.$fIxWord16_$cunsafeIndex
  = \ (ds_d2pxz :: (Word16, Word16)) (i_a2nZJ :: Word16) ->
      case ds_d2pxz of { (m_a2nZI, ds1_d2pxF) ->
      case i_a2nZJ of { W16# x#_a2o0g ->
      case m_a2nZI of { W16# y#_a2o0h ->
      GHC.Types.I#
        (word2Int# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h)))
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$crange :: (Word16, Word16) -> [Word16]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pxu [Occ=Once!] :: (Word16, Word16)) ->
                 case ds_d2pxu of { (m_a2nZG [Occ=Once], n_a2nZH [Occ=Once]) ->
                 GHC.Word.$fEnumWord16_$cenumFromTo m_a2nZG n_a2nZH
                 }}]
GHC.Word.$fIxWord16_$crange
  = \ (ds_d2pxu :: (Word16, Word16)) ->
      case ds_d2pxu of { (m_a2nZG, n_a2nZH) ->
      GHC.Word.$fEnumWord16_$cenumFromTo m_a2nZG n_a2nZH
      }

-- RHS size: {terms: 25, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$crangeSize :: (Word16, Word16) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Word16, Word16)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { W16# x_a2o1U ->
                 case h_a1KRn of { W16# y_a2o1V ->
                 case leWord# x_a2o1U y_a2o1V of {
                   __DEFAULT -> GHC.Word.$fIxWord1;
                   1# ->
                     GHC.Types.I#
                       (+# (word2Int# (narrow16Word# (minusWord# y_a2o1V x_a2o1U))) 1#)
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord16_$crangeSize
  = \ (b_a1KRl :: (Word16, Word16)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { W16# x_a2o1U ->
      case h_a1KRn of { W16# y_a2o1V ->
      case leWord# x_a2o1U y_a2o1V of {
        __DEFAULT -> GHC.Word.$fIxWord1;
        1# ->
          GHC.Types.I#
            (+# (word2Int# (narrow16Word# (minusWord# y_a2o1V x_a2o1U))) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 12, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$cunsafeRangeSize :: (Word16, Word16) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Word16, Word16)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { W16# x#_a2o0g [Occ=Once] ->
                 case _l_a1KRp of { W16# y#_a2o0h [Occ=Once] ->
                 GHC.Types.I#
                   (+# (word2Int# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h))) 1#)
                 }
                 }
                 }}]
GHC.Word.$fIxWord16_$cunsafeRangeSize
  = \ (b_a1KRo :: (Word16, Word16)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { W16# x#_a2o0g ->
      case _l_a1KRp of { W16# y#_a2o0h ->
      GHC.Types.I#
        (+# (word2Int# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h))) 1#)
      }
      }
      }

-- RHS size: {terms: 34, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Word16, Word16) -> Word16 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Word16, Word16))
                 (i_a1KRi :: Word16) ->
                 case b_a1KRh of { (m_a2nZK, n_a2nZL [Occ=Once]) ->
                 case leWord16 m_a2nZK i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leWord16 i_a1KRi n_a2nZL of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { W16# x#_a2o0g [Occ=Once] ->
                         case m_a2nZK of { W16# y#_a2o0h [Occ=Once] ->
                         GHC.Types.I#
                           (word2Int# (narrow16Word# (minusWord# x#_a2o0g y#_a2o0h)))
                         }
                         }
                     }
                 }
                 }}]
GHC.Word.$fIxWord16_$cindex
  = \ (eta_B2 :: (Word16, Word16)) (eta1_B1 :: Word16) ->
      case eta_B2 of { (m_a2nZK, n_a2nZL) ->
      case m_a2nZK of { W16# x_a2o1U ->
      case eta1_B1 of { W16# y_a2o1V ->
      case leWord# x_a2o1U y_a2o1V of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a2nZL of { W16# y1_X2ofJ ->
          case leWord# y_a2o1V y1_X2ofJ of {
            __DEFAULT -> hopelessIndexError;
            1# ->
              GHC.Types.I#
                (word2Int# (narrow16Word# (minusWord# y_a2o1V x_a2o1U)))
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord16 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Word16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Word16
                    GHC.Word.$fOrdWord16
                    GHC.Word.$fIxWord16_$crange
                    GHC.Word.$fIxWord16_$cindex
                    GHC.Word.$fIxWord16_$cunsafeIndex
                    GHC.Word.$fIxWord16_$cinRange
                    GHC.Word.$fIxWord16_$crangeSize
                    GHC.Word.$fIxWord16_$cunsafeRangeSize]
GHC.Word.$fIxWord16
  = GHC.Arr.C:Ix
      @ Word16
      GHC.Word.$fOrdWord16
      GHC.Word.$fIxWord16_$crange
      GHC.Word.$fIxWord16_$cindex
      GHC.Word.$fIxWord16_$cunsafeIndex
      GHC.Word.$fIxWord16_$cinRange
      GHC.Word.$fIxWord16_$crangeSize
      GHC.Word.$fIxWord16_$cunsafeRangeSize

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
byteSwap16 :: Word16 -> Word16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pkO [Occ=Once!] :: Word16) ->
                 case ds_d2pkO of { W16# w#_a2o1W [Occ=Once] ->
                 GHC.Word.W16# (narrow16Word# (byteSwap16# w#_a2o1W))
                 }}]
byteSwap16
  = \ (ds_d2pkO :: Word16) ->
      case ds_d2pkO of { W16# w#_a2o1W ->
      GHC.Word.W16# (narrow16Word# (byteSwap16# w#_a2o1W))
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkH [Occ=Once!] :: Word32)
                 (ds1_d2pkI [Occ=Once!] :: Word32) ->
                 case ds_d2pkH of { W32# x_a2o1X [Occ=Once] ->
                 case ds1_d2pkI of { W32# y_a2o1Y [Occ=Once] ->
                 tagToEnum# @ Bool (eqWord# x_a2o1X y_a2o1Y)
                 }
                 }}]
eqWord32
  = \ (ds_d2pkH :: Word32) (ds1_d2pkI :: Word32) ->
      case ds_d2pkH of { W32# x_a2o1X ->
      case ds1_d2pkI of { W32# y_a2o1Y ->
      tagToEnum# @ Bool (eqWord# x_a2o1X y_a2o1Y)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fEqWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Word32 eqWord32 neWord32]
GHC.Word.$fEqWord32 = GHC.Classes.C:Eq @ Word32 eqWord32 neWord32

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord2 :: Word32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fNumWord2 = GHC.Word.W32# 1##

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32_$csignum :: Word32 -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pvK [Occ=Once!] :: Word32) ->
                 case ds_d2pvK of { W32# x_a2o1X [Occ=Once!] ->
                 case x_a2o1X of {
                   __DEFAULT -> GHC.Word.$fNumWord2;
                   0## -> GHC.Word.$fBitsWord32_$cminBound
                 }
                 }}]
GHC.Word.$fNumWord32_$csignum
  = \ (ds_d2pvK :: Word32) ->
      case ds_d2pvK of { W32# x_a2o1X ->
      case x_a2o1X of {
        __DEFAULT -> GHC.Word.$fNumWord2;
        0## -> GHC.Word.$fBitsWord32_$cminBound
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fNumWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Num Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Word32
                     GHC.Word.$fNumWord32_$c+
                     GHC.Word.$fNumWord32_$c-
                     GHC.Word.$fNumWord32_$c*
                     GHC.Word.$fNumWord32_$cnegate
                     GHC.Word.$fNumWord32_$cabs
                     GHC.Word.$fNumWord32_$csignum
                     GHC.Word.$fNumWord32_$cfromInteger]
GHC.Word.$fNumWord32
  = GHC.Num.C:Num
      @ Word32
      GHC.Word.$fNumWord32_$c+
      GHC.Word.$fNumWord32_$c-
      GHC.Word.$fNumWord32_$c*
      GHC.Word.$fNumWord32_$cnegate
      GHC.Word.$fNumWord32_$cabs
      GHC.Word.$fNumWord32_$csignum
      GHC.Word.$fNumWord32_$cfromInteger

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$ccomplement :: Word32 -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ps9 [Occ=Once!] :: Word32) ->
                 case ds_d2ps9 of { W32# x#_a2nYp [Occ=Once] ->
                 GHC.Word.W32# (xor# x#_a2nYp 4294967295##)
                 }}]
GHC.Word.$fBitsWord32_$ccomplement
  = \ (ds_d2ps9 :: Word32) ->
      case ds_d2ps9 of { W32# x#_a2nYp ->
      GHC.Word.W32# (xor# x#_a2nYp 4294967295##)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord4 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord4 = GHC.Base.Just @ Int GHC.Word.$fBitsWord3

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cbitSizeMaybe :: Word32 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord4}]
GHC.Word.$fBitsWord32_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord4

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     GHC.Word.W32# (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu));
                   1# -> GHC.Word.W32# 0##
                 }
                 }}]
GHC.Word.$fBitsWord32_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          GHC.Word.W32# (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu));
        1# -> GHC.Word.$fBitsWord32_$cminBound
      }
      }

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Word32 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Word32)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { W32# x#_a2nYj [Occ=Once] ->
                 case i_a1A6i of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     neWord32
                       (GHC.Word.W32#
                          (and# x#_a2nYj (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu))))
                       (GHC.Word.W32# 0##);
                   1# -> neWord32 (GHC.Word.W32# 0##) (GHC.Word.W32# 0##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$ctestBit
  = \ (x_a1A6h :: Word32) (i_a1A6i :: Int) ->
      case x_a1A6h of { W32# x#_a2nYj ->
      case i_a1A6i of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          case and# x#_a2nYj (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu))
          of {
            __DEFAULT -> GHC.Types.True;
            0## -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Word32)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { W32# x#_a2nYB ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 31##)
                 of wild2_X6N {
                   __DEFAULT ->
                     GHC.Word.W32#
                       (narrow32Word#
                          (or#
                             (uncheckedShiftL# x#_a2nYB wild2_X6N)
                             (uncheckedShiftRL# x#_a2nYB (-# 32# wild2_X6N))));
                   0# -> GHC.Word.W32# x#_a2nYB
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$crotateR
  = \ (eta_B2 :: Word32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6B { W32# x#_a2nYB ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 31##)
      of wild2_X6N {
        __DEFAULT ->
          GHC.Word.W32#
            (narrow32Word#
               (or#
                  (uncheckedShiftL# x#_a2nYB wild2_X6N)
                  (uncheckedShiftRL# x#_a2nYB (-# 32# wild2_X6N))));
        0# -> wild_X6B
      }
      }
      }

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Word32)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { W32# x#_a2nYn [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     GHC.Word.W32#
                       (xor# x#_a2nYn (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)));
                   1# -> GHC.Word.W32# x#_a2nYn
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$ccomplementBit
  = \ (eta_B2 :: Word32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6D { W32# x#_a2nYn ->
      case eta1_B1 of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          GHC.Word.W32#
            (xor# x#_a2nYn (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)));
        1# -> wild_X6D
      }
      }
      }

-- RHS size: {terms: 27, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Word32)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { W32# x#_a2nYj [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     GHC.Word.W32#
                       (and#
                          x#_a2nYj
                          (xor#
                             (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)) 4294967295##));
                   1# -> GHC.Word.W32# (and# x#_a2nYj 4294967295##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$cclearBit
  = \ (eta_B2 :: Word32) (eta1_B1 :: Int) ->
      case eta_B2 of { W32# x#_a2nYj ->
      case eta1_B1 of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          GHC.Word.W32#
            (and#
               x#_a2nYj
               (xor#
                  (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)) 4294967295##));
        1# -> GHC.Word.W32# (and# x#_a2nYj 4294967295##)
      }
      }
      }

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Word32)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { W32# x#_a2nYl [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a2nYu ->
                 case >=# i#_a2nYu 64# of {
                   __DEFAULT ->
                     GHC.Word.W32#
                       (or# x#_a2nYl (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)));
                   1# -> GHC.Word.W32# x#_a2nYl
                 }
                 }
                 }}]
GHC.Word.$fBitsWord32_$csetBit
  = \ (eta_B2 :: Word32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6E { W32# x#_a2nYl ->
      case eta1_B1 of { I# i#_a2nYu ->
      case >=# i#_a2nYu 64# of {
        __DEFAULT ->
          GHC.Word.W32#
            (or# x#_a2nYl (narrow32Word# (uncheckedShiftL# 1## i#_a2nYu)));
        1# -> wild_X6E
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Word32 -> Int -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Word.$fBitsWord32_$crotate}]
GHC.Word.$fBitsWord32_$crotateL = GHC.Word.$fBitsWord32_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Word32
                        GHC.Word.$fEqWord32
                        GHC.Word.$fBitsWord32_$c.&.
                        GHC.Word.$fBitsWord32_$c.|.
                        GHC.Word.$fBitsWord32_$cxor
                        GHC.Word.$fBitsWord32_$ccomplement
                        GHC.Word.$fBitsWord32_$cshift
                        GHC.Word.$fBitsWord32_$crotate
                        GHC.Word.$fBitsWord32_$cminBound
                        GHC.Word.$fBitsWord32_$cbit
                        GHC.Word.$fBitsWord32_$csetBit
                        GHC.Word.$fBitsWord32_$cclearBit
                        GHC.Word.$fBitsWord32_$ccomplementBit
                        GHC.Word.$fBitsWord32_$ctestBit
                        GHC.Word.$fBitsWord32_$cbitSizeMaybe
                        GHC.Word.$fBitsWord32_$cfiniteBitSize
                        GHC.Word.$fBitsWord32_$cisSigned
                        GHC.Word.$fBitsWord32_$cshiftL
                        GHC.Word.$fBitsWord32_$cunsafeShiftL
                        GHC.Word.$fBitsWord32_$cshiftR
                        GHC.Word.$fBitsWord32_$cunsafeShiftR
                        GHC.Word.$fBitsWord32_$crotateL
                        GHC.Word.$fBitsWord32_$crotateR
                        GHC.Word.$fBitsWord32_$cpopCount]
GHC.Word.$fBitsWord32
  = Data.Bits.C:Bits
      @ Word32
      GHC.Word.$fEqWord32
      GHC.Word.$fBitsWord32_$c.&.
      GHC.Word.$fBitsWord32_$c.|.
      GHC.Word.$fBitsWord32_$cxor
      GHC.Word.$fBitsWord32_$ccomplement
      GHC.Word.$fBitsWord32_$cshift
      GHC.Word.$fBitsWord32_$crotate
      GHC.Word.$fBitsWord32_$cminBound
      GHC.Word.$fBitsWord32_$cbit
      GHC.Word.$fBitsWord32_$csetBit
      GHC.Word.$fBitsWord32_$cclearBit
      GHC.Word.$fBitsWord32_$ccomplementBit
      GHC.Word.$fBitsWord32_$ctestBit
      GHC.Word.$fBitsWord32_$cbitSizeMaybe
      GHC.Word.$fBitsWord32_$cfiniteBitSize
      GHC.Word.$fBitsWord32_$cisSigned
      GHC.Word.$fBitsWord32_$cshiftL
      GHC.Word.$fBitsWord32_$cunsafeShiftL
      GHC.Word.$fBitsWord32_$cshiftR
      GHC.Word.$fBitsWord32_$cunsafeShiftR
      GHC.Word.$fBitsWord32_$crotateL
      GHC.Word.$fBitsWord32_$crotateR
      GHC.Word.$fBitsWord32_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Word32
                              GHC.Word.$fBitsWord32
                              GHC.Word.$fBitsWord32_$cfiniteBitSize
                              GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros
                              GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros]
GHC.Word.$fFiniteBitsWord32
  = Data.Bits.C:FiniteBits
      @ Word32
      GHC.Word.$fBitsWord32
      GHC.Word.$fBitsWord32_$cfiniteBitSize
      GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros
      GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord32_$cquot :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ptb [Occ=Once!] :: Word32)
                 (y_a2nYI [Occ=Once!] :: Word32) ->
                 case ds_d2ptb of { W32# x#_a2nYH [Occ=Once] ->
                 case y_a2nYI of { W32# y#_a2nYJ [Occ=Once!] ->
                 case y#_a2nYJ of wild2_Xe7 {
                   __DEFAULT ->
                     case quotWord# x#_a2nYH wild2_Xe7 of wild3_X3Q { __DEFAULT ->
                     GHC.Word.W32# wild3_X3Q
                     };
                   0## -> divZeroError @ Word32
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord32_$cquot
  = \ (ds_d2ptb :: Word32) (y_a2nYI :: Word32) ->
      case ds_d2ptb of { W32# x#_a2nYH ->
      case y_a2nYI of { W32# y#_a2nYJ ->
      case y#_a2nYJ of wild2_Xe7 {
        __DEFAULT ->
          case quotWord# x#_a2nYH wild2_Xe7 of wild3_X3Q { __DEFAULT ->
          GHC.Word.W32# wild3_X3Q
          };
        0## -> divZeroError @ Word32
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord32_$crem :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ptk [Occ=Once!] :: Word32)
                 (y_a2nYL [Occ=Once!] :: Word32) ->
                 case ds_d2ptk of { W32# x#_a2nYK [Occ=Once] ->
                 case y_a2nYL of { W32# y#_a2nYM [Occ=Once!] ->
                 case y#_a2nYM of wild2_Xe9 {
                   __DEFAULT ->
                     case remWord# x#_a2nYK wild2_Xe9 of wild3_X3R { __DEFAULT ->
                     GHC.Word.W32# wild3_X3R
                     };
                   0## -> divZeroError @ Word32
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord32_$crem
  = \ (ds_d2ptk :: Word32) (y_a2nYL :: Word32) ->
      case ds_d2ptk of { W32# x#_a2nYK ->
      case y_a2nYL of { W32# y#_a2nYM ->
      case y#_a2nYM of wild2_Xe9 {
        __DEFAULT ->
          case remWord# x#_a2nYK wild2_Xe9 of wild3_X3R { __DEFAULT ->
          GHC.Word.W32# wild3_X3R
          };
        0## -> divZeroError @ Word32
      }
      }
      }

-- RHS size: {terms: 23, types: 19, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord32_$cquotRem
  :: Word32 -> Word32 -> (Word32, Word32)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ptL [Occ=Once!] :: Word32)
                 (y_a2nYU [Occ=Once!] :: Word32) ->
                 case ds_d2ptL of { W32# x#_a2nYT [Occ=Once] ->
                 case y_a2nYU of { W32# y#_a2nYV [Occ=Once!] ->
                 case y#_a2nYV of wild2_Xef {
                   __DEFAULT ->
                     case quotRemWord# x#_a2nYT wild2_Xef of
                     { (# ipv_s2pNx [Occ=Once], ipv1_s2pNy [Occ=Once] #) ->
                     (GHC.Word.W32# ipv_s2pNx, GHC.Word.W32# ipv1_s2pNy)
                     };
                   0## -> divZeroError @ (Word32, Word32)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord32_$cquotRem
  = \ (ds_d2ptL :: Word32) (y_a2nYU :: Word32) ->
      case ds_d2ptL of { W32# x#_a2nYT ->
      case y_a2nYU of { W32# y#_a2nYV ->
      case y#_a2nYV of wild2_Xef {
        __DEFAULT ->
          case quotRemWord# x#_a2nYT wild2_Xef of
          { (# ipv_s2pNx, ipv1_s2pNy #) ->
          (GHC.Word.W32# ipv_s2pNx, GHC.Word.W32# ipv1_s2pNy)
          };
        0## -> divZeroError @ (Word32, Word32)
      }
      }
      }

-- RHS size: {terms: 28, types: 14, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord32_$cdivMod
  :: Word32 -> Word32 -> (Word32, Word32)
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2ptZ [Occ=Once!] :: Word32)
                 (y_a2nYZ [Occ=Once!] :: Word32) ->
                 case ds_d2ptZ of { W32# x#_a2nYY ->
                 case y_a2nYZ of { W32# y#_a2nZ0 [Occ=Once!] ->
                 case y#_a2nZ0 of wild2_Xeh {
                   __DEFAULT ->
                     (case quotWord# x#_a2nYY wild2_Xeh of wild3_X3V { __DEFAULT ->
                      GHC.Word.W32# wild3_X3V
                      },
                      case remWord# x#_a2nYY wild2_Xeh of wild3_X3V { __DEFAULT ->
                      GHC.Word.W32# wild3_X3V
                      });
                   0## -> divZeroError @ (Word32, Word32)
                 }
                 }
                 }}]
GHC.Word.$fIntegralWord32_$cdivMod
  = \ (ds_d2ptZ :: Word32) (y_a2nYZ :: Word32) ->
      case ds_d2ptZ of { W32# x#_a2nYY ->
      case y_a2nYZ of { W32# y#_a2nZ0 ->
      case y#_a2nZ0 of wild2_Xeh {
        __DEFAULT ->
          (case quotWord# x#_a2nYY wild2_Xeh of wild3_X3V { __DEFAULT ->
           GHC.Word.W32# wild3_X3V
           },
           case remWord# x#_a2nYY wild2_Xeh of wild3_X3V { __DEFAULT ->
           GHC.Word.W32# wild3_X3V
           });
        0## -> divZeroError @ (Word32, Word32)
      }
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkt [Occ=Once!] :: Word32)
                 (ds1_d2pku [Occ=Once!] :: Word32) ->
                 case ds_d2pkt of { W32# x_a2o21 [Occ=Once] ->
                 case ds1_d2pku of { W32# y_a2o22 [Occ=Once] ->
                 tagToEnum# @ Bool (gtWord# x_a2o21 y_a2o22)
                 }
                 }}]
gtWord32
  = \ (ds_d2pkt :: Word32) (ds1_d2pku :: Word32) ->
      case ds_d2pkt of { W32# x_a2o21 ->
      case ds1_d2pku of { W32# y_a2o22 ->
      tagToEnum# @ Bool (gtWord# x_a2o21 y_a2o22)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkm [Occ=Once!] :: Word32)
                 (ds1_d2pkn [Occ=Once!] :: Word32) ->
                 case ds_d2pkm of { W32# x_a2o23 [Occ=Once] ->
                 case ds1_d2pkn of { W32# y_a2o24 [Occ=Once] ->
                 tagToEnum# @ Bool (geWord# x_a2o23 y_a2o24)
                 }
                 }}]
geWord32
  = \ (ds_d2pkm :: Word32) (ds1_d2pkn :: Word32) ->
      case ds_d2pkm of { W32# x_a2o23 ->
      case ds1_d2pkn of { W32# y_a2o24 ->
      tagToEnum# @ Bool (geWord# x_a2o23 y_a2o24)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pkf [Occ=Once!] :: Word32)
                 (ds1_d2pkg [Occ=Once!] :: Word32) ->
                 case ds_d2pkf of { W32# x_a2o25 [Occ=Once] ->
                 case ds1_d2pkg of { W32# y_a2o26 [Occ=Once] ->
                 tagToEnum# @ Bool (ltWord# x_a2o25 y_a2o26)
                 }
                 }}]
ltWord32
  = \ (ds_d2pkf :: Word32) (ds1_d2pkg :: Word32) ->
      case ds_d2pkf of { W32# x_a2o25 ->
      case ds1_d2pkg of { W32# y_a2o26 ->
      tagToEnum# @ Bool (ltWord# x_a2o25 y_a2o26)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leWord32 [InlPrag=INLINE[1] (sat-args=2)]
  :: Word32 -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d2pk8 [Occ=Once!] :: Word32)
                 (ds1_d2pk9 [Occ=Once!] :: Word32) ->
                 case ds_d2pk8 of { W32# x_a2o27 [Occ=Once] ->
                 case ds1_d2pk9 of { W32# y_a2o28 [Occ=Once] ->
                 tagToEnum# @ Bool (leWord# x_a2o27 y_a2o28)
                 }
                 }}]
leWord32
  = \ (ds_d2pk8 :: Word32) (ds1_d2pk9 :: Word32) ->
      case ds_d2pk8 of { W32# x_a2o27 ->
      case ds1_d2pk9 of { W32# y_a2o28 ->
      tagToEnum# @ Bool (leWord# x_a2o27 y_a2o28)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord32_$ccompare :: Word32 -> Word32 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Word32)
                 (y_a1fi3 [Occ=Once!] :: Word32) ->
                 case x_a1fi2 of { W32# x1_a2o1X ->
                 case y_a1fi3 of { W32# y1_a2o1Y ->
                 case eqWord# x1_a2o1X y1_a2o1Y of {
                   __DEFAULT ->
                     case leWord# x1_a2o1X y1_a2o1Y of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Word.$fOrdWord32_$ccompare
  = \ (x_a1fi2 :: Word32) (y_a1fi3 :: Word32) ->
      case x_a1fi2 of { W32# x1_a2o1X ->
      case y_a1fi3 of { W32# y1_a2o1Y ->
      case eqWord# x1_a2o1X y1_a2o1Y of {
        __DEFAULT ->
          case leWord# x1_a2o1X y1_a2o1Y of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord32_$cmax :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Word32)
                 (y_a55e [Occ=Once!] :: Word32) ->
                 case x_a55d of wild_X9w { W32# x1_a2o27 [Occ=Once] ->
                 case y_a55e of wild1_X5 { W32# y1_a2o28 [Occ=Once] ->
                 case leWord# x1_a2o27 y1_a2o28 of {
                   __DEFAULT -> wild_X9w;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Word.$fOrdWord32_$cmax
  = \ (x_a55d :: Word32) (y_a55e :: Word32) ->
      case x_a55d of wild_X9w { W32# x1_a2o27 ->
      case y_a55e of wild1_X5 { W32# y1_a2o28 ->
      case leWord# x1_a2o27 y1_a2o28 of {
        __DEFAULT -> wild_X9w;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord32_$cmin :: Word32 -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Word32)
                 (y_a55n [Occ=Once!] :: Word32) ->
                 case x_a55m of wild_X9w { W32# x1_a2o27 [Occ=Once] ->
                 case y_a55n of wild1_X5 { W32# y1_a2o28 [Occ=Once] ->
                 case leWord# x1_a2o27 y1_a2o28 of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X9w
                 }
                 }
                 }}]
GHC.Word.$fOrdWord32_$cmin
  = \ (x_a55m :: Word32) (y_a55n :: Word32) ->
      case x_a55m of wild_X9w { W32# x1_a2o27 ->
      case y_a55n of wild1_X5 { W32# y1_a2o28 ->
      case leWord# x1_a2o27 y1_a2o28 of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X9w
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fOrdWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Word32
                         GHC.Word.$fEqWord32
                         GHC.Word.$fOrdWord32_$ccompare
                         ltWord32
                         leWord32
                         gtWord32
                         geWord32
                         GHC.Word.$fOrdWord32_$cmax
                         GHC.Word.$fOrdWord32_$cmin]
GHC.Word.$fOrdWord32
  = GHC.Classes.C:Ord
      @ Word32
      GHC.Word.$fEqWord32
      GHC.Word.$fOrdWord32_$ccompare
      ltWord32
      leWord32
      gtWord32
      geWord32
      GHC.Word.$fOrdWord32_$cmax
      GHC.Word.$fOrdWord32_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$cinRange :: (Word32, Word32) -> Word32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pru [Occ=Once!] :: (Word32, Word32))
                 (i_a2nYd [Occ=Once!] :: Word32) ->
                 case ds_d2pru of { (m_a2nYb [Occ=Once!], n_a2nYc [Occ=Once!]) ->
                 case m_a2nYb of { W32# x_a2o27 [Occ=Once] ->
                 case i_a2nYd of { W32# y_a2o28 ->
                 case leWord# x_a2o27 y_a2o28 of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a2nYc of { W32# y1_X2ogH [Occ=Once] ->
                     tagToEnum# @ Bool (leWord# y_a2o28 y1_X2ogH)
                     }
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord32_$cinRange
  = \ (ds_d2pru :: (Word32, Word32)) (i_a2nYd :: Word32) ->
      case ds_d2pru of { (m_a2nYb, n_a2nYc) ->
      case m_a2nYb of { W32# x_a2o27 ->
      case i_a2nYd of { W32# y_a2o28 ->
      case leWord# x_a2o27 y_a2o28 of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a2nYc of { W32# y1_X2ogH ->
          tagToEnum# @ Bool (leWord# y_a2o28 y1_X2ogH)
          }
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 11, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord32_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word32 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s2sSQ [Occ=Once!] :: Word32) ->
                 case w_s2sSQ of { W32# ww1_s2sST [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger
                           (smallInteger (word2Int# ww1_s2sST)) GHC.Word.$fRealWord1)
                        GHC.Word.$fRealWord1
                 of
                 { (# ww3_s2sTk [Occ=Once], ww4_s2sTl [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s2sTk ww4_s2sTl
                 }
                 }}]
GHC.Word.$fRealWord32_$ctoRational
  = \ (w_s2sSQ :: Word32) ->
      case w_s2sSQ of { W32# ww1_s2sST ->
      case GHC.Real.$w$sreduce
             (timesInteger
                (smallInteger (word2Int# ww1_s2sST)) GHC.Word.$fRealWord1)
             GHC.Word.$fRealWord1
      of
      { (# ww3_s2sTk, ww4_s2sTl #) ->
      GHC.Real.:% @ Integer ww3_s2sTk ww4_s2sTl
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fRealWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Real Word32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Word32
                       GHC.Word.$fNumWord32
                       GHC.Word.$fOrdWord32
                       GHC.Word.$fRealWord32_$ctoRational]
GHC.Word.$fRealWord32
  = GHC.Real.C:Real
      @ Word32
      GHC.Word.$fNumWord32
      GHC.Word.$fOrdWord32
      GHC.Word.$fRealWord32_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIntegralWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Word32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Word32
                           GHC.Word.$fRealWord32
                           GHC.Word.$fEnumWord32
                           GHC.Word.$fIntegralWord32_$cquot
                           GHC.Word.$fIntegralWord32_$crem
                           GHC.Word.$fIntegralWord32_$cquot
                           GHC.Word.$fIntegralWord32_$crem
                           GHC.Word.$fIntegralWord32_$cquotRem
                           GHC.Word.$fIntegralWord32_$cdivMod
                           GHC.Word.$ctoInteger2]
GHC.Word.$fIntegralWord32
  = GHC.Real.C:Integral
      @ Word32
      GHC.Word.$fRealWord32
      GHC.Word.$fEnumWord32
      GHC.Word.$fIntegralWord32_$cquot
      GHC.Word.$fIntegralWord32_$crem
      GHC.Word.$fIntegralWord32_$cquot
      GHC.Word.$fIntegralWord32_$crem
      GHC.Word.$fIntegralWord32_$cquotRem
      GHC.Word.$fIntegralWord32_$cdivMod
      GHC.Word.$ctoInteger2

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$cunsafeIndex
  :: (Word32, Word32) -> Word32 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2prn [Occ=Once!] :: (Word32, Word32))
                 (i_a2nYa [Occ=Once!] :: Word32) ->
                 case ds_d2prn of { (m_a2nY9 [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a2nYa of { W32# x#_a2nZ9 [Occ=Once] ->
                 case m_a2nY9 of { W32# y#_a2nZa [Occ=Once] ->
                 GHC.Types.I#
                   (word2Int# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa)))
                 }
                 }
                 }}]
GHC.Word.$fIxWord32_$cunsafeIndex
  = \ (ds_d2prn :: (Word32, Word32)) (i_a2nYa :: Word32) ->
      case ds_d2prn of { (m_a2nY9, ds1_d2prt) ->
      case i_a2nYa of { W32# x#_a2nZ9 ->
      case m_a2nY9 of { W32# y#_a2nZa ->
      GHC.Types.I#
        (word2Int# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa)))
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$crange :: (Word32, Word32) -> [Word32]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pri [Occ=Once!] :: (Word32, Word32)) ->
                 case ds_d2pri of { (m_a2nY7 [Occ=Once], n_a2nY8 [Occ=Once]) ->
                 GHC.Word.$fEnumWord32_$cenumFromTo m_a2nY7 n_a2nY8
                 }}]
GHC.Word.$fIxWord32_$crange
  = \ (ds_d2pri :: (Word32, Word32)) ->
      case ds_d2pri of { (m_a2nY7, n_a2nY8) ->
      GHC.Word.$fEnumWord32_$cenumFromTo m_a2nY7 n_a2nY8
      }

-- RHS size: {terms: 25, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$crangeSize :: (Word32, Word32) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Word32, Word32)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { W32# x_a2o27 ->
                 case h_a1KRn of { W32# y_a2o28 ->
                 case leWord# x_a2o27 y_a2o28 of {
                   __DEFAULT -> GHC.Word.$fIxWord1;
                   1# ->
                     GHC.Types.I#
                       (+# (word2Int# (narrow32Word# (minusWord# y_a2o28 x_a2o27))) 1#)
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord32_$crangeSize
  = \ (b_a1KRl :: (Word32, Word32)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { W32# x_a2o27 ->
      case h_a1KRn of { W32# y_a2o28 ->
      case leWord# x_a2o27 y_a2o28 of {
        __DEFAULT -> GHC.Word.$fIxWord1;
        1# ->
          GHC.Types.I#
            (+# (word2Int# (narrow32Word# (minusWord# y_a2o28 x_a2o27))) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 12, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$cunsafeRangeSize :: (Word32, Word32) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Word32, Word32)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { W32# x#_a2nZ9 [Occ=Once] ->
                 case _l_a1KRp of { W32# y#_a2nZa [Occ=Once] ->
                 GHC.Types.I#
                   (+# (word2Int# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa))) 1#)
                 }
                 }
                 }}]
GHC.Word.$fIxWord32_$cunsafeRangeSize
  = \ (b_a1KRo :: (Word32, Word32)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { W32# x#_a2nZ9 ->
      case _l_a1KRp of { W32# y#_a2nZa ->
      GHC.Types.I#
        (+# (word2Int# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa))) 1#)
      }
      }
      }

-- RHS size: {terms: 34, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Word32, Word32) -> Word32 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Word32, Word32))
                 (i_a1KRi :: Word32) ->
                 case b_a1KRh of { (m_a2nYb, n_a2nYc [Occ=Once]) ->
                 case leWord32 m_a2nYb i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leWord32 i_a1KRi n_a2nYc of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { W32# x#_a2nZ9 [Occ=Once] ->
                         case m_a2nYb of { W32# y#_a2nZa [Occ=Once] ->
                         GHC.Types.I#
                           (word2Int# (narrow32Word# (minusWord# x#_a2nZ9 y#_a2nZa)))
                         }
                         }
                     }
                 }
                 }}]
GHC.Word.$fIxWord32_$cindex
  = \ (eta_B2 :: (Word32, Word32)) (eta1_B1 :: Word32) ->
      case eta_B2 of { (m_a2nYb, n_a2nYc) ->
      case m_a2nYb of { W32# x_a2o27 ->
      case eta1_B1 of { W32# y_a2o28 ->
      case leWord# x_a2o27 y_a2o28 of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a2nYc of { W32# y1_X2ogR ->
          case leWord# y_a2o28 y1_X2ogR of {
            __DEFAULT -> hopelessIndexError;
            1# ->
              GHC.Types.I#
                (word2Int# (narrow32Word# (minusWord# y_a2o28 x_a2o27)))
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord32 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Word32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Word32
                    GHC.Word.$fOrdWord32
                    GHC.Word.$fIxWord32_$crange
                    GHC.Word.$fIxWord32_$cindex
                    GHC.Word.$fIxWord32_$cunsafeIndex
                    GHC.Word.$fIxWord32_$cinRange
                    GHC.Word.$fIxWord32_$crangeSize
                    GHC.Word.$fIxWord32_$cunsafeRangeSize]
GHC.Word.$fIxWord32
  = GHC.Arr.C:Ix
      @ Word32
      GHC.Word.$fOrdWord32
      GHC.Word.$fIxWord32_$crange
      GHC.Word.$fIxWord32_$cindex
      GHC.Word.$fIxWord32_$cunsafeIndex
      GHC.Word.$fIxWord32_$cinRange
      GHC.Word.$fIxWord32_$crangeSize
      GHC.Word.$fIxWord32_$cunsafeRangeSize

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
byteSwap32 :: Word32 -> Word32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pk4 [Occ=Once!] :: Word32) ->
                 case ds_d2pk4 of { W32# w#_a2o29 [Occ=Once] ->
                 GHC.Word.W32# (narrow32Word# (byteSwap32# w#_a2o29))
                 }}]
byteSwap32
  = \ (ds_d2pk4 :: Word32) ->
      case ds_d2pk4 of { W32# w#_a2o29 ->
      GHC.Word.W32# (narrow32Word# (byteSwap32# w#_a2o29))
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$ccomplement :: Word64 -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pnj [Occ=Once!] :: Word64) ->
                 case ds_d2pnj of { W64# x#_a2nXe [Occ=Once] ->
                 GHC.Word.W64# (xor# x#_a2nXe 18446744073709551615##)
                 }}]
GHC.Word.$fBitsWord64_$ccomplement
  = \ (ds_d2pnj :: Word64) ->
      case ds_d2pnj of { W64# x#_a2nXe ->
      GHC.Word.W64# (xor# x#_a2nXe 18446744073709551615##)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord6 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$fBitsWord6 = GHC.Base.Just @ Int GHC.Word.$fBitsWord5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cbitSizeMaybe :: Word64 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Word.$fBitsWord6}]
GHC.Word.$fBitsWord64_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Word.$fBitsWord6

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# 1## i#_a2nXj);
                   1# -> GHC.Word.W64# 0##
                 }
                 }}]
GHC.Word.$fBitsWord64_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT -> GHC.Word.W64# (uncheckedShiftL# 1## i#_a2nXj);
        1# -> GHC.Word.$fBitsWord7
      }
      }

-- RHS size: {terms: 25, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Word64 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Word64)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { W64# x#_a2nX8 [Occ=Once] ->
                 case i_a1A6i of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT ->
                     neWord64
                       (GHC.Word.W64# (and# x#_a2nX8 (uncheckedShiftL# 1## i#_a2nXj)))
                       (GHC.Word.W64# 0##);
                   1# -> neWord64 (GHC.Word.W64# 0##) (GHC.Word.W64# 0##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$ctestBit
  = \ (x_a1A6h :: Word64) (i_a1A6i :: Int) ->
      case x_a1A6h of { W64# x#_a2nX8 ->
      case i_a1A6i of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT ->
          case and# x#_a2nX8 (uncheckedShiftL# 1## i#_a2nXj) of {
            __DEFAULT -> GHC.Types.True;
            0## -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 28, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Word64)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { W64# x#_a2nXq ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 63##)
                 of wild2_X78 {
                   __DEFAULT ->
                     GHC.Word.W64#
                       (or#
                          (uncheckedShiftL# x#_a2nXq wild2_X78)
                          (uncheckedShiftRL# x#_a2nXq (-# 64# wild2_X78)));
                   0# -> GHC.Word.W64# x#_a2nXq
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$crotateR
  = \ (eta_B2 :: Word64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6W { W64# x#_a2nXq ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 63##)
      of wild2_X78 {
        __DEFAULT ->
          GHC.Word.W64#
            (or#
               (uncheckedShiftL# x#_a2nXq wild2_X78)
               (uncheckedShiftRL# x#_a2nXq (-# 64# wild2_X78)));
        0# -> wild_X6W
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Word64)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { W64# x#_a2nXc [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT ->
                     GHC.Word.W64# (xor# x#_a2nXc (uncheckedShiftL# 1## i#_a2nXj));
                   1# -> GHC.Word.W64# x#_a2nXc
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$ccomplementBit
  = \ (eta_B2 :: Word64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6Y { W64# x#_a2nXc ->
      case eta1_B1 of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT ->
          GHC.Word.W64# (xor# x#_a2nXc (uncheckedShiftL# 1## i#_a2nXj));
        1# -> wild_X6Y
      }
      }
      }

-- RHS size: {terms: 26, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Word64)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { W64# x#_a2nX8 [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT ->
                     GHC.Word.W64#
                       (and#
                          x#_a2nX8
                          (xor# (uncheckedShiftL# 1## i#_a2nXj) 18446744073709551615##));
                   1# -> GHC.Word.W64# (and# x#_a2nX8 18446744073709551615##)
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$cclearBit
  = \ (eta_B2 :: Word64) (eta1_B1 :: Int) ->
      case eta_B2 of { W64# x#_a2nX8 ->
      case eta1_B1 of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT ->
          GHC.Word.W64#
            (and#
               x#_a2nX8
               (xor# (uncheckedShiftL# 1## i#_a2nXj) 18446744073709551615##));
        1# -> GHC.Word.W64# (and# x#_a2nX8 18446744073709551615##)
      }
      }
      }

-- RHS size: {terms: 21, types: 7, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Word64)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { W64# x#_a2nXa [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a2nXj ->
                 case >=# i#_a2nXj 64# of {
                   __DEFAULT ->
                     GHC.Word.W64# (or# x#_a2nXa (uncheckedShiftL# 1## i#_a2nXj));
                   1# -> GHC.Word.W64# x#_a2nXa
                 }
                 }
                 }}]
GHC.Word.$fBitsWord64_$csetBit
  = \ (eta_B2 :: Word64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6Z { W64# x#_a2nXa ->
      case eta1_B1 of { I# i#_a2nXj ->
      case >=# i#_a2nXj 64# of {
        __DEFAULT ->
          GHC.Word.W64# (or# x#_a2nXa (uncheckedShiftL# 1## i#_a2nXj));
        1# -> wild_X6Z
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Word.$fBitsWord64_$crotate}]
GHC.Word.$fBitsWord64_$crotateL = GHC.Word.$fBitsWord64_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fBitsWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Word64
                        GHC.Word.$fEqWord64
                        GHC.Word.$fBitsWord64_$c.&.
                        GHC.Word.$fBitsWord64_$c.|.
                        GHC.Word.$fBitsWord64_$cxor
                        GHC.Word.$fBitsWord64_$ccomplement
                        GHC.Word.$fBitsWord64_$cshift
                        GHC.Word.$fBitsWord64_$crotate
                        GHC.Word.$fBitsWord7
                        GHC.Word.$fBitsWord64_$cbit
                        GHC.Word.$fBitsWord64_$csetBit
                        GHC.Word.$fBitsWord64_$cclearBit
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        GHC.Word.$fBitsWord64_$ctestBit
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        GHC.Word.$fBitsWord64_$cisSigned
                        GHC.Word.$fBitsWord64_$cshiftL
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        GHC.Word.$fBitsWord64_$cshiftR
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        GHC.Word.$fBitsWord64_$crotateL
                        GHC.Word.$fBitsWord64_$crotateR
                        GHC.Word.$fBitsWord64_$cpopCount]
GHC.Word.$fBitsWord64
  = Data.Bits.C:Bits
      @ Word64
      GHC.Word.$fEqWord64
      GHC.Word.$fBitsWord64_$c.&.
      GHC.Word.$fBitsWord64_$c.|.
      GHC.Word.$fBitsWord64_$cxor
      GHC.Word.$fBitsWord64_$ccomplement
      GHC.Word.$fBitsWord64_$cshift
      GHC.Word.$fBitsWord64_$crotate
      GHC.Word.$fBitsWord7
      GHC.Word.$fBitsWord64_$cbit
      GHC.Word.$fBitsWord64_$csetBit
      GHC.Word.$fBitsWord64_$cclearBit
      GHC.Word.$fBitsWord64_$ccomplementBit
      GHC.Word.$fBitsWord64_$ctestBit
      GHC.Word.$fBitsWord64_$cbitSizeMaybe
      GHC.Word.$fBitsWord64_$cfiniteBitSize
      GHC.Word.$fBitsWord64_$cisSigned
      GHC.Word.$fBitsWord64_$cshiftL
      GHC.Word.$fBitsWord64_$cunsafeShiftL
      GHC.Word.$fBitsWord64_$cshiftR
      GHC.Word.$fBitsWord64_$cunsafeShiftR
      GHC.Word.$fBitsWord64_$crotateL
      GHC.Word.$fBitsWord64_$crotateR
      GHC.Word.$fBitsWord64_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fFiniteBitsWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Word64
                              GHC.Word.$fBitsWord64
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros]
GHC.Word.$fFiniteBitsWord64
  = Data.Bits.C:FiniteBits
      @ Word64
      GHC.Word.$fBitsWord64
      GHC.Word.$fBitsWord64_$cfiniteBitSize
      GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
      GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$cinRange :: (Word64, Word64) -> Word64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pmq [Occ=Once!] :: (Word64, Word64))
                 (i_a2nX2 [Occ=Once!] :: Word64) ->
                 case ds_d2pmq of { (m_a2nX0 [Occ=Once!], n_a2nX1 [Occ=Once!]) ->
                 case m_a2nX0 of { W64# x_a2o2k [Occ=Once] ->
                 case i_a2nX2 of { W64# y_a2o2l ->
                 case leWord# x_a2o2k y_a2o2l of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a2nX1 of { W64# y1_X2oho [Occ=Once] ->
                     tagToEnum# @ Bool (leWord# y_a2o2l y1_X2oho)
                     }
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord64_$cinRange
  = \ (ds_d2pmq :: (Word64, Word64)) (i_a2nX2 :: Word64) ->
      case ds_d2pmq of { (m_a2nX0, n_a2nX1) ->
      case m_a2nX0 of { W64# x_a2o2k ->
      case i_a2nX2 of { W64# y_a2o2l ->
      case leWord# x_a2o2k y_a2o2l of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a2nX1 of { W64# y1_X2oho ->
          tagToEnum# @ Bool (leWord# y_a2o2l y1_X2oho)
          }
      }
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$crange :: (Word64, Word64) -> [Word64]
[GblId,
 Arity=1,
 Str=<S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pme [Occ=Once!] :: (Word64, Word64)) ->
                 case ds_d2pme of { (m_a2nWW [Occ=Once], n_a2nWX [Occ=Once]) ->
                 GHC.Word.$fEnumWord64_$cenumFromTo m_a2nWW n_a2nWX
                 }}]
GHC.Word.$fIxWord64_$crange
  = \ (ds_d2pme :: (Word64, Word64)) ->
      case ds_d2pme of { (m_a2nWW, n_a2nWX) ->
      GHC.Word.$fEnumWord64_$cenumFromTo m_a2nWW n_a2nWX
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$cunsafeIndex
  :: (Word64, Word64) -> Word64 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pmj [Occ=Once!] :: (Word64, Word64))
                 (i_a2nWZ [Occ=Once!] :: Word64) ->
                 case ds_d2pmj of { (m_a2nWY [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a2nWZ of { W64# x#_a2nY0 [Occ=Once] ->
                 case m_a2nWY of { W64# y#_a2nY1 [Occ=Once] ->
                 GHC.Types.I# (word2Int# (minusWord# x#_a2nY0 y#_a2nY1))
                 }
                 }
                 }}]
GHC.Word.$fIxWord64_$cunsafeIndex
  = \ (ds_d2pmj :: (Word64, Word64)) (i_a2nWZ :: Word64) ->
      case ds_d2pmj of { (m_a2nWY, ds1_d2pmp) ->
      case i_a2nWZ of { W64# x#_a2nY0 ->
      case m_a2nWY of { W64# y#_a2nY1 ->
      GHC.Types.I# (word2Int# (minusWord# x#_a2nY0 y#_a2nY1))
      }
      }
      }

-- RHS size: {terms: 24, types: 13, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$crangeSize :: (Word64, Word64) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Word64, Word64)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { W64# x_a2o2k ->
                 case h_a1KRn of { W64# y_a2o2l ->
                 case leWord# x_a2o2k y_a2o2l of {
                   __DEFAULT -> GHC.Word.$fIxWord1;
                   1# -> GHC.Types.I# (+# (word2Int# (minusWord# y_a2o2l x_a2o2k)) 1#)
                 }
                 }
                 }
                 }}]
GHC.Word.$fIxWord64_$crangeSize
  = \ (b_a1KRl :: (Word64, Word64)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { W64# x_a2o2k ->
      case h_a1KRn of { W64# y_a2o2l ->
      case leWord# x_a2o2k y_a2o2l of {
        __DEFAULT -> GHC.Word.$fIxWord1;
        1# -> GHC.Types.I# (+# (word2Int# (minusWord# y_a2o2l x_a2o2k)) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 17, types: 12, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$cunsafeRangeSize :: (Word64, Word64) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Word64, Word64)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { W64# x#_a2nY0 [Occ=Once] ->
                 case _l_a1KRp of { W64# y#_a2nY1 [Occ=Once] ->
                 GHC.Types.I# (+# (word2Int# (minusWord# x#_a2nY0 y#_a2nY1)) 1#)
                 }
                 }
                 }}]
GHC.Word.$fIxWord64_$cunsafeRangeSize
  = \ (b_a1KRo :: (Word64, Word64)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { W64# x#_a2nY0 ->
      case _l_a1KRp of { W64# y#_a2nY1 ->
      GHC.Types.I# (+# (word2Int# (minusWord# x#_a2nY0 y#_a2nY1)) 1#)
      }
      }
      }

-- RHS size: {terms: 33, types: 17, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Word64, Word64) -> Word64 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Word64, Word64))
                 (i_a1KRi :: Word64) ->
                 case b_a1KRh of { (m_a2nX0, n_a2nX1 [Occ=Once]) ->
                 case leWord64 m_a2nX0 i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leWord64 i_a1KRi n_a2nX1 of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { W64# x#_a2nY0 [Occ=Once] ->
                         case m_a2nX0 of { W64# y#_a2nY1 [Occ=Once] ->
                         GHC.Types.I# (word2Int# (minusWord# x#_a2nY0 y#_a2nY1))
                         }
                         }
                     }
                 }
                 }}]
GHC.Word.$fIxWord64_$cindex
  = \ (eta_B2 :: (Word64, Word64)) (eta1_B1 :: Word64) ->
      case eta_B2 of { (m_a2nX0, n_a2nX1) ->
      case m_a2nX0 of { W64# x_a2o2k ->
      case eta1_B1 of { W64# y_a2o2l ->
      case leWord# x_a2o2k y_a2o2l of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a2nX1 of { W64# y1_X2ohu ->
          case leWord# y_a2o2l y1_X2ohu of {
            __DEFAULT -> hopelessIndexError;
            1# -> GHC.Types.I# (word2Int# (minusWord# y_a2o2l x_a2o2k))
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Word.$fIxWord64 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Word64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Word64
                    GHC.Word.$fOrdWord64
                    GHC.Word.$fIxWord64_$crange
                    GHC.Word.$fIxWord64_$cindex
                    GHC.Word.$fIxWord64_$cunsafeIndex
                    GHC.Word.$fIxWord64_$cinRange
                    GHC.Word.$fIxWord64_$crangeSize
                    GHC.Word.$fIxWord64_$cunsafeRangeSize]
GHC.Word.$fIxWord64
  = GHC.Arr.C:Ix
      @ Word64
      GHC.Word.$fOrdWord64
      GHC.Word.$fIxWord64_$crange
      GHC.Word.$fIxWord64_$cindex
      GHC.Word.$fIxWord64_$cunsafeIndex
      GHC.Word.$fIxWord64_$cinRange
      GHC.Word.$fIxWord64_$crangeSize
      GHC.Word.$fIxWord64_$cunsafeRangeSize

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
uncheckedShiftL64# :: Word# -> Int# -> Word#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= uncheckedShiftL#}]
uncheckedShiftL64# = uncheckedShiftL#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
uncheckedShiftRL64# :: Word# -> Int# -> Word#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= uncheckedShiftRL#}]
uncheckedShiftRL64# = uncheckedShiftRL#

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
byteSwap64 :: Word64 -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d2pji [Occ=Once!] :: Word64) ->
                 case ds_d2pji of { W64# w#_a2o2m [Occ=Once] ->
                 GHC.Word.W64# (byteSwap# w#_a2o2m)
                 }}]
byteSwap64
  = \ (ds_d2pji :: Word64) ->
      case ds_d2pji of { W64# w#_a2o2m ->
      GHC.Word.W64# (byteSwap# w#_a2o2m)
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Word.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$trModule3 = GHC.Types.TrNameS GHC.Word.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$trModule2 = "GHC.Word"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$trModule1 = GHC.Types.TrNameS GHC.Word.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Word.$trModule
  = GHC.Types.Module GHC.Word.$trModule3 GHC.Word.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r2uFN :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r2uFN
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcWord# (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord7 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tcWord7 = GHC.Types.TrNameS GHC.Word.$tcWord9

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord8 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tcWord8
  = GHC.Types.TyCon
      2052113150978616866##
      10393726928463219846##
      GHC.Word.$trModule
      GHC.Word.$tcWord7
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r2uFO :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r2uFO
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord8 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W8#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Word.$tc'W8#1 = GHC.Types.KindRepFun $krep_r2uFN $krep1_r2uFO

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W8#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Word.$tc'W8#3 = "'W8#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W8#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tc'W8#2 = GHC.Types.TrNameS GHC.Word.$tc'W8#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W8# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tc'W8#
  = GHC.Types.TyCon
      12964227823649101302##
      11115249754126507208##
      GHC.Word.$trModule
      GHC.Word.$tc'W8#2
      0#
      GHC.Word.$tc'W8#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tcWord1 = GHC.Types.TrNameS GHC.Word.$tcWord2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord16 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tcWord16
  = GHC.Types.TyCon
      1884349046328127494##
      12602100146125136909##
      GHC.Word.$trModule
      GHC.Word.$tcWord1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r2uFP :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r2uFP
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord16 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W16#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Word.$tc'W16#1 = GHC.Types.KindRepFun $krep_r2uFN $krep2_r2uFP

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W16#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tc'W16#3 = "'W16#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W16#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tc'W16#2 = GHC.Types.TrNameS GHC.Word.$tc'W16#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W16# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tc'W16#
  = GHC.Types.TyCon
      13828125037659739325##
      16689402625363715300##
      GHC.Word.$trModule
      GHC.Word.$tc'W16#2
      0#
      GHC.Word.$tc'W16#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tcWord3 = GHC.Types.TrNameS GHC.Word.$tcWord4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord32 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tcWord32
  = GHC.Types.TyCon
      3293767376230595825##
      2424786049275339072##
      GHC.Word.$trModule
      GHC.Word.$tcWord3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r2uFQ :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r2uFQ
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord32 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W32#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Word.$tc'W32#1 = GHC.Types.KindRepFun $krep_r2uFN $krep3_r2uFQ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W32#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tc'W32#3 = "'W32#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W32#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tc'W32#2 = GHC.Types.TrNameS GHC.Word.$tc'W32#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W32# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tc'W32#
  = GHC.Types.TyCon
      15609358257729636621##
      4567728021977807739##
      GHC.Word.$trModule
      GHC.Word.$tc'W32#2
      0#
      GHC.Word.$tc'W32#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord5 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tcWord5 = GHC.Types.TrNameS GHC.Word.$tcWord6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tcWord64 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tcWord64
  = GHC.Types.TyCon
      3342358330123258062##
      10610880953247303810##
      GHC.Word.$trModule
      GHC.Word.$tcWord5
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4_r2uFR :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r2uFR
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord64 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W64#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Word.$tc'W64#1 = GHC.Types.KindRepFun $krep_r2uFN $krep4_r2uFR

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W64#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Word.$tc'W64#3 = "'W64#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W64#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Word.$tc'W64#2 = GHC.Types.TrNameS GHC.Word.$tc'W64#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Word.$tc'W64# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Word.$tc'W64#
  = GHC.Types.TyCon
      3390197976568817661##
      1176743391454549598##
      GHC.Word.$trModule
      GHC.Word.$tc'W64#2
      0#
      GHC.Word.$tc'W64#1


------ Local rules for imported ids --------
"fromIntegral/a->Word64"
    forall (@ a_a2oHp)
           ($dIntegral_a2oHm :: Integral a_a2oHp)
           ($dNum_a2oHn :: Num Word64).
      fromIntegral @ a_a2oHp @ Word64 $dIntegral_a2oHm $dNum_a2oHn
      = \ (x_a2o2n :: a_a2oHp) ->
          case fromIntegral
                 @ a_a2oHp @ Word $dIntegral_a2oHm GHC.Num.$fNumWord x_a2o2n
          of
          { W# x#_a2o2o ->
          GHC.Word.W64# x#_a2o2o
          }
"fromIntegral/Word64->a"
    forall (@ b_a2oHE)
           ($dIntegral_a2oHF :: Integral Word64)
           ($dNum_a2oHG :: Num b_a2oHE).
      fromIntegral @ Word64 @ b_a2oHE $dIntegral_a2oHF $dNum_a2oHG
      = \ (ds_d2pDD :: Word64) ->
          case ds_d2pDD of { W64# x#_a2o2p ->
          fromIntegral
            @ Word
            @ b_a2oHE
            GHC.Real.$fIntegralWord
            $dNum_a2oHG
            (GHC.Types.W# x#_a2o2p)
          }
"fromIntegral/Word8->Word32"
    forall ($dIntegral_a2oHW :: Integral Word8)
           ($dNum_a2oHX :: Num Word32).
      fromIntegral @ Word8 @ Word32 $dIntegral_a2oHW $dNum_a2oHX
      = \ (ds_d2pDH :: Word8) ->
          case ds_d2pDH of { W8# x#_a2o2q -> GHC.Word.W32# x#_a2o2q }
"fromIntegral/Word16->Word32"
    forall ($dIntegral_a2oI7 :: Integral Word16)
           ($dNum_a2oI8 :: Num Word32).
      fromIntegral @ Word16 @ Word32 $dIntegral_a2oI7 $dNum_a2oI8
      = \ (ds_d2pDL :: Word16) ->
          case ds_d2pDL of { W16# x#_a2o2r -> GHC.Word.W32# x#_a2o2r }
"fromIntegral/Word32->Word32"
    forall ($dIntegral_a2oIi :: Integral Word32)
           ($dNum_a2oIj :: Num Word32).
      fromIntegral @ Word32 @ Word32 $dIntegral_a2oIi $dNum_a2oIj
      = id @ Word32
"fromIntegral/Word32->Integer"
    forall ($dIntegral_a2oIB :: Integral Word32)
           ($dNum_a2oIC :: Num Integer).
      fromIntegral @ Word32 @ Integer $dIntegral_a2oIB $dNum_a2oIC
      = GHC.Word.$ctoInteger2
"fromIntegral/a->Word32"
    forall (@ a_a2oIZ)
           ($dIntegral_a2oIW :: Integral a_a2oIZ)
           ($dNum_a2oIX :: Num Word32).
      fromIntegral @ a_a2oIZ @ Word32 $dIntegral_a2oIW $dNum_a2oIX
      = \ (x_a2o2s :: a_a2oIZ) ->
          case fromIntegral
                 @ a_a2oIZ @ Word $dIntegral_a2oIW GHC.Num.$fNumWord x_a2o2s
          of
          { W# x#_a2o2t ->
          GHC.Word.W32# (narrow32Word# x#_a2o2t)
          }
"fromIntegral/Word32->a"
    forall (@ b_a2oJe)
           ($dIntegral_a2oJf :: Integral Word32)
           ($dNum_a2oJg :: Num b_a2oJe).
      fromIntegral @ Word32 @ b_a2oJe $dIntegral_a2oJf $dNum_a2oJg
      = \ (ds_d2pDU :: Word32) ->
          case ds_d2pDU of { W32# x#_a2o2u ->
          fromIntegral
            @ Word
            @ b_a2oJe
            GHC.Real.$fIntegralWord
            $dNum_a2oJg
            (GHC.Types.W# x#_a2o2u)
          }
"properFraction/Double->(Word32,Double)"
    forall ($dRealFrac_a2oJF :: RealFrac Double)
           ($dIntegral_a2oJH :: Integral Word32).
      properFraction @ Double $dRealFrac_a2oJF @ Word32 $dIntegral_a2oJH
      = \ (x_a2o2v :: Double) ->
          case properFraction
                 @ Double $dRealFrac_a2oJF @ Int GHC.Real.$fIntegralInt x_a2o2v
          of
          { (n_a2o2w, y_a2o2x) ->
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32 n_a2o2w,
           y_a2o2x)
          }
"truncate/Double->Word32"
    forall ($dRealFrac_a2oKj :: RealFrac Double)
           ($dIntegral_a2oKl :: Integral Word32).
      truncate @ Double $dRealFrac_a2oKj @ Word32 $dIntegral_a2oKl
      = . @ Int
          @ Word32
          @ Double
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (truncate @ Double $dRealFrac_a2oKj @ Int GHC.Real.$fIntegralInt)
"floor/Double->Word32"
    forall ($dRealFrac_a2oKY :: RealFrac Double)
           ($dIntegral_a2oL0 :: Integral Word32).
      floor @ Double $dRealFrac_a2oKY @ Word32 $dIntegral_a2oL0
      = . @ Int
          @ Word32
          @ Double
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (floor @ Double $dRealFrac_a2oKY @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Word32"
    forall ($dRealFrac_a2oLD :: RealFrac Double)
           ($dIntegral_a2oLF :: Integral Word32).
      ceiling @ Double $dRealFrac_a2oLD @ Word32 $dIntegral_a2oLF
      = . @ Int
          @ Word32
          @ Double
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (ceiling @ Double $dRealFrac_a2oLD @ Int GHC.Real.$fIntegralInt)
"round/Double->Word32"
    forall ($dRealFrac_a2oMi :: RealFrac Double)
           ($dIntegral_a2oMk :: Integral Word32).
      round @ Double $dRealFrac_a2oMi @ Word32 $dIntegral_a2oMk
      = . @ Int
          @ Word32
          @ Double
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (round @ Double $dRealFrac_a2oMi @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Word32,Float)"
    forall ($dRealFrac_a2oMW :: RealFrac Float)
           ($dIntegral_a2oMY :: Integral Word32).
      properFraction @ Float $dRealFrac_a2oMW @ Word32 $dIntegral_a2oMY
      = \ (x_a2o2y :: Float) ->
          case properFraction
                 @ Float $dRealFrac_a2oMW @ Int GHC.Real.$fIntegralInt x_a2o2y
          of
          { (n_a2o2z, y_a2o2A) ->
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32 n_a2o2z,
           y_a2o2A)
          }
"truncate/Float->Word32"
    forall ($dRealFrac_a2oNz :: RealFrac Float)
           ($dIntegral_a2oNB :: Integral Word32).
      truncate @ Float $dRealFrac_a2oNz @ Word32 $dIntegral_a2oNB
      = . @ Int
          @ Word32
          @ Float
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (truncate @ Float $dRealFrac_a2oNz @ Int GHC.Real.$fIntegralInt)
"floor/Float->Word32"
    forall ($dRealFrac_a2oOd :: RealFrac Float)
           ($dIntegral_a2oOf :: Integral Word32).
      floor @ Float $dRealFrac_a2oOd @ Word32 $dIntegral_a2oOf
      = . @ Int
          @ Word32
          @ Float
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (floor @ Float $dRealFrac_a2oOd @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Word32"
    forall ($dRealFrac_a2oOR :: RealFrac Float)
           ($dIntegral_a2oOT :: Integral Word32).
      ceiling @ Float $dRealFrac_a2oOR @ Word32 $dIntegral_a2oOT
      = . @ Int
          @ Word32
          @ Float
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (ceiling @ Float $dRealFrac_a2oOR @ Int GHC.Real.$fIntegralInt)
"round/Float->Word32"
    forall ($dRealFrac_a2oPv :: RealFrac Float)
           ($dIntegral_a2oPx :: Integral Word32).
      round @ Float $dRealFrac_a2oPv @ Word32 $dIntegral_a2oPx
      = . @ Int
          @ Word32
          @ Float
          (fromIntegral
             @ Int @ Word32 GHC.Real.$fIntegralInt GHC.Word.$fNumWord32)
          (round @ Float $dRealFrac_a2oPv @ Int GHC.Real.$fIntegralInt)
"properFraction/Double->(Word16,Double)"
    forall ($dRealFrac_a2oQ9 :: RealFrac Double)
           ($dIntegral_a2oQb :: Integral Word16).
      properFraction @ Double $dRealFrac_a2oQ9 @ Word16 $dIntegral_a2oQb
      = \ (x_a2o2B :: Double) ->
          case properFraction
                 @ Double $dRealFrac_a2oQ9 @ Int GHC.Real.$fIntegralInt x_a2o2B
          of
          { (n_a2o2C, y_a2o2D) ->
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16 n_a2o2C,
           y_a2o2D)
          }
"truncate/Double->Word16"
    forall ($dRealFrac_a2oQM :: RealFrac Double)
           ($dIntegral_a2oQO :: Integral Word16).
      truncate @ Double $dRealFrac_a2oQM @ Word16 $dIntegral_a2oQO
      = . @ Int
          @ Word16
          @ Double
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (truncate @ Double $dRealFrac_a2oQM @ Int GHC.Real.$fIntegralInt)
"floor/Double->Word16"
    forall ($dRealFrac_a2oRq :: RealFrac Double)
           ($dIntegral_a2oRs :: Integral Word16).
      floor @ Double $dRealFrac_a2oRq @ Word16 $dIntegral_a2oRs
      = . @ Int
          @ Word16
          @ Double
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (floor @ Double $dRealFrac_a2oRq @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Word16"
    forall ($dRealFrac_a2oS4 :: RealFrac Double)
           ($dIntegral_a2oS6 :: Integral Word16).
      ceiling @ Double $dRealFrac_a2oS4 @ Word16 $dIntegral_a2oS6
      = . @ Int
          @ Word16
          @ Double
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (ceiling @ Double $dRealFrac_a2oS4 @ Int GHC.Real.$fIntegralInt)
"round/Double->Word16"
    forall ($dRealFrac_a2oSI :: RealFrac Double)
           ($dIntegral_a2oSK :: Integral Word16).
      round @ Double $dRealFrac_a2oSI @ Word16 $dIntegral_a2oSK
      = . @ Int
          @ Word16
          @ Double
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (round @ Double $dRealFrac_a2oSI @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Word16,Float)"
    forall ($dRealFrac_a2oTm :: RealFrac Float)
           ($dIntegral_a2oTo :: Integral Word16).
      properFraction @ Float $dRealFrac_a2oTm @ Word16 $dIntegral_a2oTo
      = \ (x_a2o2E :: Float) ->
          case properFraction
                 @ Float $dRealFrac_a2oTm @ Int GHC.Real.$fIntegralInt x_a2o2E
          of
          { (n_a2o2F, y_a2o2G) ->
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16 n_a2o2F,
           y_a2o2G)
          }
"truncate/Float->Word16"
    forall ($dRealFrac_a2oTZ :: RealFrac Float)
           ($dIntegral_a2oU1 :: Integral Word16).
      truncate @ Float $dRealFrac_a2oTZ @ Word16 $dIntegral_a2oU1
      = . @ Int
          @ Word16
          @ Float
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (truncate @ Float $dRealFrac_a2oTZ @ Int GHC.Real.$fIntegralInt)
"floor/Float->Word16"
    forall ($dRealFrac_a2oUD :: RealFrac Float)
           ($dIntegral_a2oUF :: Integral Word16).
      floor @ Float $dRealFrac_a2oUD @ Word16 $dIntegral_a2oUF
      = . @ Int
          @ Word16
          @ Float
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (floor @ Float $dRealFrac_a2oUD @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Word16"
    forall ($dRealFrac_a2oVh :: RealFrac Float)
           ($dIntegral_a2oVj :: Integral Word16).
      ceiling @ Float $dRealFrac_a2oVh @ Word16 $dIntegral_a2oVj
      = . @ Int
          @ Word16
          @ Float
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (ceiling @ Float $dRealFrac_a2oVh @ Int GHC.Real.$fIntegralInt)
"round/Float->Word16"
    forall ($dRealFrac_a2oVV :: RealFrac Float)
           ($dIntegral_a2oVX :: Integral Word16).
      round @ Float $dRealFrac_a2oVV @ Word16 $dIntegral_a2oVX
      = . @ Int
          @ Word16
          @ Float
          (fromIntegral
             @ Int @ Word16 GHC.Real.$fIntegralInt GHC.Word.$fNumWord16)
          (round @ Float $dRealFrac_a2oVV @ Int GHC.Real.$fIntegralInt)
"fromIntegral/Word8->Word16"
    forall ($dIntegral_a2oWA :: Integral Word8)
           ($dNum_a2oWB :: Num Word16).
      fromIntegral @ Word8 @ Word16 $dIntegral_a2oWA $dNum_a2oWB
      = \ (ds_d2pEm :: Word8) ->
          case ds_d2pEm of { W8# x#_a2o2H -> GHC.Word.W16# x#_a2o2H }
"fromIntegral/Word16->Word16"
    forall ($dIntegral_a2oWL :: Integral Word16)
           ($dNum_a2oWM :: Num Word16).
      fromIntegral @ Word16 @ Word16 $dIntegral_a2oWL $dNum_a2oWM
      = id @ Word16
"fromIntegral/Word16->Integer"
    forall ($dIntegral_a2oX4 :: Integral Word16)
           ($dNum_a2oX5 :: Num Integer).
      fromIntegral @ Word16 @ Integer $dIntegral_a2oX4 $dNum_a2oX5
      = GHC.Word.$ctoInteger1
"fromIntegral/a->Word16"
    forall (@ a_a2oXs)
           ($dIntegral_a2oXp :: Integral a_a2oXs)
           ($dNum_a2oXq :: Num Word16).
      fromIntegral @ a_a2oXs @ Word16 $dIntegral_a2oXp $dNum_a2oXq
      = \ (x_a2o2I :: a_a2oXs) ->
          case fromIntegral
                 @ a_a2oXs @ Word $dIntegral_a2oXp GHC.Num.$fNumWord x_a2o2I
          of
          { W# x#_a2o2J ->
          GHC.Word.W16# (narrow16Word# x#_a2o2J)
          }
"fromIntegral/Word16->a"
    forall (@ b_a2oXH)
           ($dIntegral_a2oXI :: Integral Word16)
           ($dNum_a2oXJ :: Num b_a2oXH).
      fromIntegral @ Word16 @ b_a2oXH $dIntegral_a2oXI $dNum_a2oXJ
      = \ (ds_d2pEv :: Word16) ->
          case ds_d2pEv of { W16# x#_a2o2K ->
          fromIntegral
            @ Word
            @ b_a2oXH
            GHC.Real.$fIntegralWord
            $dNum_a2oXJ
            (GHC.Types.W# x#_a2o2K)
          }
"properFraction/Double->(Word8,Double)"
    forall ($dRealFrac_a2oXY :: RealFrac Double)
           ($dIntegral_a2oY0 :: Integral Word8).
      properFraction @ Double $dRealFrac_a2oXY @ Word8 $dIntegral_a2oY0
      = \ (x_a2o2L :: Double) ->
          case properFraction
                 @ Double $dRealFrac_a2oXY @ Int GHC.Real.$fIntegralInt x_a2o2L
          of
          { (n_a2o2M, y_a2o2N) ->
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8 n_a2o2M,
           y_a2o2N)
          }
"truncate/Double->Word8"
    forall ($dRealFrac_a2oYB :: RealFrac Double)
           ($dIntegral_a2oYD :: Integral Word8).
      truncate @ Double $dRealFrac_a2oYB @ Word8 $dIntegral_a2oYD
      = . @ Int
          @ Word8
          @ Double
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (truncate @ Double $dRealFrac_a2oYB @ Int GHC.Real.$fIntegralInt)
"floor/Double->Word8"
    forall ($dRealFrac_a2oZf :: RealFrac Double)
           ($dIntegral_a2oZh :: Integral Word8).
      floor @ Double $dRealFrac_a2oZf @ Word8 $dIntegral_a2oZh
      = . @ Int
          @ Word8
          @ Double
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (floor @ Double $dRealFrac_a2oZf @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Word8"
    forall ($dRealFrac_a2oZT :: RealFrac Double)
           ($dIntegral_a2oZV :: Integral Word8).
      ceiling @ Double $dRealFrac_a2oZT @ Word8 $dIntegral_a2oZV
      = . @ Int
          @ Word8
          @ Double
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (ceiling @ Double $dRealFrac_a2oZT @ Int GHC.Real.$fIntegralInt)
"round/Double->Word8"
    forall ($dRealFrac_a2p0x :: RealFrac Double)
           ($dIntegral_a2p0z :: Integral Word8).
      round @ Double $dRealFrac_a2p0x @ Word8 $dIntegral_a2p0z
      = . @ Int
          @ Word8
          @ Double
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (round @ Double $dRealFrac_a2p0x @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Word8,Float)"
    forall ($dRealFrac_a2p1b :: RealFrac Float)
           ($dIntegral_a2p1d :: Integral Word8).
      properFraction @ Float $dRealFrac_a2p1b @ Word8 $dIntegral_a2p1d
      = \ (x_a2o2O :: Float) ->
          case properFraction
                 @ Float $dRealFrac_a2p1b @ Int GHC.Real.$fIntegralInt x_a2o2O
          of
          { (n_a2o2P, y_a2o2Q) ->
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8 n_a2o2P,
           y_a2o2Q)
          }
"truncate/Float->Word8"
    forall ($dRealFrac_a2p1O :: RealFrac Float)
           ($dIntegral_a2p1Q :: Integral Word8).
      truncate @ Float $dRealFrac_a2p1O @ Word8 $dIntegral_a2p1Q
      = . @ Int
          @ Word8
          @ Float
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (truncate @ Float $dRealFrac_a2p1O @ Int GHC.Real.$fIntegralInt)
"floor/Float->Word8"
    forall ($dRealFrac_a2p2s :: RealFrac Float)
           ($dIntegral_a2p2u :: Integral Word8).
      floor @ Float $dRealFrac_a2p2s @ Word8 $dIntegral_a2p2u
      = . @ Int
          @ Word8
          @ Float
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (floor @ Float $dRealFrac_a2p2s @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Word8"
    forall ($dRealFrac_a2p36 :: RealFrac Float)
           ($dIntegral_a2p38 :: Integral Word8).
      ceiling @ Float $dRealFrac_a2p36 @ Word8 $dIntegral_a2p38
      = . @ Int
          @ Word8
          @ Float
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (ceiling @ Float $dRealFrac_a2p36 @ Int GHC.Real.$fIntegralInt)
"round/Float->Word8"
    forall ($dRealFrac_a2p3K :: RealFrac Float)
           ($dIntegral_a2p3M :: Integral Word8).
      round @ Float $dRealFrac_a2p3K @ Word8 $dIntegral_a2p3M
      = . @ Int
          @ Word8
          @ Float
          (fromIntegral
             @ Int @ Word8 GHC.Real.$fIntegralInt GHC.Word.$fNumWord8)
          (round @ Float $dRealFrac_a2p3K @ Int GHC.Real.$fIntegralInt)
"fromIntegral/Word8->Word8"
    forall ($dIntegral_a2p4p :: Integral Word8)
           ($dNum_a2p4q :: Num Word8).
      fromIntegral @ Word8 @ Word8 $dIntegral_a2p4p $dNum_a2p4q
      = id @ Word8
"fromIntegral/Word8->Integer"
    forall ($dIntegral_a2p4I :: Integral Word8)
           ($dNum_a2p4J :: Num Integer).
      fromIntegral @ Word8 @ Integer $dIntegral_a2p4I $dNum_a2p4J
      = GHC.Word.$ctoInteger
"fromIntegral/a->Word8"
    forall (@ a_a2p56)
           ($dIntegral_a2p53 :: Integral a_a2p56)
           ($dNum_a2p54 :: Num Word8).
      fromIntegral @ a_a2p56 @ Word8 $dIntegral_a2p53 $dNum_a2p54
      = \ (x_a2o2R :: a_a2p56) ->
          case fromIntegral
                 @ a_a2p56 @ Word $dIntegral_a2p53 GHC.Num.$fNumWord x_a2o2R
          of
          { W# x#_a2o2S ->
          GHC.Word.W8# (narrow8Word# x#_a2o2S)
          }
"fromIntegral/Word8->a"
    forall (@ b_a2p5l)
           ($dIntegral_a2p5m :: Integral Word8)
           ($dNum_a2p5n :: Num b_a2p5l).
      fromIntegral @ Word8 @ b_a2p5l $dIntegral_a2p5m $dNum_a2p5n
      = \ (ds_d2pEQ :: Word8) ->
          case ds_d2pEQ of { W8# x#_a2o2T ->
          fromIntegral
            @ Word
            @ b_a2p5l
            GHC.Real.$fIntegralWord
            $dNum_a2p5n
            (GHC.Types.W# x#_a2o2T)
          }

