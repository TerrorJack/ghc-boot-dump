
==================== Tidy Core ====================
2018-03-16 15:54:59.636625121 UTC

Result size of Tidy Core
  = {terms: 388, types: 392, coercions: 0, joins: 0/0}

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
+ :: forall a. Num a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>,
 RULES: Built in rule for +: "Class op +"]
+ = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
- :: forall a. Num a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>,
 RULES: Built in rule for -: "Class op -"]
- = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
* :: forall a. Num a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>,
 RULES: Built in rule for *: "Class op *"]
* = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
negate :: forall a. Num a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>,
 RULES: Built in rule for negate: "Class op negate"]
negate
  = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
abs :: forall a. Num a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>,
 RULES: Built in rule for abs: "Class op abs"]
abs
  = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
signum :: forall a. Num a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>,
 RULES: Built in rule for signum: "Class op signum"]
signum
  = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B7
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
fromInteger :: forall a. Num a => Integer -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>,
 RULES: Built in rule for fromInteger: "Class op fromInteger"]
fromInteger
  = \ (@ a_alGX) (v_B1 :: Num a_alGX) ->
      case v_B1 of v_B1
      { GHC.Num.C:Num v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B8
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$cfromInteger [InlPrag=INLINE (sat-args=1)]
  :: Integer -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_alHk [Occ=Once] :: Integer) ->
                 case integerToInt i_alHk of wild_XF { __DEFAULT ->
                 GHC.Types.I# wild_XF
                 }}]
GHC.Num.$fNumInt_$cfromInteger
  = \ (i_alHk :: Integer) ->
      case integerToInt i_alHk of wild_XF { __DEFAULT ->
      GHC.Types.I# wild_XF
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$cnegate :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMQ [Occ=Once!] :: Int) ->
                 case ds_dlMQ of { I# x_alHf [Occ=Once] ->
                 GHC.Types.I# (negateInt# x_alHf)
                 }}]
GHC.Num.$fNumInt_$cnegate
  = \ (ds_dlMQ :: Int) ->
      case ds_dlMQ of { I# x_alHf -> GHC.Types.I# (negateInt# x_alHf) }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$c* :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMJ [Occ=Once!] :: Int)
                 (ds1_dlMK [Occ=Once!] :: Int) ->
                 case ds_dlMJ of { I# x_alHg [Occ=Once] ->
                 case ds1_dlMK of { I# y_alHh [Occ=Once] ->
                 GHC.Types.I# (*# x_alHg y_alHh)
                 }
                 }}]
GHC.Num.$fNumInt_$c*
  = \ (ds_dlMJ :: Int) (ds1_dlMK :: Int) ->
      case ds_dlMJ of { I# x_alHg ->
      case ds1_dlMK of { I# y_alHh -> GHC.Types.I# (*# x_alHg y_alHh) }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$c- :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMC [Occ=Once!] :: Int)
                 (ds1_dlMD [Occ=Once!] :: Int) ->
                 case ds_dlMC of { I# x_alHd [Occ=Once] ->
                 case ds1_dlMD of { I# y_alHe [Occ=Once] ->
                 GHC.Types.I# (-# x_alHd y_alHe)
                 }
                 }}]
GHC.Num.$fNumInt_$c-
  = \ (ds_dlMC :: Int) (ds1_dlMD :: Int) ->
      case ds_dlMC of { I# x_alHd ->
      case ds1_dlMD of { I# y_alHe -> GHC.Types.I# (-# x_alHd y_alHe) }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$c+ :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMv [Occ=Once!] :: Int)
                 (ds1_dlMw [Occ=Once!] :: Int) ->
                 case ds_dlMv of { I# x_alHb [Occ=Once] ->
                 case ds1_dlMw of { I# y_alHc [Occ=Once] ->
                 GHC.Types.I# (+# x_alHb y_alHc)
                 }
                 }}]
GHC.Num.$fNumInt_$c+
  = \ (ds_dlMv :: Int) (ds1_dlMw :: Int) ->
      case ds_dlMv of { I# x_alHb ->
      case ds1_dlMw of { I# y_alHc -> GHC.Types.I# (+# x_alHb y_alHc) }
      }

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$cabs :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_alHi [Occ=Once!] :: Int) ->
                 case n_alHi of wild_alMW { I# x_alMY ->
                 case >=# x_alMY 0# of {
                   __DEFAULT -> GHC.Types.I# (negateInt# x_alMY);
                   1# -> wild_alMW
                 }
                 }}]
GHC.Num.$fNumInt_$cabs
  = \ (n_alHi :: Int) ->
      case n_alHi of wild_alMW { I# x_alMY ->
      case >=# x_alMY 0# of {
        __DEFAULT -> GHC.Types.I# (negateInt# x_alMY);
        1# -> wild_alMW
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$fNumInt3 = GHC.Types.I# 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$fNumInt2 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$fNumInt1 = GHC.Types.I# -1#

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt_$csignum :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_alHj [Occ=Once!] :: Int) ->
                 case n_alHj of { I# x_alN9 ->
                 case <# x_alN9 0# of {
                   __DEFAULT ->
                     case x_alN9 of {
                       __DEFAULT -> GHC.Num.$fNumInt3;
                       0# -> GHC.Num.$fNumInt2
                     };
                   1# -> GHC.Num.$fNumInt1
                 }
                 }}]
GHC.Num.$fNumInt_$csignum
  = \ (n_alHj :: Int) ->
      case n_alHj of { I# x_alN9 ->
      case <# x_alN9 0# of {
        __DEFAULT ->
          case x_alN9 of {
            __DEFAULT -> GHC.Num.$fNumInt3;
            0# -> GHC.Num.$fNumInt2
          };
        1# -> GHC.Num.$fNumInt1
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Num.$fNumInt [InlPrag=NOUSERINLINE CONLIKE] :: Num Int
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Int
                     GHC.Num.$fNumInt_$c+
                     GHC.Num.$fNumInt_$c-
                     GHC.Num.$fNumInt_$c*
                     GHC.Num.$fNumInt_$cnegate
                     GHC.Num.$fNumInt_$cabs
                     GHC.Num.$fNumInt_$csignum
                     GHC.Num.$fNumInt_$cfromInteger]
GHC.Num.$fNumInt
  = GHC.Num.C:Num
      @ Int
      GHC.Num.$fNumInt_$c+
      GHC.Num.$fNumInt_$c-
      GHC.Num.$fNumInt_$c*
      GHC.Num.$fNumInt_$cnegate
      GHC.Num.$fNumInt_$cabs
      GHC.Num.$fNumInt_$csignum
      GHC.Num.$fNumInt_$cfromInteger

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$cfromInteger :: Integer -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_alHa [Occ=Once] :: Integer) ->
                 case integerToWord i_alHa of wild_XN { __DEFAULT ->
                 GHC.Types.W# wild_XN
                 }}]
GHC.Num.$fNumWord_$cfromInteger
  = \ (i_alHa :: Integer) ->
      case integerToWord i_alHa of wild_XN { __DEFAULT ->
      GHC.Types.W# wild_XN
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord2 :: Word
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$fNumWord2 = GHC.Types.W# 1##

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord1 :: Word
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$fNumWord1 = GHC.Types.W# 0##

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$csignum :: Word -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMo [Occ=Once!] :: Word) ->
                 case ds_dlMo of { W# ds1_dlMr [Occ=Once!] ->
                 case ds1_dlMr of {
                   __DEFAULT -> GHC.Num.$fNumWord2;
                   0## -> GHC.Num.$fNumWord1
                 }
                 }}]
GHC.Num.$fNumWord_$csignum
  = \ (ds_dlMo :: Word) ->
      case ds_dlMo of { W# ds1_dlMr ->
      case ds1_dlMr of {
        __DEFAULT -> GHC.Num.$fNumWord2;
        0## -> GHC.Num.$fNumWord1
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$cabs :: Word -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_alH9 [Occ=Once] :: Word) -> x_alH9}]
GHC.Num.$fNumWord_$cabs = \ (x_alH9 :: Word) -> x_alH9

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$cnegate :: Word -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMj [Occ=Once!] :: Word) ->
                 case ds_dlMj of { W# x#_alH8 [Occ=Once] ->
                 GHC.Types.W# (int2Word# (negateInt# (word2Int# x#_alH8)))
                 }}]
GHC.Num.$fNumWord_$cnegate
  = \ (ds_dlMj :: Word) ->
      case ds_dlMj of { W# x#_alH8 ->
      GHC.Types.W# (int2Word# (negateInt# (word2Int# x#_alH8)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$c* :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlMc [Occ=Once!] :: Word)
                 (ds1_dlMd [Occ=Once!] :: Word) ->
                 case ds_dlMc of { W# x#_alH6 [Occ=Once] ->
                 case ds1_dlMd of { W# y#_alH7 [Occ=Once] ->
                 GHC.Types.W# (timesWord# x#_alH6 y#_alH7)
                 }
                 }}]
GHC.Num.$fNumWord_$c*
  = \ (ds_dlMc :: Word) (ds1_dlMd :: Word) ->
      case ds_dlMc of { W# x#_alH6 ->
      case ds1_dlMd of { W# y#_alH7 ->
      GHC.Types.W# (timesWord# x#_alH6 y#_alH7)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$c- :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlM5 [Occ=Once!] :: Word)
                 (ds1_dlM6 [Occ=Once!] :: Word) ->
                 case ds_dlM5 of { W# x#_alH4 [Occ=Once] ->
                 case ds1_dlM6 of { W# y#_alH5 [Occ=Once] ->
                 GHC.Types.W# (minusWord# x#_alH4 y#_alH5)
                 }
                 }}]
GHC.Num.$fNumWord_$c-
  = \ (ds_dlM5 :: Word) (ds1_dlM6 :: Word) ->
      case ds_dlM5 of { W# x#_alH4 ->
      case ds1_dlM6 of { W# y#_alH5 ->
      GHC.Types.W# (minusWord# x#_alH4 y#_alH5)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord_$c+ :: Word -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dlLY [Occ=Once!] :: Word)
                 (ds1_dlLZ [Occ=Once!] :: Word) ->
                 case ds_dlLY of { W# x#_alH2 [Occ=Once] ->
                 case ds1_dlLZ of { W# y#_alH3 [Occ=Once] ->
                 GHC.Types.W# (plusWord# x#_alH2 y#_alH3)
                 }
                 }}]
GHC.Num.$fNumWord_$c+
  = \ (ds_dlLY :: Word) (ds1_dlLZ :: Word) ->
      case ds_dlLY of { W# x#_alH2 ->
      case ds1_dlLZ of { W# y#_alH3 ->
      GHC.Types.W# (plusWord# x#_alH2 y#_alH3)
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Num.$fNumWord [InlPrag=NOUSERINLINE CONLIKE] :: Num Word
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Word
                     GHC.Num.$fNumWord_$c+
                     GHC.Num.$fNumWord_$c-
                     GHC.Num.$fNumWord_$c*
                     GHC.Num.$fNumWord_$cnegate
                     GHC.Num.$fNumWord_$cabs
                     GHC.Num.$fNumWord_$csignum
                     GHC.Num.$fNumWord_$cfromInteger]
GHC.Num.$fNumWord
  = GHC.Num.C:Num
      @ Word
      GHC.Num.$fNumWord_$c+
      GHC.Num.$fNumWord_$c-
      GHC.Num.$fNumWord_$c*
      GHC.Num.$fNumWord_$cnegate
      GHC.Num.$fNumWord_$cabs
      GHC.Num.$fNumWord_$csignum
      GHC.Num.$fNumWord_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Num.$fNumInteger_$cfromInteger :: Integer -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_alH1 [Occ=Once] :: Integer) -> x_alH1}]
GHC.Num.$fNumInteger_$cfromInteger
  = \ (x_alH1 :: Integer) -> x_alH1

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Num.$fNumInteger [InlPrag=NOUSERINLINE CONLIKE] :: Num Integer
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Integer
                     plusInteger
                     minusInteger
                     timesInteger
                     negateInteger
                     absInteger
                     signumInteger
                     GHC.Num.$fNumInteger_$cfromInteger]
GHC.Num.$fNumInteger
  = GHC.Num.C:Num
      @ Integer
      plusInteger
      minusInteger
      timesInteger
      negateInteger
      absInteger
      signumInteger
      GHC.Num.$fNumInteger_$cfromInteger

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rlU7 :: Integer
[GblId, Unf=OtherCon []]
lvl_rlU7 = 0

-- RHS size: {terms: 9, types: 7, coercions: 0, joins: 0/0}
GHC.Num.$dmnegate [InlPrag=INLINE (sat-args=1)]
  :: forall a. Num a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_alGX)
                 ($dNum_alJz :: Num a_alGX)
                 (x_alH0 [Occ=Once] :: a_alGX) ->
                 - @ a_alGX $dNum_alJz (fromInteger @ a_alGX $dNum_alJz 0) x_alH0}]
GHC.Num.$dmnegate
  = \ (@ a_alGX) ($dNum_alJz :: Num a_alGX) (x_alH0 :: a_alGX) ->
      - @ a_alGX
        $dNum_alJz
        (fromInteger @ a_alGX $dNum_alJz lvl_rlU7)
        x_alH0

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
GHC.Num.$dm- [InlPrag=INLINE (sat-args=2)]
  :: forall a. Num a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_alGX)
                 ($dNum_alJz :: Num a_alGX)
                 (x_alGY [Occ=Once] :: a_alGX)
                 (y_alGZ [Occ=Once] :: a_alGX) ->
                 + @ a_alGX $dNum_alJz x_alGY (negate @ a_alGX $dNum_alJz y_alGZ)}]
GHC.Num.$dm-
  = \ (@ a_alGX)
      ($dNum_alJz :: Num a_alGX)
      (x_alGY :: a_alGX)
      (y_alGZ :: a_alGX) ->
      + @ a_alGX $dNum_alJz x_alGY (negate @ a_alGX $dNum_alJz y_alGZ)

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
subtract [InlPrag=INLINE (sat-args=2)]
  :: forall a. Num a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_alJt)
                 ($dNum_alJv [Occ=Once] :: Num a_alJt)
                 (x_alHm [Occ=Once] :: a_alJt)
                 (y_alHn [Occ=Once] :: a_alJt) ->
                 - @ a_alJt $dNum_alJv y_alHn x_alHm}]
subtract
  = \ (@ a_alJt)
      ($dNum_alJv :: Num a_alJt)
      (eta_B2 :: a_alJt)
      (eta1_B1 :: a_alJt) ->
      - @ a_alJt $dNum_alJv eta1_B1 eta_B2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Num.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$trModule3 = GHC.Types.TrNameS GHC.Num.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Num.$trModule2 = "GHC.Num"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$trModule1 = GHC.Types.TrNameS GHC.Num.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Num.$trModule
  = GHC.Types.Module GHC.Num.$trModule3 GHC.Num.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rlU8 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rlU8
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rlU9 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rlU9
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tcNum1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Num.$tcNum1 = GHC.Types.KindRepFun GHC.Types.krep$* $krep1_rlU9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rlUa :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rlUa = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rlUb :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep3_rlUb = GHC.Types.KindRepFun $krep2_rlUa $krep2_rlUa

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_rlUc :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep4_rlUc = GHC.Types.KindRepFun $krep2_rlUa $krep3_rlUb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rlUd :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_rlUd = GHC.Types.KindRepFun $krep_rlU8 $krep2_rlUa

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tcNum3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Num.$tcNum3 = "Num"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tcNum2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$tcNum2 = GHC.Types.TrNameS GHC.Num.$tcNum3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tcNum :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Num.$tcNum
  = GHC.Types.TyCon
      4789207468288702218##
      12287762746798050066##
      GHC.Num.$trModule
      GHC.Num.$tcNum2
      0#
      GHC.Num.$tcNum1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_rlUe :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_rlUe
  = GHC.Types.: @ KindRep $krep2_rlUa (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rlUf :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_rlUf = GHC.Types.KindRepTyConApp GHC.Num.$tcNum $krep6_rlUe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rlUg :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep8_rlUg = GHC.Types.KindRepFun $krep5_rlUd $krep7_rlUf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_rlUh :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_rlUh = GHC.Types.KindRepFun $krep3_rlUb $krep8_rlUg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_rlUi :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_rlUi = GHC.Types.KindRepFun $krep3_rlUb $krep9_rlUh

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_rlUj :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_rlUj = GHC.Types.KindRepFun $krep3_rlUb $krep10_rlUi

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rlUk :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_rlUk = GHC.Types.KindRepFun $krep4_rlUc $krep11_rlUj

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rlUl :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep13_rlUl = GHC.Types.KindRepFun $krep4_rlUc $krep12_rlUk

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tc'C:Num1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Num.$tc'C:Num1 = GHC.Types.KindRepFun $krep4_rlUc $krep13_rlUl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tc'C:Num3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Num.$tc'C:Num3 = "'C:Num"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tc'C:Num2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Num.$tc'C:Num2 = GHC.Types.TrNameS GHC.Num.$tc'C:Num3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Num.$tc'C:Num :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Num.$tc'C:Num
  = GHC.Types.TyCon
      277567704124416124##
      17341550453118006986##
      GHC.Num.$trModule
      GHC.Num.$tc'C:Num2
      1#
      GHC.Num.$tc'C:Num1


