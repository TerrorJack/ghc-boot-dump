
==================== Output Cmm ====================
2018-03-16 15:59:02.929386632 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:02.930483728 UTC

[section ""data" . GHC.Fingerprint.Type.$WFingerprint_closure" {
     GHC.Fingerprint.Type.$WFingerprint_closure:
         const GHC.Fingerprint.Type.$WFingerprint_info;
 },
 GHC.Fingerprint.Type.$WFingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4a2t,
                       label: GHC.Fingerprint.Type.$WFingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a2t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4a2C; else goto c4a2D;
       c4a2C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$WFingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a2D: // global
           I64[Sp - 16] = block_c4a2q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a2J; else goto c4a2r;
       u4a2J: // global
           call _c4a2q(R1) args: 0, res: 0, upd: 0;
       c4a2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a2q() //  [R1]
         { info_tbl: [(c4a2q,
                       label: block_c4a2q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a2q: // global
           I64[Sp] = block_c4a2w_info;
           _s4a08::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4a08::I64;
           if (R1 & 7 != 0) goto u4a2I; else goto c4a2x;
       u4a2I: // global
           call _c4a2w(R1) args: 0, res: 0, upd: 0;
       c4a2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a2w() //  [R1]
         { info_tbl: [(c4a2w,
                       label: block_c4a2w_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a2w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4a2H; else goto c4a2G;
       c4a2H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4a2G: // global
           _s4a0a::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _s4a0a::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.931834141 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint3_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint3_closure:
         const GHC.Word.W64#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.932379059 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint2_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint2_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.933839726 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_info;
         const 0;
 },
 sat_s4a0l_entry() //  [R1]
         { info_tbl: [(c4a3h,
                       label: sat_s4a0l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4a3i; else goto c4a3j;
       c4a3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4a3j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s4a0h_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s4a0h_entry() //  [R1, R2]
         { info_tbl: [(c4a3n,
                       label: $wxs_s4a0h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3n: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4a3r; else goto c4a3q;
       c4a3r: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4a3q: // global
           if (R2 == 1) goto c4a3m; else goto c4a3l;
       c4a3m: // global
           _s4a0g::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s4a0g::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a3l: // global
           I64[Hp - 48] = sat_s4a0l_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry() //  [R2]
         { info_tbl: [(c4a3t,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_hex16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4a3u; else goto c4a3v;
       c4a3u: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4a3v: // global
           I64[Sp - 8] = block_c4a2O_info;
           R6 = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = GHC.Fingerprint.Type.$fShowFingerprint3_closure+1;
           R3 = GHC.Word.$fShowWord64_closure;
           R2 = GHC.Word.$fIntegralWord64_closure;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _c4a2O() //  [R1]
         { info_tbl: [(c4a2O,
                       label: block_c4a2O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a2O: // global
           I64[Sp - 8] = block_c4a2S_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4a2S() //  [R1]
         { info_tbl: [(c4a2S,
                       label: block_c4a2S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a2S: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4a3z; else goto c4a3y;
       c4a3z: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4a3y: // global
           _s4a0c::P64 = P64[Sp + 8];
           _s4a0e::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s4a0e::I64)) goto c4a3B; else goto c4a3C;
       c4a3B: // global
           Hp = Hp - 40;
           R1 = _s4a0c::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4a3C: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp - 16] = _s4a0c::P64;
           I64[Hp - 8] = $wxs_s4a0h_info;
           P64[Hp] = Hp - 30;
           R2 = _s4a0e::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call $wxs_s4a0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.936271223 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshow_closure" {
     GHC.Fingerprint.Type.$w$cshow_closure:
         const GHC.Fingerprint.Type.$w$cshow_info;
         const 0;
 },
 sat_s4a0r_entry() //  [R1]
         { info_tbl: [(c4a3N,
                       label: sat_s4a0r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4a3R; else goto c4a3Q;
       c4a3R: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4a3Q: // global
           _s4a0n::I64 = I64[R1 + 16];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0n::I64;
           R2 = Hp - 7;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshow_entry() //  [R2, R3]
         { info_tbl: [(c4a3V,
                       label: GHC.Fingerprint.Type.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3V: // global
           _s4a0n::I64 = R3;
           _s4a0m::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4a3W; else goto c4a3X;
       c4a3X: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4a3Z; else goto c4a3Y;
       c4a3Z: // global
           HpAlloc = 40;
           goto c4a3W;
       c4a3W: // global
           R3 = _s4a0n::I64;
           R2 = _s4a0m::I64;
           R1 = GHC.Fingerprint.Type.$w$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a3Y: // global
           I64[Hp - 32] = sat_s4a0r_info;
           I64[Hp - 16] = _s4a0n::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0m::I64;
           I64[Sp - 16] = block_c4a3T_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4a3T() //  [R1]
         { info_tbl: [(c4a3T,
                       label: block_c4a3T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a3T: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.937933779 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshow_entry() //  [R2]
         { info_tbl: [(c4a4a,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4a4b; else goto c4a4c;
       c4a4b: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4a4c: // global
           I64[Sp - 8] = block_c4a47_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a4g; else goto c4a48;
       u4a4g: // global
           call _c4a47(R1) args: 0, res: 0, upd: 0;
       c4a48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a47() //  [R1]
         { info_tbl: [(c4a47,
                       label: block_c4a47_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a47: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Fingerprint.Type.$w$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.93939084 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$w$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$w$cshowsPrec_info;
         const 0;
 },
 sat_s4a0D_entry() //  [R1]
         { info_tbl: [(c4a4s,
                       label: sat_s4a0D_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4s: // global
           _s4a0D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4a4t; else goto c4a4u;
       c4a4u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4a4w; else goto c4a4v;
       c4a4w: // global
           HpAlloc = 16;
           goto c4a4t;
       c4a4t: // global
           R1 = _s4a0D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4a4v: // global
           _s4a0y::P64 = P64[_s4a0D::P64 + 16];
           _s4a0x::I64 = I64[_s4a0D::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0x::I64;
           I64[Sp - 16] = block_c4a4q_info;
           R2 = Hp - 7;
           P64[Sp - 8] = _s4a0y::P64;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4a4q() //  [R1]
         { info_tbl: [(c4a4q,
                       label: block_c4a4q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4q: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4a4D,
                       label: GHC.Fingerprint.Type.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4D: // global
           _s4a0y::P64 = R4;
           _s4a0x::I64 = R3;
           _s4a0w::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4a4E; else goto c4a4F;
       c4a4F: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4a4H; else goto c4a4G;
       c4a4H: // global
           HpAlloc = 48;
           goto c4a4E;
       c4a4E: // global
           R4 = _s4a0y::P64;
           R3 = _s4a0x::I64;
           R2 = _s4a0w::I64;
           R1 = GHC.Fingerprint.Type.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a4G: // global
           I64[Hp - 40] = sat_s4a0D_info;
           P64[Hp - 24] = _s4a0y::P64;
           I64[Hp - 16] = _s4a0x::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0w::I64;
           I64[Sp - 16] = block_c4a4B_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4a4B() //  [R1]
         { info_tbl: [(c4a4B,
                       label: block_c4a4B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4B: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.941158422 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(c4a4S,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4a4T; else goto c4a4U;
       c4a4T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a4U: // global
           I64[Sp - 16] = block_c4a4P_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a4Y; else goto c4a4Q;
       u4a4Y: // global
           call _c4a4P(R1) args: 0, res: 0, upd: 0;
       c4a4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a4P() //  [R1]
         { info_tbl: [(c4a4P,
                       label: block_c4a4P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a4P: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.942449793 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint1_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint1_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint1_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4a56,
                       label: GHC.Fingerprint.Type.$fShowFingerprint1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a56: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4a57; else goto c4a58;
       c4a57: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a58: // global
           I64[Sp - 16] = block_c4a53_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a5c; else goto c4a54;
       u4a5c: // global
           call _c4a53(R1) args: 0, res: 0, upd: 0;
       c4a54: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a53() //  [R1]
         { info_tbl: [(c4a53,
                       label: block_c4a53_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a53: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.943643949 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c4a5h,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a5h: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Fingerprint.Type.$fShowFingerprint1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.944422791 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure+3;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure+1;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.945541675 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4a5r,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a5r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a5v; else goto c4a5w;
       c4a5v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a5w: // global
           I64[Sp - 16] = block_c4a5o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a5R; else goto c4a5p;
       u4a5R: // global
           call _c4a5o(R1) args: 0, res: 0, upd: 0;
       c4a5p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a5o() //  [R1]
         { info_tbl: [(c4a5o,
                       label: block_c4a5o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a5o: // global
           I64[Sp - 8] = block_c4a5u_info;
           _s4a0U::I64 = I64[R1 + 7];
           _s4a0V::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a0V::I64;
           I64[Sp + 8] = _s4a0U::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a5Q; else goto c4a5y;
       u4a5Q: // global
           call _c4a5u(R1) args: 0, res: 0, upd: 0;
       c4a5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a5u() //  [R1]
         { info_tbl: [(c4a5u,
                       label: block_c4a5u_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a5u: // global
           _s4a0U::I64 = I64[Sp + 16];
           _s4a0X::I64 = I64[R1 + 7];
           if (_s4a0U::I64 == _s4a0X::I64) goto c4a5N; else goto c4a5M;
       c4a5N: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a5M: // global
           if (_s4a0U::I64 > _s4a0X::I64) goto c4a5J; else goto c4a5K;
       c4a5J: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a5K: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.947342563 UTC

[section ""data" . GHC.Fingerprint.Type.$w$ccompare_closure" {
     GHC.Fingerprint.Type.$w$ccompare_closure:
         const GHC.Fingerprint.Type.$w$ccompare_info;
 },
 GHC.Fingerprint.Type.$w$ccompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a5T: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4a62,
                       label: GHC.Fingerprint.Type.$w$ccompare_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a62: // global
           if (R2 == R4) goto c4a61; else goto c4a60;
       c4a61: // global
           if (R3 == R5) goto c4a6m; else goto c4a6l;
       c4a6m: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a6l: // global
           if (R3 > R5) goto c4a6i; else goto c4a6j;
       c4a60: // global
           if (R2 > R4) goto c4a6i; else goto c4a6j;
       c4a6i: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a6j: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.948712667 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c4a6u,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a6y; else goto c4a6z;
       c4a6y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a6z: // global
           I64[Sp - 16] = block_c4a6r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a6H; else goto c4a6s;
       u4a6H: // global
           call _c4a6r(R1) args: 0, res: 0, upd: 0;
       c4a6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a6r() //  [R1]
         { info_tbl: [(c4a6r,
                       label: block_c4a6r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6r: // global
           I64[Sp - 8] = block_c4a6x_info;
           _s4a1d::I64 = I64[R1 + 7];
           _s4a1e::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1e::I64;
           I64[Sp + 8] = _s4a1d::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a6G; else goto c4a6B;
       u4a6G: // global
           call _c4a6x(R1) args: 0, res: 0, upd: 0;
       c4a6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a6x() //  [R1]
         { info_tbl: [(c4a6x,
                       label: block_c4a6x_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6x: // global
           R5 = I64[R1 + 15];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.950544084 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4a6P,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a6T; else goto c4a6U;
       c4a6T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a6U: // global
           I64[Sp - 16] = block_c4a6M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a7a; else goto c4a6N;
       u4a7a: // global
           call _c4a6M(R1) args: 0, res: 0, upd: 0;
       c4a6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a6M() //  [R1]
         { info_tbl: [(c4a6M,
                       label: block_c4a6M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6M: // global
           I64[Sp - 8] = block_c4a6S_info;
           _s4a1l::I64 = I64[R1 + 7];
           _s4a1m::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1m::I64;
           I64[Sp + 8] = _s4a1l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a79; else goto c4a6W;
       u4a79: // global
           call _c4a6S(R1) args: 0, res: 0, upd: 0;
       c4a6W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a6S() //  [R1]
         { info_tbl: [(c4a6S,
                       label: block_c4a6S_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a6S: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto c4a75; else goto c4a74;
       c4a75: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a74: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.952310092 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4a7i,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a7m; else goto c4a7n;
       c4a7m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a7n: // global
           I64[Sp - 16] = block_c4a7f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a7H; else goto c4a7g;
       u4a7H: // global
           call _c4a7f(R1) args: 0, res: 0, upd: 0;
       c4a7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a7f() //  [R1]
         { info_tbl: [(c4a7f,
                       label: block_c4a7f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7f: // global
           I64[Sp - 8] = block_c4a7l_info;
           _s4a1v::I64 = I64[R1 + 7];
           _s4a1w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1w::I64;
           I64[Sp + 8] = _s4a1v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a7G; else goto c4a7p;
       u4a7G: // global
           call _c4a7l(R1) args: 0, res: 0, upd: 0;
       c4a7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a7l() //  [R1]
         { info_tbl: [(c4a7l,
                       label: block_c4a7l_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7l: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto c4a7D; else goto c4a7F;
       c4a7F: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto c4a7D; else goto c4a7E;
       c4a7D: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a7E: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.953680913 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure+2;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.954729281 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4a7P,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a7T; else goto c4a7U;
       c4a7T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a7U: // global
           I64[Sp - 16] = block_c4a7M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a8j; else goto c4a7N;
       u4a8j: // global
           call _c4a7M(R1) args: 0, res: 0, upd: 0;
       c4a7N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a7M() //  [R1]
         { info_tbl: [(c4a7M,
                       label: block_c4a7M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7M: // global
           I64[Sp - 8] = block_c4a7S_info;
           _s4a1F::I64 = I64[R1 + 7];
           _s4a1G::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1G::I64;
           I64[Sp + 8] = _s4a1F::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a8i; else goto c4a7W;
       u4a8i: // global
           call _c4a7S(R1) args: 0, res: 0, upd: 0;
       c4a7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a7S() //  [R1]
         { info_tbl: [(c4a7S,
                       label: block_c4a7S_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a7S: // global
           _s4a1F::I64 = I64[Sp + 16];
           _s4a1I::I64 = I64[R1 + 7];
           if (_s4a1F::I64 == _s4a1I::I64) goto c4a8h; else goto c4a8a;
       c4a8h: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4a8f; else goto c4a8g;
       c4a8a: // global
           if (_s4a1F::I64 > _s4a1I::I64) goto c4a8f; else goto c4a8g;
       c4a8f: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a8g: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.956690327 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4a8r,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a8r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4a8v; else goto c4a8w;
       c4a8v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a8w: // global
           I64[Sp - 16] = block_c4a8o_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a8V; else goto c4a8p;
       u4a8V: // global
           call _c4a8o(R1) args: 0, res: 0, upd: 0;
       c4a8p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a8o() //  [R1]
         { info_tbl: [(c4a8o,
                       label: block_c4a8o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a8o: // global
           I64[Sp - 16] = block_c4a8u_info;
           _s4a1P::P64 = R1;
           _s4a1Q::I64 = I64[R1 + 7];
           _s4a1R::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a1R::I64;
           I64[Sp] = _s4a1Q::I64;
           P64[Sp + 8] = _s4a1P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a8U; else goto c4a8y;
       u4a8U: // global
           call _c4a8u(R1) args: 0, res: 0, upd: 0;
       c4a8y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a8u() //  [R1]
         { info_tbl: [(c4a8u,
                       label: block_c4a8u_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a8u: // global
           _s4a1P::P64 = P64[Sp + 24];
           _s4a1Q::I64 = I64[Sp + 16];
           _s4a1T::I64 = I64[R1 + 7];
           if (_s4a1Q::I64 == _s4a1T::I64) goto c4a8T; else goto c4a8M;
       c4a8T: // global
           _s4a1S::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4a8R; else goto c4a8S;
       c4a8M: // global
           _s4a1S::P64 = R1;
           if (_s4a1Q::I64 > _s4a1T::I64) goto c4a8R; else goto c4a8S;
       c4a8R: // global
           R1 = _s4a1P::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4a8S: // global
           R1 = _s4a1S::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.959935271 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4a93,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a93: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4a97; else goto c4a98;
       c4a97: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a98: // global
           I64[Sp - 16] = block_c4a90_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4a9x; else goto c4a91;
       u4a9x: // global
           call _c4a90(R1) args: 0, res: 0, upd: 0;
       c4a91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a90() //  [R1]
         { info_tbl: [(c4a90,
                       label: block_c4a90_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a90: // global
           I64[Sp - 8] = block_c4a96_info;
           _s4a21::I64 = I64[R1 + 7];
           _s4a22::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a22::I64;
           I64[Sp + 8] = _s4a21::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4a9w; else goto c4a9a;
       u4a9w: // global
           call _c4a96(R1) args: 0, res: 0, upd: 0;
       c4a9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a96() //  [R1]
         { info_tbl: [(c4a96,
                       label: block_c4a96_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a96: // global
           _s4a21::I64 = I64[Sp + 16];
           _s4a24::I64 = I64[R1 + 7];
           if (_s4a21::I64 == _s4a24::I64) goto c4a9v; else goto c4a9o;
       c4a9v: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4a9t; else goto c4a9u;
       c4a9o: // global
           if (_s4a21::I64 > _s4a24::I64) goto c4a9t; else goto c4a9u;
       c4a9t: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4a9u: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.961441634 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4a9C,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a9C: // global
           _s4a2a::P64 = R3;
           R3 = R2;
           R2 = _s4a2a::P64;
           call GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.962641921 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4a9M,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a9M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4a9Q; else goto c4a9R;
       c4a9Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4a9R: // global
           I64[Sp - 16] = block_c4a9J_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aag; else goto c4a9K;
       u4aag: // global
           call _c4a9J(R1) args: 0, res: 0, upd: 0;
       c4a9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a9J() //  [R1]
         { info_tbl: [(c4a9J,
                       label: block_c4a9J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a9J: // global
           I64[Sp - 16] = block_c4a9P_info;
           _s4a2d::P64 = R1;
           _s4a2e::I64 = I64[R1 + 7];
           _s4a2f::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a2f::I64;
           I64[Sp] = _s4a2e::I64;
           P64[Sp + 8] = _s4a2d::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aaf; else goto c4a9T;
       u4aaf: // global
           call _c4a9P(R1) args: 0, res: 0, upd: 0;
       c4a9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4a9P() //  [R1]
         { info_tbl: [(c4a9P,
                       label: block_c4a9P_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4a9P: // global
           _s4a2d::P64 = P64[Sp + 24];
           _s4a2e::I64 = I64[Sp + 16];
           _s4a2h::I64 = I64[R1 + 7];
           if (_s4a2e::I64 == _s4a2h::I64) goto c4aae; else goto c4aa7;
       c4aae: // global
           _s4a2g::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aac; else goto c4aad;
       c4aa7: // global
           _s4a2g::P64 = R1;
           if (_s4a2e::I64 > _s4a2h::I64) goto c4aac; else goto c4aad;
       c4aac: // global
           R1 = _s4a2g::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4aad: // global
           R1 = _s4a2d::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.964038364 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_closure+1;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.964647513 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule4_bytes" {
     GHC.Fingerprint.Type.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.96518373 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule3_closure" {
     GHC.Fingerprint.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.965763995 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule2_bytes" {
     GHC.Fingerprint.Type.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.966311066 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule1_closure" {
     GHC.Fingerprint.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.966870309 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule_closure" {
     GHC.Fingerprint.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.Type.$trModule3_closure+1;
         const GHC.Fingerprint.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.967435805 UTC

[section ""data" . $krep_r4a01_closure" {
     $krep_r4a01_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.968013888 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tcFingerprint2_bytes" {
     GHC.Fingerprint.Type.$tcFingerprint2_bytes:
         I8[] [70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.968522204 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint1_closure" {
     GHC.Fingerprint.Type.$tcFingerprint1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.969123898 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint_closure" {
     GHC.Fingerprint.Type.$tcFingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tcFingerprint1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12761381476876783108;
         const 2142724667088540655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.9697714 UTC

[section ""data" . $krep1_r4a02_closure" {
     $krep1_r4a02_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.97032777 UTC

[section ""data" . $krep2_r4a03_closure" {
     $krep2_r4a03_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep1_r4a02_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.970886201 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint1_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep2_r4a03_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.971448916 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tc'Fingerprint3_bytes" {
     GHC.Fingerprint.Type.$tc'Fingerprint3_bytes:
         I8[] [39,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.97198634 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint2_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tc'Fingerprint3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.972549238 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint2_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint1_closure+4;
         const 2008132202540166604;
         const 4312636609190854538;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.97379904 UTC

[section ""data" . GHC.Fingerprint.Type.Fingerprint_closure" {
     GHC.Fingerprint.Type.Fingerprint_closure:
         const GHC.Fingerprint.Type.Fingerprint_info;
 },
 GHC.Fingerprint.Type.Fingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4aam,
                       label: GHC.Fingerprint.Type.Fingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aam: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4aaq; else goto c4aap;
       c4aaq: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.Fingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aap: // global
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.974631083 UTC

[GHC.Fingerprint.Type.Fingerprint_con_entry() //  [R1]
         { info_tbl: [(c4aar,
                       label: GHC.Fingerprint.Type.Fingerprint_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101,46,70,105,110,103,101,114,112,114,105,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aar: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.975317793 UTC

[section ""relreadonly" . S4a3D_srt" {
     S4a3D_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Word.$fShowWord64_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
         const GHC.Fingerprint.Type.$w$cshow_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
         const GHC.Fingerprint.Type.$w$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.975921775 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:02.976790651 UTC

[section ""data" . GHC.Fingerprint.Type.$WFingerprint_closure" {
     GHC.Fingerprint.Type.$WFingerprint_closure:
         const GHC.Fingerprint.Type.$WFingerprint_info;
 },
 GHC.Fingerprint.Type.$WFingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4aaz,
                       label: GHC.Fingerprint.Type.$WFingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aaz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4aaI; else goto c4aaJ;
       c4aaI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$WFingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aaJ: // global
           I64[Sp - 16] = block_c4aaw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aaP; else goto c4aax;
       u4aaP: // global
           call _c4aaw(R1) args: 0, res: 0, upd: 0;
       c4aax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aaw() //  [R1]
         { info_tbl: [(c4aaw,
                       label: block_c4aaw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aaw: // global
           I64[Sp] = block_c4aaC_info;
           _s4a08::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4a08::I64;
           if (R1 & 7 != 0) goto u4aaO; else goto c4aaD;
       u4aaO: // global
           call _c4aaC(R1) args: 0, res: 0, upd: 0;
       c4aaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aaC() //  [R1]
         { info_tbl: [(c4aaC,
                       label: block_c4aaC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aaC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4aaN; else goto c4aaM;
       c4aaN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4aaM: // global
           _s4a0a::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _s4a0a::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.978164827 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint3_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint3_closure:
         const GHC.Word.W64#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.978757317 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint2_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint2_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.980139561 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_info;
         const 0;
 },
 sat_s4a0l_entry() //  [R1]
         { info_tbl: [(c4abn,
                       label: sat_s4a0l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4abn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4abo; else goto c4abp;
       c4abo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4abp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s4a0h_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s4a0h_entry() //  [R1, R2]
         { info_tbl: [(c4abt,
                       label: $wxs_s4a0h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4abt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4abx; else goto c4abw;
       c4abx: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4abw: // global
           if (R2 == 1) goto c4abs; else goto c4abr;
       c4abs: // global
           _s4a0g::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s4a0g::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4abr: // global
           I64[Hp - 48] = sat_s4a0l_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry() //  [R2]
         { info_tbl: [(c4abz,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_hex16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4abz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4abA; else goto c4abB;
       c4abA: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4abB: // global
           I64[Sp - 8] = block_c4aaU_info;
           R6 = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = GHC.Fingerprint.Type.$fShowFingerprint3_closure+1;
           R3 = GHC.Word.$fShowWord64_closure;
           R2 = GHC.Word.$fIntegralWord64_closure;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _c4aaU() //  [R1]
         { info_tbl: [(c4aaU,
                       label: block_c4aaU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aaU: // global
           I64[Sp - 8] = block_c4aaY_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4aaY() //  [R1]
         { info_tbl: [(c4aaY,
                       label: block_c4aaY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aaY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4abF; else goto c4abE;
       c4abF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4abE: // global
           _s4a0c::P64 = P64[Sp + 8];
           _s4a0e::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s4a0e::I64)) goto c4abH; else goto c4abI;
       c4abH: // global
           Hp = Hp - 40;
           R1 = _s4a0c::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4abI: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp - 16] = _s4a0c::P64;
           I64[Hp - 8] = $wxs_s4a0h_info;
           P64[Hp] = Hp - 30;
           R2 = _s4a0e::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call $wxs_s4a0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.982560155 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshow_closure" {
     GHC.Fingerprint.Type.$w$cshow_closure:
         const GHC.Fingerprint.Type.$w$cshow_info;
         const 0;
 },
 sat_s4a0r_entry() //  [R1]
         { info_tbl: [(c4abS,
                       label: sat_s4a0r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4abS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4abW; else goto c4abV;
       c4abW: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4abV: // global
           _s4a0n::I64 = I64[R1 + 16];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0n::I64;
           R2 = Hp - 7;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshow_entry() //  [R2, R3]
         { info_tbl: [(c4ac0,
                       label: GHC.Fingerprint.Type.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ac0: // global
           _s4a0n::I64 = R3;
           _s4a0m::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ac1; else goto c4ac2;
       c4ac2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4ac4; else goto c4ac3;
       c4ac4: // global
           HpAlloc = 40;
           goto c4ac1;
       c4ac1: // global
           R3 = _s4a0n::I64;
           R2 = _s4a0m::I64;
           R1 = GHC.Fingerprint.Type.$w$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ac3: // global
           I64[Hp - 32] = sat_s4a0r_info;
           I64[Hp - 16] = _s4a0n::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0m::I64;
           I64[Sp - 16] = block_c4abY_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4abY() //  [R1]
         { info_tbl: [(c4abY,
                       label: block_c4abY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4abY: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.98409567 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshow_entry() //  [R2]
         { info_tbl: [(c4acf,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4acg; else goto c4ach;
       c4acg: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ach: // global
           I64[Sp - 8] = block_c4acc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4acl; else goto c4acd;
       u4acl: // global
           call _c4acc(R1) args: 0, res: 0, upd: 0;
       c4acd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4acc() //  [R1]
         { info_tbl: [(c4acc,
                       label: block_c4acc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acc: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Fingerprint.Type.$w$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.985563646 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$w$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$w$cshowsPrec_info;
         const 0;
 },
 sat_s4a0D_entry() //  [R1]
         { info_tbl: [(c4acx,
                       label: sat_s4a0D_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acx: // global
           _s4a0D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4acy; else goto c4acz;
       c4acz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4acB; else goto c4acA;
       c4acB: // global
           HpAlloc = 16;
           goto c4acy;
       c4acy: // global
           R1 = _s4a0D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4acA: // global
           _s4a0y::P64 = P64[_s4a0D::P64 + 16];
           _s4a0x::I64 = I64[_s4a0D::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0x::I64;
           I64[Sp - 16] = block_c4acv_info;
           R2 = Hp - 7;
           P64[Sp - 8] = _s4a0y::P64;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4acv() //  [R1]
         { info_tbl: [(c4acv,
                       label: block_c4acv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acv: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4acI,
                       label: GHC.Fingerprint.Type.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acI: // global
           _s4a0y::P64 = R4;
           _s4a0x::I64 = R3;
           _s4a0w::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4acJ; else goto c4acK;
       c4acK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4acM; else goto c4acL;
       c4acM: // global
           HpAlloc = 48;
           goto c4acJ;
       c4acJ: // global
           R4 = _s4a0y::P64;
           R3 = _s4a0x::I64;
           R2 = _s4a0w::I64;
           R1 = GHC.Fingerprint.Type.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4acL: // global
           I64[Hp - 40] = sat_s4a0D_info;
           P64[Hp - 24] = _s4a0y::P64;
           I64[Hp - 16] = _s4a0x::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0w::I64;
           I64[Sp - 16] = block_c4acG_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4acG() //  [R1]
         { info_tbl: [(c4acG,
                       label: block_c4acG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acG: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.987310302 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(c4acX,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4acY; else goto c4acZ;
       c4acY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4acZ: // global
           I64[Sp - 16] = block_c4acU_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ad3; else goto c4acV;
       u4ad3: // global
           call _c4acU(R1) args: 0, res: 0, upd: 0;
       c4acV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4acU() //  [R1]
         { info_tbl: [(c4acU,
                       label: block_c4acU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4acU: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.98860366 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint1_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint1_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint1_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4adb,
                       label: GHC.Fingerprint.Type.$fShowFingerprint1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4adc; else goto c4add;
       c4adc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4add: // global
           I64[Sp - 16] = block_c4ad8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4adh; else goto c4ad9;
       u4adh: // global
           call _c4ad8(R1) args: 0, res: 0, upd: 0;
       c4ad9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ad8() //  [R1]
         { info_tbl: [(c4ad8,
                       label: block_c4ad8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ad8: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.990239422 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c4adm,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adm: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Fingerprint.Type.$fShowFingerprint1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.991014492 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure+3;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure+1;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.992031841 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4adw,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4adA; else goto c4adB;
       c4adA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4adB: // global
           I64[Sp - 16] = block_c4adt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4adW; else goto c4adu;
       u4adW: // global
           call _c4adt(R1) args: 0, res: 0, upd: 0;
       c4adu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4adt() //  [R1]
         { info_tbl: [(c4adt,
                       label: block_c4adt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adt: // global
           I64[Sp - 8] = block_c4adz_info;
           _s4a0U::I64 = I64[R1 + 7];
           _s4a0V::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a0V::I64;
           I64[Sp + 8] = _s4a0U::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4adV; else goto c4adD;
       u4adV: // global
           call _c4adz(R1) args: 0, res: 0, upd: 0;
       c4adD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4adz() //  [R1]
         { info_tbl: [(c4adz,
                       label: block_c4adz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adz: // global
           _s4a0U::I64 = I64[Sp + 16];
           _s4a0X::I64 = I64[R1 + 7];
           if (_s4a0U::I64 == _s4a0X::I64) goto c4adS; else goto c4adR;
       c4adS: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4adR: // global
           if (_s4a0U::I64 > _s4a0X::I64) goto c4adO; else goto c4adP;
       c4adO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4adP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.993802495 UTC

[section ""data" . GHC.Fingerprint.Type.$w$ccompare_closure" {
     GHC.Fingerprint.Type.$w$ccompare_closure:
         const GHC.Fingerprint.Type.$w$ccompare_info;
 },
 GHC.Fingerprint.Type.$w$ccompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4adY: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4ae7,
                       label: GHC.Fingerprint.Type.$w$ccompare_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ae7: // global
           if (R2 == R4) goto c4ae6; else goto c4ae5;
       c4ae6: // global
           if (R3 == R5) goto c4aer; else goto c4aeq;
       c4aer: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aeq: // global
           if (R3 > R5) goto c4aen; else goto c4aeo;
       c4ae5: // global
           if (R2 > R4) goto c4aen; else goto c4aeo;
       c4aen: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aeo: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.995114992 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c4aez,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aez: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aeD; else goto c4aeE;
       c4aeD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aeE: // global
           I64[Sp - 16] = block_c4aew_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aeM; else goto c4aex;
       u4aeM: // global
           call _c4aew(R1) args: 0, res: 0, upd: 0;
       c4aex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aew() //  [R1]
         { info_tbl: [(c4aew,
                       label: block_c4aew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aew: // global
           I64[Sp - 8] = block_c4aeC_info;
           _s4a1d::I64 = I64[R1 + 7];
           _s4a1e::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1e::I64;
           I64[Sp + 8] = _s4a1d::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aeL; else goto c4aeG;
       u4aeL: // global
           call _c4aeC(R1) args: 0, res: 0, upd: 0;
       c4aeG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aeC() //  [R1]
         { info_tbl: [(c4aeC,
                       label: block_c4aeC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aeC: // global
           R5 = I64[R1 + 15];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.996767645 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4aeU,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aeU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aeY; else goto c4aeZ;
       c4aeY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aeZ: // global
           I64[Sp - 16] = block_c4aeR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aff; else goto c4aeS;
       u4aff: // global
           call _c4aeR(R1) args: 0, res: 0, upd: 0;
       c4aeS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aeR() //  [R1]
         { info_tbl: [(c4aeR,
                       label: block_c4aeR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aeR: // global
           I64[Sp - 8] = block_c4aeX_info;
           _s4a1l::I64 = I64[R1 + 7];
           _s4a1m::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1m::I64;
           I64[Sp + 8] = _s4a1l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4afe; else goto c4af1;
       u4afe: // global
           call _c4aeX(R1) args: 0, res: 0, upd: 0;
       c4af1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aeX() //  [R1]
         { info_tbl: [(c4aeX,
                       label: block_c4aeX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aeX: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto c4afa; else goto c4af9;
       c4afa: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4af9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.998552095 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4afn,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4afr; else goto c4afs;
       c4afr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4afs: // global
           I64[Sp - 16] = block_c4afk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4afM; else goto c4afl;
       u4afM: // global
           call _c4afk(R1) args: 0, res: 0, upd: 0;
       c4afl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4afk() //  [R1]
         { info_tbl: [(c4afk,
                       label: block_c4afk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afk: // global
           I64[Sp - 8] = block_c4afq_info;
           _s4a1v::I64 = I64[R1 + 7];
           _s4a1w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1w::I64;
           I64[Sp + 8] = _s4a1v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4afL; else goto c4afu;
       u4afL: // global
           call _c4afq(R1) args: 0, res: 0, upd: 0;
       c4afu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4afq() //  [R1]
         { info_tbl: [(c4afq,
                       label: block_c4afq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afq: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto c4afI; else goto c4afK;
       c4afK: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto c4afI; else goto c4afJ;
       c4afI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4afJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:02.999944568 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure+2;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.000961193 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4afU,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4afY; else goto c4afZ;
       c4afY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4afZ: // global
           I64[Sp - 16] = block_c4afR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ago; else goto c4afS;
       u4ago: // global
           call _c4afR(R1) args: 0, res: 0, upd: 0;
       c4afS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4afR() //  [R1]
         { info_tbl: [(c4afR,
                       label: block_c4afR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afR: // global
           I64[Sp - 8] = block_c4afX_info;
           _s4a1F::I64 = I64[R1 + 7];
           _s4a1G::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1G::I64;
           I64[Sp + 8] = _s4a1F::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4agn; else goto c4ag1;
       u4agn: // global
           call _c4afX(R1) args: 0, res: 0, upd: 0;
       c4ag1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4afX() //  [R1]
         { info_tbl: [(c4afX,
                       label: block_c4afX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4afX: // global
           _s4a1F::I64 = I64[Sp + 16];
           _s4a1I::I64 = I64[R1 + 7];
           if (_s4a1F::I64 == _s4a1I::I64) goto c4agm; else goto c4agf;
       c4agm: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4agk; else goto c4agl;
       c4agf: // global
           if (_s4a1F::I64 > _s4a1I::I64) goto c4agk; else goto c4agl;
       c4agk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4agl: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.004226739 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4agw,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4agw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4agA; else goto c4agB;
       c4agA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4agB: // global
           I64[Sp - 16] = block_c4agt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ah0; else goto c4agu;
       u4ah0: // global
           call _c4agt(R1) args: 0, res: 0, upd: 0;
       c4agu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4agt() //  [R1]
         { info_tbl: [(c4agt,
                       label: block_c4agt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4agt: // global
           I64[Sp - 16] = block_c4agz_info;
           _s4a1P::P64 = R1;
           _s4a1Q::I64 = I64[R1 + 7];
           _s4a1R::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a1R::I64;
           I64[Sp] = _s4a1Q::I64;
           P64[Sp + 8] = _s4a1P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4agZ; else goto c4agD;
       u4agZ: // global
           call _c4agz(R1) args: 0, res: 0, upd: 0;
       c4agD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4agz() //  [R1]
         { info_tbl: [(c4agz,
                       label: block_c4agz_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4agz: // global
           _s4a1P::P64 = P64[Sp + 24];
           _s4a1Q::I64 = I64[Sp + 16];
           _s4a1T::I64 = I64[R1 + 7];
           if (_s4a1Q::I64 == _s4a1T::I64) goto c4agY; else goto c4agR;
       c4agY: // global
           _s4a1S::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4agW; else goto c4agX;
       c4agR: // global
           _s4a1S::P64 = R1;
           if (_s4a1Q::I64 > _s4a1T::I64) goto c4agW; else goto c4agX;
       c4agW: // global
           R1 = _s4a1P::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4agX: // global
           R1 = _s4a1S::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.006087965 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4ah8,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ah8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ahc; else goto c4ahd;
       c4ahc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ahd: // global
           I64[Sp - 16] = block_c4ah5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ahC; else goto c4ah6;
       u4ahC: // global
           call _c4ah5(R1) args: 0, res: 0, upd: 0;
       c4ah6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ah5() //  [R1]
         { info_tbl: [(c4ah5,
                       label: block_c4ah5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ah5: // global
           I64[Sp - 8] = block_c4ahb_info;
           _s4a21::I64 = I64[R1 + 7];
           _s4a22::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a22::I64;
           I64[Sp + 8] = _s4a21::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ahB; else goto c4ahf;
       u4ahB: // global
           call _c4ahb(R1) args: 0, res: 0, upd: 0;
       c4ahf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ahb() //  [R1]
         { info_tbl: [(c4ahb,
                       label: block_c4ahb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ahb: // global
           _s4a21::I64 = I64[Sp + 16];
           _s4a24::I64 = I64[R1 + 7];
           if (_s4a21::I64 == _s4a24::I64) goto c4ahA; else goto c4aht;
       c4ahA: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4ahy; else goto c4ahz;
       c4aht: // global
           if (_s4a21::I64 > _s4a24::I64) goto c4ahy; else goto c4ahz;
       c4ahy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ahz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.007527943 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4ahH,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ahH: // global
           _s4a2a::P64 = R3;
           R3 = R2;
           R2 = _s4a2a::P64;
           call GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.008732686 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4ahR,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ahR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4ahV; else goto c4ahW;
       c4ahV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ahW: // global
           I64[Sp - 16] = block_c4ahO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ail; else goto c4ahP;
       u4ail: // global
           call _c4ahO(R1) args: 0, res: 0, upd: 0;
       c4ahP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ahO() //  [R1]
         { info_tbl: [(c4ahO,
                       label: block_c4ahO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ahO: // global
           I64[Sp - 16] = block_c4ahU_info;
           _s4a2d::P64 = R1;
           _s4a2e::I64 = I64[R1 + 7];
           _s4a2f::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a2f::I64;
           I64[Sp] = _s4a2e::I64;
           P64[Sp + 8] = _s4a2d::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aik; else goto c4ahY;
       u4aik: // global
           call _c4ahU(R1) args: 0, res: 0, upd: 0;
       c4ahY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ahU() //  [R1]
         { info_tbl: [(c4ahU,
                       label: block_c4ahU_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ahU: // global
           _s4a2d::P64 = P64[Sp + 24];
           _s4a2e::I64 = I64[Sp + 16];
           _s4a2h::I64 = I64[R1 + 7];
           if (_s4a2e::I64 == _s4a2h::I64) goto c4aij; else goto c4aic;
       c4aij: // global
           _s4a2g::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aih; else goto c4aii;
       c4aic: // global
           _s4a2g::P64 = R1;
           if (_s4a2e::I64 > _s4a2h::I64) goto c4aih; else goto c4aii;
       c4aih: // global
           R1 = _s4a2g::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4aii: // global
           R1 = _s4a2d::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.010147569 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_closure+1;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.010749825 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule4_bytes" {
     GHC.Fingerprint.Type.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.01125676 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule3_closure" {
     GHC.Fingerprint.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.011797623 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule2_bytes" {
     GHC.Fingerprint.Type.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.012346674 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule1_closure" {
     GHC.Fingerprint.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.012845846 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule_closure" {
     GHC.Fingerprint.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.Type.$trModule3_closure+1;
         const GHC.Fingerprint.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.013788069 UTC

[section ""data" . $krep_r4a01_closure" {
     $krep_r4a01_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.014362248 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tcFingerprint2_bytes" {
     GHC.Fingerprint.Type.$tcFingerprint2_bytes:
         I8[] [70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.014869973 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint1_closure" {
     GHC.Fingerprint.Type.$tcFingerprint1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.015379025 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint_closure" {
     GHC.Fingerprint.Type.$tcFingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tcFingerprint1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12761381476876783108;
         const 2142724667088540655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.015936485 UTC

[section ""data" . $krep1_r4a02_closure" {
     $krep1_r4a02_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.016476778 UTC

[section ""data" . $krep2_r4a03_closure" {
     $krep2_r4a03_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep1_r4a02_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.017043823 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint1_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep2_r4a03_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.017651587 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tc'Fingerprint3_bytes" {
     GHC.Fingerprint.Type.$tc'Fingerprint3_bytes:
         I8[] [39,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.018182084 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint2_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tc'Fingerprint3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.018753169 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint2_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint1_closure+4;
         const 2008132202540166604;
         const 4312636609190854538;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.019648681 UTC

[section ""data" . GHC.Fingerprint.Type.Fingerprint_closure" {
     GHC.Fingerprint.Type.Fingerprint_closure:
         const GHC.Fingerprint.Type.Fingerprint_info;
 },
 GHC.Fingerprint.Type.Fingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4air,
                       label: GHC.Fingerprint.Type.Fingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4air: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4aiv; else goto c4aiu;
       c4aiv: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.Fingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aiu: // global
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.020572866 UTC

[GHC.Fingerprint.Type.Fingerprint_con_entry() //  [R1]
         { info_tbl: [(c4aiw,
                       label: GHC.Fingerprint.Type.Fingerprint_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101,46,70,105,110,103,101,114,112,114,105,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aiw: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.021314921 UTC

[section ""relreadonly" . S4a3D_srt" {
     S4a3D_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Word.$fShowWord64_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
         const GHC.Fingerprint.Type.$w$cshow_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
         const GHC.Fingerprint.Type.$w$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.022151593 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:03.02368043 UTC

[section ""data" . GHC.Fingerprint.Type.$WFingerprint_closure" {
     GHC.Fingerprint.Type.$WFingerprint_closure:
         const GHC.Fingerprint.Type.$WFingerprint_info;
 },
 GHC.Fingerprint.Type.$WFingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4aiF,
                       label: GHC.Fingerprint.Type.$WFingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aiF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4aiO; else goto c4aiP;
       c4aiO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$WFingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aiP: // global
           I64[Sp - 16] = block_c4aiC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aiV; else goto c4aiD;
       u4aiV: // global
           call _c4aiC(R1) args: 0, res: 0, upd: 0;
       c4aiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aiC() //  [R1]
         { info_tbl: [(c4aiC,
                       label: block_c4aiC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aiC: // global
           I64[Sp] = block_c4aiI_info;
           _s4a08::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4a08::I64;
           if (R1 & 7 != 0) goto u4aiU; else goto c4aiJ;
       u4aiU: // global
           call _c4aiI(R1) args: 0, res: 0, upd: 0;
       c4aiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aiI() //  [R1]
         { info_tbl: [(c4aiI,
                       label: block_c4aiI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aiI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4aiT; else goto c4aiS;
       c4aiT: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4aiS: // global
           _s4a0a::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _s4a0a::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.031429167 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint3_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint3_closure:
         const GHC.Word.W64#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.03318847 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint2_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint2_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.03590913 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_info;
         const 0;
 },
 sat_s4a0l_entry() //  [R1]
         { info_tbl: [(c4ajK,
                       label: sat_s4a0l_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ajK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ajL; else goto c4ajM;
       c4ajL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ajM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s4a0h_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s4a0h_entry() //  [R1, R2]
         { info_tbl: [(c4ajQ,
                       label: $wxs_s4a0h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ajQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4ajU; else goto c4ajT;
       c4ajU: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ajT: // global
           if (R2 == 1) goto c4ajP; else goto c4ajO;
       c4ajP: // global
           _s4a0g::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s4a0g::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ajO: // global
           I64[Hp - 48] = sat_s4a0l_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry() //  [R2]
         { info_tbl: [(c4ajW,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_hex16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ajW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ajX; else goto c4ajY;
       c4ajX: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ajY: // global
           I64[Sp - 8] = block_c4ajh_info;
           R6 = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = GHC.Fingerprint.Type.$fShowFingerprint3_closure+1;
           R3 = GHC.Word.$fShowWord64_closure;
           R2 = GHC.Word.$fIntegralWord64_closure;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _c4ajh() //  [R1]
         { info_tbl: [(c4ajh,
                       label: block_c4ajh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ajh: // global
           I64[Sp - 8] = block_c4ajl_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ajl() //  [R1]
         { info_tbl: [(c4ajl,
                       label: block_c4ajl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ajl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4ak2; else goto c4ak1;
       c4ak2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ak1: // global
           _s4a0c::P64 = P64[Sp + 8];
           _s4a0e::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s4a0e::I64)) goto c4ak4; else goto c4ak5;
       c4ak4: // global
           Hp = Hp - 40;
           R1 = _s4a0c::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ak5: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp - 16] = _s4a0c::P64;
           I64[Hp - 8] = $wxs_s4a0h_info;
           P64[Hp] = Hp - 30;
           R2 = _s4a0e::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call $wxs_s4a0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.049475107 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshow_closure" {
     GHC.Fingerprint.Type.$w$cshow_closure:
         const GHC.Fingerprint.Type.$w$cshow_info;
         const 0;
 },
 sat_s4a0r_entry() //  [R1]
         { info_tbl: [(c4akF,
                       label: sat_s4a0r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4akF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4akJ; else goto c4akI;
       c4akJ: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4akI: // global
           _s4a0n::I64 = I64[R1 + 16];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0n::I64;
           R2 = Hp - 7;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshow_entry() //  [R2, R3]
         { info_tbl: [(c4akN,
                       label: GHC.Fingerprint.Type.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4akN: // global
           _s4a0n::I64 = R3;
           _s4a0m::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4akO; else goto c4akP;
       c4akP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4akR; else goto c4akQ;
       c4akR: // global
           HpAlloc = 40;
           goto c4akO;
       c4akO: // global
           R3 = _s4a0n::I64;
           R2 = _s4a0m::I64;
           R1 = GHC.Fingerprint.Type.$w$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4akQ: // global
           I64[Hp - 32] = sat_s4a0r_info;
           I64[Hp - 16] = _s4a0n::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0m::I64;
           I64[Sp - 16] = block_c4akL_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4akL() //  [R1]
         { info_tbl: [(c4akL,
                       label: block_c4akL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4akL: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.05743004 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshow_entry() //  [R2]
         { info_tbl: [(c4ale,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ale: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4alf; else goto c4alg;
       c4alf: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4alg: // global
           I64[Sp - 8] = block_c4alb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4alk; else goto c4alc;
       u4alk: // global
           call _c4alb(R1) args: 0, res: 0, upd: 0;
       c4alc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4alb() //  [R1]
         { info_tbl: [(c4alb,
                       label: block_c4alb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4alb: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Fingerprint.Type.$w$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.063303246 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$w$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$w$cshowsPrec_info;
         const 0;
 },
 sat_s4a0D_entry() //  [R1]
         { info_tbl: [(c4alF,
                       label: sat_s4a0D_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4alF: // global
           _s4a0D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4alG; else goto c4alH;
       c4alH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4alJ; else goto c4alI;
       c4alJ: // global
           HpAlloc = 16;
           goto c4alG;
       c4alG: // global
           R1 = _s4a0D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4alI: // global
           _s4a0y::P64 = P64[_s4a0D::P64 + 16];
           _s4a0x::I64 = I64[_s4a0D::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0x::I64;
           I64[Sp - 16] = block_c4alD_info;
           R2 = Hp - 7;
           P64[Sp - 8] = _s4a0y::P64;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4alD() //  [R1]
         { info_tbl: [(c4alD,
                       label: block_c4alD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4alD: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4alQ,
                       label: GHC.Fingerprint.Type.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4alQ: // global
           _s4a0y::P64 = R4;
           _s4a0x::I64 = R3;
           _s4a0w::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4alR; else goto c4alS;
       c4alS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4alU; else goto c4alT;
       c4alU: // global
           HpAlloc = 48;
           goto c4alR;
       c4alR: // global
           R4 = _s4a0y::P64;
           R3 = _s4a0x::I64;
           R2 = _s4a0w::I64;
           R1 = GHC.Fingerprint.Type.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4alT: // global
           I64[Hp - 40] = sat_s4a0D_info;
           P64[Hp - 24] = _s4a0y::P64;
           I64[Hp - 16] = _s4a0x::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4a0w::I64;
           I64[Sp - 16] = block_c4alO_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4alO() //  [R1]
         { info_tbl: [(c4alO,
                       label: block_c4alO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4alO: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.072858133 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(c4aml,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4amm; else goto c4amn;
       c4amm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4amn: // global
           I64[Sp - 16] = block_c4ami_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4amr; else goto c4amj;
       u4amr: // global
           call _c4ami(R1) args: 0, res: 0, upd: 0;
       c4amj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ami() //  [R1]
         { info_tbl: [(c4ami,
                       label: block_c4ami_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ami: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.079210925 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint1_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint1_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint1_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4amI,
                       label: GHC.Fingerprint.Type.$fShowFingerprint1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4amI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4amJ; else goto c4amK;
       c4amJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4amK: // global
           I64[Sp - 16] = block_c4amF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4amO; else goto c4amG;
       u4amO: // global
           call _c4amF(R1) args: 0, res: 0, upd: 0;
       c4amG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4amF() //  [R1]
         { info_tbl: [(c4amF,
                       label: block_c4amF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4amF: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.084776304 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c4an2,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4an2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Fingerprint.Type.$fShowFingerprint1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.088047746 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure+3;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure+1;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.090397798 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4anh,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4anh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4anl; else goto c4anm;
       c4anl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4anm: // global
           I64[Sp - 16] = block_c4ane_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4anH; else goto c4anf;
       u4anH: // global
           call _c4ane(R1) args: 0, res: 0, upd: 0;
       c4anf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ane() //  [R1]
         { info_tbl: [(c4ane,
                       label: block_c4ane_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ane: // global
           I64[Sp - 8] = block_c4ank_info;
           _s4a0U::I64 = I64[R1 + 7];
           _s4a0V::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a0V::I64;
           I64[Sp + 8] = _s4a0U::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4anG; else goto c4ano;
       u4anG: // global
           call _c4ank(R1) args: 0, res: 0, upd: 0;
       c4ano: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ank() //  [R1]
         { info_tbl: [(c4ank,
                       label: block_c4ank_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ank: // global
           _s4a0U::I64 = I64[Sp + 16];
           _s4a0X::I64 = I64[R1 + 7];
           if (_s4a0U::I64 == _s4a0X::I64) goto c4anD; else goto c4anC;
       c4anD: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4anC: // global
           if (_s4a0U::I64 > _s4a0X::I64) goto c4anz; else goto c4anA;
       c4anz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4anA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.098825868 UTC

[section ""data" . GHC.Fingerprint.Type.$w$ccompare_closure" {
     GHC.Fingerprint.Type.$w$ccompare_closure:
         const GHC.Fingerprint.Type.$w$ccompare_info;
 },
 GHC.Fingerprint.Type.$w$ccompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ao2: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4aob,
                       label: GHC.Fingerprint.Type.$w$ccompare_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aob: // global
           if (R2 == R4) goto c4aoa; else goto c4ao9;
       c4aoa: // global
           if (R3 == R5) goto c4aov; else goto c4aou;
       c4aov: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aou: // global
           if (R3 > R5) goto c4aor; else goto c4aos;
       c4ao9: // global
           if (R2 > R4) goto c4aor; else goto c4aos;
       c4aor: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aos: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.104108222 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c4aoM,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aoM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aoQ; else goto c4aoR;
       c4aoQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aoR: // global
           I64[Sp - 16] = block_c4aoJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aoZ; else goto c4aoK;
       u4aoZ: // global
           call _c4aoJ(R1) args: 0, res: 0, upd: 0;
       c4aoK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aoJ() //  [R1]
         { info_tbl: [(c4aoJ,
                       label: block_c4aoJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aoJ: // global
           I64[Sp - 8] = block_c4aoP_info;
           _s4a1d::I64 = I64[R1 + 7];
           _s4a1e::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1e::I64;
           I64[Sp + 8] = _s4a1d::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aoY; else goto c4aoT;
       u4aoY: // global
           call _c4aoP(R1) args: 0, res: 0, upd: 0;
       c4aoT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aoP() //  [R1]
         { info_tbl: [(c4aoP,
                       label: block_c4aoP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aoP: // global
           R5 = I64[R1 + 15];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.114665084 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4apk,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4apk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4apo; else goto c4app;
       c4apo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4app: // global
           I64[Sp - 16] = block_c4aph_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4apF; else goto c4api;
       u4apF: // global
           call _c4aph(R1) args: 0, res: 0, upd: 0;
       c4api: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aph() //  [R1]
         { info_tbl: [(c4aph,
                       label: block_c4aph_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aph: // global
           I64[Sp - 8] = block_c4apn_info;
           _s4a1l::I64 = I64[R1 + 7];
           _s4a1m::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1m::I64;
           I64[Sp + 8] = _s4a1l::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4apE; else goto c4apr;
       u4apE: // global
           call _c4apn(R1) args: 0, res: 0, upd: 0;
       c4apr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4apn() //  [R1]
         { info_tbl: [(c4apn,
                       label: block_c4apn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4apn: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto c4apA; else goto c4apz;
       c4apA: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4apz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.123944899 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4aq6,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aq6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aqa; else goto c4aqb;
       c4aqa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aqb: // global
           I64[Sp - 16] = block_c4aq3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aqv; else goto c4aq4;
       u4aqv: // global
           call _c4aq3(R1) args: 0, res: 0, upd: 0;
       c4aq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aq3() //  [R1]
         { info_tbl: [(c4aq3,
                       label: block_c4aq3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aq3: // global
           I64[Sp - 8] = block_c4aq9_info;
           _s4a1v::I64 = I64[R1 + 7];
           _s4a1w::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1w::I64;
           I64[Sp + 8] = _s4a1v::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aqu; else goto c4aqd;
       u4aqu: // global
           call _c4aq9(R1) args: 0, res: 0, upd: 0;
       c4aqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aq9() //  [R1]
         { info_tbl: [(c4aq9,
                       label: block_c4aq9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aq9: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto c4aqr; else goto c4aqt;
       c4aqt: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto c4aqr; else goto c4aqs;
       c4aqr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aqs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.132441942 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure+2;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.135442162 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4aqV,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aqV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aqZ; else goto c4ar0;
       c4aqZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ar0: // global
           I64[Sp - 16] = block_c4aqS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4arp; else goto c4aqT;
       u4arp: // global
           call _c4aqS(R1) args: 0, res: 0, upd: 0;
       c4aqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aqS() //  [R1]
         { info_tbl: [(c4aqS,
                       label: block_c4aqS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aqS: // global
           I64[Sp - 8] = block_c4aqY_info;
           _s4a1F::I64 = I64[R1 + 7];
           _s4a1G::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a1G::I64;
           I64[Sp + 8] = _s4a1F::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aro; else goto c4ar2;
       u4aro: // global
           call _c4aqY(R1) args: 0, res: 0, upd: 0;
       c4ar2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aqY() //  [R1]
         { info_tbl: [(c4aqY,
                       label: block_c4aqY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aqY: // global
           _s4a1F::I64 = I64[Sp + 16];
           _s4a1I::I64 = I64[R1 + 7];
           if (_s4a1F::I64 == _s4a1I::I64) goto c4arn; else goto c4arg;
       c4arn: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4arl; else goto c4arm;
       c4arg: // global
           if (_s4a1F::I64 > _s4a1I::I64) goto c4arl; else goto c4arm;
       c4arl: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4arm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.144225635 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4arN,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4arN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4arR; else goto c4arS;
       c4arR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4arS: // global
           I64[Sp - 16] = block_c4arK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ash; else goto c4arL;
       u4ash: // global
           call _c4arK(R1) args: 0, res: 0, upd: 0;
       c4arL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4arK() //  [R1]
         { info_tbl: [(c4arK,
                       label: block_c4arK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4arK: // global
           I64[Sp - 16] = block_c4arQ_info;
           _s4a1P::P64 = R1;
           _s4a1Q::I64 = I64[R1 + 7];
           _s4a1R::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a1R::I64;
           I64[Sp] = _s4a1Q::I64;
           P64[Sp + 8] = _s4a1P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4asg; else goto c4arU;
       u4asg: // global
           call _c4arQ(R1) args: 0, res: 0, upd: 0;
       c4arU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4arQ() //  [R1]
         { info_tbl: [(c4arQ,
                       label: block_c4arQ_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4arQ: // global
           _s4a1P::P64 = P64[Sp + 24];
           _s4a1Q::I64 = I64[Sp + 16];
           _s4a1T::I64 = I64[R1 + 7];
           if (_s4a1Q::I64 == _s4a1T::I64) goto c4asf; else goto c4as8;
       c4asf: // global
           _s4a1S::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4asd; else goto c4ase;
       c4as8: // global
           _s4a1S::P64 = R1;
           if (_s4a1Q::I64 > _s4a1T::I64) goto c4asd; else goto c4ase;
       c4asd: // global
           R1 = _s4a1P::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ase: // global
           R1 = _s4a1S::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.152742159 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4asI,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4asI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4asM; else goto c4asN;
       c4asM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4asN: // global
           I64[Sp - 16] = block_c4asF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4atc; else goto c4asG;
       u4atc: // global
           call _c4asF(R1) args: 0, res: 0, upd: 0;
       c4asG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4asF() //  [R1]
         { info_tbl: [(c4asF,
                       label: block_c4asF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4asF: // global
           I64[Sp - 8] = block_c4asL_info;
           _s4a21::I64 = I64[R1 + 7];
           _s4a22::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4a22::I64;
           I64[Sp + 8] = _s4a21::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4atb; else goto c4asP;
       u4atb: // global
           call _c4asL(R1) args: 0, res: 0, upd: 0;
       c4asP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4asL() //  [R1]
         { info_tbl: [(c4asL,
                       label: block_c4asL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4asL: // global
           _s4a21::I64 = I64[Sp + 16];
           _s4a24::I64 = I64[R1 + 7];
           if (_s4a21::I64 == _s4a24::I64) goto c4ata; else goto c4at3;
       c4ata: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4at8; else goto c4at9;
       c4at3: // global
           if (_s4a21::I64 > _s4a24::I64) goto c4at8; else goto c4at9;
       c4at8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4at9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.162048603 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4atx,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4atx: // global
           _s4a2a::P64 = R3;
           R3 = R2;
           R2 = _s4a2a::P64;
           call GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.165975448 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4atL,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4atL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4atP; else goto c4atQ;
       c4atP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4atQ: // global
           I64[Sp - 16] = block_c4atI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4auf; else goto c4atJ;
       u4auf: // global
           call _c4atI(R1) args: 0, res: 0, upd: 0;
       c4atJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4atI() //  [R1]
         { info_tbl: [(c4atI,
                       label: block_c4atI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4atI: // global
           I64[Sp - 16] = block_c4atO_info;
           _s4a2d::P64 = R1;
           _s4a2e::I64 = I64[R1 + 7];
           _s4a2f::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4a2f::I64;
           I64[Sp] = _s4a2e::I64;
           P64[Sp + 8] = _s4a2d::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aue; else goto c4atS;
       u4aue: // global
           call _c4atO(R1) args: 0, res: 0, upd: 0;
       c4atS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4atO() //  [R1]
         { info_tbl: [(c4atO,
                       label: block_c4atO_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4atO: // global
           _s4a2d::P64 = P64[Sp + 24];
           _s4a2e::I64 = I64[Sp + 16];
           _s4a2h::I64 = I64[R1 + 7];
           if (_s4a2e::I64 == _s4a2h::I64) goto c4aud; else goto c4au6;
       c4aud: // global
           _s4a2g::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aub; else goto c4auc;
       c4au6: // global
           _s4a2g::P64 = R1;
           if (_s4a2e::I64 > _s4a2h::I64) goto c4aub; else goto c4auc;
       c4aub: // global
           R1 = _s4a2g::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4auc: // global
           R1 = _s4a2d::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.174124176 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_closure+1;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.175986301 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule4_bytes" {
     GHC.Fingerprint.Type.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.177716184 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule3_closure" {
     GHC.Fingerprint.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.179362533 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule2_bytes" {
     GHC.Fingerprint.Type.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.181043911 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule1_closure" {
     GHC.Fingerprint.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.182812038 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule_closure" {
     GHC.Fingerprint.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.Type.$trModule3_closure+1;
         const GHC.Fingerprint.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.184594931 UTC

[section ""data" . $krep_r4a01_closure" {
     $krep_r4a01_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.186344234 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tcFingerprint2_bytes" {
     GHC.Fingerprint.Type.$tcFingerprint2_bytes:
         I8[] [70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.188480126 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint1_closure" {
     GHC.Fingerprint.Type.$tcFingerprint1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.190816674 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint_closure" {
     GHC.Fingerprint.Type.$tcFingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tcFingerprint1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12761381476876783108;
         const 2142724667088540655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.192650893 UTC

[section ""data" . $krep1_r4a02_closure" {
     $krep1_r4a02_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.194355427 UTC

[section ""data" . $krep2_r4a03_closure" {
     $krep2_r4a03_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep1_r4a02_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.196026808 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint1_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep2_r4a03_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.197728387 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tc'Fingerprint3_bytes" {
     GHC.Fingerprint.Type.$tc'Fingerprint3_bytes:
         I8[] [39,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.199387693 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint2_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tc'Fingerprint3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.201017493 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint2_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint1_closure+4;
         const 2008132202540166604;
         const 4312636609190854538;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.203248003 UTC

[section ""data" . GHC.Fingerprint.Type.Fingerprint_closure" {
     GHC.Fingerprint.Type.Fingerprint_closure:
         const GHC.Fingerprint.Type.Fingerprint_info;
 },
 GHC.Fingerprint.Type.Fingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4auU,
                       label: GHC.Fingerprint.Type.Fingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4auU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4auY; else goto c4auX;
       c4auY: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.Fingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4auX: // global
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.206992437 UTC

[GHC.Fingerprint.Type.Fingerprint_con_entry() //  [R1]
         { info_tbl: [(c4av4,
                       label: GHC.Fingerprint.Type.Fingerprint_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101,46,70,105,110,103,101,114,112,114,105,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4av4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.210322669 UTC

[section ""relreadonly" . S4a3D_srt" {
     S4a3D_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Word.$fShowWord64_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
         const GHC.Fingerprint.Type.$w$cshow_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
         const GHC.Fingerprint.Type.$w$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.520129447 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:03.521866784 UTC

[section ""data" . GHC.Fingerprint.Type.$WFingerprint_closure" {
     GHC.Fingerprint.Type.$WFingerprint_closure:
         const GHC.Fingerprint.Type.$WFingerprint_info;
 },
 GHC.Fingerprint.Type.$WFingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4axz,
                       label: GHC.Fingerprint.Type.$WFingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4axz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4axI; else goto c4axJ;
       c4axI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$WFingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4axJ: // global
           I64[Sp - 16] = block_c4axw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4axP; else goto c4axx;
       u4axP: // global
           call _c4axw(R1) args: 0, res: 0, upd: 0;
       c4axx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4axw() //  [R1]
         { info_tbl: [(c4axw,
                       label: block_c4axw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4axw: // global
           I64[Sp] = block_c4axC_info;
           _s4ave::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ave::I64;
           if (R1 & 7 != 0) goto u4axO; else goto c4axD;
       u4axO: // global
           call _c4axC(R1) args: 0, res: 0, upd: 0;
       c4axD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4axC() //  [R1]
         { info_tbl: [(c4axC,
                       label: block_c4axC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4axC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4axN; else goto c4axM;
       c4axN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4axM: // global
           _s4avg::I64 = I64[R1 + 7];
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = _s4avg::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.529445004 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint3_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint3_closure:
         const GHC.Word.W64#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.531173271 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint2_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint2_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.535731264 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_info;
         const 0;
 },
 sat_s4avr_entry() //  [R1]
         { info_tbl: [(c4ayH,
                       label: sat_s4avr_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ayH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ayI; else goto c4ayJ;
       c4ayI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ayJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s4avn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s4avn_entry() //  [R1, R2]
         { info_tbl: [(c4ayN,
                       label: $wxs_s4avn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ayN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4ayR; else goto c4ayQ;
       c4ayR: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ayQ: // global
           if (R2 == 1) goto c4ayM; else goto c4ayL;
       c4ayM: // global
           _s4avm::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s4avm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ayL: // global
           I64[Hp - 48] = sat_s4avr_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry() //  [R2]
         { info_tbl: [(c4ayT,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_hex16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ayT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ayU; else goto c4ayV;
       c4ayU: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ayV: // global
           I64[Sp - 8] = block_c4aye_info;
           R6 = R2;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = GHC.Fingerprint.Type.$fShowFingerprint3_closure+1;
           R3 = GHC.Word.$fShowWord64_closure;
           R2 = GHC.Word.$fIntegralWord64_closure;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 16, res: 8, upd: 8;
     }
 },
 _c4aye() //  [R1]
         { info_tbl: [(c4aye,
                       label: block_c4aye_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aye: // global
           I64[Sp - 8] = block_c4ayi_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ayi() //  [R1]
         { info_tbl: [(c4ayi,
                       label: block_c4ayi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ayi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4ayZ; else goto c4ayY;
       c4ayZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ayY: // global
           _s4avi::P64 = P64[Sp + 8];
           _s4avk::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s4avk::I64)) goto c4az1; else goto c4az2;
       c4az1: // global
           Hp = Hp - 40;
           R1 = _s4avi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4az2: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Fingerprint.Type.$fShowFingerprint2_closure+1;
           P64[Hp - 16] = _s4avi::P64;
           I64[Hp - 8] = $wxs_s4avn_info;
           P64[Hp] = Hp - 30;
           R2 = _s4avk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call $wxs_s4avn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.548372622 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshow_closure" {
     GHC.Fingerprint.Type.$w$cshow_closure:
         const GHC.Fingerprint.Type.$w$cshow_info;
         const 0;
 },
 sat_s4avx_entry() //  [R1]
         { info_tbl: [(c4azP,
                       label: sat_s4avx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4azP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4azT; else goto c4azS;
       c4azT: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4azS: // global
           _s4avt::I64 = I64[R1 + 16];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4avt::I64;
           R2 = Hp - 7;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshow_entry() //  [R2, R3]
         { info_tbl: [(c4azX,
                       label: GHC.Fingerprint.Type.$w$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4azX: // global
           _s4avt::I64 = R3;
           _s4avs::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4azY; else goto c4azZ;
       c4azZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4aA1; else goto c4aA0;
       c4aA1: // global
           HpAlloc = 40;
           goto c4azY;
       c4azY: // global
           R3 = _s4avt::I64;
           R2 = _s4avs::I64;
           R1 = GHC.Fingerprint.Type.$w$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aA0: // global
           I64[Hp - 32] = sat_s4avx_info;
           I64[Hp - 16] = _s4avt::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4avs::I64;
           I64[Sp - 16] = block_c4azV_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4azV() //  [R1]
         { info_tbl: [(c4azV,
                       label: block_c4azV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4azV: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.556590162 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshow_entry() //  [R2]
         { info_tbl: [(c4aAs,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aAs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4aAt; else goto c4aAu;
       c4aAt: // global
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4aAu: // global
           I64[Sp - 8] = block_c4aAp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aAy; else goto c4aAq;
       u4aAy: // global
           call _c4aAp(R1) args: 0, res: 0, upd: 0;
       c4aAq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aAp() //  [R1]
         { info_tbl: [(c4aAp,
                       label: block_c4aAp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aAp: // global
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Fingerprint.Type.$w$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.562874253 UTC

[section ""data" . GHC.Fingerprint.Type.$w$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$w$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$w$cshowsPrec_info;
         const 0;
 },
 sat_s4avJ_entry() //  [R1]
         { info_tbl: [(c4aAU,
                       label: sat_s4avJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aAU: // global
           _s4avJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4aAV; else goto c4aAW;
       c4aAW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4aAY; else goto c4aAX;
       c4aAY: // global
           HpAlloc = 16;
           goto c4aAV;
       c4aAV: // global
           R1 = _s4avJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4aAX: // global
           _s4avE::P64 = P64[_s4avJ::P64 + 16];
           _s4avD::I64 = I64[_s4avJ::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4avD::I64;
           I64[Sp - 16] = block_c4aAS_info;
           R2 = Hp - 7;
           P64[Sp - 8] = _s4avE::P64;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4aAS() //  [R1]
         { info_tbl: [(c4aAS,
                       label: block_c4aAS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aAS: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4aB5,
                       label: GHC.Fingerprint.Type.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aB5: // global
           _s4avE::P64 = R4;
           _s4avD::I64 = R3;
           _s4avC::I64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4aB6; else goto c4aB7;
       c4aB7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4aB9; else goto c4aB8;
       c4aB9: // global
           HpAlloc = 48;
           goto c4aB6;
       c4aB6: // global
           R4 = _s4avE::P64;
           R3 = _s4avD::I64;
           R2 = _s4avC::I64;
           R1 = GHC.Fingerprint.Type.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aB8: // global
           I64[Hp - 40] = sat_s4avJ_info;
           P64[Hp - 24] = _s4avE::P64;
           I64[Hp - 16] = _s4avD::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4avC::I64;
           I64[Sp - 16] = block_c4aB3_info;
           R2 = Hp - 7;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$fShowFingerprint_hex16_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4aB3() //  [R1]
         { info_tbl: [(c4aB3,
                       label: block_c4aB3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aB3: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.573930803 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_entry() //  [R2,
                                                                 R3, R4]
         { info_tbl: [(c4aBF,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aBF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4aBG; else goto c4aBH;
       c4aBG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aBH: // global
           I64[Sp - 16] = block_c4aBC_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aBL; else goto c4aBD;
       u4aBL: // global
           call _c4aBC(R1) args: 0, res: 0, upd: 0;
       c4aBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aBC() //  [R1]
         { info_tbl: [(c4aBC,
                       label: block_c4aBC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aBC: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.579784524 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint1_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint1_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint1_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4aC3,
                       label: GHC.Fingerprint.Type.$fShowFingerprint1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aC3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4aC4; else goto c4aC5;
       c4aC4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fShowFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aC5: // global
           I64[Sp - 16] = block_c4aC0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aC9; else goto c4aC1;
       u4aC9: // global
           call _c4aC0(R1) args: 0, res: 0, upd: 0;
       c4aC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aC0() //  [R1]
         { info_tbl: [(c4aC0,
                       label: block_c4aC0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aC0: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 15];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Fingerprint.Type.$w$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.585510693 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure:
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info;
         const 0;
 },
 GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c4aCo,
                       label: GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aCo: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Fingerprint.Type.$fShowFingerprint1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.588959651 UTC

[section ""data" . GHC.Fingerprint.Type.$fShowFingerprint_closure" {
     GHC.Fingerprint.Type.$fShowFingerprint_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure+3;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure+1;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.591335769 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry() //  [R2, R3]
         { info_tbl: [(c4aCD,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aCD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aCH; else goto c4aCI;
       c4aCH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aCI: // global
           I64[Sp - 16] = block_c4aCA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aD3; else goto c4aCB;
       u4aD3: // global
           call _c4aCA(R1) args: 0, res: 0, upd: 0;
       c4aCB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aCA() //  [R1]
         { info_tbl: [(c4aCA,
                       label: block_c4aCA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aCA: // global
           I64[Sp - 8] = block_c4aCG_info;
           _s4aw0::I64 = I64[R1 + 7];
           _s4aw1::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4aw1::I64;
           I64[Sp + 8] = _s4aw0::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aD2; else goto c4aCK;
       u4aD2: // global
           call _c4aCG(R1) args: 0, res: 0, upd: 0;
       c4aCK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aCG() //  [R1]
         { info_tbl: [(c4aCG,
                       label: block_c4aCG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aCG: // global
           _s4aw0::I64 = I64[Sp + 16];
           _s4aw3::I64 = I64[R1 + 7];
           if (_s4aw0::I64 == _s4aw3::I64) goto c4aCZ; else goto c4aCY;
       c4aCZ: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aCY: // global
           if (_s4aw0::I64 > _s4aw3::I64) goto c4aCV; else goto c4aCW;
       c4aCV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aCW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.60047878 UTC

[section ""data" . GHC.Fingerprint.Type.$w$ccompare_closure" {
     GHC.Fingerprint.Type.$w$ccompare_closure:
         const GHC.Fingerprint.Type.$w$ccompare_info;
 },
 GHC.Fingerprint.Type.$w$ccompare_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aDt: // global
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Fingerprint.Type.$w$ccompare_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4aDC,
                       label: GHC.Fingerprint.Type.$w$ccompare_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, True, True, True]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aDC: // global
           if (R2 == R4) goto c4aDB; else goto c4aDA;
       c4aDB: // global
           if (R3 == R5) goto c4aDW; else goto c4aDV;
       c4aDW: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aDV: // global
           if (R3 > R5) goto c4aDS; else goto c4aDT;
       c4aDA: // global
           if (R2 > R4) goto c4aDS; else goto c4aDT;
       c4aDS: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aDT: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.606544708 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c4aEg,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aEg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aEk; else goto c4aEl;
       c4aEk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aEl: // global
           I64[Sp - 16] = block_c4aEd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aEt; else goto c4aEe;
       u4aEt: // global
           call _c4aEd(R1) args: 0, res: 0, upd: 0;
       c4aEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aEd() //  [R1]
         { info_tbl: [(c4aEd,
                       label: block_c4aEd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aEd: // global
           I64[Sp - 8] = block_c4aEj_info;
           _s4awj::I64 = I64[R1 + 7];
           _s4awk::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4awk::I64;
           I64[Sp + 8] = _s4awj::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aEs; else goto c4aEn;
       u4aEs: // global
           call _c4aEj(R1) args: 0, res: 0, upd: 0;
       c4aEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aEj() //  [R1]
         { info_tbl: [(c4aEj,
                       label: block_c4aEj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aEj: // global
           R5 = I64[R1 + 15];
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.Type.$w$ccompare_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.614728534 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c==_entry() //  [R2, R3]
         { info_tbl: [(c4aEQ,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aEQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aEU; else goto c4aEV;
       c4aEU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aEV: // global
           I64[Sp - 16] = block_c4aEN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aFb; else goto c4aEO;
       u4aFb: // global
           call _c4aEN(R1) args: 0, res: 0, upd: 0;
       c4aEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aEN() //  [R1]
         { info_tbl: [(c4aEN,
                       label: block_c4aEN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aEN: // global
           I64[Sp - 8] = block_c4aET_info;
           _s4awr::I64 = I64[R1 + 7];
           _s4aws::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4aws::I64;
           I64[Sp + 8] = _s4awr::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aFa; else goto c4aEX;
       u4aFa: // global
           call _c4aET(R1) args: 0, res: 0, upd: 0;
       c4aEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aET() //  [R1]
         { info_tbl: [(c4aET,
                       label: block_c4aET_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aET: // global
           if (I64[Sp + 16] == I64[R1 + 7]) goto c4aF6; else goto c4aF5;
       c4aF6: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 15]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aF5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.623134245 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure:
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info;
 },
 GHC.Fingerprint.Type.$fEqFingerprint_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c4aFG,
                       label: GHC.Fingerprint.Type.$fEqFingerprint_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aFG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aFK; else goto c4aFL;
       c4aFK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aFL: // global
           I64[Sp - 16] = block_c4aFD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aG5; else goto c4aFE;
       u4aG5: // global
           call _c4aFD(R1) args: 0, res: 0, upd: 0;
       c4aFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aFD() //  [R1]
         { info_tbl: [(c4aFD,
                       label: block_c4aFD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aFD: // global
           I64[Sp - 8] = block_c4aFJ_info;
           _s4awB::I64 = I64[R1 + 7];
           _s4awC::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4awC::I64;
           I64[Sp + 8] = _s4awB::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aG4; else goto c4aFN;
       u4aG4: // global
           call _c4aFJ(R1) args: 0, res: 0, upd: 0;
       c4aFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aFJ() //  [R1]
         { info_tbl: [(c4aFJ,
                       label: block_c4aFJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aFJ: // global
           if (I64[Sp + 16] != I64[R1 + 7]) goto c4aG1; else goto c4aG3;
       c4aG3: // global
           if (I64[Sp + 8] != I64[R1 + 15]) goto c4aG1; else goto c4aG2;
       c4aG1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aG2: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.631360589 UTC

[section ""data" . GHC.Fingerprint.Type.$fEqFingerprint_closure" {
     GHC.Fingerprint.Type.$fEqFingerprint_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c==_closure+2;
         const GHC.Fingerprint.Type.$fEqFingerprint_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.634328671 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c4aGz,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aGz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aGD; else goto c4aGE;
       c4aGD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aGE: // global
           I64[Sp - 16] = block_c4aGw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aH3; else goto c4aGx;
       u4aH3: // global
           call _c4aGw(R1) args: 0, res: 0, upd: 0;
       c4aGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aGw() //  [R1]
         { info_tbl: [(c4aGw,
                       label: block_c4aGw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aGw: // global
           I64[Sp - 8] = block_c4aGC_info;
           _s4awL::I64 = I64[R1 + 7];
           _s4awM::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4awM::I64;
           I64[Sp + 8] = _s4awL::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aH2; else goto c4aGG;
       u4aH2: // global
           call _c4aGC(R1) args: 0, res: 0, upd: 0;
       c4aGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aGC() //  [R1]
         { info_tbl: [(c4aGC,
                       label: block_c4aGC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aGC: // global
           _s4awL::I64 = I64[Sp + 16];
           _s4awO::I64 = I64[R1 + 7];
           if (_s4awL::I64 == _s4awO::I64) goto c4aH1; else goto c4aGU;
       c4aH1: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aGZ; else goto c4aH0;
       c4aGU: // global
           if (_s4awL::I64 > _s4awO::I64) goto c4aGZ; else goto c4aH0;
       c4aGZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aH0: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.642555656 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4aHv,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aHv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4aHz; else goto c4aHA;
       c4aHz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aHA: // global
           I64[Sp - 16] = block_c4aHs_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aHZ; else goto c4aHt;
       u4aHZ: // global
           call _c4aHs(R1) args: 0, res: 0, upd: 0;
       c4aHt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aHs() //  [R1]
         { info_tbl: [(c4aHs,
                       label: block_c4aHs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aHs: // global
           I64[Sp - 16] = block_c4aHy_info;
           _s4awV::P64 = R1;
           _s4awW::I64 = I64[R1 + 7];
           _s4awX::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4awX::I64;
           I64[Sp] = _s4awW::I64;
           P64[Sp + 8] = _s4awV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aHY; else goto c4aHC;
       u4aHY: // global
           call _c4aHy(R1) args: 0, res: 0, upd: 0;
       c4aHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aHy() //  [R1]
         { info_tbl: [(c4aHy,
                       label: block_c4aHy_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aHy: // global
           _s4awV::P64 = P64[Sp + 24];
           _s4awW::I64 = I64[Sp + 16];
           _s4awZ::I64 = I64[R1 + 7];
           if (_s4awW::I64 == _s4awZ::I64) goto c4aHX; else goto c4aHQ;
       c4aHX: // global
           _s4awY::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aHV; else goto c4aHW;
       c4aHQ: // global
           _s4awY::P64 = R1;
           if (_s4awW::I64 > _s4awZ::I64) goto c4aHV; else goto c4aHW;
       c4aHV: // global
           R1 = _s4awV::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4aHW: // global
           R1 = _s4awY::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.651148661 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c4aIs,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aIs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4aIw; else goto c4aIx;
       c4aIw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aIx: // global
           I64[Sp - 16] = block_c4aIp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aIW; else goto c4aIq;
       u4aIW: // global
           call _c4aIp(R1) args: 0, res: 0, upd: 0;
       c4aIq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aIp() //  [R1]
         { info_tbl: [(c4aIp,
                       label: block_c4aIp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aIp: // global
           I64[Sp - 8] = block_c4aIv_info;
           _s4ax7::I64 = I64[R1 + 7];
           _s4ax8::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ax8::I64;
           I64[Sp + 8] = _s4ax7::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4aIV; else goto c4aIz;
       u4aIV: // global
           call _c4aIv(R1) args: 0, res: 0, upd: 0;
       c4aIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aIv() //  [R1]
         { info_tbl: [(c4aIv,
                       label: block_c4aIv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aIv: // global
           _s4ax7::I64 = I64[Sp + 16];
           _s4axa::I64 = I64[R1 + 7];
           if (_s4ax7::I64 == _s4axa::I64) goto c4aIU; else goto c4aIN;
       c4aIU: // global
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aIS; else goto c4aIT;
       c4aIN: // global
           if (_s4ax7::I64 > _s4axa::I64) goto c4aIS; else goto c4aIT;
       c4aIS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4aIT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.659323102 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$c>_entry() //  [R2, R3]
         { info_tbl: [(c4aJl,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aJl: // global
           _s4axg::P64 = R3;
           R3 = R2;
           R2 = _s4axg::P64;
           call GHC.Fingerprint.Type.$fOrdFingerprint_$c<_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.663353942 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure:
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info;
 },
 GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4aJz,
                       label: GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aJz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4aJD; else goto c4aJE;
       c4aJD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aJE: // global
           I64[Sp - 16] = block_c4aJw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aK3; else goto c4aJx;
       u4aK3: // global
           call _c4aJw(R1) args: 0, res: 0, upd: 0;
       c4aJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aJw() //  [R1]
         { info_tbl: [(c4aJw,
                       label: block_c4aJw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aJw: // global
           I64[Sp - 16] = block_c4aJC_info;
           _s4axj::P64 = R1;
           _s4axk::I64 = I64[R1 + 7];
           _s4axl::I64 = I64[R1 + 15];
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _s4axl::I64;
           I64[Sp] = _s4axk::I64;
           P64[Sp + 8] = _s4axj::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4aK2; else goto c4aJG;
       u4aK2: // global
           call _c4aJC(R1) args: 0, res: 0, upd: 0;
       c4aJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4aJC() //  [R1]
         { info_tbl: [(c4aJC,
                       label: block_c4aJC_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aJC: // global
           _s4axj::P64 = P64[Sp + 24];
           _s4axk::I64 = I64[Sp + 16];
           _s4axn::I64 = I64[R1 + 7];
           if (_s4axk::I64 == _s4axn::I64) goto c4aK1; else goto c4aJU;
       c4aK1: // global
           _s4axm::P64 = R1;
           if (I64[Sp + 8] >= I64[R1 + 15]) goto c4aJZ; else goto c4aK0;
       c4aJU: // global
           _s4axm::P64 = R1;
           if (_s4axk::I64 > _s4axn::I64) goto c4aJZ; else goto c4aK0;
       c4aJZ: // global
           R1 = _s4axm::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4aK0: // global
           R1 = _s4axj::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.671662505 UTC

[section ""data" . GHC.Fingerprint.Type.$fOrdFingerprint_closure" {
     GHC.Fingerprint.Type.$fOrdFingerprint_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Fingerprint.Type.$fEqFingerprint_closure+1;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$ccompare_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c<=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$c>=_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmax_closure+2;
         const GHC.Fingerprint.Type.$fOrdFingerprint_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.674013131 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule4_bytes" {
     GHC.Fingerprint.Type.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.675682279 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule3_closure" {
     GHC.Fingerprint.Type.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.677400473 UTC

[section ""cstring" . GHC.Fingerprint.Type.$trModule2_bytes" {
     GHC.Fingerprint.Type.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.678995711 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule1_closure" {
     GHC.Fingerprint.Type.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.680677162 UTC

[section ""data" . GHC.Fingerprint.Type.$trModule_closure" {
     GHC.Fingerprint.Type.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.Type.$trModule3_closure+1;
         const GHC.Fingerprint.Type.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.682478105 UTC

[section ""data" . $krep_r4a01_closure" {
     $krep_r4a01_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.684124422 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tcFingerprint2_bytes" {
     GHC.Fingerprint.Type.$tcFingerprint2_bytes:
         I8[] [70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.685995158 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint1_closure" {
     GHC.Fingerprint.Type.$tcFingerprint1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.687680752 UTC

[section ""data" . GHC.Fingerprint.Type.$tcFingerprint_closure" {
     GHC.Fingerprint.Type.$tcFingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tcFingerprint1_closure+1;
         const GHC.Types.krep$*_closure;
         const 12761381476876783108;
         const 2142724667088540655;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.689631308 UTC

[section ""data" . $krep1_r4a02_closure" {
     $krep1_r4a02_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Fingerprint.Type.$tcFingerprint_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.691449667 UTC

[section ""data" . $krep2_r4a03_closure" {
     $krep2_r4a03_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep1_r4a02_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.694015687 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint1_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4a01_closure+1;
         const $krep2_r4a03_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.695788602 UTC

[section ""cstring" . GHC.Fingerprint.Type.$tc'Fingerprint3_bytes" {
     GHC.Fingerprint.Type.$tc'Fingerprint3_bytes:
         I8[] [39,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.697490747 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint2_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.Type.$tc'Fingerprint3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.699156934 UTC

[section ""data" . GHC.Fingerprint.Type.$tc'Fingerprint_closure" {
     GHC.Fingerprint.Type.$tc'Fingerprint_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.Type.$trModule_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint2_closure+1;
         const GHC.Fingerprint.Type.$tc'Fingerprint1_closure+4;
         const 2008132202540166604;
         const 4312636609190854538;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.701355342 UTC

[section ""data" . GHC.Fingerprint.Type.Fingerprint_closure" {
     GHC.Fingerprint.Type.Fingerprint_closure:
         const GHC.Fingerprint.Type.Fingerprint_info;
 },
 GHC.Fingerprint.Type.Fingerprint_entry() //  [R2, R3]
         { info_tbl: [(c4aKK,
                       label: GHC.Fingerprint.Type.Fingerprint_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aKK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4aKO; else goto c4aKN;
       c4aKO: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.Type.Fingerprint_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4aKN: // global
           I64[Hp - 16] = GHC.Fingerprint.Type.Fingerprint_con_info;
           I64[Hp - 8] = R2;
           I64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.705205614 UTC

[GHC.Fingerprint.Type.Fingerprint_con_entry() //  [R1]
         { info_tbl: [(c4aKV,
                       label: GHC.Fingerprint.Type.Fingerprint_con_info
                       rep:HeapRep 2 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,84,121,112,101,46,70,105,110,103,101,114,112,114,105,110,116]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4aKV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.70839785 UTC

[section ""relreadonly" . S4az3_srt" {
     S4az3_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Word.$fShowWord64_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const Numeric.showIntAtBase_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_hex16_closure;
         const GHC.Fingerprint.Type.$w$cshow_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshow_closure;
         const GHC.Fingerprint.Type.$w$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint_$cshowsPrec_closure;
         const GHC.Fingerprint.Type.$fShowFingerprint1_closure;
 }]

