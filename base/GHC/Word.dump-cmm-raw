
==================== Raw Cmm ====================
2018-03-16 15:57:11.172403697 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:57:11.175381903 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2zY7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zYe; else goto c2zYf;
       c2zYe: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zYf: // global
           I64[Sp - 8] = block_c2zY4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zYj; else goto c2zY5;
       u2zYj: // global
           call _c2zY4(R1) args: 0, res: 0, upd: 0;
       c2zY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cfromEnum_info" {
     GHC.Word.$fEnumWord8_$cfromEnum_info:
         const GHC.Word.$fEnumWord8_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2zY4() //  [R1]
         { []
         }
     {offset
       c2zY4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zYi; else goto c2zYh;
       c2zYi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zYh: // global
           _s2uFW::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2zY4_info" {
     block_c2zY4_info:
         const _c2zY4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.181890076 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2zYB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zYI; else goto c2zYJ;
       c2zYI: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zYJ: // global
           I64[Sp - 8] = block_c2zYy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zYN; else goto c2zYz;
       u2zYN: // global
           call _c2zYy(R1) args: 0, res: 0, upd: 0;
       c2zYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cfromEnum_info" {
     GHC.Word.$fEnumWord16_$cfromEnum_info:
         const GHC.Word.$fEnumWord16_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2zYy() //  [R1]
         { []
         }
     {offset
       c2zYy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zYM; else goto c2zYL;
       c2zYM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zYL: // global
           _s2uG0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2zYy_info" {
     block_c2zYy_info:
         const _c2zYy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.188161048 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2zZ5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zZc; else goto c2zZd;
       c2zZc: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zZd: // global
           I64[Sp - 8] = block_c2zZ2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2zZh; else goto c2zZ3;
       u2zZh: // global
           call _c2zZ2(R1) args: 0, res: 0, upd: 0;
       c2zZ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cfromEnum_info" {
     GHC.Word.$fEnumWord32_$cfromEnum_info:
         const GHC.Word.$fEnumWord32_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2zZ2() //  [R1]
         { []
         }
     {offset
       c2zZ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zZg; else goto c2zZf;
       c2zZg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2zZf: // global
           _s2uG4::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uG4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2zZ2_info" {
     block_c2zZ2_info:
         const _c2zZ2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.194785112 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2zZy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2zZC; else goto c2zZD;
       c2zZC: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2zZD: // global
           I64[Sp - 8] = block_c2zZw_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cfromInteger_info" {
     GHC.Word.$fNumWord64_$cfromInteger_info:
         const GHC.Word.$fNumWord64_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2zZw() //  [R1]
         { []
         }
     {offset
       c2zZw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2zZG; else goto c2zZF;
       c2zZG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2zZF: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2zZw_info" {
     block_c2zZw_info:
         const _c2zZw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.201811271 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2zZU: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cabs_info" {
     GHC.Word.$fNumWord64_$cabs_info:
         const GHC.Word.$fNumWord64_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.206793737 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2A0a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A0n; else goto c2A0o;
       c2A0n: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A0o: // global
           I64[Sp - 8] = block_c2A07_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A0s; else goto c2A08;
       u2A0s: // global
           call _c2A07(R1) args: 0, res: 0, upd: 0;
       c2A08: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cnegate_info" {
     GHC.Word.$fNumWord64_$cnegate_info:
         const GHC.Word.$fNumWord64_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2A07() //  [R1]
         { []
         }
     {offset
       c2A07: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A0r; else goto c2A0q;
       c2A0r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A0q: // global
           _s2uGd::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A07_info" {
     block_c2A07_info:
         const _c2A07;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.214100458 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A0K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A0W; else goto c2A0X;
       c2A0W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A0X: // global
           I64[Sp - 16] = block_c2A0H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A13; else goto c2A0I;
       u2A13: // global
           call _c2A0H(R1) args: 0, res: 0, upd: 0;
       c2A0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c*_info" {
     GHC.Word.$fNumWord64_$c*_info:
         const GHC.Word.$fNumWord64_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2A0H() //  [R1]
         { []
         }
     {offset
       c2A0H: // global
           I64[Sp] = block_c2A0N_info;
           _s2uGh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGh::I64;
           if (R1 & 7 != 0) goto u2A12; else goto c2A0O;
       u2A12: // global
           call _c2A0N(R1) args: 0, res: 0, upd: 0;
       c2A0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A0H_info" {
     block_c2A0H_info:
         const _c2A0H;
         const 1;
         const 30;
 },
 _c2A0N() //  [R1]
         { []
         }
     {offset
       c2A0N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A11; else goto c2A10;
       c2A11: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A10: // global
           _s2uGk::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A0N_info" {
     block_c2A0N_info:
         const _c2A0N;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.22254482 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A1r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A1D; else goto c2A1E;
       c2A1D: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A1E: // global
           I64[Sp - 16] = block_c2A1o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A1K; else goto c2A1p;
       u2A1K: // global
           call _c2A1o(R1) args: 0, res: 0, upd: 0;
       c2A1p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c-_info" {
     GHC.Word.$fNumWord64_$c-_info:
         const GHC.Word.$fNumWord64_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2A1o() //  [R1]
         { []
         }
     {offset
       c2A1o: // global
           I64[Sp] = block_c2A1u_info;
           _s2uGo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGo::I64;
           if (R1 & 7 != 0) goto u2A1J; else goto c2A1v;
       u2A1J: // global
           call _c2A1u(R1) args: 0, res: 0, upd: 0;
       c2A1v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A1o_info" {
     block_c2A1o_info:
         const _c2A1o;
         const 1;
         const 30;
 },
 _c2A1u() //  [R1]
         { []
         }
     {offset
       c2A1u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A1I; else goto c2A1H;
       c2A1I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A1H: // global
           _s2uGr::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A1u_info" {
     block_c2A1u_info:
         const _c2A1u;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.2310438 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A28: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A2k; else goto c2A2l;
       c2A2k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A2l: // global
           I64[Sp - 16] = block_c2A25_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2A2r; else goto c2A26;
       u2A2r: // global
           call _c2A25(R1) args: 0, res: 0, upd: 0;
       c2A26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c+_info" {
     GHC.Word.$fNumWord64_$c+_info:
         const GHC.Word.$fNumWord64_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2A25() //  [R1]
         { []
         }
     {offset
       c2A25: // global
           I64[Sp] = block_c2A2b_info;
           _s2uGv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uGv::I64;
           if (R1 & 7 != 0) goto u2A2q; else goto c2A2c;
       u2A2q: // global
           call _c2A2b(R1) args: 0, res: 0, upd: 0;
       c2A2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A25_info" {
     block_c2A25_info:
         const _c2A25;
         const 1;
         const 30;
 },
 _c2A2b() //  [R1]
         { []
         }
     {offset
       c2A2b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2A2p; else goto c2A2o;
       c2A2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2A2o: // global
           _s2uGy::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uGy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A2b_info" {
     block_c2A2b_info:
         const _c2A2b;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.238142675 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.24107137 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { []
         }
     {offset
       c2A2P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A2Q; else goto c2A2R;
       c2A2Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A2R: // global
           (_c2A2M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A2M::I64 == 0) goto c2A2O; else goto c2A2N;
       c2A2O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A2N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A2M::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r2uFF_info" {
     lvl_r2uFF_info:
         const lvl_r2uFF_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.245503564 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c2A36: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A37; else goto c2A38;
       c2A37: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A38: // global
           I64[Sp - 8] = block_c2A33_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A3k; else goto c2A34;
       u2A3k: // global
           call _c2A33(R1) args: 0, res: 0, upd: 0;
       c2A34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$ctoInteger_info" {
     GHC.Word.$fIntegralWord64_$ctoInteger_info:
         const GHC.Word.$fIntegralWord64_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2A33() //  [R1]
         { []
         }
     {offset
       c2A33: // global
           _s2uGB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGB::I64, 0)) goto c2A3i; else goto c2A3j;
       c2A3i: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2A3j: // global
           R2 = _s2uGB::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A33_info" {
     block_c2A33_info:
         const _c2A33;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.25320498 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2uGF_entry() //  [R1]
         { []
         }
     {offset
       c2A3F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A3G; else goto c2A3H;
       c2A3G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A3H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2A3C_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A3T; else goto c2A3D;
       u2A3T: // global
           call _c2A3C(R1) args: 0, res: 0, upd: 0;
       c2A3D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . w1_s2uGF_info" {
     w1_s2uGF_info:
         const w1_s2uGF_entry;
         const 1;
         const 16;
 },
 _c2A3C() //  [R1]
         { []
         }
     {offset
       c2A3C: // global
           _s2uGH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uGH::I64, 0)) goto c2A3R; else goto c2A3S;
       c2A3R: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2A3S: // global
           R2 = _s2uGH::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2A3C_info" {
     block_c2A3C_info:
         const _c2A3C;
         const 0;
         const 30;
 },
 sat_s2uGO_entry() //  [R1, R2]
         { []
         }
     {offset
       c2A42: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A43; else goto c2A44;
       c2A43: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A44: // global
           I64[Sp - 8] = block_c2A3Z_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s2uGO_info" {
     sat_s2uGO_info:
         const sat_s2uGO_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S2vim_srt;
 },
 _c2A3Z() //  [R1, R2]
         { []
         }
     {offset
       c2A3Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A47; else goto c2A46;
       c2A47: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A46: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A3Z_info" {
     block_c2A3Z_info:
         const _c2A3Z;
         const 0;
         const 30;
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { []
         }
     {offset
       c2A48: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2A4c; else goto c2A4b;
       c2A4c: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A4b: // global
           I64[Hp - 32] = w1_s2uGF_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2uGO_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord3_info" {
     GHC.Word.$fShowWord3_info:
         const GHC.Word.$fShowWord3_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.264320786 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A4D: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshowList_info" {
     GHC.Word.$fShowWord64_$cshowList_info:
         const GHC.Word.$fShowWord64_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2vim_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.268543121 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2A4Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A4R; else goto c2A4S;
       c2A4R: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A4S: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2A4Z; else goto c2A56;
       c2A4Z: // global
           I64[Sp - 8] = block_c2A4X_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2A56: // global
           I64[Sp - 8] = block_c2A55_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cshow_info" {
     GHC.Word.$w$cshow_info:
         const GHC.Word.$w$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967300;
         const S2vim_srt;
 },
 _c2A4X() //  [R1]
         { []
         }
     {offset
       c2A4X: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A4X_info" {
     block_c2A4X_info:
         const _c2A4X;
         const 0;
         const 4294967326;
         const S2vim_srt;
 },
 _c2A55() //  [R1]
         { []
         }
     {offset
       c2A55: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A55_info" {
     block_c2A55_info:
         const _c2A55;
         const 0;
         const 4294967326;
         const S2vim_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.276969332 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2A5t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A5z; else goto c2A5A;
       c2A5z: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A5A: // global
           I64[Sp - 8] = block_c2A5q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A5F; else goto c2A5r;
       u2A5F: // global
           call _c2A5q(R1) args: 0, res: 0, upd: 0;
       c2A5r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshow_info" {
     GHC.Word.$fShowWord64_$cshow_info:
         const GHC.Word.$fShowWord64_$cshow_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+16;
 },
 _c2A5q() //  [R1]
         { []
         }
     {offset
       c2A5q: // global
           I64[Sp] = block_c2A5w_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A5q_info" {
     block_c2A5q_info:
         const _c2A5q;
         const 0;
         const 4294967326;
         const S2vim_srt+16;
 },
 _c2A5w() //  [R1, R2]
         { []
         }
     {offset
       c2A5w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A5E; else goto c2A5D;
       c2A5E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A5D: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A5w_info" {
     block_c2A5w_info:
         const _c2A5w;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.286898552 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2uH4_entry() //  [R1]
         { []
         }
     {offset
       c2A64: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A65; else goto c2A66;
       c2A65: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A66: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2A61_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A6i; else goto c2A62;
       u2A6i: // global
           call _c2A61(R1) args: 0, res: 0, upd: 0;
       c2A62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . w1_s2uH4_info" {
     w1_s2uH4_info:
         const w1_s2uH4_entry;
         const 1;
         const 16;
 },
 _c2A61() //  [R1]
         { []
         }
     {offset
       c2A61: // global
           _s2uH6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uH6::I64, 0)) goto c2A6g; else goto c2A6h;
       c2A6g: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2A6h: // global
           R2 = _s2uH6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2A61_info" {
     block_c2A61_info:
         const _c2A61;
         const 0;
         const 30;
 },
 sat_s2uHf_entry() //  [R1, R2]
         { []
         }
     {offset
       c2A6r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A6x; else goto c2A6y;
       c2A6x: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A6y: // global
           I64[Sp - 24] = block_c2A6o_info;
           _s2uH4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2uH4::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2A6D; else goto c2A6p;
       u2A6D: // global
           call _c2A6o(R1) args: 0, res: 0, upd: 0;
       c2A6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s2uHf_info" {
     sat_s2uHf_info:
         const sat_s2uHf_entry;
         const 2;
         const 4294967307;
         const 4294967301;
         const S2vim_srt;
 },
 _c2A6o() //  [R1]
         { []
         }
     {offset
       c2A6o: // global
           _s2uH9::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2A6u_info;
           R4 = _s2uH9::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A6o_info" {
     block_c2A6o_info:
         const _c2A6o;
         const 2;
         const 4294967326;
         const S2vim_srt;
 },
 _c2A6u() //  [R1, R2]
         { []
         }
     {offset
       c2A6u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A6C; else goto c2A6B;
       c2A6C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A6B: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A6u_info" {
     block_c2A6u_info:
         const _c2A6u;
         const 0;
         const 30;
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A6E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2A6I; else goto c2A6H;
       c2A6I: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2A6H: // global
           I64[Hp - 40] = w1_s2uH4_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2uHf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshowsPrec_info" {
     GHC.Word.$fShowWord64_$cshowsPrec_info:
         const GHC.Word.$fShowWord64_$cshowsPrec_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S2vim_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.299113455 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.301533688 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { []
         }
     {offset
       c2A7e: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord5_info" {
     GHC.Word.$fEnumWord5_info:
         const GHC.Word.$fEnumWord5_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const S2vim_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.305307883 UTC

[section ""data" . sat_s2uHh_closure" {
     sat_s2uHh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.30704939 UTC

[section ""data" . sat_s2uHi_closure" {
     sat_s2uHi_closure:
         const :_con_info;
         const sat_s2uHh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.309785003 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { []
         }
     {offset
       c2A7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2A7u; else goto c2A7v;
       c2A7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A7v: // global
           (_c2A7q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A7q::I64 == 0) goto c2A7s; else goto c2A7r;
       c2A7s: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A7r: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A7q::I64;
           R3 = sat_s2uHi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord1_info" {
     GHC.Word.$fRealWord1_info:
         const GHC.Word.$fRealWord1_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.314981972 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2A7J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A7K; else goto c2A7L;
       c2A7K: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A7L: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2A7W; else goto c2A88;
       c2A7W: // global
           I64[Sp - 8] = block_c2A7Q_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2A88: // global
           I64[Sp - 8] = block_c2A83_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoRational_info" {
     GHC.Word.$w$ctoRational_info:
         const GHC.Word.$w$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967300;
         const S2vim_srt+72;
 },
 _c2A7Q() //  [R1]
         { []
         }
     {offset
       c2A7Q: // global
           I64[Sp] = block_c2A7U_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A7Q_info" {
     block_c2A7Q_info:
         const _c2A7Q;
         const 0;
         const 30064771102;
         const S2vim_srt+72;
 },
 _c2A7U() //  [R1]
         { []
         }
     {offset
       c2A7U: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A7U_info" {
     block_c2A7U_info:
         const _c2A7U;
         const 0;
         const 12884901918;
         const S2vim_srt+80;
 },
 _c2A83() //  [R1]
         { []
         }
     {offset
       c2A83: // global
           I64[Sp] = block_c2A87_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A83_info" {
     block_c2A83_info:
         const _c2A83;
         const 0;
         const 30064771102;
         const S2vim_srt+72;
 },
 _c2A87() //  [R1]
         { []
         }
     {offset
       c2A87: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A87_info" {
     block_c2A87_info:
         const _c2A87;
         const 0;
         const 12884901918;
         const S2vim_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.325840194 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2A8C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2A8I; else goto c2A8J;
       c2A8I: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2A8J: // global
           I64[Sp - 8] = block_c2A8z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2A8O; else goto c2A8A;
       u2A8O: // global
           call _c2A8z(R1) args: 0, res: 0, upd: 0;
       c2A8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord64_$ctoRational_info" {
     GHC.Word.$fRealWord64_$ctoRational_info:
         const GHC.Word.$fRealWord64_$ctoRational_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+96;
 },
 _c2A8z() //  [R1]
         { []
         }
     {offset
       c2A8z: // global
           I64[Sp] = block_c2A8F_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A8z_info" {
     block_c2A8z_info:
         const _c2A8z;
         const 0;
         const 4294967326;
         const S2vim_srt+96;
 },
 _c2A8F() //  [R1, R2]
         { []
         }
     {offset
       c2A8F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2A8N; else goto c2A8M;
       c2A8N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2A8M: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A8F_info" {
     block_c2A8F_info:
         const _c2A8F;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.332343976 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.336049315 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { []
         }
     {offset
       c2A9b: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A9c; else goto c2A9d;
       c2A9c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A9d: // global
           (_c2A96::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A96::I64 == 0) goto c2A98; else goto c2A97;
       c2A98: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A97: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A96::I64;
           I64[Sp - 24] = block_c2A99_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord10_info" {
     GHC.Word.$fEnumWord10_info:
         const GHC.Word.$fEnumWord10_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+112;
 },
 _c2A99() //  [R1]
         { []
         }
     {offset
       c2A99: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2A99_info" {
     block_c2A99_info:
         const _c2A99;
         const 0;
         const 4294967326;
         const S2vim_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.342037909 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { []
         }
     {offset
       c2A9z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2A9A; else goto c2A9B;
       c2A9A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2A9B: // global
           (_c2A9u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2A9u::I64 == 0) goto c2A9w; else goto c2A9v;
       c2A9w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2A9v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2A9u::I64;
           I64[Sp - 24] = block_c2A9x_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord11_info" {
     GHC.Word.$fEnumWord11_info:
         const GHC.Word.$fEnumWord11_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+120;
 },
 _c2A9x() //  [R1]
         { []
         }
     {offset
       c2A9x: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2A9x_info" {
     block_c2A9x_info:
         const _c2A9x;
         const 0;
         const 4294967326;
         const S2vim_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.348225501 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2A9W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aa0; else goto c2Aa1;
       c2Aa0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aa1: // global
           I64[Sp - 16] = block_c2A9T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Aaa; else goto c2A9U;
       u2Aaa: // global
           call _c2A9T(R1) args: 0, res: 0, upd: 0;
       c2A9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord8_info" {
     GHC.Word.neWord8_info:
         const GHC.Word.neWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2A9T() //  [R1]
         { []
         }
     {offset
       c2A9T: // global
           I64[Sp] = block_c2A9Z_info;
           _s2uHB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHB::I64;
           if (R1 & 7 != 0) goto u2Aa9; else goto c2Aa3;
       u2Aa9: // global
           call _c2A9Z(R1) args: 0, res: 0, upd: 0;
       c2Aa3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A9T_info" {
     block_c2A9T_info:
         const _c2A9T;
         const 1;
         const 30;
 },
 _c2A9Z() //  [R1]
         { []
         }
     {offset
       c2A9Z: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2A9Z_info" {
     block_c2A9Z_info:
         const _c2A9Z;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.357324479 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { []
         }
     {offset
       c2Aay: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aaz; else goto c2AaA;
       c2Aaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AaA: // global
           (_c2Aav::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Aav::I64 == 0) goto c2Aax; else goto c2Aaw;
       c2Aax: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Aaw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Aav::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_r2uFH_info" {
     lvl2_r2uFH_info:
         const lvl2_r2uFH_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.360985249 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.364311828 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2AaQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AaR; else goto c2AaS;
       c2AaR: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AaS: // global
           I64[Sp - 8] = block_c2AaN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Aba; else goto c2AaO;
       u2Aba: // global
           call _c2AaN(R1) args: 0, res: 0, upd: 0;
       c2AaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cpred_info" {
     GHC.Word.$fEnumWord8_$cpred_info:
         const GHC.Word.$fEnumWord8_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+128;
 },
 _c2AaN() //  [R1]
         { []
         }
     {offset
       c2AaN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AaX; else goto c2AaW;
       c2AaX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AaW: // global
           _s2uHI::I64 = I64[R1 + 7];
           if (_s2uHI::I64 != 0) goto c2Ab8; else goto c2Ab9;
       c2Ab8: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHI::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ab9: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AaN_info" {
     block_c2AaN_info:
         const _c2AaN;
         const 0;
         const 4294967326;
         const S2vim_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.370393405 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.372206017 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.375659263 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2Abx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Aby; else goto c2Abz;
       c2Aby: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Abz: // global
           I64[Sp - 8] = block_c2Abu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AbR; else goto c2Abv;
       u2AbR: // global
           call _c2Abu(R1) args: 0, res: 0, upd: 0;
       c2Abv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$csucc_info" {
     GHC.Word.$fEnumWord8_$csucc_info:
         const GHC.Word.$fEnumWord8_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+144;
 },
 _c2Abu() //  [R1]
         { []
         }
     {offset
       c2Abu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AbE; else goto c2AbD;
       c2AbE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AbD: // global
           _s2uHO::I64 = I64[R1 + 7];
           if (_s2uHO::I64 != 255) goto c2AbP; else goto c2AbQ;
       c2AbP: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uHO::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AbQ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Abu_info" {
     block_c2Abu_info:
         const _c2Abu;
         const 0;
         const 4294967326;
         const S2vim_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.383223394 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2Acc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Acq; else goto c2Acr;
       c2Acq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Acr: // global
           I64[Sp - 24] = block_c2Ac9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Acy; else goto c2Aca;
       u2Acy: // global
           call _c2Ac9(R1) args: 0, res: 0, upd: 0;
       c2Aca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshowsPrec_info" {
     GHC.Word.$fShowWord8_$cshowsPrec_info:
         const GHC.Word.$fShowWord8_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2Ac9() //  [R1]
         { []
         }
     {offset
       c2Ac9: // global
           I64[Sp] = block_c2Acf_info;
           _s2uHV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uHV::I64;
           if (R1 & 7 != 0) goto u2Acx; else goto c2Acg;
       u2Acx: // global
           call _c2Acf(R1) args: 0, res: 0, upd: 0;
       c2Acg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ac9_info" {
     block_c2Ac9_info:
         const _c2Ac9;
         const 2;
         const 30;
 },
 _c2Acf() //  [R1]
         { []
         }
     {offset
       c2Acf: // global
           _s2uHT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2Acn_info;
           R4 = _s2uHT::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Acf_info" {
     block_c2Acf_info:
         const _c2Acf;
         const 66;
         const 30;
 },
 _c2Acn() //  [R1, R2]
         { []
         }
     {offset
       c2Acn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Acw; else goto c2Acv;
       c2Acw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Acv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Acn_info" {
     block_c2Acn_info:
         const _c2Acn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.392966776 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2AcX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ad6; else goto c2Ad7;
       c2Ad6: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ad7: // global
           I64[Sp - 8] = block_c2AcU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Adc; else goto c2AcV;
       u2Adc: // global
           call _c2AcU(R1) args: 0, res: 0, upd: 0;
       c2AcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshow_info" {
     GHC.Word.$fShowWord8_$cshow_info:
         const GHC.Word.$fShowWord8_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2AcU() //  [R1]
         { []
         }
     {offset
       c2AcU: // global
           I64[Sp] = block_c2Ad3_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AcU_info" {
     block_c2AcU_info:
         const _c2AcU;
         const 0;
         const 30;
 },
 _c2Ad3() //  [R1, R2]
         { []
         }
     {offset
       c2Ad3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Adb; else goto c2Ada;
       c2Adb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ada: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ad3_info" {
     block_c2Ad3_info:
         const _c2Ad3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.401842647 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Adx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AdG; else goto c2AdH;
       c2AdG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AdH: // global
           I64[Sp - 16] = block_c2Adu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AdM; else goto c2Adv;
       u2AdM: // global
           call _c2Adu(R1) args: 0, res: 0, upd: 0;
       c2Adv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord4_info" {
     GHC.Word.$fShowWord4_info:
         const GHC.Word.$fShowWord4_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Adu() //  [R1]
         { []
         }
     {offset
       c2Adu: // global
           _s2uIa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2AdD_info;
           R4 = _s2uIa::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Adu_info" {
     block_c2Adu_info:
         const _c2Adu;
         const 1;
         const 30;
 },
 _c2AdD() //  [R1, R2]
         { []
         }
     {offset
       c2AdD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AdL; else goto c2AdK;
       c2AdL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AdK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AdD_info" {
     block_c2AdD_info:
         const _c2AdD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.408988148 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Ae4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshowList_info" {
     GHC.Word.$fShowWord8_$cshowList_info:
         const GHC.Word.$fShowWord8_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.412512116 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.415330509 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { []
         }
     {offset
       c2Aeg: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl3_info" {
     GHC.Word.$wlvl3_info:
         const GHC.Word.$wlvl3_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2vim_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.419489823 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { []
         }
     {offset
       c2Aew: // global
           _s2uIk::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2AeE; else goto c2Aev;
       c2Aev: // global
           if (%MO_S_Gt_W64(_s2uIk::I64, 255)) goto c2AeE; else goto c2AeI;
       c2AeE: // global
           R2 = _s2uIk::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2AeI: // global
           R1 = _s2uIk::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum2_info" {
     GHC.Word.$w$ctoEnum2_info:
         const GHC.Word.$w$ctoEnum2_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2vim_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.424127466 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2AeV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Af3; else goto c2Af4;
       c2Af3: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Af4: // global
           I64[Sp - 8] = block_c2AeS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Af9; else goto c2AeT;
       u2Af9: // global
           call _c2AeS(R1) args: 0, res: 0, upd: 0;
       c2AeT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$ctoEnum_info" {
     GHC.Word.$fEnumWord8_$ctoEnum_info:
         const GHC.Word.$fEnumWord8_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+184;
 },
 _c2AeS() //  [R1]
         { []
         }
     {offset
       c2AeS: // global
           I64[Sp] = block_c2AeY_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AeS_info" {
     block_c2AeS_info:
         const _c2AeS;
         const 0;
         const 4294967326;
         const S2vim_srt+192;
 },
 _c2AeY() //  [R1]
         { []
         }
     {offset
       c2AeY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Af8; else goto c2Af7;
       c2Af8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Af7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AeY_info" {
     block_c2AeY_info:
         const _c2AeY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.44224407 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2uIP_entry() //  [R1]
         { []
         }
     {offset
       c2Ag4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ag5; else goto c2Ag6;
       c2Ag5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ag6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIP_info" {
     sat_s2uIP_info:
         const sat_s2uIP_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+176;
 },
 sat_s2uIN_entry() //  [R1]
         { []
         }
     {offset
       c2Agg: // global
           _s2uIN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Agh; else goto c2Agi;
       c2Agi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Agk; else goto c2Agj;
       c2Agk: // global
           HpAlloc = 16;
           goto c2Agh;
       c2Agh: // global
           R1 = _s2uIN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Agj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIN::P64;
           _s2uII::I64 = I64[_s2uIN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2Agq; else goto c2Agf;
       c2Agf: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2Agq; else goto c2Agx;
       c2Agq: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Agx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIN_info" {
     sat_s2uIN_info:
         const sat_s2uIN_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 sat_s2uIT_entry() //  [R1]
         { []
         }
     {offset
       c2AgI: // global
           _s2uIT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AgJ; else goto c2AgK;
       c2AgK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AgM; else goto c2AgL;
       c2AgM: // global
           HpAlloc = 16;
           goto c2AgJ;
       c2AgJ: // global
           R1 = _s2uIT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AgL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIT::P64;
           _s2uII::I64 = I64[_s2uIT::P64 + 16];
           if (%MO_S_Lt_W64(_s2uII::I64, 0)) goto c2AgS; else goto c2AgH;
       c2AgH: // global
           if (%MO_S_Gt_W64(_s2uII::I64, 255)) goto c2AgS; else goto c2AgZ;
       c2AgS: // global
           Hp = Hp - 16;
           R2 = _s2uII::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AgZ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uII::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIT_info" {
     sat_s2uIT_info:
         const sat_s2uIT_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 go_dn_s2uIH_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Ah3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Ah7; else goto c2Ah6;
       c2Ah7: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ah6: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2Ah1; else goto c2Ah2;
       c2Ah1: // global
           _s2uIF::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uIP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uIF::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uIN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ah2: // global
           I64[Hp - 80] = sat_s2uIT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Ah9::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Ah9::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2uIH_info" {
     go_dn_s2uIH_info:
         const go_dn_s2uIH_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+176;
 },
 sat_s2uIU_entry() //  [R1]
         { []
         }
     {offset
       c2Aha: // global
           _s2uIU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ahb; else goto c2Ahc;
       c2Ahc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Ahe; else goto c2Ahd;
       c2Ahe: // global
           HpAlloc = 24;
           goto c2Ahb;
       c2Ahb: // global
           R1 = _s2uIU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ahd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIU::P64;
           _s2uIx::I64 = I64[_s2uIU::P64 + 24];
           _s2uIF::I64 = _s2uIx::I64 - I64[_s2uIU::P64 + 16];
           _s2uIG::I64 = I64[_s2uIU::P64 + 32] - _s2uIF::I64;
           I64[Hp - 16] = go_dn_s2uIH_info;
           I64[Hp - 8] = _s2uIF::I64;
           I64[Hp] = _s2uIG::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uIH_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIU_info" {
     sat_s2uIU_info:
         const sat_s2uIU_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+176;
 },
 sat_s2uIE_entry() //  [R1]
         { []
         }
     {offset
       c2Aho: // global
           _s2uIE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ahp; else goto c2Ahq;
       c2Ahq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ahs; else goto c2Ahr;
       c2Ahs: // global
           HpAlloc = 16;
           goto c2Ahp;
       c2Ahp: // global
           R1 = _s2uIE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ahr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIE::P64;
           _s2uIw::I64 = I64[_s2uIE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Ahy; else goto c2Ahn;
       c2Ahn: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Ahy; else goto c2AhF;
       c2Ahy: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AhF: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIE_info" {
     sat_s2uIE_info:
         const sat_s2uIE_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 sat_s2uIZ_entry() //  [R1]
         { []
         }
     {offset
       c2AhT: // global
           _s2uIZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AhU; else goto c2AhV;
       c2AhV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AhX; else goto c2AhW;
       c2AhX: // global
           HpAlloc = 16;
           goto c2AhU;
       c2AhU: // global
           R1 = _s2uIZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AhW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uIZ::P64;
           _s2uIw::I64 = I64[_s2uIZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Ai3; else goto c2AhS;
       c2AhS: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Ai3; else goto c2Aia;
       c2Ai3: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aia: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uIZ_info" {
     sat_s2uIZ_info:
         const sat_s2uIZ_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 sat_s2uJg_entry() //  [R1]
         { []
         }
     {offset
       c2AiG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AiH; else goto c2AiI;
       c2AiH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AiI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJg_info" {
     sat_s2uJg_info:
         const sat_s2uJg_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+176;
 },
 sat_s2uJe_entry() //  [R1]
         { []
         }
     {offset
       c2AiS: // global
           _s2uJe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AiT; else goto c2AiU;
       c2AiU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AiW; else goto c2AiV;
       c2AiW: // global
           HpAlloc = 16;
           goto c2AiT;
       c2AiT: // global
           R1 = _s2uJe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AiV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJe::P64;
           _s2uJ9::I64 = I64[_s2uJe::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2Aj2; else goto c2AiR;
       c2AiR: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2Aj2; else goto c2Aj9;
       c2Aj2: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aj9: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJe_info" {
     sat_s2uJe_info:
         const sat_s2uJe_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 sat_s2uJk_entry() //  [R1]
         { []
         }
     {offset
       c2Ajk: // global
           _s2uJk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ajl; else goto c2Ajm;
       c2Ajm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ajo; else goto c2Ajn;
       c2Ajo: // global
           HpAlloc = 16;
           goto c2Ajl;
       c2Ajl: // global
           R1 = _s2uJk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ajn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJk::P64;
           _s2uJ9::I64 = I64[_s2uJk::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJ9::I64, 0)) goto c2Aju; else goto c2Ajj;
       c2Ajj: // global
           if (%MO_S_Gt_W64(_s2uJ9::I64, 255)) goto c2Aju; else goto c2AjB;
       c2Aju: // global
           Hp = Hp - 16;
           R2 = _s2uJ9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AjB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJ9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJk_info" {
     sat_s2uJk_info:
         const sat_s2uJk_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 go_up_s2uJ8_entry() //  [R1, R2]
         { []
         }
     {offset
       c2AjF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AjJ; else goto c2AjI;
       c2AjJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AjI: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2AjD; else goto c2AjE;
       c2AjD: // global
           _s2uJ6::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJg_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJ6::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AjE: // global
           I64[Hp - 80] = sat_s2uJk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AjL::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AjL::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2uJ8_info" {
     go_up_s2uJ8_info:
         const go_up_s2uJ8_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+176;
 },
 sat_s2uJl_entry() //  [R1]
         { []
         }
     {offset
       c2AjM: // global
           _s2uJl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AjN; else goto c2AjO;
       c2AjO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AjQ; else goto c2AjP;
       c2AjQ: // global
           HpAlloc = 24;
           goto c2AjN;
       c2AjN: // global
           R1 = _s2uJl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AjP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJl::P64;
           _s2uIx::I64 = I64[_s2uJl::P64 + 24];
           _s2uJ6::I64 = _s2uIx::I64 - I64[_s2uJl::P64 + 16];
           _s2uJ7::I64 = I64[_s2uJl::P64 + 32] - _s2uJ6::I64;
           I64[Hp - 16] = go_up_s2uJ8_info;
           I64[Hp - 8] = _s2uJ6::I64;
           I64[Hp] = _s2uJ7::I64;
           R2 = _s2uIx::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uJ8_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJl_info" {
     sat_s2uJl_info:
         const sat_s2uJl_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+176;
 },
 sat_s2uJ5_entry() //  [R1]
         { []
         }
     {offset
       c2Ak0: // global
           _s2uJ5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ak1; else goto c2Ak2;
       c2Ak2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ak4; else goto c2Ak3;
       c2Ak4: // global
           HpAlloc = 16;
           goto c2Ak1;
       c2Ak1: // global
           R1 = _s2uJ5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ak3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJ5::P64;
           _s2uIw::I64 = I64[_s2uJ5::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2Aka; else goto c2AjZ;
       c2AjZ: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2Aka; else goto c2Akh;
       c2Aka: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Akh: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJ5_info" {
     sat_s2uJ5_info:
         const sat_s2uJ5_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 sat_s2uJq_entry() //  [R1]
         { []
         }
     {offset
       c2Akv: // global
           _s2uJq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Akw; else goto c2Akx;
       c2Akx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Akz; else goto c2Aky;
       c2Akz: // global
           HpAlloc = 16;
           goto c2Akw;
       c2Akw: // global
           R1 = _s2uJq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Aky: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJq::P64;
           _s2uIw::I64 = I64[_s2uJq::P64 + 16];
           if (%MO_S_Lt_W64(_s2uIw::I64, 0)) goto c2AkF; else goto c2Aku;
       c2Aku: // global
           if (%MO_S_Gt_W64(_s2uIw::I64, 255)) goto c2AkF; else goto c2AkM;
       c2AkF: // global
           Hp = Hp - 16;
           R2 = _s2uIw::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2AkM: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uIw::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJq_info" {
     sat_s2uJq_info:
         const sat_s2uJq_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AkN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AkR; else goto c2AkQ;
       c2AkR: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AkQ: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2Al1; else goto c2Ala;
       c2Al1: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2AkU; else goto c2AkZ;
       c2AkU: // global
           I64[Hp - 80] = sat_s2uIU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uIE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AkZ: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2Al8; else goto c2AkX;
       c2AkX: // global
           I64[Hp - 80] = sat_s2uIZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AkV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AkV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ala: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2Al4; else goto c2Al9;
       c2Al4: // global
           I64[Hp - 80] = sat_s2uJl_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uJ5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Al9: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2Al8; else goto c2Al7;
       c2Al8: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Al7: // global
           I64[Hp - 80] = sat_s2uJq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Al5::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Al5::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo2_info" {
     GHC.Word.$w$cenumFromThenTo2_info:
         const GHC.Word.$w$cenumFromThenTo2_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2vim_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.478521061 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AmP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AmY; else goto c2AmZ;
       c2AmY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AmZ: // global
           I64[Sp - 24] = block_c2AmM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2An8; else goto c2AmN;
       u2An8: // global
           call _c2AmM(R1) args: 0, res: 0, upd: 0;
       c2AmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2vim_srt+200;
 },
 _c2AmM() //  [R1]
         { []
         }
     {offset
       c2AmM: // global
           I64[Sp] = block_c2AmS_info;
           _s2uJv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJv::I64;
           if (R1 & 7 != 0) goto u2An7; else goto c2AmT;
       u2An7: // global
           call _c2AmS(R1) args: 0, res: 0, upd: 0;
       c2AmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AmM_info" {
     block_c2AmM_info:
         const _c2AmM;
         const 2;
         const 4294967326;
         const S2vim_srt+200;
 },
 _c2AmS() //  [R1]
         { []
         }
     {offset
       c2AmS: // global
           I64[Sp] = block_c2AmX_info;
           _s2uJx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uJx::I64;
           if (R1 & 7 != 0) goto u2An9; else goto c2An2;
       u2An9: // global
           call _c2AmX(R1) args: 0, res: 0, upd: 0;
       c2An2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AmS_info" {
     block_c2AmS_info:
         const _c2AmS;
         const 66;
         const 4294967326;
         const S2vim_srt+200;
 },
 _c2AmX() //  [R1]
         { []
         }
     {offset
       c2AmX: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AmX_info" {
     block_c2AmX_info:
         const _c2AmX;
         const 194;
         const 4294967326;
         const S2vim_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.489530055 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2uJN_entry() //  [R1]
         { []
         }
     {offset
       c2AnS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AnT; else goto c2AnU;
       c2AnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AnU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJG::I64 = I64[R1 + 32];
           if (_s2uJG::I64 == I64[R1 + 24]) goto c2AnR; else goto c2AnQ;
       c2AnR: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AnQ: // global
           R2 = _s2uJG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uJF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJN_info" {
     sat_s2uJN_info:
         const sat_s2uJN_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+176;
 },
 sat_s2uJK_entry() //  [R1]
         { []
         }
     {offset
       c2Ao6: // global
           _s2uJK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ao7; else goto c2Ao8;
       c2Ao8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aoa; else goto c2Ao9;
       c2Aoa: // global
           HpAlloc = 16;
           goto c2Ao7;
       c2Ao7: // global
           R1 = _s2uJK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ao9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJK::P64;
           _s2uJG::I64 = I64[_s2uJK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJG::I64, 0)) goto c2Aog; else goto c2Ao5;
       c2Ao5: // global
           if (%MO_S_Gt_W64(_s2uJG::I64, 255)) goto c2Aog; else goto c2Aon;
       c2Aog: // global
           Hp = Hp - 16;
           R2 = _s2uJG::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aon: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJK_info" {
     sat_s2uJK_info:
         const sat_s2uJK_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 go_s2uJF_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Aop: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Aot; else goto c2Aos;
       c2Aot: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Aos: // global
           _s2uJD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uJN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uJD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uJK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2uJF_info" {
     go_s2uJF_info:
         const go_s2uJF_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2vim_srt+176;
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Aou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aoy; else goto c2Aox;
       c2Aoy: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aox: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2AoA; else goto c2AoB;
       c2AoA: // global
           I64[Hp - 8] = go_s2uJF_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uJF_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2AoB: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo2_info" {
     GHC.Word.$w$cenumFromTo2_info:
         const GHC.Word.$w$cenumFromTo2_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2vim_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.500855433 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Ap4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ap8; else goto c2Ap9;
       c2Ap8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ap9: // global
           I64[Sp - 16] = block_c2Ap1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Aph; else goto c2Ap2;
       u2Aph: // global
           call _c2Ap1(R1) args: 0, res: 0, upd: 0;
       c2Ap2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromTo_info" {
     GHC.Word.$fEnumWord8_$cenumFromTo_info:
         const GHC.Word.$fEnumWord8_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+216;
 },
 _c2Ap1() //  [R1]
         { []
         }
     {offset
       c2Ap1: // global
           I64[Sp] = block_c2Ap7_info;
           _s2uJR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uJR::I64;
           if (R1 & 7 != 0) goto u2Apg; else goto c2Apb;
       u2Apg: // global
           call _c2Ap7(R1) args: 0, res: 0, upd: 0;
       c2Apb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ap1_info" {
     block_c2Ap1_info:
         const _c2Ap1;
         const 1;
         const 4294967326;
         const S2vim_srt+216;
 },
 _c2Ap7() //  [R1]
         { []
         }
     {offset
       c2Ap7: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ap7_info" {
     block_c2Ap7_info:
         const _c2Ap7;
         const 65;
         const 4294967326;
         const S2vim_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.510549876 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2uK4_entry() //  [R1]
         { []
         }
     {offset
       c2ApH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ApI; else goto c2ApT;
       c2ApI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ApT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uJZ::I64 = I64[R1 + 16];
           if (_s2uJZ::I64 != 255) goto c2ApF; else goto c2ApG;
       c2ApF: // global
           I64[Sp - 24] = block_c2ApN_info;
           R2 = _s2uJZ::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2ApG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uK4_info" {
     sat_s2uK4_info:
         const sat_s2uK4_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+232;
 },
 _c2ApN() //  [R1, R2]
         { []
         }
     {offset
       c2ApN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ApS; else goto c2ApR;
       c2ApS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2ApR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2ApN_info" {
     block_c2ApN_info:
         const _c2ApN;
         const 0;
         const 30;
 },
 sat_s2uJY_entry() //  [R1]
         { []
         }
     {offset
       c2Aq3: // global
           _s2uJY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Aq4; else goto c2Aq5;
       c2Aq5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aq7; else goto c2Aq6;
       c2Aq7: // global
           HpAlloc = 16;
           goto c2Aq4;
       c2Aq4: // global
           R1 = _s2uJY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Aq6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uJY::P64;
           _s2uJU::I64 = I64[_s2uJY::P64 + 16];
           if (%MO_S_Lt_W64(_s2uJU::I64, 0)) goto c2Aqd; else goto c2Aq2;
       c2Aq2: // global
           if (%MO_S_Gt_W64(_s2uJU::I64, 255)) goto c2Aqd; else goto c2Aqk;
       c2Aqd: // global
           Hp = Hp - 16;
           R2 = _s2uJU::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Aqk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uJU::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uJY_info" {
     sat_s2uJY_info:
         const sat_s2uJY_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+176;
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { []
         }
     {offset
       c2Aql: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2Aqp; else goto c2Aqo;
       c2Aqp: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Aqo: // global
           I64[Hp - 40] = sat_s2uK4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uJY_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo2_info" {
     GHC.Word.$wgo2_info:
         const GHC.Word.$wgo2_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2vim_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.520757815 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { []
         }
     {offset
       c2AqQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AqR; else goto c2AqS;
       c2AqR: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AqS: // global
           I64[Sp - 8] = block_c2AqN_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_go_info" {
     GHC.Word.$fEnumWord8_go_info:
         const GHC.Word.$fEnumWord8_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2vim_srt+232;
 },
 _c2AqN() //  [R1, R2]
         { []
         }
     {offset
       c2AqN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AqV; else goto c2AqU;
       c2AqV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AqU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AqN_info" {
     block_c2AqN_info:
         const _c2AqN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.527433196 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2Arc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ard; else goto c2Are;
       c2Ard: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Are: // global
           I64[Sp - 8] = block_c2Ar9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Arq; else goto c2Ara;
       u2Arq: // global
           call _c2Ar9(R1) args: 0, res: 0, upd: 0;
       c2Ara: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFrom_info" {
     GHC.Word.$fEnumWord8_$cenumFrom_info:
         const GHC.Word.$fEnumWord8_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+240;
 },
 _c2Ar9() //  [R1]
         { []
         }
     {offset
       c2Ar9: // global
           _s2uKc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uKc::I64, 255)) goto c2Aro; else goto c2Arp;
       c2Aro: // global
           R2 = _s2uKc::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2Arp: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ar9_info" {
     block_c2Ar9_info:
         const _c2Ar9;
         const 0;
         const 4294967326;
         const S2vim_srt+240;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.533569429 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ArF: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromThen_info" {
     GHC.Word.$fEnumWord8_$cenumFromThen_info:
         const GHC.Word.$fEnumWord8_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2vim_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.537720259 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.540906793 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { []
         }
     {offset
       c2ArW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ArX; else goto c2ArY;
       c2ArX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ArY: // global
           (_c2ArR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2ArR::I64 == 0) goto c2ArT; else goto c2ArS;
       c2ArT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2ArS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2ArR::I64;
           I64[Sp - 24] = block_c2ArU_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord1_info" {
     GHC.Word.$fEnumWord1_info:
         const GHC.Word.$fEnumWord1_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+112;
 },
 _c2ArU() //  [R1]
         { []
         }
     {offset
       c2ArU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2ArU_info" {
     block_c2ArU_info:
         const _c2ArU;
         const 0;
         const 4294967326;
         const S2vim_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.547377841 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { []
         }
     {offset
       c2Ask: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Asl; else goto c2Asm;
       c2Asl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Asm: // global
           (_c2Asf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Asf::I64 == 0) goto c2Ash; else goto c2Asg;
       c2Ash: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Asg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Asf::I64;
           I64[Sp - 24] = block_c2Asi_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord2_info" {
     GHC.Word.$fEnumWord2_info:
         const GHC.Word.$fEnumWord2_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+120;
 },
 _c2Asi() //  [R1]
         { []
         }
     {offset
       c2Asi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2Asi_info" {
     block_c2Asi_info:
         const _c2Asi;
         const 0;
         const 4294967326;
         const S2vim_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.553914373 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AsH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AsL; else goto c2AsM;
       c2AsL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AsM: // global
           I64[Sp - 16] = block_c2AsE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AsV; else goto c2AsF;
       u2AsV: // global
           call _c2AsE(R1) args: 0, res: 0, upd: 0;
       c2AsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord16_info" {
     GHC.Word.neWord16_info:
         const GHC.Word.neWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2AsE() //  [R1]
         { []
         }
     {offset
       c2AsE: // global
           I64[Sp] = block_c2AsK_info;
           _s2uKj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKj::I64;
           if (R1 & 7 != 0) goto u2AsU; else goto c2AsO;
       u2AsU: // global
           call _c2AsK(R1) args: 0, res: 0, upd: 0;
       c2AsO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AsE_info" {
     block_c2AsE_info:
         const _c2AsE;
         const 1;
         const 30;
 },
 _c2AsK() //  [R1]
         { []
         }
     {offset
       c2AsK: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AsK_info" {
     block_c2AsK_info:
         const _c2AsK;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.561746688 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { []
         }
     {offset
       c2Atj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Atk; else goto c2Atl;
       c2Atk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Atl: // global
           (_c2Atg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Atg::I64 == 0) goto c2Ati; else goto c2Ath;
       c2Ati: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Ath: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Atg::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_r2uFJ_info" {
     lvl4_r2uFJ_info:
         const lvl4_r2uFJ_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.565338851 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.568285554 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2AtB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AtC; else goto c2AtD;
       c2AtC: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AtD: // global
           I64[Sp - 8] = block_c2Aty_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AtV; else goto c2Atz;
       u2AtV: // global
           call _c2Aty(R1) args: 0, res: 0, upd: 0;
       c2Atz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cpred_info" {
     GHC.Word.$fEnumWord16_$cpred_info:
         const GHC.Word.$fEnumWord16_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+264;
 },
 _c2Aty() //  [R1]
         { []
         }
     {offset
       c2Aty: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AtI; else goto c2AtH;
       c2AtI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AtH: // global
           _s2uKq::I64 = I64[R1 + 7];
           if (_s2uKq::I64 != 0) goto c2AtT; else goto c2AtU;
       c2AtT: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AtU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Aty_info" {
     block_c2Aty_info:
         const _c2Aty;
         const 0;
         const 4294967326;
         const S2vim_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.574646356 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.576422103 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.57957413 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2Aui: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Auj; else goto c2Auk;
       c2Auj: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Auk: // global
           I64[Sp - 8] = block_c2Auf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AuC; else goto c2Aug;
       u2AuC: // global
           call _c2Auf(R1) args: 0, res: 0, upd: 0;
       c2Aug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$csucc_info" {
     GHC.Word.$fEnumWord16_$csucc_info:
         const GHC.Word.$fEnumWord16_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+280;
 },
 _c2Auf() //  [R1]
         { []
         }
     {offset
       c2Auf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Aup; else goto c2Auo;
       c2Aup: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Auo: // global
           _s2uKw::I64 = I64[R1 + 7];
           if (_s2uKw::I64 != 65535) goto c2AuA; else goto c2AuB;
       c2AuA: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uKw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AuB: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Auf_info" {
     block_c2Auf_info:
         const _c2Auf;
         const 0;
         const 4294967326;
         const S2vim_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.588159893 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AuX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Avb; else goto c2Avc;
       c2Avb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Avc: // global
           I64[Sp - 24] = block_c2AuU_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Avj; else goto c2AuV;
       u2Avj: // global
           call _c2AuU(R1) args: 0, res: 0, upd: 0;
       c2AuV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshowsPrec_info" {
     GHC.Word.$fShowWord16_$cshowsPrec_info:
         const GHC.Word.$fShowWord16_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2AuU() //  [R1]
         { []
         }
     {offset
       c2AuU: // global
           I64[Sp] = block_c2Av0_info;
           _s2uKD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uKD::I64;
           if (R1 & 7 != 0) goto u2Avi; else goto c2Av1;
       u2Avi: // global
           call _c2Av0(R1) args: 0, res: 0, upd: 0;
       c2Av1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AuU_info" {
     block_c2AuU_info:
         const _c2AuU;
         const 2;
         const 30;
 },
 _c2Av0() //  [R1]
         { []
         }
     {offset
       c2Av0: // global
           _s2uKB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2Av8_info;
           R4 = _s2uKB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Av0_info" {
     block_c2Av0_info:
         const _c2Av0;
         const 66;
         const 30;
 },
 _c2Av8() //  [R1, R2]
         { []
         }
     {offset
       c2Av8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Avh; else goto c2Avg;
       c2Avh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Avg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Av8_info" {
     block_c2Av8_info:
         const _c2Av8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.597740435 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2AvI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AvR; else goto c2AvS;
       c2AvR: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AvS: // global
           I64[Sp - 8] = block_c2AvF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AvX; else goto c2AvG;
       u2AvX: // global
           call _c2AvF(R1) args: 0, res: 0, upd: 0;
       c2AvG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshow_info" {
     GHC.Word.$fShowWord16_$cshow_info:
         const GHC.Word.$fShowWord16_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2AvF() //  [R1]
         { []
         }
     {offset
       c2AvF: // global
           I64[Sp] = block_c2AvO_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AvF_info" {
     block_c2AvF_info:
         const _c2AvF;
         const 0;
         const 30;
 },
 _c2AvO() //  [R1, R2]
         { []
         }
     {offset
       c2AvO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AvW; else goto c2AvV;
       c2AvW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AvV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AvO_info" {
     block_c2AvO_info:
         const _c2AvO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.606644994 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Awi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Awr; else goto c2Aws;
       c2Awr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Aws: // global
           I64[Sp - 16] = block_c2Awf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Awx; else goto c2Awg;
       u2Awx: // global
           call _c2Awf(R1) args: 0, res: 0, upd: 0;
       c2Awg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord1_info" {
     GHC.Word.$fShowWord1_info:
         const GHC.Word.$fShowWord1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Awf() //  [R1]
         { []
         }
     {offset
       c2Awf: // global
           _s2uKS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Awo_info;
           R4 = _s2uKS::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Awf_info" {
     block_c2Awf_info:
         const _c2Awf;
         const 1;
         const 30;
 },
 _c2Awo() //  [R1, R2]
         { []
         }
     {offset
       c2Awo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Aww; else goto c2Awv;
       c2Aww: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Awv: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Awo_info" {
     block_c2Awo_info:
         const _c2Awo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.613906757 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AwP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshowList_info" {
     GHC.Word.$fShowWord16_$cshowList_info:
         const GHC.Word.$fShowWord16_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.617319345 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.6200978 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       c2Ax1: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl_info" {
     GHC.Word.$wlvl_info:
         const GHC.Word.$wlvl_entry;
         const 0;
         const 562954248388622;
         const 4294967300;
         const S2vim_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.624315036 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2Axh: // global
           _s2uL2::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2Axp; else goto c2Axg;
       c2Axg: // global
           if (%MO_S_Gt_W64(_s2uL2::I64, 65535)) goto c2Axp; else goto c2Axt;
       c2Axp: // global
           R2 = _s2uL2::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2Axt: // global
           R1 = _s2uL2::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum_info" {
     GHC.Word.$w$ctoEnum_info:
         const GHC.Word.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2vim_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.629491461 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2AxG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AxO; else goto c2AxP;
       c2AxO: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AxP: // global
           I64[Sp - 8] = block_c2AxD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AxU; else goto c2AxE;
       u2AxU: // global
           call _c2AxD(R1) args: 0, res: 0, upd: 0;
       c2AxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$ctoEnum_info" {
     GHC.Word.$fEnumWord16_$ctoEnum_info:
         const GHC.Word.$fEnumWord16_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+312;
 },
 _c2AxD() //  [R1]
         { []
         }
     {offset
       c2AxD: // global
           I64[Sp] = block_c2AxJ_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AxD_info" {
     block_c2AxD_info:
         const _c2AxD;
         const 0;
         const 4294967326;
         const S2vim_srt+320;
 },
 _c2AxJ() //  [R1]
         { []
         }
     {offset
       c2AxJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AxT; else goto c2AxS;
       c2AxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2AxS: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AxJ_info" {
     block_c2AxJ_info:
         const _c2AxJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.654154041 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2uLx_entry() //  [R1]
         { []
         }
     {offset
       c2AyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AyQ; else goto c2AyR;
       c2AyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AyR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLx_info" {
     sat_s2uLx_info:
         const sat_s2uLx_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+304;
 },
 sat_s2uLv_entry() //  [R1]
         { []
         }
     {offset
       c2Az1: // global
           _s2uLv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Az2; else goto c2Az3;
       c2Az3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Az5; else goto c2Az4;
       c2Az5: // global
           HpAlloc = 16;
           goto c2Az2;
       c2Az2: // global
           R1 = _s2uLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Az4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLv::P64;
           _s2uLq::I64 = I64[_s2uLv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2Azb; else goto c2Az0;
       c2Az0: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2Azb; else goto c2Azi;
       c2Azb: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2Azi: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLv_info" {
     sat_s2uLv_info:
         const sat_s2uLv_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 sat_s2uLB_entry() //  [R1]
         { []
         }
     {offset
       c2Azt: // global
           _s2uLB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Azu; else goto c2Azv;
       c2Azv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Azx; else goto c2Azw;
       c2Azx: // global
           HpAlloc = 16;
           goto c2Azu;
       c2Azu: // global
           R1 = _s2uLB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Azw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLB::P64;
           _s2uLq::I64 = I64[_s2uLB::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLq::I64, 0)) goto c2AzD; else goto c2Azs;
       c2Azs: // global
           if (%MO_S_Gt_W64(_s2uLq::I64, 65535)) goto c2AzD; else goto c2AzK;
       c2AzD: // global
           Hp = Hp - 16;
           R2 = _s2uLq::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AzK: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLq::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLB_info" {
     sat_s2uLB_info:
         const sat_s2uLB_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 go_dn_s2uLp_entry() //  [R1, R2]
         { []
         }
     {offset
       c2AzO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AzS; else goto c2AzR;
       c2AzS: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AzR: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2AzM; else goto c2AzN;
       c2AzM: // global
           _s2uLn::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLx_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLn::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AzN: // global
           I64[Hp - 80] = sat_s2uLB_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AzU::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AzU::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2uLp_info" {
     go_dn_s2uLp_info:
         const go_dn_s2uLp_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+304;
 },
 sat_s2uLC_entry() //  [R1]
         { []
         }
     {offset
       c2AzV: // global
           _s2uLC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AzW; else goto c2AzX;
       c2AzX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AzZ; else goto c2AzY;
       c2AzZ: // global
           HpAlloc = 24;
           goto c2AzW;
       c2AzW: // global
           R1 = _s2uLC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AzY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLC::P64;
           _s2uLf::I64 = I64[_s2uLC::P64 + 24];
           _s2uLn::I64 = _s2uLf::I64 - I64[_s2uLC::P64 + 16];
           _s2uLo::I64 = I64[_s2uLC::P64 + 32] - _s2uLn::I64;
           I64[Hp - 16] = go_dn_s2uLp_info;
           I64[Hp - 8] = _s2uLn::I64;
           I64[Hp] = _s2uLo::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uLp_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLC_info" {
     sat_s2uLC_info:
         const sat_s2uLC_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+304;
 },
 sat_s2uLm_entry() //  [R1]
         { []
         }
     {offset
       c2AA9: // global
           _s2uLm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AAa; else goto c2AAb;
       c2AAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AAd; else goto c2AAc;
       c2AAd: // global
           HpAlloc = 16;
           goto c2AAa;
       c2AAa: // global
           R1 = _s2uLm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AAc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLm::P64;
           _s2uLe::I64 = I64[_s2uLm::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2AAj; else goto c2AA8;
       c2AA8: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2AAj; else goto c2AAq;
       c2AAj: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AAq: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLm_info" {
     sat_s2uLm_info:
         const sat_s2uLm_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 sat_s2uLH_entry() //  [R1]
         { []
         }
     {offset
       c2AAE: // global
           _s2uLH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AAF; else goto c2AAG;
       c2AAG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AAI; else goto c2AAH;
       c2AAI: // global
           HpAlloc = 16;
           goto c2AAF;
       c2AAF: // global
           R1 = _s2uLH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AAH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLH::P64;
           _s2uLe::I64 = I64[_s2uLH::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2AAO; else goto c2AAD;
       c2AAD: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2AAO; else goto c2AAV;
       c2AAO: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AAV: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLH_info" {
     sat_s2uLH_info:
         const sat_s2uLH_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 sat_s2uLY_entry() //  [R1]
         { []
         }
     {offset
       c2ABr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ABs; else goto c2ABt;
       c2ABs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ABt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLY_info" {
     sat_s2uLY_info:
         const sat_s2uLY_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+304;
 },
 sat_s2uLW_entry() //  [R1]
         { []
         }
     {offset
       c2ABD: // global
           _s2uLW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ABE; else goto c2ABF;
       c2ABF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ABH; else goto c2ABG;
       c2ABH: // global
           HpAlloc = 16;
           goto c2ABE;
       c2ABE: // global
           R1 = _s2uLW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ABG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLW::P64;
           _s2uLR::I64 = I64[_s2uLW::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2ABN; else goto c2ABC;
       c2ABC: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2ABN; else goto c2ABU;
       c2ABN: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ABU: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLW_info" {
     sat_s2uLW_info:
         const sat_s2uLW_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 sat_s2uM2_entry() //  [R1]
         { []
         }
     {offset
       c2AC5: // global
           _s2uM2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AC6; else goto c2AC7;
       c2AC7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AC9; else goto c2AC8;
       c2AC9: // global
           HpAlloc = 16;
           goto c2AC6;
       c2AC6: // global
           R1 = _s2uM2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AC8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM2::P64;
           _s2uLR::I64 = I64[_s2uM2::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLR::I64, 0)) goto c2ACf; else goto c2AC4;
       c2AC4: // global
           if (%MO_S_Gt_W64(_s2uLR::I64, 65535)) goto c2ACf; else goto c2ACm;
       c2ACf: // global
           Hp = Hp - 16;
           R2 = _s2uLR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ACm: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uM2_info" {
     sat_s2uM2_info:
         const sat_s2uM2_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 go_up_s2uLQ_entry() //  [R1, R2]
         { []
         }
     {offset
       c2ACq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ACu; else goto c2ACt;
       c2ACu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ACt: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2ACo; else goto c2ACp;
       c2ACo: // global
           _s2uLO::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uLY_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uLO::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uLW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ACp: // global
           I64[Hp - 80] = sat_s2uM2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ACw::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ACw::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2uLQ_info" {
     go_up_s2uLQ_info:
         const go_up_s2uLQ_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+304;
 },
 sat_s2uM3_entry() //  [R1]
         { []
         }
     {offset
       c2ACx: // global
           _s2uM3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ACy; else goto c2ACz;
       c2ACz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ACB; else goto c2ACA;
       c2ACB: // global
           HpAlloc = 24;
           goto c2ACy;
       c2ACy: // global
           R1 = _s2uM3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ACA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM3::P64;
           _s2uLf::I64 = I64[_s2uM3::P64 + 24];
           _s2uLO::I64 = _s2uLf::I64 - I64[_s2uM3::P64 + 16];
           _s2uLP::I64 = I64[_s2uM3::P64 + 32] - _s2uLO::I64;
           I64[Hp - 16] = go_up_s2uLQ_info;
           I64[Hp - 8] = _s2uLO::I64;
           I64[Hp] = _s2uLP::I64;
           R2 = _s2uLf::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uLQ_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uM3_info" {
     sat_s2uM3_info:
         const sat_s2uM3_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+304;
 },
 sat_s2uLN_entry() //  [R1]
         { []
         }
     {offset
       c2ACL: // global
           _s2uLN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ACM; else goto c2ACN;
       c2ACN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ACP; else goto c2ACO;
       c2ACP: // global
           HpAlloc = 16;
           goto c2ACM;
       c2ACM: // global
           R1 = _s2uLN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ACO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uLN::P64;
           _s2uLe::I64 = I64[_s2uLN::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2ACV; else goto c2ACK;
       c2ACK: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2ACV; else goto c2AD2;
       c2ACV: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AD2: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uLN_info" {
     sat_s2uLN_info:
         const sat_s2uLN_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 sat_s2uM8_entry() //  [R1]
         { []
         }
     {offset
       c2ADg: // global
           _s2uM8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ADh; else goto c2ADi;
       c2ADi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ADk; else goto c2ADj;
       c2ADk: // global
           HpAlloc = 16;
           goto c2ADh;
       c2ADh: // global
           R1 = _s2uM8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ADj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uM8::P64;
           _s2uLe::I64 = I64[_s2uM8::P64 + 16];
           if (%MO_S_Lt_W64(_s2uLe::I64, 0)) goto c2ADq; else goto c2ADf;
       c2ADf: // global
           if (%MO_S_Gt_W64(_s2uLe::I64, 65535)) goto c2ADq; else goto c2ADx;
       c2ADq: // global
           Hp = Hp - 16;
           R2 = _s2uLe::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ADx: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uLe::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uM8_info" {
     sat_s2uM8_info:
         const sat_s2uM8_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2ADy: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ADC; else goto c2ADB;
       c2ADC: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ADB: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2ADM; else goto c2ADV;
       c2ADM: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2ADF; else goto c2ADK;
       c2ADF: // global
           I64[Hp - 80] = sat_s2uLC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADK: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2ADT; else goto c2ADI;
       c2ADI: // global
           I64[Hp - 80] = sat_s2uLH_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ADG::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ADG::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADV: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2ADP; else goto c2ADU;
       c2ADP: // global
           I64[Hp - 80] = sat_s2uM3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uLN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADU: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2ADT; else goto c2ADS;
       c2ADT: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ADS: // global
           I64[Hp - 80] = sat_s2uM8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ADQ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ADQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo_info" {
     GHC.Word.$w$cenumFromThenTo_info:
         const GHC.Word.$w$cenumFromThenTo_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2vim_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.693234169 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AFA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AFJ; else goto c2AFK;
       c2AFJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AFK: // global
           I64[Sp - 24] = block_c2AFx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AFT; else goto c2AFy;
       u2AFT: // global
           call _c2AFx(R1) args: 0, res: 0, upd: 0;
       c2AFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2vim_srt+328;
 },
 _c2AFx() //  [R1]
         { []
         }
     {offset
       c2AFx: // global
           I64[Sp] = block_c2AFD_info;
           _s2uMd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMd::I64;
           if (R1 & 7 != 0) goto u2AFS; else goto c2AFE;
       u2AFS: // global
           call _c2AFD(R1) args: 0, res: 0, upd: 0;
       c2AFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AFx_info" {
     block_c2AFx_info:
         const _c2AFx;
         const 2;
         const 4294967326;
         const S2vim_srt+328;
 },
 _c2AFD() //  [R1]
         { []
         }
     {offset
       c2AFD: // global
           I64[Sp] = block_c2AFI_info;
           _s2uMf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uMf::I64;
           if (R1 & 7 != 0) goto u2AFU; else goto c2AFN;
       u2AFU: // global
           call _c2AFI(R1) args: 0, res: 0, upd: 0;
       c2AFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AFD_info" {
     block_c2AFD_info:
         const _c2AFD;
         const 66;
         const 4294967326;
         const S2vim_srt+328;
 },
 _c2AFI() //  [R1]
         { []
         }
     {offset
       c2AFI: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AFI_info" {
     block_c2AFI_info:
         const _c2AFI;
         const 194;
         const 4294967326;
         const S2vim_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.7045095 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2uMv_entry() //  [R1]
         { []
         }
     {offset
       c2AGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AGE; else goto c2AGF;
       c2AGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMo::I64 = I64[R1 + 32];
           if (_s2uMo::I64 == I64[R1 + 24]) goto c2AGC; else goto c2AGB;
       c2AGC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AGB: // global
           R2 = _s2uMo::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uMn_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uMv_info" {
     sat_s2uMv_info:
         const sat_s2uMv_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+304;
 },
 sat_s2uMs_entry() //  [R1]
         { []
         }
     {offset
       c2AGR: // global
           _s2uMs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AGS; else goto c2AGT;
       c2AGT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AGV; else goto c2AGU;
       c2AGV: // global
           HpAlloc = 16;
           goto c2AGS;
       c2AGS: // global
           R1 = _s2uMs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AGU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMs::P64;
           _s2uMo::I64 = I64[_s2uMs::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMo::I64, 0)) goto c2AH1; else goto c2AGQ;
       c2AGQ: // global
           if (%MO_S_Gt_W64(_s2uMo::I64, 65535)) goto c2AH1; else goto c2AH8;
       c2AH1: // global
           Hp = Hp - 16;
           R2 = _s2uMo::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AH8: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMo::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uMs_info" {
     sat_s2uMs_info:
         const sat_s2uMs_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 go_s2uMn_entry() //  [R1, R2]
         { []
         }
     {offset
       c2AHa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AHe; else goto c2AHd;
       c2AHe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AHd: // global
           _s2uMl::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uMv_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uMl::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uMs_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2uMn_info" {
     go_s2uMn_info:
         const go_s2uMn_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2vim_srt+304;
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AHf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AHj; else goto c2AHi;
       c2AHj: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AHi: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2AHl; else goto c2AHm;
       c2AHl: // global
           I64[Hp - 8] = go_s2uMn_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uMn_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2AHm: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo_info" {
     GHC.Word.$w$cenumFromTo_info:
         const GHC.Word.$w$cenumFromTo_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2vim_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.716030461 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AHP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AHT; else goto c2AHU;
       c2AHT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AHU: // global
           I64[Sp - 16] = block_c2AHM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2AI2; else goto c2AHN;
       u2AI2: // global
           call _c2AHM(R1) args: 0, res: 0, upd: 0;
       c2AHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromTo_info" {
     GHC.Word.$fEnumWord16_$cenumFromTo_info:
         const GHC.Word.$fEnumWord16_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+344;
 },
 _c2AHM() //  [R1]
         { []
         }
     {offset
       c2AHM: // global
           I64[Sp] = block_c2AHS_info;
           _s2uMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uMz::I64;
           if (R1 & 7 != 0) goto u2AI1; else goto c2AHW;
       u2AI1: // global
           call _c2AHS(R1) args: 0, res: 0, upd: 0;
       c2AHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AHM_info" {
     block_c2AHM_info:
         const _c2AHM;
         const 1;
         const 4294967326;
         const S2vim_srt+344;
 },
 _c2AHS() //  [R1]
         { []
         }
     {offset
       c2AHS: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AHS_info" {
     block_c2AHS_info:
         const _c2AHS;
         const 65;
         const 4294967326;
         const S2vim_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.726194524 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2uMM_entry() //  [R1]
         { []
         }
     {offset
       c2AIs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AIt; else goto c2AIE;
       c2AIt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uMH::I64 = I64[R1 + 16];
           if (_s2uMH::I64 != 65535) goto c2AIq; else goto c2AIr;
       c2AIq: // global
           I64[Sp - 24] = block_c2AIy_info;
           R2 = _s2uMH::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2AIr: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uMM_info" {
     sat_s2uMM_info:
         const sat_s2uMM_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+360;
 },
 _c2AIy() //  [R1, R2]
         { []
         }
     {offset
       c2AIy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AID; else goto c2AIC;
       c2AID: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2AIC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2AIy_info" {
     block_c2AIy_info:
         const _c2AIy;
         const 0;
         const 30;
 },
 sat_s2uMG_entry() //  [R1]
         { []
         }
     {offset
       c2AIO: // global
           _s2uMG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AIP; else goto c2AIQ;
       c2AIQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AIS; else goto c2AIR;
       c2AIS: // global
           HpAlloc = 16;
           goto c2AIP;
       c2AIP: // global
           R1 = _s2uMG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AIR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uMG::P64;
           _s2uMC::I64 = I64[_s2uMG::P64 + 16];
           if (%MO_S_Lt_W64(_s2uMC::I64, 0)) goto c2AIY; else goto c2AIN;
       c2AIN: // global
           if (%MO_S_Gt_W64(_s2uMC::I64, 65535)) goto c2AIY; else goto c2AJ5;
       c2AIY: // global
           Hp = Hp - 16;
           R2 = _s2uMC::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2AJ5: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uMC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uMG_info" {
     sat_s2uMG_info:
         const sat_s2uMG_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+304;
 },
 GHC.Word.$wgo_entry() //  [R2]
         { []
         }
     {offset
       c2AJ6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2AJa; else goto c2AJ9;
       c2AJa: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJ9: // global
           I64[Hp - 40] = sat_s2uMM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uMG_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo_info" {
     GHC.Word.$wgo_info:
         const GHC.Word.$wgo_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2vim_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.736160887 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { []
         }
     {offset
       c2AJB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AJC; else goto c2AJD;
       c2AJC: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJD: // global
           I64[Sp - 8] = block_c2AJy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_go_info" {
     GHC.Word.$fEnumWord16_go_info:
         const GHC.Word.$fEnumWord16_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2vim_srt+360;
 },
 _c2AJy() //  [R1, R2]
         { []
         }
     {offset
       c2AJy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AJG; else goto c2AJF;
       c2AJG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AJF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AJy_info" {
     block_c2AJy_info:
         const _c2AJy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.74277825 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2AJX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AJY; else goto c2AJZ;
       c2AJY: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AJZ: // global
           I64[Sp - 8] = block_c2AJU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AKb; else goto c2AJV;
       u2AKb: // global
           call _c2AJU(R1) args: 0, res: 0, upd: 0;
       c2AJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFrom_info" {
     GHC.Word.$fEnumWord16_$cenumFrom_info:
         const GHC.Word.$fEnumWord16_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+368;
 },
 _c2AJU() //  [R1]
         { []
         }
     {offset
       c2AJU: // global
           _s2uMU::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uMU::I64, 65535)) goto c2AK9; else goto c2AKa;
       c2AK9: // global
           R2 = _s2uMU::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2AKa: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AJU_info" {
     block_c2AJU_info:
         const _c2AJU;
         const 0;
         const 4294967326;
         const S2vim_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.748549355 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AKq: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromThen_info" {
     GHC.Word.$fEnumWord16_$cenumFromThen_info:
         const GHC.Word.$fEnumWord16_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2vim_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.752572338 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.755850763 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { []
         }
     {offset
       c2AKH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AKI; else goto c2AKJ;
       c2AKI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AKJ: // global
           (_c2AKC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AKC::I64 == 0) goto c2AKE; else goto c2AKD;
       c2AKE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AKD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AKC::I64;
           I64[Sp - 24] = block_c2AKF_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord3_info" {
     GHC.Word.$fEnumWord3_info:
         const GHC.Word.$fEnumWord3_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+392;
 },
 _c2AKF() //  [R1]
         { []
         }
     {offset
       c2AKF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2AKF_info" {
     block_c2AKF_info:
         const _c2AKF;
         const 0;
         const 4294967326;
         const S2vim_srt+392;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.762355169 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { []
         }
     {offset
       c2AL5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AL6; else goto c2AL7;
       c2AL6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AL7: // global
           (_c2AL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AL0::I64 == 0) goto c2AL2; else goto c2AL1;
       c2AL2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AL1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AL0::I64;
           I64[Sp - 24] = block_c2AL3_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord4_info" {
     GHC.Word.$fEnumWord4_info:
         const GHC.Word.$fEnumWord4_entry;
         const 0;
         const 4294967317;
         const S2vim_srt+400;
 },
 _c2AL3() //  [R1]
         { []
         }
     {offset
       c2AL3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2AL3_info" {
     block_c2AL3_info:
         const _c2AL3;
         const 0;
         const 4294967326;
         const S2vim_srt+400;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.768638921 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ALs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ALw; else goto c2ALx;
       c2ALw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ALx: // global
           I64[Sp - 16] = block_c2ALp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ALG; else goto c2ALq;
       u2ALG: // global
           call _c2ALp(R1) args: 0, res: 0, upd: 0;
       c2ALq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord32_info" {
     GHC.Word.neWord32_info:
         const GHC.Word.neWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2ALp() //  [R1]
         { []
         }
     {offset
       c2ALp: // global
           I64[Sp] = block_c2ALv_info;
           _s2uN1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uN1::I64;
           if (R1 & 7 != 0) goto u2ALF; else goto c2ALz;
       u2ALF: // global
           call _c2ALv(R1) args: 0, res: 0, upd: 0;
       c2ALz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ALp_info" {
     block_c2ALp_info:
         const _c2ALp;
         const 1;
         const 30;
 },
 _c2ALv() //  [R1]
         { []
         }
     {offset
       c2ALv: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ALv_info" {
     block_c2ALv_info:
         const _c2ALv;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.776545869 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { []
         }
     {offset
       c2AM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AM5; else goto c2AM6;
       c2AM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AM6: // global
           (_c2AM1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2AM1::I64 == 0) goto c2AM3; else goto c2AM2;
       c2AM3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2AM2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2AM1::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_r2uFL_info" {
     lvl6_r2uFL_info:
         const lvl6_r2uFL_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.780305347 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.783344019 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2AMm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AMn; else goto c2AMo;
       c2AMn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AMo: // global
           I64[Sp - 8] = block_c2AMj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AMG; else goto c2AMk;
       u2AMG: // global
           call _c2AMj(R1) args: 0, res: 0, upd: 0;
       c2AMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cpred_info" {
     GHC.Word.$fEnumWord32_$cpred_info:
         const GHC.Word.$fEnumWord32_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+408;
 },
 _c2AMj() //  [R1]
         { []
         }
     {offset
       c2AMj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AMt; else goto c2AMs;
       c2AMt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AMs: // global
           _s2uN8::I64 = I64[R1 + 7];
           if (_s2uN8::I64 != 0) goto c2AME; else goto c2AMF;
       c2AME: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uN8::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AMF: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AMj_info" {
     block_c2AMj_info:
         const _c2AMj;
         const 0;
         const 4294967326;
         const S2vim_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.789644733 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.791358254 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.794505857 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2AN3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AN4; else goto c2AN5;
       c2AN4: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AN5: // global
           I64[Sp - 8] = block_c2AN0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ANn; else goto c2AN1;
       u2ANn: // global
           call _c2AN0(R1) args: 0, res: 0, upd: 0;
       c2AN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$csucc_info" {
     GHC.Word.$fEnumWord32_$csucc_info:
         const GHC.Word.$fEnumWord32_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+424;
 },
 _c2AN0() //  [R1]
         { []
         }
     {offset
       c2AN0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ANa; else goto c2AN9;
       c2ANa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2AN9: // global
           _s2uNe::I64 = I64[R1 + 7];
           if (_s2uNe::I64 != 4294967295) goto c2ANl; else goto c2ANm;
       c2ANl: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uNe::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ANm: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AN0_info" {
     block_c2AN0_info:
         const _c2AN0;
         const 0;
         const 4294967326;
         const S2vim_srt+432;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.802036047 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2ANJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ANX; else goto c2ANY;
       c2ANX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ANY: // global
           I64[Sp - 24] = block_c2ANG_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AO5; else goto c2ANH;
       u2AO5: // global
           call _c2ANG(R1) args: 0, res: 0, upd: 0;
       c2ANH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshowsPrec_info" {
     GHC.Word.$fShowWord32_$cshowsPrec_info:
         const GHC.Word.$fShowWord32_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2ANG() //  [R1]
         { []
         }
     {offset
       c2ANG: // global
           I64[Sp] = block_c2ANM_info;
           _s2uNl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uNl::I64;
           if (R1 & 7 != 0) goto u2AO4; else goto c2ANN;
       u2AO4: // global
           call _c2ANM(R1) args: 0, res: 0, upd: 0;
       c2ANN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ANG_info" {
     block_c2ANG_info:
         const _c2ANG;
         const 2;
         const 30;
 },
 _c2ANM() //  [R1]
         { []
         }
     {offset
       c2ANM: // global
           _s2uNj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2ANU_info;
           R4 = _s2uNj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ANM_info" {
     block_c2ANM_info:
         const _c2ANM;
         const 66;
         const 30;
 },
 _c2ANU() //  [R1, R2]
         { []
         }
     {offset
       c2ANU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AO3; else goto c2AO2;
       c2AO3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AO2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ANU_info" {
     block_c2ANU_info:
         const _c2ANU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.811673662 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2AOu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AOD; else goto c2AOE;
       c2AOD: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AOE: // global
           I64[Sp - 8] = block_c2AOr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AOJ; else goto c2AOs;
       u2AOJ: // global
           call _c2AOr(R1) args: 0, res: 0, upd: 0;
       c2AOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshow_info" {
     GHC.Word.$fShowWord32_$cshow_info:
         const GHC.Word.$fShowWord32_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2AOr() //  [R1]
         { []
         }
     {offset
       c2AOr: // global
           I64[Sp] = block_c2AOA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AOr_info" {
     block_c2AOr_info:
         const _c2AOr;
         const 0;
         const 30;
 },
 _c2AOA() //  [R1, R2]
         { []
         }
     {offset
       c2AOA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AOI; else goto c2AOH;
       c2AOI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2AOH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AOA_info" {
     block_c2AOA_info:
         const _c2AOA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.8201749 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { []
         }
     {offset
       c2AP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2APd; else goto c2APe;
       c2APd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2APe: // global
           I64[Sp - 16] = block_c2AP1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2APj; else goto c2AP2;
       u2APj: // global
           call _c2AP1(R1) args: 0, res: 0, upd: 0;
       c2AP2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord2_info" {
     GHC.Word.$fShowWord2_info:
         const GHC.Word.$fShowWord2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2AP1() //  [R1]
         { []
         }
     {offset
       c2AP1: // global
           _s2uNA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2APa_info;
           R4 = _s2uNA::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AP1_info" {
     block_c2AP1_info:
         const _c2AP1;
         const 1;
         const 30;
 },
 _c2APa() //  [R1, R2]
         { []
         }
     {offset
       c2APa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2APi; else goto c2APh;
       c2APi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2APh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2APa_info" {
     block_c2APa_info:
         const _c2APa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.827246739 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2APB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshowList_info" {
     GHC.Word.$fShowWord32_$cshowList_info:
         const GHC.Word.$fShowWord32_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.8309262 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.833577752 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { []
         }
     {offset
       c2APN: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl1_info" {
     GHC.Word.$wlvl1_info:
         const GHC.Word.$wlvl1_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2vim_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.837566627 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { []
         }
     {offset
       c2AQ3: // global
           _s2uNK::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2AQb; else goto c2AQ2;
       c2AQ2: // global
           if (%MO_S_Gt_W64(_s2uNK::I64,
                            4294967295)) goto c2AQb; else goto c2AQf;
       c2AQb: // global
           R2 = _s2uNK::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2AQf: // global
           R1 = _s2uNK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum1_info" {
     GHC.Word.$w$ctoEnum1_info:
         const GHC.Word.$w$ctoEnum1_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2vim_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.842397905 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2AQt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2AQB; else goto c2AQC;
       c2AQB: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AQC: // global
           I64[Sp - 8] = block_c2AQq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2AQH; else goto c2AQr;
       u2AQH: // global
           call _c2AQq(R1) args: 0, res: 0, upd: 0;
       c2AQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$ctoEnum_info" {
     GHC.Word.$fEnumWord32_$ctoEnum_info:
         const GHC.Word.$fEnumWord32_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+464;
 },
 _c2AQq() //  [R1]
         { []
         }
     {offset
       c2AQq: // global
           I64[Sp] = block_c2AQw_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AQq_info" {
     block_c2AQq_info:
         const _c2AQq;
         const 0;
         const 4294967326;
         const S2vim_srt+472;
 },
 _c2AQw() //  [R1]
         { []
         }
     {offset
       c2AQw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AQG; else goto c2AQF;
       c2AQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2AQF: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AQw_info" {
     block_c2AQw_info:
         const _c2AQw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.861699716 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2uOf_entry() //  [R1]
         { []
         }
     {offset
       c2ARC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ARD; else goto c2ARE;
       c2ARD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ARE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOf_info" {
     sat_s2uOf_info:
         const sat_s2uOf_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+456;
 },
 sat_s2uOd_entry() //  [R1]
         { []
         }
     {offset
       c2ARO: // global
           _s2uOd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ARP; else goto c2ARQ;
       c2ARQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ARS; else goto c2ARR;
       c2ARS: // global
           HpAlloc = 16;
           goto c2ARP;
       c2ARP: // global
           R1 = _s2uOd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ARR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOd::P64;
           _s2uO8::I64 = I64[_s2uOd::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2ARY; else goto c2ARN;
       c2ARN: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2ARY; else goto c2AS5;
       c2ARY: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AS5: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOd_info" {
     sat_s2uOd_info:
         const sat_s2uOd_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 sat_s2uOj_entry() //  [R1]
         { []
         }
     {offset
       c2ASg: // global
           _s2uOj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASh; else goto c2ASi;
       c2ASi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ASk; else goto c2ASj;
       c2ASk: // global
           HpAlloc = 16;
           goto c2ASh;
       c2ASh: // global
           R1 = _s2uOj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOj::P64;
           _s2uO8::I64 = I64[_s2uOj::P64 + 16];
           if (%MO_S_Lt_W64(_s2uO8::I64, 0)) goto c2ASq; else goto c2ASf;
       c2ASf: // global
           if (%MO_S_Gt_W64(_s2uO8::I64,
                            4294967295)) goto c2ASq; else goto c2ASx;
       c2ASq: // global
           Hp = Hp - 16;
           R2 = _s2uO8::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ASx: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uO8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOj_info" {
     sat_s2uOj_info:
         const sat_s2uOj_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 go_dn_s2uO7_entry() //  [R1, R2]
         { []
         }
     {offset
       c2ASB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ASF; else goto c2ASE;
       c2ASF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ASE: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2ASz; else goto c2ASA;
       c2ASz: // global
           _s2uO5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOf_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uO5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ASA: // global
           I64[Hp - 80] = sat_s2uOj_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2ASH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2ASH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2uO7_info" {
     go_dn_s2uO7_info:
         const go_dn_s2uO7_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+456;
 },
 sat_s2uOk_entry() //  [R1]
         { []
         }
     {offset
       c2ASI: // global
           _s2uOk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASJ; else goto c2ASK;
       c2ASK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ASM; else goto c2ASL;
       c2ASM: // global
           HpAlloc = 24;
           goto c2ASJ;
       c2ASJ: // global
           R1 = _s2uOk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOk::P64;
           _s2uNX::I64 = I64[_s2uOk::P64 + 24];
           _s2uO5::I64 = _s2uNX::I64 - I64[_s2uOk::P64 + 16];
           _s2uO6::I64 = I64[_s2uOk::P64 + 32] - _s2uO5::I64;
           I64[Hp - 16] = go_dn_s2uO7_info;
           I64[Hp - 8] = _s2uO5::I64;
           I64[Hp] = _s2uO6::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2uO7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOk_info" {
     sat_s2uOk_info:
         const sat_s2uOk_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+456;
 },
 sat_s2uO4_entry() //  [R1]
         { []
         }
     {offset
       c2ASW: // global
           _s2uO4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ASX; else goto c2ASY;
       c2ASY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AT0; else goto c2ASZ;
       c2AT0: // global
           HpAlloc = 16;
           goto c2ASX;
       c2ASX: // global
           R1 = _s2uO4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ASZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uO4::P64;
           _s2uNW::I64 = I64[_s2uO4::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AT6; else goto c2ASV;
       c2ASV: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AT6; else goto c2ATd;
       c2AT6: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ATd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uO4_info" {
     sat_s2uO4_info:
         const sat_s2uO4_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 sat_s2uOp_entry() //  [R1]
         { []
         }
     {offset
       c2ATr: // global
           _s2uOp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ATs; else goto c2ATt;
       c2ATt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ATv; else goto c2ATu;
       c2ATv: // global
           HpAlloc = 16;
           goto c2ATs;
       c2ATs: // global
           R1 = _s2uOp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ATu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOp::P64;
           _s2uNW::I64 = I64[_s2uOp::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2ATB; else goto c2ATq;
       c2ATq: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2ATB; else goto c2ATI;
       c2ATB: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2ATI: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOp_info" {
     sat_s2uOp_info:
         const sat_s2uOp_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 sat_s2uOG_entry() //  [R1]
         { []
         }
     {offset
       c2AUe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUf; else goto c2AUg;
       c2AUf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOG_info" {
     sat_s2uOG_info:
         const sat_s2uOG_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+456;
 },
 sat_s2uOE_entry() //  [R1]
         { []
         }
     {offset
       c2AUq: // global
           _s2uOE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUr; else goto c2AUs;
       c2AUs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AUu; else goto c2AUt;
       c2AUu: // global
           HpAlloc = 16;
           goto c2AUr;
       c2AUr: // global
           R1 = _s2uOE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOE::P64;
           _s2uOz::I64 = I64[_s2uOE::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2AUA; else goto c2AUp;
       c2AUp: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2AUA; else goto c2AUH;
       c2AUA: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AUH: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOE_info" {
     sat_s2uOE_info:
         const sat_s2uOE_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 sat_s2uOK_entry() //  [R1]
         { []
         }
     {offset
       c2AUS: // global
           _s2uOK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AUT; else goto c2AUU;
       c2AUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AUW; else goto c2AUV;
       c2AUW: // global
           HpAlloc = 16;
           goto c2AUT;
       c2AUT: // global
           R1 = _s2uOK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOK::P64;
           _s2uOz::I64 = I64[_s2uOK::P64 + 16];
           if (%MO_S_Lt_W64(_s2uOz::I64, 0)) goto c2AV2; else goto c2AUR;
       c2AUR: // global
           if (%MO_S_Gt_W64(_s2uOz::I64,
                            4294967295)) goto c2AV2; else goto c2AV9;
       c2AV2: // global
           Hp = Hp - 16;
           R2 = _s2uOz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AV9: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uOz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOK_info" {
     sat_s2uOK_info:
         const sat_s2uOK_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 go_up_s2uOy_entry() //  [R1, R2]
         { []
         }
     {offset
       c2AVd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AVh; else goto c2AVg;
       c2AVh: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2AVg: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2AVb; else goto c2AVc;
       c2AVb: // global
           _s2uOw::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uOG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uOw::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uOE_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AVc: // global
           I64[Hp - 80] = sat_s2uOK_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AVj::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AVj::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2uOy_info" {
     go_up_s2uOy_info:
         const go_up_s2uOy_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2vim_srt+456;
 },
 sat_s2uOL_entry() //  [R1]
         { []
         }
     {offset
       c2AVk: // global
           _s2uOL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AVl; else goto c2AVm;
       c2AVm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2AVo; else goto c2AVn;
       c2AVo: // global
           HpAlloc = 24;
           goto c2AVl;
       c2AVl: // global
           R1 = _s2uOL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AVn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOL::P64;
           _s2uNX::I64 = I64[_s2uOL::P64 + 24];
           _s2uOw::I64 = _s2uNX::I64 - I64[_s2uOL::P64 + 16];
           _s2uOx::I64 = I64[_s2uOL::P64 + 32] - _s2uOw::I64;
           I64[Hp - 16] = go_up_s2uOy_info;
           I64[Hp - 8] = _s2uOw::I64;
           I64[Hp] = _s2uOx::I64;
           R2 = _s2uNX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2uOy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOL_info" {
     sat_s2uOL_info:
         const sat_s2uOL_entry;
         const 12884901888;
         const 4294967311;
         const S2vim_srt+456;
 },
 sat_s2uOv_entry() //  [R1]
         { []
         }
     {offset
       c2AVy: // global
           _s2uOv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AVz; else goto c2AVA;
       c2AVA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AVC; else goto c2AVB;
       c2AVC: // global
           HpAlloc = 16;
           goto c2AVz;
       c2AVz: // global
           R1 = _s2uOv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOv::P64;
           _s2uNW::I64 = I64[_s2uOv::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AVI; else goto c2AVx;
       c2AVx: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AVI; else goto c2AVP;
       c2AVI: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AVP: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOv_info" {
     sat_s2uOv_info:
         const sat_s2uOv_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 sat_s2uOQ_entry() //  [R1]
         { []
         }
     {offset
       c2AW3: // global
           _s2uOQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AW4; else goto c2AW5;
       c2AW5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AW7; else goto c2AW6;
       c2AW7: // global
           HpAlloc = 16;
           goto c2AW4;
       c2AW4: // global
           R1 = _s2uOQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AW6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uOQ::P64;
           _s2uNW::I64 = I64[_s2uOQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2uNW::I64, 0)) goto c2AWd; else goto c2AW2;
       c2AW2: // global
           if (%MO_S_Gt_W64(_s2uNW::I64,
                            4294967295)) goto c2AWd; else goto c2AWk;
       c2AWd: // global
           Hp = Hp - 16;
           R2 = _s2uNW::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2AWk: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uNW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uOQ_info" {
     sat_s2uOQ_info:
         const sat_s2uOQ_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AWl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2AWp; else goto c2AWo;
       c2AWp: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AWo: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2AWz; else goto c2AWI;
       c2AWz: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2AWs; else goto c2AWx;
       c2AWs: // global
           I64[Hp - 80] = sat_s2uOk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uO4_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWx: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2AWG; else goto c2AWv;
       c2AWv: // global
           I64[Hp - 80] = sat_s2uOp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AWt::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AWt::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWI: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2AWC; else goto c2AWH;
       c2AWC: // global
           I64[Hp - 80] = sat_s2uOL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2uOv_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWH: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2AWG; else goto c2AWF;
       c2AWG: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2AWF: // global
           I64[Hp - 80] = sat_s2uOQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2AWD::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2AWD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo1_info" {
     GHC.Word.$w$cenumFromThenTo1_info:
         const GHC.Word.$w$cenumFromThenTo1_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2vim_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.897516947 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2AYv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2AYE; else goto c2AYF;
       c2AYE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2AYF: // global
           I64[Sp - 24] = block_c2AYs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2AYO; else goto c2AYt;
       u2AYO: // global
           call _c2AYs(R1) args: 0, res: 0, upd: 0;
       c2AYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2vim_srt+480;
 },
 _c2AYs() //  [R1]
         { []
         }
     {offset
       c2AYs: // global
           I64[Sp] = block_c2AYy_info;
           _s2uOV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uOV::I64;
           if (R1 & 7 != 0) goto u2AYN; else goto c2AYz;
       u2AYN: // global
           call _c2AYy(R1) args: 0, res: 0, upd: 0;
       c2AYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AYs_info" {
     block_c2AYs_info:
         const _c2AYs;
         const 2;
         const 4294967326;
         const S2vim_srt+480;
 },
 _c2AYy() //  [R1]
         { []
         }
     {offset
       c2AYy: // global
           I64[Sp] = block_c2AYD_info;
           _s2uOX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2uOX::I64;
           if (R1 & 7 != 0) goto u2AYP; else goto c2AYI;
       u2AYP: // global
           call _c2AYD(R1) args: 0, res: 0, upd: 0;
       c2AYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AYy_info" {
     block_c2AYy_info:
         const _c2AYy;
         const 66;
         const 4294967326;
         const S2vim_srt+480;
 },
 _c2AYD() //  [R1]
         { []
         }
     {offset
       c2AYD: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2AYD_info" {
     block_c2AYD_info:
         const _c2AYD;
         const 194;
         const 4294967326;
         const S2vim_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.90822462 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2uPd_entry() //  [R1]
         { []
         }
     {offset
       c2AZy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2AZz; else goto c2AZA;
       c2AZz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AZA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uP6::I64 = I64[R1 + 32];
           if (_s2uP6::I64 == I64[R1 + 24]) goto c2AZx; else goto c2AZw;
       c2AZx: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2AZw: // global
           R2 = _s2uP6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2uP5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uPd_info" {
     sat_s2uPd_info:
         const sat_s2uPd_entry;
         const 8589934593;
         const 4294967311;
         const S2vim_srt+456;
 },
 sat_s2uPa_entry() //  [R1]
         { []
         }
     {offset
       c2AZM: // global
           _s2uPa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2AZN; else goto c2AZO;
       c2AZO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2AZQ; else goto c2AZP;
       c2AZQ: // global
           HpAlloc = 16;
           goto c2AZN;
       c2AZN: // global
           R1 = _s2uPa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2AZP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPa::P64;
           _s2uP6::I64 = I64[_s2uPa::P64 + 16];
           if (%MO_S_Lt_W64(_s2uP6::I64, 0)) goto c2AZW; else goto c2AZL;
       c2AZL: // global
           if (%MO_S_Gt_W64(_s2uP6::I64,
                            4294967295)) goto c2AZW; else goto c2B03;
       c2AZW: // global
           Hp = Hp - 16;
           R2 = _s2uP6::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2B03: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uP6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uPa_info" {
     sat_s2uPa_info:
         const sat_s2uPa_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 go_s2uP5_entry() //  [R1, R2]
         { []
         }
     {offset
       c2B05: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2B09; else goto c2B08;
       c2B09: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B08: // global
           _s2uP3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2uPd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2uP3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2uPa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2uP5_info" {
     go_s2uP5_info:
         const go_s2uP5_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2vim_srt+456;
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B0a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B0e; else goto c2B0d;
       c2B0e: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B0d: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2B0g; else goto c2B0h;
       c2B0g: // global
           I64[Hp - 8] = go_s2uP5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2uP5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2B0h: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo1_info" {
     GHC.Word.$w$cenumFromTo1_info:
         const GHC.Word.$w$cenumFromTo1_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2vim_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.919987896 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B0L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B0P; else goto c2B0Q;
       c2B0P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B0Q: // global
           I64[Sp - 16] = block_c2B0I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B0Y; else goto c2B0J;
       u2B0Y: // global
           call _c2B0I(R1) args: 0, res: 0, upd: 0;
       c2B0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromTo_info" {
     GHC.Word.$fEnumWord32_$cenumFromTo_info:
         const GHC.Word.$fEnumWord32_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+496;
 },
 _c2B0I() //  [R1]
         { []
         }
     {offset
       c2B0I: // global
           I64[Sp] = block_c2B0O_info;
           _s2uPh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPh::I64;
           if (R1 & 7 != 0) goto u2B0X; else goto c2B0S;
       u2B0X: // global
           call _c2B0O(R1) args: 0, res: 0, upd: 0;
       c2B0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B0I_info" {
     block_c2B0I_info:
         const _c2B0I;
         const 1;
         const 4294967326;
         const S2vim_srt+496;
 },
 _c2B0O() //  [R1]
         { []
         }
     {offset
       c2B0O: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B0O_info" {
     block_c2B0O_info:
         const _c2B0O;
         const 65;
         const 4294967326;
         const S2vim_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.929786915 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2uPu_entry() //  [R1]
         { []
         }
     {offset
       c2B1o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2B1p; else goto c2B1A;
       c2B1p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B1A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2uPp::I64 = I64[R1 + 16];
           if (_s2uPp::I64 != 4294967295) goto c2B1m; else goto c2B1n;
       c2B1m: // global
           I64[Sp - 24] = block_c2B1u_info;
           R2 = _s2uPp::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2B1n: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uPu_info" {
     sat_s2uPu_info:
         const sat_s2uPu_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+512;
 },
 _c2B1u() //  [R1, R2]
         { []
         }
     {offset
       c2B1u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2B1z; else goto c2B1y;
       c2B1z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2B1y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2B1u_info" {
     block_c2B1u_info:
         const _c2B1u;
         const 0;
         const 30;
 },
 sat_s2uPo_entry() //  [R1]
         { []
         }
     {offset
       c2B1K: // global
           _s2uPo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B1L; else goto c2B1M;
       c2B1M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B1O; else goto c2B1N;
       c2B1O: // global
           HpAlloc = 16;
           goto c2B1L;
       c2B1L: // global
           R1 = _s2uPo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B1N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uPo::P64;
           _s2uPk::I64 = I64[_s2uPo::P64 + 16];
           if (%MO_S_Lt_W64(_s2uPk::I64, 0)) goto c2B1U; else goto c2B1J;
       c2B1J: // global
           if (%MO_S_Gt_W64(_s2uPk::I64,
                            4294967295)) goto c2B1U; else goto c2B21;
       c2B1U: // global
           Hp = Hp - 16;
           R2 = _s2uPk::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2B21: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uPk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uPo_info" {
     sat_s2uPo_info:
         const sat_s2uPo_entry;
         const 4294967296;
         const 4294967313;
         const S2vim_srt+456;
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { []
         }
     {offset
       c2B22: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2B26; else goto c2B25;
       c2B26: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B25: // global
           I64[Hp - 40] = sat_s2uPu_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2uPo_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo1_info" {
     GHC.Word.$wgo1_info:
         const GHC.Word.$wgo1_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2vim_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.939476184 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { []
         }
     {offset
       c2B2z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B2A; else goto c2B2B;
       c2B2A: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B2B: // global
           I64[Sp - 8] = block_c2B2w_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_go_info" {
     GHC.Word.$fEnumWord32_go_info:
         const GHC.Word.$fEnumWord32_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2vim_srt+512;
 },
 _c2B2w() //  [R1, R2]
         { []
         }
     {offset
       c2B2w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2B2E; else goto c2B2D;
       c2B2E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2B2D: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B2w_info" {
     block_c2B2w_info:
         const _c2B2w;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.945794308 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2B2V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B2W; else goto c2B2X;
       c2B2W: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B2X: // global
           I64[Sp - 8] = block_c2B2S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B39; else goto c2B2T;
       u2B39: // global
           call _c2B2S(R1) args: 0, res: 0, upd: 0;
       c2B2T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFrom_info" {
     GHC.Word.$fEnumWord32_$cenumFrom_info:
         const GHC.Word.$fEnumWord32_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+520;
 },
 _c2B2S() //  [R1]
         { []
         }
     {offset
       c2B2S: // global
           _s2uPC::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2uPC::I64,
                            4294967295)) goto c2B37; else goto c2B38;
       c2B37: // global
           R2 = _s2uPC::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2B38: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B2S_info" {
     block_c2B2S_info:
         const _c2B2S;
         const 0;
         const 4294967326;
         const S2vim_srt+520;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.951187521 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B3p: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromThen_info" {
     GHC.Word.$fEnumWord32_$cenumFromThen_info:
         const GHC.Word.$fEnumWord32_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2vim_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.955113855 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.957219283 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.960274825 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B3G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B3K; else goto c2B3L;
       c2B3K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B3L: // global
           I64[Sp - 16] = block_c2B3D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B3U; else goto c2B3E;
       u2B3U: // global
           call _c2B3D(R1) args: 0, res: 0, upd: 0;
       c2B3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord64_info" {
     GHC.Word.eqWord64_info:
         const GHC.Word.eqWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2B3D() //  [R1]
         { []
         }
     {offset
       c2B3D: // global
           I64[Sp] = block_c2B3J_info;
           _s2uPH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPH::I64;
           if (R1 & 7 != 0) goto u2B3T; else goto c2B3N;
       u2B3T: // global
           call _c2B3J(R1) args: 0, res: 0, upd: 0;
       c2B3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B3D_info" {
     block_c2B3D_info:
         const _c2B3D;
         const 1;
         const 30;
 },
 _c2B3J() //  [R1]
         { []
         }
     {offset
       c2B3J: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B3J_info" {
     block_c2B3J_info:
         const _c2B3J;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.967496352 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2B4j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B4k; else goto c2B4l;
       c2B4k: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B4l: // global
           I64[Sp - 8] = block_c2B4g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B4t; else goto c2B4h;
       u2B4t: // global
           call _c2B4g(R1) args: 0, res: 0, upd: 0;
       c2B4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$csignum_info" {
     GHC.Word.$fNumWord64_$csignum_info:
         const GHC.Word.$fNumWord64_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2B4g() //  [R1]
         { []
         }
     {offset
       c2B4g: // global
           if (I64[R1 + 7] == 0) goto c2B4s; else goto c2B4r;
       c2B4s: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B4r: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B4g_info" {
     block_c2B4g_info:
         const _c2B4g;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.97299674 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.976194282 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2B4P_srtd" {
     u2B4P_srtd:
         const S2vim_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { []
         }
     {offset
       c2B4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B4N; else goto c2B4O;
       c2B4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B4O: // global
           (_c2B4J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2B4J::I64 == 0) goto c2B4L; else goto c2B4K;
       c2B4L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2B4K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2B4J::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord7_info" {
     GHC.Word.$fEnumWord7_info:
         const GHC.Word.$fEnumWord7_entry;
         const 0;
         const 18446744069414584341;
         const u2B4P_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.980862592 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2B57_srtd" {
     u2B57_srtd:
         const S2vim_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { []
         }
     {offset
       c2B54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B55; else goto c2B56;
       c2B55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B56: // global
           (_c2B51::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2B51::I64 == 0) goto c2B53; else goto c2B52;
       c2B53: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2B52: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2B51::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord9_info" {
     GHC.Word.$fEnumWord9_info:
         const GHC.Word.$fEnumWord9_entry;
         const 0;
         const 18446744069414584341;
         const u2B57_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.986135933 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B5n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B5r; else goto c2B5s;
       c2B5r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B5s: // global
           I64[Sp - 16] = block_c2B5k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B5B; else goto c2B5l;
       u2B5B: // global
           call _c2B5k(R1) args: 0, res: 0, upd: 0;
       c2B5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord64_info" {
     GHC.Word.neWord64_info:
         const GHC.Word.neWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2B5k() //  [R1]
         { []
         }
     {offset
       c2B5k: // global
           I64[Sp] = block_c2B5q_info;
           _s2uPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPS::I64;
           if (R1 & 7 != 0) goto u2B5A; else goto c2B5u;
       u2B5A: // global
           call _c2B5q(R1) args: 0, res: 0, upd: 0;
       c2B5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B5k_info" {
     block_c2B5k_info:
         const _c2B5k;
         const 1;
         const 30;
 },
 _c2B5q() //  [R1]
         { []
         }
     {offset
       c2B5q: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B5q_info" {
     block_c2B5q_info:
         const _c2B5q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:11.995369291 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2uQ6_entry() //  [R1]
         { []
         }
     {offset
       c2B6f: // global
           _s2uQ6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6i; else goto c2B6j;
       c2B6j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B6l; else goto c2B6k;
       c2B6l: // global
           HpAlloc = 16;
           goto c2B6i;
       c2B6i: // global
           R1 = _s2uQ6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ6::P64;
           _s2uQ5::I64 = I64[_s2uQ6::P64 + 16] % I64[_s2uQ6::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uQ6_info" {
     sat_s2uQ6_info:
         const sat_s2uQ6_entry;
         const 8589934592;
         const 20;
 },
 sat_s2uQ4_entry() //  [R1]
         { []
         }
     {offset
       c2B6s: // global
           _s2uQ4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6v; else goto c2B6w;
       c2B6w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B6y; else goto c2B6x;
       c2B6y: // global
           HpAlloc = 16;
           goto c2B6v;
       c2B6v: // global
           R1 = _s2uQ4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2B6x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2uQ4::P64;
           _s2uQ3::I64 = I64[_s2uQ4::P64 + 16] / I64[_s2uQ4::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQ3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2uQ4_info" {
     sat_s2uQ4_info:
         const sat_s2uQ4_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B6A; else goto c2B6B;
       c2B6A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B6B: // global
           I64[Sp - 16] = block_c2B5X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B6L; else goto c2B5Y;
       u2B6L: // global
           call _c2B5X(R1) args: 0, res: 0, upd: 0;
       c2B5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cdivMod_info" {
     GHC.Word.$fIntegralWord64_$cdivMod_info:
         const GHC.Word.$fIntegralWord64_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2B5X() //  [R1]
         { []
         }
     {offset
       c2B5X: // global
           I64[Sp] = block_c2B62_info;
           _s2uPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uPZ::I64;
           if (R1 & 7 != 0) goto u2B6K; else goto c2B63;
       u2B6K: // global
           call _c2B62(R1) args: 0, res: 0, upd: 0;
       c2B63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B5X_info" {
     block_c2B5X_info:
         const _c2B5X;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2B62() //  [R1]
         { []
         }
     {offset
       c2B62: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2B6F; else goto c2B6E;
       c2B6F: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B6E: // global
           _s2uQ2::I64 = I64[R1 + 7];
           if (_s2uQ2::I64 != 0) goto c2B6I; else goto c2B6J;
       c2B6I: // global
           I64[Hp - 80] = sat_s2uQ6_info;
           _s2uPZ::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2uPZ::I64;
           I64[Hp - 56] = _s2uQ2::I64;
           I64[Hp - 48] = sat_s2uQ4_info;
           I64[Hp - 32] = _s2uPZ::I64;
           I64[Hp - 24] = _s2uQ2::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B6J: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B62_info" {
     block_c2B62_info:
         const _c2B62;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.008350197 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B7j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B7n; else goto c2B7o;
       c2B7n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B7o: // global
           I64[Sp - 16] = block_c2B7g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B7G; else goto c2B7h;
       u2B7G: // global
           call _c2B7g(R1) args: 0, res: 0, upd: 0;
       c2B7h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cquotRem_info" {
     GHC.Word.$fIntegralWord64_$cquotRem_info:
         const GHC.Word.$fIntegralWord64_$cquotRem_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2B7g() //  [R1]
         { []
         }
     {offset
       c2B7g: // global
           I64[Sp] = block_c2B7m_info;
           _s2uQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQa::I64;
           if (R1 & 7 != 0) goto u2B7F; else goto c2B7q;
       u2B7F: // global
           call _c2B7m(R1) args: 0, res: 0, upd: 0;
       c2B7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B7g_info" {
     block_c2B7g_info:
         const _c2B7g;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2B7m() //  [R1]
         { []
         }
     {offset
       c2B7m: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2B7w; else goto c2B7v;
       c2B7w: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B7v: // global
           _s2uQd::I64 = I64[R1 + 7];
           if (_s2uQd::I64 != 0) goto c2B7D; else goto c2B7E;
       c2B7D: // global
           (_s2uQf::I64, _s2uQg::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2uQd::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2uQg::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2uQf::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B7E: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B7m_info" {
     block_c2B7m_info:
         const _c2B7m;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.017232664 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B84: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B88; else goto c2B89;
       c2B88: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B89: // global
           I64[Sp - 16] = block_c2B81_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B8s; else goto c2B82;
       u2B8s: // global
           call _c2B81(R1) args: 0, res: 0, upd: 0;
       c2B82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cmod_info" {
     GHC.Word.$fIntegralWord64_$cmod_info:
         const GHC.Word.$fIntegralWord64_$cmod_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2B81() //  [R1]
         { []
         }
     {offset
       c2B81: // global
           I64[Sp] = block_c2B87_info;
           _s2uQm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQm::I64;
           if (R1 & 7 != 0) goto u2B8r; else goto c2B8b;
       u2B8r: // global
           call _c2B87(R1) args: 0, res: 0, upd: 0;
       c2B8b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B81_info" {
     block_c2B81_info:
         const _c2B81;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2B87() //  [R1]
         { []
         }
     {offset
       c2B87: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B8h; else goto c2B8g;
       c2B8h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B8g: // global
           _s2uQp::I64 = I64[R1 + 7];
           if (_s2uQp::I64 != 0) goto c2B8p; else goto c2B8q;
       c2B8p: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2uQp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B8q: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B87_info" {
     block_c2B87_info:
         const _c2B87;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.026148466 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c2B8P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2B8T; else goto c2B8U;
       c2B8T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2B8U: // global
           I64[Sp - 16] = block_c2B8M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2B9d; else goto c2B8N;
       u2B9d: // global
           call _c2B8M(R1) args: 0, res: 0, upd: 0;
       c2B8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cdiv_info" {
     GHC.Word.$fIntegralWord64_$cdiv_info:
         const GHC.Word.$fIntegralWord64_$cdiv_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2B8M() //  [R1]
         { []
         }
     {offset
       c2B8M: // global
           I64[Sp] = block_c2B8S_info;
           _s2uQu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQu::I64;
           if (R1 & 7 != 0) goto u2B9c; else goto c2B8W;
       u2B9c: // global
           call _c2B8S(R1) args: 0, res: 0, upd: 0;
       c2B8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B8M_info" {
     block_c2B8M_info:
         const _c2B8M;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2B8S() //  [R1]
         { []
         }
     {offset
       c2B8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B92; else goto c2B91;
       c2B92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B91: // global
           _s2uQx::I64 = I64[R1 + 7];
           if (_s2uQx::I64 != 0) goto c2B9a; else goto c2B9b;
       c2B9a: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2uQx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B9b: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B8S_info" {
     block_c2B8S_info:
         const _c2B8S;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.032889243 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.03665773 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2B9B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2B9C; else goto c2B9D;
       c2B9C: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2B9D: // global
           I64[Sp - 8] = block_c2B9y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2B9S; else goto c2B9z;
       u2B9S: // global
           call _c2B9y(R1) args: 0, res: 0, upd: 0;
       c2B9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cpred_info" {
     GHC.Word.$fEnumWord64_$cpred_info:
         const GHC.Word.$fEnumWord64_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+584;
 },
 _c2B9y() //  [R1]
         { []
         }
     {offset
       c2B9y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2B9I; else goto c2B9H;
       c2B9I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2B9H: // global
           _s2uQC::I64 = I64[R1 + 7];
           if (_s2uQC::I64 != 0) goto c2B9Q; else goto c2B9R;
       c2B9Q: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQC::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2B9R: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2B9y_info" {
     block_c2B9y_info:
         const _c2B9y;
         const 0;
         const 4294967326;
         const S2vim_srt+592;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.041914981 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.043583494 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.046667557 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2Bae: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Baf; else goto c2Bag;
       c2Baf: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bag: // global
           I64[Sp - 8] = block_c2Bab_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bav; else goto c2Bac;
       u2Bav: // global
           call _c2Bab(R1) args: 0, res: 0, upd: 0;
       c2Bac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$csucc_info" {
     GHC.Word.$fEnumWord64_$csucc_info:
         const GHC.Word.$fEnumWord64_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+600;
 },
 _c2Bab() //  [R1]
         { []
         }
     {offset
       c2Bab: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bal; else goto c2Bak;
       c2Bal: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bak: // global
           _s2uQH::I64 = I64[R1 + 7];
           if (_s2uQH::I64 != 18446744073709551615) goto c2Bat; else goto c2Bau;
       c2Bat: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQH::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bau: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bab_info" {
     block_c2Bab_info:
         const _c2Bab;
         const 0;
         const 4294967326;
         const S2vim_srt+608;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.053113378 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2BaP_srtd" {
     u2BaP_srtd:
         const S2vim_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { []
         }
     {offset
       c2BaM: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl2_info" {
     GHC.Word.$wlvl2_info:
         const GHC.Word.$wlvl2_entry;
         const 0;
         const 18446744069414584334;
         const 4294967300;
         const u2BaP_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.057935633 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { []
         }
     {offset
       c2Bb2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bb3; else goto c2Bb4;
       c2Bb3: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bb4: // global
           I64[Sp - 8] = block_c2BaZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bb8; else goto c2Bb0;
       u2Bb8: // global
           call _c2BaZ(R1) args: 0, res: 0, upd: 0;
       c2Bb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord6_info" {
     GHC.Word.$fEnumWord6_info:
         const GHC.Word.$fEnumWord6_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+616;
 },
 _c2BaZ() //  [R1]
         { []
         }
     {offset
       c2BaZ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BaZ_info" {
     block_c2BaZ_info:
         const _c2BaZ;
         const 0;
         const 4294967326;
         const S2vim_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.064027151 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2Bbp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bbq; else goto c2Bbr;
       c2Bbq: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bbr: // global
           I64[Sp - 8] = block_c2Bbm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BbI; else goto c2Bbn;
       u2BbI: // global
           call _c2Bbm(R1) args: 0, res: 0, upd: 0;
       c2Bbn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$ctoEnum_info" {
     GHC.Word.$fEnumWord64_$ctoEnum_info:
         const GHC.Word.$fEnumWord64_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+624;
 },
 _c2Bbm() //  [R1]
         { []
         }
     {offset
       c2Bbm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bbw; else goto c2Bbv;
       c2Bbw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bbv: // global
           _s2uQP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uQP::I64, 0)) goto c2BbA; else goto c2BbH;
       c2BbA: // global
           Hp = Hp - 16;
           R2 = _s2uQP::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2BbH: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bbm_info" {
     block_c2Bbm_info:
         const _c2Bbm;
         const 0;
         const 4294967326;
         const S2vim_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.071109745 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bc0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bc4; else goto c2Bc5;
       c2Bc4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bc5: // global
           I64[Sp - 16] = block_c2BbX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bce; else goto c2BbY;
       u2Bce: // global
           call _c2BbX(R1) args: 0, res: 0, upd: 0;
       c2BbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord64_info" {
     GHC.Word.gtWord64_info:
         const GHC.Word.gtWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BbX() //  [R1]
         { []
         }
     {offset
       c2BbX: // global
           I64[Sp] = block_c2Bc3_info;
           _s2uQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uQV::I64;
           if (R1 & 7 != 0) goto u2Bcd; else goto c2Bc7;
       u2Bcd: // global
           call _c2Bc3(R1) args: 0, res: 0, upd: 0;
       c2Bc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BbX_info" {
     block_c2BbX_info:
         const _c2BbX;
         const 1;
         const 30;
 },
 _c2Bc3() //  [R1]
         { []
         }
     {offset
       c2Bc3: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bc3_info" {
     block_c2Bc3_info:
         const _c2Bc3;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.079200998 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BcD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BcH; else goto c2BcI;
       c2BcH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BcI: // global
           I64[Sp - 16] = block_c2BcA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BcR; else goto c2BcB;
       u2BcR: // global
           call _c2BcA(R1) args: 0, res: 0, upd: 0;
       c2BcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord64_info" {
     GHC.Word.geWord64_info:
         const GHC.Word.geWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BcA() //  [R1]
         { []
         }
     {offset
       c2BcA: // global
           I64[Sp] = block_c2BcG_info;
           _s2uR2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR2::I64;
           if (R1 & 7 != 0) goto u2BcQ; else goto c2BcK;
       u2BcQ: // global
           call _c2BcG(R1) args: 0, res: 0, upd: 0;
       c2BcK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BcA_info" {
     block_c2BcA_info:
         const _c2BcA;
         const 1;
         const 30;
 },
 _c2BcG() //  [R1]
         { []
         }
     {offset
       c2BcG: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BcG_info" {
     block_c2BcG_info:
         const _c2BcG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.087236157 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bdg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bdk; else goto c2Bdl;
       c2Bdk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bdl: // global
           I64[Sp - 16] = block_c2Bdd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bdu; else goto c2Bde;
       u2Bdu: // global
           call _c2Bdd(R1) args: 0, res: 0, upd: 0;
       c2Bde: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord64_info" {
     GHC.Word.ltWord64_info:
         const GHC.Word.ltWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bdd() //  [R1]
         { []
         }
     {offset
       c2Bdd: // global
           I64[Sp] = block_c2Bdj_info;
           _s2uR9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uR9::I64;
           if (R1 & 7 != 0) goto u2Bdt; else goto c2Bdn;
       u2Bdt: // global
           call _c2Bdj(R1) args: 0, res: 0, upd: 0;
       c2Bdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bdd_info" {
     block_c2Bdd_info:
         const _c2Bdd;
         const 1;
         const 30;
 },
 _c2Bdj() //  [R1]
         { []
         }
     {offset
       c2Bdj: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bdj_info" {
     block_c2Bdj_info:
         const _c2Bdj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.094849834 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BdT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BdX; else goto c2BdY;
       c2BdX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BdY: // global
           I64[Sp - 16] = block_c2BdQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Be7; else goto c2BdR;
       u2Be7: // global
           call _c2BdQ(R1) args: 0, res: 0, upd: 0;
       c2BdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord64_info" {
     GHC.Word.leWord64_info:
         const GHC.Word.leWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BdQ() //  [R1]
         { []
         }
     {offset
       c2BdQ: // global
           I64[Sp] = block_c2BdW_info;
           _s2uRg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRg::I64;
           if (R1 & 7 != 0) goto u2Be6; else goto c2Be0;
       u2Be6: // global
           call _c2BdW(R1) args: 0, res: 0, upd: 0;
       c2Be0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BdQ_info" {
     block_c2BdQ_info:
         const _c2BdQ;
         const 1;
         const 30;
 },
 _c2BdW() //  [R1]
         { []
         }
     {offset
       c2BdW: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BdW_info" {
     block_c2BdW_info:
         const _c2BdW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.103044058 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bew: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BeA; else goto c2BeB;
       c2BeA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BeB: // global
           I64[Sp - 16] = block_c2Bet_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BeO; else goto c2Beu;
       u2BeO: // global
           call _c2Bet(R1) args: 0, res: 0, upd: 0;
       c2Beu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$cmin_info" {
     GHC.Word.$fOrdWord64_$cmin_info:
         const GHC.Word.$fOrdWord64_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bet() //  [R1]
         { []
         }
     {offset
       c2Bet: // global
           I64[Sp - 8] = block_c2Bez_info;
           _s2uRm::P64 = R1;
           _s2uRn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRn::I64;
           P64[Sp + 8] = _s2uRm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BeN; else goto c2BeD;
       u2BeN: // global
           call _c2Bez(R1) args: 0, res: 0, upd: 0;
       c2BeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bet_info" {
     block_c2Bet_info:
         const _c2Bet;
         const 1;
         const 30;
 },
 _c2Bez() //  [R1]
         { []
         }
     {offset
       c2Bez: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2BeL; else goto c2BeM;
       c2BeL: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2BeM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bez_info" {
     block_c2Bez_info:
         const _c2Bez;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.111091247 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bfe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Bfi; else goto c2Bfj;
       c2Bfi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bfj: // global
           I64[Sp - 16] = block_c2Bfb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bfw; else goto c2Bfc;
       u2Bfw: // global
           call _c2Bfb(R1) args: 0, res: 0, upd: 0;
       c2Bfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$cmax_info" {
     GHC.Word.$fOrdWord64_$cmax_info:
         const GHC.Word.$fOrdWord64_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bfb() //  [R1]
         { []
         }
     {offset
       c2Bfb: // global
           I64[Sp - 8] = block_c2Bfh_info;
           _s2uRt::P64 = R1;
           _s2uRu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uRu::I64;
           P64[Sp + 8] = _s2uRt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bfv; else goto c2Bfl;
       u2Bfv: // global
           call _c2Bfh(R1) args: 0, res: 0, upd: 0;
       c2Bfl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bfb_info" {
     block_c2Bfb_info:
         const _c2Bfb;
         const 1;
         const 30;
 },
 _c2Bfh() //  [R1]
         { []
         }
     {offset
       c2Bfh: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Bft; else goto c2Bfu;
       c2Bft: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Bfu: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bfh_info" {
     block_c2Bfh_info:
         const _c2Bfh;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.119671529 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bg0; else goto c2Bg1;
       c2Bg0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bg1: // global
           I64[Sp - 16] = block_c2BfT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bgk; else goto c2BfU;
       u2Bgk: // global
           call _c2BfT(R1) args: 0, res: 0, upd: 0;
       c2BfU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$ccompare_info" {
     GHC.Word.$fOrdWord64_$ccompare_info:
         const GHC.Word.$fOrdWord64_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BfT() //  [R1]
         { []
         }
     {offset
       c2BfT: // global
           I64[Sp] = block_c2BfZ_info;
           _s2uRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRB::I64;
           if (R1 & 7 != 0) goto u2Bgj; else goto c2Bg3;
       u2Bgj: // global
           call _c2BfZ(R1) args: 0, res: 0, upd: 0;
       c2Bg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BfT_info" {
     block_c2BfT_info:
         const _c2BfT;
         const 1;
         const 30;
 },
 _c2BfZ() //  [R1]
         { []
         }
     {offset
       c2BfZ: // global
           _s2uRB::I64 = I64[Sp + 8];
           _s2uRD::I64 = I64[R1 + 7];
           if (_s2uRB::I64 == _s2uRD::I64) goto c2Bgi; else goto c2Bgh;
       c2Bgi: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bgh: // global
           if (_s2uRB::I64 > _s2uRD::I64) goto c2Bge; else goto c2Bgf;
       c2Bge: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bgf: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BfZ_info" {
     block_c2BfZ_info:
         const _c2BfZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.127399463 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.129158449 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.132239133 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2BgK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BgL; else goto c2BgM;
       c2BgL: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BgM: // global
           I64[Sp - 8] = block_c2BgH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bh3; else goto c2BgI;
       u2Bh3: // global
           call _c2BgH(R1) args: 0, res: 0, upd: 0;
       c2BgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cfromEnum_info" {
     GHC.Word.$fEnumWord64_$cfromEnum_info:
         const GHC.Word.$fEnumWord64_$cfromEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+640;
 },
 _c2BgH() //  [R1]
         { []
         }
     {offset
       c2BgH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BgR; else goto c2BgQ;
       c2BgR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BgQ: // global
           _s2uRI::I64 = I64[R1 + 7];
           if (_s2uRI::I64 > 9223372036854775807) goto c2BgV; else goto c2Bh2;
       c2BgV: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2Bh2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2uRI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BgH_info" {
     block_c2BgH_info:
         const _c2BgH;
         const 0;
         const 4294967326;
         const S2vim_srt+648;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.13934649 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2Bhj: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2vim_srt+656;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bhq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromTo_info" {
     GHC.Word.$fEnumWord64_$cenumFromTo_info:
         const GHC.Word.$fEnumWord64_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+664;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2Bhx: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFrom_info" {
     GHC.Word.$fEnumWord64_$cenumFrom_info:
         const GHC.Word.$fEnumWord64_$cenumFrom_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S2vim_srt+664;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BhE: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromThen_info" {
     GHC.Word.$fEnumWord64_$cenumFromThen_info:
         const GHC.Word.$fEnumWord64_$cenumFromThen_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S2vim_srt+664;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.152579647 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2Bi5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bic; else goto c2Bid;
       c2Bic: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bid: // global
           I64[Sp - 8] = block_c2Bi3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cfromInteger_info" {
     GHC.Word.$fNumWord8_$cfromInteger_info:
         const GHC.Word.$fNumWord8_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Bi3() //  [R1]
         { []
         }
     {offset
       c2Bi3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Big; else goto c2Bif;
       c2Big: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Bif: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bi3_info" {
     block_c2Bi3_info:
         const _c2Bi3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.158654988 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2Biw: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cabs_info" {
     GHC.Word.$fNumWord8_$cabs_info:
         const GHC.Word.$fNumWord8_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.16297015 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2BiM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bj2; else goto c2Bj3;
       c2Bj2: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bj3: // global
           I64[Sp - 8] = block_c2BiJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bj7; else goto c2BiK;
       u2Bj7: // global
           call _c2BiJ(R1) args: 0, res: 0, upd: 0;
       c2BiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cnegate_info" {
     GHC.Word.$fNumWord8_$cnegate_info:
         const GHC.Word.$fNumWord8_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BiJ() //  [R1]
         { []
         }
     {offset
       c2BiJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bj6; else goto c2Bj5;
       c2Bj6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bj5: // global
           _s2uRV::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uRV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BiJ_info" {
     block_c2BiJ_info:
         const _c2BiJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.169901863 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bjq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BjF; else goto c2BjG;
       c2BjF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BjG: // global
           I64[Sp - 16] = block_c2Bjn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BjM; else goto c2Bjo;
       u2BjM: // global
           call _c2Bjn(R1) args: 0, res: 0, upd: 0;
       c2Bjo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c*_info" {
     GHC.Word.$fNumWord8_$c*_info:
         const GHC.Word.$fNumWord8_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bjn() //  [R1]
         { []
         }
     {offset
       c2Bjn: // global
           I64[Sp] = block_c2Bjt_info;
           _s2uRZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uRZ::I64;
           if (R1 & 7 != 0) goto u2BjL; else goto c2Bju;
       u2BjL: // global
           call _c2Bjt(R1) args: 0, res: 0, upd: 0;
       c2Bju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bjn_info" {
     block_c2Bjn_info:
         const _c2Bjn;
         const 1;
         const 30;
 },
 _c2Bjt() //  [R1]
         { []
         }
     {offset
       c2Bjt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BjK; else goto c2BjJ;
       c2BjK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BjJ: // global
           _s2uS3::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bjt_info" {
     block_c2Bjt_info:
         const _c2Bjt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.178549213 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bkb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bkq; else goto c2Bkr;
       c2Bkq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bkr: // global
           I64[Sp - 16] = block_c2Bk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bkx; else goto c2Bk9;
       u2Bkx: // global
           call _c2Bk8(R1) args: 0, res: 0, upd: 0;
       c2Bk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c-_info" {
     GHC.Word.$fNumWord8_$c-_info:
         const GHC.Word.$fNumWord8_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bk8() //  [R1]
         { []
         }
     {offset
       c2Bk8: // global
           I64[Sp] = block_c2Bke_info;
           _s2uS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uS7::I64;
           if (R1 & 7 != 0) goto u2Bkw; else goto c2Bkf;
       u2Bkw: // global
           call _c2Bke(R1) args: 0, res: 0, upd: 0;
       c2Bkf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bk8_info" {
     block_c2Bk8_info:
         const _c2Bk8;
         const 1;
         const 30;
 },
 _c2Bke() //  [R1]
         { []
         }
     {offset
       c2Bke: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bkv; else goto c2Bku;
       c2Bkv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bku: // global
           _s2uSb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bke_info" {
     block_c2Bke_info:
         const _c2Bke;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.186808069 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BkW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Blb; else goto c2Blc;
       c2Blb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Blc: // global
           I64[Sp - 16] = block_c2BkT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bli; else goto c2BkU;
       u2Bli: // global
           call _c2BkT(R1) args: 0, res: 0, upd: 0;
       c2BkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c+_info" {
     GHC.Word.$fNumWord8_$c+_info:
         const GHC.Word.$fNumWord8_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BkT() //  [R1]
         { []
         }
     {offset
       c2BkT: // global
           I64[Sp] = block_c2BkZ_info;
           _s2uSf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSf::I64;
           if (R1 & 7 != 0) goto u2Blh; else goto c2Bl0;
       u2Blh: // global
           call _c2BkZ(R1) args: 0, res: 0, upd: 0;
       c2Bl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BkT_info" {
     block_c2BkT_info:
         const _c2BkT;
         const 1;
         const 30;
 },
 _c2BkZ() //  [R1]
         { []
         }
     {offset
       c2BkZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Blg; else goto c2Blf;
       c2Blg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Blf: // global
           _s2uSj::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BkZ_info" {
     block_c2BkZ_info:
         const _c2BkZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.195019731 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c2BlH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BlI; else goto c2BlJ;
       c2BlI: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BlJ: // global
           I64[Sp - 8] = block_c2BlE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BlO; else goto c2BlF;
       u2BlO: // global
           call _c2BlE(R1) args: 0, res: 0, upd: 0;
       c2BlF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger_info" {
     GHC.Word.$ctoInteger_info:
         const GHC.Word.$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BlE() //  [R1]
         { []
         }
     {offset
       c2BlE: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BlE_info" {
     block_c2BlE_info:
         const _c2BlE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.202127638 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2Bm5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bmg; else goto c2Bmh;
       c2Bmg: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bmh: // global
           I64[Sp - 8] = block_c2Bm2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bml; else goto c2Bm3;
       u2Bml: // global
           call _c2Bm2(R1) args: 0, res: 0, upd: 0;
       c2Bm3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cpopCount_info" {
     GHC.Word.$fBitsWord8_$cpopCount_info:
         const GHC.Word.$fBitsWord8_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Bm2() //  [R1]
         { []
         }
     {offset
       c2Bm2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bmk; else goto c2Bmj;
       c2Bmk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bmj: // global
           (_c2Bm8::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Bm8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bm2_info" {
     block_c2Bm2_info:
         const _c2Bm2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.20923689 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BmP; else goto c2BmQ;
       c2BmP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BmQ: // global
           I64[Sp - 16] = block_c2BmA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BmW; else goto c2BmB;
       u2BmW: // global
           call _c2BmA(R1) args: 0, res: 0, upd: 0;
       c2BmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BmA() //  [R1]
         { []
         }
     {offset
       c2BmA: // global
           I64[Sp] = block_c2BmG_info;
           _s2uSw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSw::I64;
           if (R1 & 7 != 0) goto u2BmV; else goto c2BmH;
       u2BmV: // global
           call _c2BmG(R1) args: 0, res: 0, upd: 0;
       c2BmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BmA_info" {
     block_c2BmA_info:
         const _c2BmA;
         const 1;
         const 30;
 },
 _c2BmG() //  [R1]
         { []
         }
     {offset
       c2BmG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BmU; else goto c2BmT;
       c2BmU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BmT: // global
           _s2uSz::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BmG_info" {
     block_c2BmG_info:
         const _c2BmG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.217961767 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bnj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bnn; else goto c2Bno;
       c2Bnn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bno: // global
           I64[Sp - 16] = block_c2Bng_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BnI; else goto c2Bnh;
       u2BnI: // global
           call _c2Bng(R1) args: 0, res: 0, upd: 0;
       c2Bnh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshiftR_info" {
     GHC.Word.$fBitsWord8_$cshiftR_info:
         const GHC.Word.$fBitsWord8_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bng() //  [R1]
         { []
         }
     {offset
       c2Bng: // global
           I64[Sp] = block_c2Bnm_info;
           _s2uSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSD::I64;
           if (R1 & 7 != 0) goto u2BnH; else goto c2Bnq;
       u2BnH: // global
           call _c2Bnm(R1) args: 0, res: 0, upd: 0;
       c2Bnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bng_info" {
     block_c2Bng_info:
         const _c2Bng;
         const 1;
         const 30;
 },
 _c2Bnm() //  [R1]
         { []
         }
     {offset
       c2Bnm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bnw; else goto c2Bnv;
       c2Bnw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bnv: // global
           _s2uSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSF::I64, 64)) goto c2BnF; else goto c2BnG;
       c2BnF: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uSF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BnG: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bnm_info" {
     block_c2Bnm_info:
         const _c2Bnm;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.227235058 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bo6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bol; else goto c2Bom;
       c2Bol: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bom: // global
           I64[Sp - 16] = block_c2Bo3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bos; else goto c2Bo4;
       u2Bos: // global
           call _c2Bo3(R1) args: 0, res: 0, upd: 0;
       c2Bo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bo3() //  [R1]
         { []
         }
     {offset
       c2Bo3: // global
           I64[Sp] = block_c2Bo9_info;
           _s2uSL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uSL::I64;
           if (R1 & 7 != 0) goto u2Bor; else goto c2Boa;
       u2Bor: // global
           call _c2Bo9(R1) args: 0, res: 0, upd: 0;
       c2Boa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bo3_info" {
     block_c2Bo3_info:
         const _c2Bo3;
         const 1;
         const 30;
 },
 _c2Bo9() //  [R1]
         { []
         }
     {offset
       c2Bo9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Boq; else goto c2Bop;
       c2Boq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bop: // global
           _s2uSP::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uSP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bo9_info" {
     block_c2Bo9_info:
         const _c2Bo9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.236054615 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BoU; else goto c2BoV;
       c2BoU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BoV: // global
           I64[Sp - 16] = block_c2BoN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bpi; else goto c2BoO;
       u2Bpi: // global
           call _c2BoN(R1) args: 0, res: 0, upd: 0;
       c2BoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshiftL_info" {
     GHC.Word.$fBitsWord8_$cshiftL_info:
         const GHC.Word.$fBitsWord8_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BoN() //  [R1]
         { []
         }
     {offset
       c2BoN: // global
           I64[Sp] = block_c2BoT_info;
           _s2uST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uST::I64;
           if (R1 & 7 != 0) goto u2Bph; else goto c2BoX;
       u2Bph: // global
           call _c2BoT(R1) args: 0, res: 0, upd: 0;
       c2BoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BoN_info" {
     block_c2BoN_info:
         const _c2BoN;
         const 1;
         const 30;
 },
 _c2BoT() //  [R1]
         { []
         }
     {offset
       c2BoT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bp3; else goto c2Bp2;
       c2Bp3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bp2: // global
           _s2uSV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uSV::I64, 64)) goto c2Bpf; else goto c2Bpg;
       c2Bpf: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2uSV::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bpg: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BoT_info" {
     block_c2BoT_info:
         const _c2BoT;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.243540614 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2BpF: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cisSigned_info" {
     GHC.Word.$fBitsWord8_$cisSigned_info:
         const GHC.Word.$fBitsWord8_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.248633532 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BpU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BpY; else goto c2BpZ;
       c2BpY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BpZ: // global
           I64[Sp - 16] = block_c2BpR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BqM; else goto c2BpS;
       u2BqM: // global
           call _c2BpR(R1) args: 0, res: 0, upd: 0;
       c2BpS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotate_info" {
     GHC.Word.$fBitsWord8_$crotate_info:
         const GHC.Word.$fBitsWord8_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BpR() //  [R1]
         { []
         }
     {offset
       c2BpR: // global
           I64[Sp - 8] = block_c2BpX_info;
           _s2uT2::P64 = R1;
           _s2uT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uT3::I64;
           P64[Sp + 8] = _s2uT2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BqL; else goto c2Bq1;
       u2BqL: // global
           call _c2BpX(R1) args: 0, res: 0, upd: 0;
       c2Bq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BpR_info" {
     block_c2BpR_info:
         const _c2BpR;
         const 1;
         const 30;
 },
 _c2BpX() //  [R1]
         { []
         }
     {offset
       c2BpX: // global
           _s2uT8::I64 = I64[R1 + 7] & 7;
           if (_s2uT8::I64 != 0) goto u2BqJ; else goto c2BqF;
       u2BqJ: // global
           I64[Sp + 16] = _s2uT8::I64;
           Sp = Sp + 8;
           call _c2Bqg() args: 0, res: 0, upd: 0;
       c2BqF: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BpX_info" {
     block_c2BpX_info:
         const _c2BpX;
         const 66;
         const 30;
 },
 _c2Bqg() //  []
         { []
         }
     {offset
       c2Bqg: // global
           Hp = Hp + 16;
           _s2uT8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BqC; else goto c2BqB;
       c2BqC: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Bqf_info;
           R1 = _s2uT8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BqB: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2uT3::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2uT3::I64 << _s2uT8::I64) | (_s2uT3::I64 >> 8 - _s2uT8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Bqf() //  [R1]
         { []
         }
     {offset
       c2Bqf: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Bqg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2Bqf_info" {
     block_c2Bqf_info:
         const _c2Bqf;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.26149399 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bro: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Brs; else goto c2Brt;
       c2Brs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Brt: // global
           I64[Sp - 16] = block_c2Brl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bsa; else goto c2Brm;
       u2Bsa: // global
           call _c2Brl(R1) args: 0, res: 0, upd: 0;
       c2Brm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshift_info" {
     GHC.Word.$fBitsWord8_$cshift_info:
         const GHC.Word.$fBitsWord8_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Brl() //  [R1]
         { []
         }
     {offset
       c2Brl: // global
           I64[Sp] = block_c2Brr_info;
           _s2uTh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTh::I64;
           if (R1 & 7 != 0) goto u2Bs9; else goto c2Brv;
       u2Bs9: // global
           call _c2Brr(R1) args: 0, res: 0, upd: 0;
       c2Brv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Brl_info" {
     block_c2Brl_info:
         const _c2Brl;
         const 1;
         const 30;
 },
 _c2Brr() //  [R1]
         { []
         }
     {offset
       c2Brr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BrB; else goto c2BrA;
       c2BrB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BrA: // global
           _s2uTh::I64 = I64[Sp + 8];
           _s2uTj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uTj::I64, 0)) goto c2BrT; else goto c2Bs8;
       c2BrT: // global
           _s2uTl::I64 = -_s2uTj::I64;
           if (%MO_S_Ge_W64(_s2uTl::I64, 64)) goto c2Bs7; else goto c2BrQ;
       c2BrQ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTh::I64 >> _s2uTl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bs8: // global
           if (%MO_S_Ge_W64(_s2uTj::I64, 64)) goto c2Bs7; else goto c2Bs6;
       c2Bs7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Bs6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2uTh::I64 << _s2uTj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Brr_info" {
     block_c2Brr_info:
         const _c2Brr;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.271123415 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BsO; else goto c2BsP;
       c2BsO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BsP: // global
           I64[Sp - 16] = block_c2Bsz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BsV; else goto c2BsA;
       u2BsV: // global
           call _c2Bsz(R1) args: 0, res: 0, upd: 0;
       c2BsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cxor_info" {
     GHC.Word.$fBitsWord8_$cxor_info:
         const GHC.Word.$fBitsWord8_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bsz() //  [R1]
         { []
         }
     {offset
       c2Bsz: // global
           I64[Sp] = block_c2BsF_info;
           _s2uTu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTu::I64;
           if (R1 & 7 != 0) goto u2BsU; else goto c2BsG;
       u2BsU: // global
           call _c2BsF(R1) args: 0, res: 0, upd: 0;
       c2BsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bsz_info" {
     block_c2Bsz_info:
         const _c2Bsz;
         const 1;
         const 30;
 },
 _c2BsF() //  [R1]
         { []
         }
     {offset
       c2BsF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BsT; else goto c2BsS;
       c2BsT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BsS: // global
           _s2uTx::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BsF_info" {
     block_c2BsF_info:
         const _c2BsF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.279438908 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2Btj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Btv; else goto c2Btw;
       c2Btv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Btw: // global
           I64[Sp - 16] = block_c2Btg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BtC; else goto c2Bth;
       u2BtC: // global
           call _c2Btg(R1) args: 0, res: 0, upd: 0;
       c2Bth: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$c.|._info" {
     GHC.Word.$fBitsWord8_$c.|._info:
         const GHC.Word.$fBitsWord8_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Btg() //  [R1]
         { []
         }
     {offset
       c2Btg: // global
           I64[Sp] = block_c2Btm_info;
           _s2uTB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTB::I64;
           if (R1 & 7 != 0) goto u2BtB; else goto c2Btn;
       u2BtB: // global
           call _c2Btm(R1) args: 0, res: 0, upd: 0;
       c2Btn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Btg_info" {
     block_c2Btg_info:
         const _c2Btg;
         const 1;
         const 30;
 },
 _c2Btm() //  [R1]
         { []
         }
     {offset
       c2Btm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BtA; else goto c2Btz;
       c2BtA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Btz: // global
           _s2uTE::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Btm_info" {
     block_c2Btm_info:
         const _c2Btm;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.28838577 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bu0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Buc; else goto c2Bud;
       c2Buc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bud: // global
           I64[Sp - 16] = block_c2BtX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Buj; else goto c2BtY;
       u2Buj: // global
           call _c2BtX(R1) args: 0, res: 0, upd: 0;
       c2BtY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$c.&._info" {
     GHC.Word.$fBitsWord8_$c.&._info:
         const GHC.Word.$fBitsWord8_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BtX() //  [R1]
         { []
         }
     {offset
       c2BtX: // global
           I64[Sp] = block_c2Bu3_info;
           _s2uTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uTI::I64;
           if (R1 & 7 != 0) goto u2Bui; else goto c2Bu4;
       u2Bui: // global
           call _c2Bu3(R1) args: 0, res: 0, upd: 0;
       c2Bu4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BtX_info" {
     block_c2BtX_info:
         const _c2BtX;
         const 1;
         const 30;
 },
 _c2Bu3() //  [R1]
         { []
         }
     {offset
       c2Bu3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Buh; else goto c2Bug;
       c2Buh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bug: // global
           _s2uTL::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2uTL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bu3_info" {
     block_c2Bu3_info:
         const _c2Bu3;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.296634014 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2BuH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BuS; else goto c2BuT;
       c2BuS: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BuT: // global
           I64[Sp - 8] = block_c2BuE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BuX; else goto c2BuF;
       u2BuX: // global
           call _c2BuE(R1) args: 0, res: 0, upd: 0;
       c2BuF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BuE() //  [R1]
         { []
         }
     {offset
       c2BuE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BuW; else goto c2BuV;
       c2BuW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BuV: // global
           (_c2BuK::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BuK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BuE_info" {
     block_c2BuE_info:
         const _c2BuE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.303370742 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2Bvh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bvs; else goto c2Bvt;
       c2Bvs: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bvt: // global
           I64[Sp - 8] = block_c2Bve_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bvx; else goto c2Bvf;
       u2Bvx: // global
           call _c2Bve(R1) args: 0, res: 0, upd: 0;
       c2Bvf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Bve() //  [R1]
         { []
         }
     {offset
       c2Bve: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bvw; else goto c2Bvv;
       c2Bvw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bvv: // global
           (_c2Bvk::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Bvk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bve_info" {
     block_c2Bve_info:
         const _c2Bve;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.308430411 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.310617351 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2BvP: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.315195669 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2Bw3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bwa; else goto c2Bwb;
       c2Bwa: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bwb: // global
           I64[Sp - 8] = block_c2Bw1_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cfromInteger_info" {
     GHC.Word.$fNumWord16_$cfromInteger_info:
         const GHC.Word.$fNumWord16_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Bw1() //  [R1]
         { []
         }
     {offset
       c2Bw1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bwe; else goto c2Bwd;
       c2Bwe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Bwd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bw1_info" {
     block_c2Bw1_info:
         const _c2Bw1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.320984518 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2Bwu: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cabs_info" {
     GHC.Word.$fNumWord16_$cabs_info:
         const GHC.Word.$fNumWord16_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.325366586 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2BwK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Bx0; else goto c2Bx1;
       c2Bx0: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Bx1: // global
           I64[Sp - 8] = block_c2BwH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Bx5; else goto c2BwI;
       u2Bx5: // global
           call _c2BwH(R1) args: 0, res: 0, upd: 0;
       c2BwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cnegate_info" {
     GHC.Word.$fNumWord16_$cnegate_info:
         const GHC.Word.$fNumWord16_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BwH() //  [R1]
         { []
         }
     {offset
       c2BwH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bx4; else goto c2Bx3;
       c2Bx4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bx3: // global
           _s2uU7::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uU7::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BwH_info" {
     block_c2BwH_info:
         const _c2BwH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.332529249 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Bxo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BxD; else goto c2BxE;
       c2BxD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BxE: // global
           I64[Sp - 16] = block_c2Bxl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BxK; else goto c2Bxm;
       u2BxK: // global
           call _c2Bxl(R1) args: 0, res: 0, upd: 0;
       c2Bxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c*_info" {
     GHC.Word.$fNumWord16_$c*_info:
         const GHC.Word.$fNumWord16_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Bxl() //  [R1]
         { []
         }
     {offset
       c2Bxl: // global
           I64[Sp] = block_c2Bxr_info;
           _s2uUb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUb::I64;
           if (R1 & 7 != 0) goto u2BxJ; else goto c2Bxs;
       u2BxJ: // global
           call _c2Bxr(R1) args: 0, res: 0, upd: 0;
       c2Bxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bxl_info" {
     block_c2Bxl_info:
         const _c2Bxl;
         const 1;
         const 30;
 },
 _c2Bxr() //  [R1]
         { []
         }
     {offset
       c2Bxr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BxI; else goto c2BxH;
       c2BxI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BxH: // global
           _s2uUf::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Bxr_info" {
     block_c2Bxr_info:
         const _c2Bxr;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.3406822 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2By9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Byo; else goto c2Byp;
       c2Byo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Byp: // global
           I64[Sp - 16] = block_c2By6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Byv; else goto c2By7;
       u2Byv: // global
           call _c2By6(R1) args: 0, res: 0, upd: 0;
       c2By7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c-_info" {
     GHC.Word.$fNumWord16_$c-_info:
         const GHC.Word.$fNumWord16_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2By6() //  [R1]
         { []
         }
     {offset
       c2By6: // global
           I64[Sp] = block_c2Byc_info;
           _s2uUj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUj::I64;
           if (R1 & 7 != 0) goto u2Byu; else goto c2Byd;
       u2Byu: // global
           call _c2Byc(R1) args: 0, res: 0, upd: 0;
       c2Byd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2By6_info" {
     block_c2By6_info:
         const _c2By6;
         const 1;
         const 30;
 },
 _c2Byc() //  [R1]
         { []
         }
     {offset
       c2Byc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Byt; else goto c2Bys;
       c2Byt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bys: // global
           _s2uUn::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Byc_info" {
     block_c2Byc_info:
         const _c2Byc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.349153025 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ByU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Bz9; else goto c2Bza;
       c2Bz9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Bza: // global
           I64[Sp - 16] = block_c2ByR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Bzg; else goto c2ByS;
       u2Bzg: // global
           call _c2ByR(R1) args: 0, res: 0, upd: 0;
       c2ByS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c+_info" {
     GHC.Word.$fNumWord16_$c+_info:
         const GHC.Word.$fNumWord16_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2ByR() //  [R1]
         { []
         }
     {offset
       c2ByR: // global
           I64[Sp] = block_c2ByX_info;
           _s2uUr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUr::I64;
           if (R1 & 7 != 0) goto u2Bzf; else goto c2ByY;
       u2Bzf: // global
           call _c2ByX(R1) args: 0, res: 0, upd: 0;
       c2ByY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ByR_info" {
     block_c2ByR_info:
         const _c2ByR;
         const 1;
         const 30;
 },
 _c2ByX() //  [R1]
         { []
         }
     {offset
       c2ByX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Bze; else goto c2Bzd;
       c2Bze: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Bzd: // global
           _s2uUv::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ByX_info" {
     block_c2ByX_info:
         const _c2ByX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.356769954 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { []
         }
     {offset
       c2BzF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BzG; else goto c2BzH;
       c2BzG: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BzH: // global
           I64[Sp - 8] = block_c2BzC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BzM; else goto c2BzD;
       u2BzM: // global
           call _c2BzC(R1) args: 0, res: 0, upd: 0;
       c2BzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger1_info" {
     GHC.Word.$ctoInteger1_info:
         const GHC.Word.$ctoInteger1_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BzC() //  [R1]
         { []
         }
     {offset
       c2BzC: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BzC_info" {
     block_c2BzC_info:
         const _c2BzC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.363282019 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2BA3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BAe; else goto c2BAf;
       c2BAe: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BAf: // global
           I64[Sp - 8] = block_c2BA0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BAj; else goto c2BA1;
       u2BAj: // global
           call _c2BA0(R1) args: 0, res: 0, upd: 0;
       c2BA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cpopCount_info" {
     GHC.Word.$fBitsWord16_$cpopCount_info:
         const GHC.Word.$fBitsWord16_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BA0() //  [R1]
         { []
         }
     {offset
       c2BA0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BAi; else goto c2BAh;
       c2BAi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BAh: // global
           (_c2BA6::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BA6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BA0_info" {
     block_c2BA0_info:
         const _c2BA0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.37003654 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BAB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BAN; else goto c2BAO;
       c2BAN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BAO: // global
           I64[Sp - 16] = block_c2BAy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BAU; else goto c2BAz;
       u2BAU: // global
           call _c2BAy(R1) args: 0, res: 0, upd: 0;
       c2BAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BAy() //  [R1]
         { []
         }
     {offset
       c2BAy: // global
           I64[Sp] = block_c2BAE_info;
           _s2uUI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUI::I64;
           if (R1 & 7 != 0) goto u2BAT; else goto c2BAF;
       u2BAT: // global
           call _c2BAE(R1) args: 0, res: 0, upd: 0;
       c2BAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BAy_info" {
     block_c2BAy_info:
         const _c2BAy;
         const 1;
         const 30;
 },
 _c2BAE() //  [R1]
         { []
         }
     {offset
       c2BAE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BAS; else goto c2BAR;
       c2BAS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BAR: // global
           _s2uUL::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uUL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BAE_info" {
     block_c2BAE_info:
         const _c2BAE;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.379250837 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BBh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BBl; else goto c2BBm;
       c2BBl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BBm: // global
           I64[Sp - 16] = block_c2BBe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BBG; else goto c2BBf;
       u2BBG: // global
           call _c2BBe(R1) args: 0, res: 0, upd: 0;
       c2BBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshiftR_info" {
     GHC.Word.$fBitsWord16_$cshiftR_info:
         const GHC.Word.$fBitsWord16_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BBe() //  [R1]
         { []
         }
     {offset
       c2BBe: // global
           I64[Sp] = block_c2BBk_info;
           _s2uUP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUP::I64;
           if (R1 & 7 != 0) goto u2BBF; else goto c2BBo;
       u2BBF: // global
           call _c2BBk(R1) args: 0, res: 0, upd: 0;
       c2BBo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BBe_info" {
     block_c2BBe_info:
         const _c2BBe;
         const 1;
         const 30;
 },
 _c2BBk() //  [R1]
         { []
         }
     {offset
       c2BBk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BBu; else goto c2BBt;
       c2BBu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BBt: // global
           _s2uUR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uUR::I64, 64)) goto c2BBD; else goto c2BBE;
       c2BBD: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uUR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BBE: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BBk_info" {
     block_c2BBk_info:
         const _c2BBk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.387800189 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BC4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BCj; else goto c2BCk;
       c2BCj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BCk: // global
           I64[Sp - 16] = block_c2BC1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BCq; else goto c2BC2;
       u2BCq: // global
           call _c2BC1(R1) args: 0, res: 0, upd: 0;
       c2BC2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BC1() //  [R1]
         { []
         }
     {offset
       c2BC1: // global
           I64[Sp] = block_c2BC7_info;
           _s2uUX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uUX::I64;
           if (R1 & 7 != 0) goto u2BCp; else goto c2BC8;
       u2BCp: // global
           call _c2BC7(R1) args: 0, res: 0, upd: 0;
       c2BC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BC1_info" {
     block_c2BC1_info:
         const _c2BC1;
         const 1;
         const 30;
 },
 _c2BC7() //  [R1]
         { []
         }
     {offset
       c2BC7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BCo; else goto c2BCn;
       c2BCo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BCn: // global
           _s2uV1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uV1::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BC7_info" {
     block_c2BC7_info:
         const _c2BC7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.397024877 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BCO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BCS; else goto c2BCT;
       c2BCS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BCT: // global
           I64[Sp - 16] = block_c2BCL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BDg; else goto c2BCM;
       u2BDg: // global
           call _c2BCL(R1) args: 0, res: 0, upd: 0;
       c2BCM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshiftL_info" {
     GHC.Word.$fBitsWord16_$cshiftL_info:
         const GHC.Word.$fBitsWord16_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BCL() //  [R1]
         { []
         }
     {offset
       c2BCL: // global
           I64[Sp] = block_c2BCR_info;
           _s2uV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uV5::I64;
           if (R1 & 7 != 0) goto u2BDf; else goto c2BCV;
       u2BDf: // global
           call _c2BCR(R1) args: 0, res: 0, upd: 0;
       c2BCV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BCL_info" {
     block_c2BCL_info:
         const _c2BCL;
         const 1;
         const 30;
 },
 _c2BCR() //  [R1]
         { []
         }
     {offset
       c2BCR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BD1; else goto c2BD0;
       c2BD1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BD0: // global
           _s2uV7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uV7::I64, 64)) goto c2BDd; else goto c2BDe;
       c2BDd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2uV7::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BDe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BCR_info" {
     block_c2BCR_info:
         const _c2BCR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.405073598 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2BDD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cisSigned_info" {
     GHC.Word.$fBitsWord16_$cisSigned_info:
         const GHC.Word.$fBitsWord16_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.410376809 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BDS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BDW; else goto c2BDX;
       c2BDW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BDX: // global
           I64[Sp - 16] = block_c2BDP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BEK; else goto c2BDQ;
       u2BEK: // global
           call _c2BDP(R1) args: 0, res: 0, upd: 0;
       c2BDQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotate_info" {
     GHC.Word.$fBitsWord16_$crotate_info:
         const GHC.Word.$fBitsWord16_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BDP() //  [R1]
         { []
         }
     {offset
       c2BDP: // global
           I64[Sp - 8] = block_c2BDV_info;
           _s2uVe::P64 = R1;
           _s2uVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uVf::I64;
           P64[Sp + 8] = _s2uVe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BEJ; else goto c2BDZ;
       u2BEJ: // global
           call _c2BDV(R1) args: 0, res: 0, upd: 0;
       c2BDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BDP_info" {
     block_c2BDP_info:
         const _c2BDP;
         const 1;
         const 30;
 },
 _c2BDV() //  [R1]
         { []
         }
     {offset
       c2BDV: // global
           _s2uVk::I64 = I64[R1 + 7] & 15;
           if (_s2uVk::I64 != 0) goto u2BEH; else goto c2BED;
       u2BEH: // global
           I64[Sp + 16] = _s2uVk::I64;
           Sp = Sp + 8;
           call _c2BEe() args: 0, res: 0, upd: 0;
       c2BED: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BDV_info" {
     block_c2BDV_info:
         const _c2BDV;
         const 66;
         const 30;
 },
 _c2BEe() //  []
         { []
         }
     {offset
       c2BEe: // global
           Hp = Hp + 16;
           _s2uVk::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BEA; else goto c2BEz;
       c2BEA: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2BEd_info;
           R1 = _s2uVk::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BEz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2uVf::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2uVf::I64 << _s2uVk::I64) | (_s2uVf::I64 >> 16 - _s2uVk::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BEd() //  [R1]
         { []
         }
     {offset
       c2BEd: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2BEe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2BEd_info" {
     block_c2BEd_info:
         const _c2BEd;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.423374225 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BFq; else goto c2BFr;
       c2BFq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BFr: // global
           I64[Sp - 16] = block_c2BFj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BG8; else goto c2BFk;
       u2BG8: // global
           call _c2BFj(R1) args: 0, res: 0, upd: 0;
       c2BFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshift_info" {
     GHC.Word.$fBitsWord16_$cshift_info:
         const GHC.Word.$fBitsWord16_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BFj() //  [R1]
         { []
         }
     {offset
       c2BFj: // global
           I64[Sp] = block_c2BFp_info;
           _s2uVt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVt::I64;
           if (R1 & 7 != 0) goto u2BG7; else goto c2BFt;
       u2BG7: // global
           call _c2BFp(R1) args: 0, res: 0, upd: 0;
       c2BFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BFj_info" {
     block_c2BFj_info:
         const _c2BFj;
         const 1;
         const 30;
 },
 _c2BFp() //  [R1]
         { []
         }
     {offset
       c2BFp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BFz; else goto c2BFy;
       c2BFz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BFy: // global
           _s2uVt::I64 = I64[Sp + 8];
           _s2uVv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uVv::I64, 0)) goto c2BFR; else goto c2BG6;
       c2BFR: // global
           _s2uVx::I64 = -_s2uVv::I64;
           if (%MO_S_Ge_W64(_s2uVx::I64, 64)) goto c2BG5; else goto c2BFO;
       c2BFO: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVt::I64 >> _s2uVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BG6: // global
           if (%MO_S_Ge_W64(_s2uVv::I64, 64)) goto c2BG5; else goto c2BG4;
       c2BG5: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BG4: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2uVt::I64 << _s2uVv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BFp_info" {
     block_c2BFp_info:
         const _c2BFp;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.432090912 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BGA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BGM; else goto c2BGN;
       c2BGM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BGN: // global
           I64[Sp - 16] = block_c2BGx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BGT; else goto c2BGy;
       u2BGT: // global
           call _c2BGx(R1) args: 0, res: 0, upd: 0;
       c2BGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cxor_info" {
     GHC.Word.$fBitsWord16_$cxor_info:
         const GHC.Word.$fBitsWord16_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BGx() //  [R1]
         { []
         }
     {offset
       c2BGx: // global
           I64[Sp] = block_c2BGD_info;
           _s2uVG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVG::I64;
           if (R1 & 7 != 0) goto u2BGS; else goto c2BGE;
       u2BGS: // global
           call _c2BGD(R1) args: 0, res: 0, upd: 0;
       c2BGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BGx_info" {
     block_c2BGx_info:
         const _c2BGx;
         const 1;
         const 30;
 },
 _c2BGD() //  [R1]
         { []
         }
     {offset
       c2BGD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BGR; else goto c2BGQ;
       c2BGR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BGQ: // global
           _s2uVJ::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BGD_info" {
     block_c2BGD_info:
         const _c2BGD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.440945227 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2BHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BHt; else goto c2BHu;
       c2BHt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BHu: // global
           I64[Sp - 16] = block_c2BHe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BHA; else goto c2BHf;
       u2BHA: // global
           call _c2BHe(R1) args: 0, res: 0, upd: 0;
       c2BHf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$c.|._info" {
     GHC.Word.$fBitsWord16_$c.|._info:
         const GHC.Word.$fBitsWord16_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BHe() //  [R1]
         { []
         }
     {offset
       c2BHe: // global
           I64[Sp] = block_c2BHk_info;
           _s2uVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVN::I64;
           if (R1 & 7 != 0) goto u2BHz; else goto c2BHl;
       u2BHz: // global
           call _c2BHk(R1) args: 0, res: 0, upd: 0;
       c2BHl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BHe_info" {
     block_c2BHe_info:
         const _c2BHe;
         const 1;
         const 30;
 },
 _c2BHk() //  [R1]
         { []
         }
     {offset
       c2BHk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BHy; else goto c2BHx;
       c2BHy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BHx: // global
           _s2uVQ::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BHk_info" {
     block_c2BHk_info:
         const _c2BHk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.449167851 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2BHY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BIa; else goto c2BIb;
       c2BIa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BIb: // global
           I64[Sp - 16] = block_c2BHV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BIh; else goto c2BHW;
       u2BIh: // global
           call _c2BHV(R1) args: 0, res: 0, upd: 0;
       c2BHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$c.&._info" {
     GHC.Word.$fBitsWord16_$c.&._info:
         const GHC.Word.$fBitsWord16_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BHV() //  [R1]
         { []
         }
     {offset
       c2BHV: // global
           I64[Sp] = block_c2BI1_info;
           _s2uVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uVU::I64;
           if (R1 & 7 != 0) goto u2BIg; else goto c2BI2;
       u2BIg: // global
           call _c2BI1(R1) args: 0, res: 0, upd: 0;
       c2BI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BHV_info" {
     block_c2BHV_info:
         const _c2BHV;
         const 1;
         const 30;
 },
 _c2BI1() //  [R1]
         { []
         }
     {offset
       c2BI1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BIf; else goto c2BIe;
       c2BIf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BIe: // global
           _s2uVX::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2uVX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BI1_info" {
     block_c2BI1_info:
         const _c2BI1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.457950751 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2BIF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BIQ; else goto c2BIR;
       c2BIQ: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BIR: // global
           I64[Sp - 8] = block_c2BIC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BIV; else goto c2BID;
       u2BIV: // global
           call _c2BIC(R1) args: 0, res: 0, upd: 0;
       c2BID: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BIC() //  [R1]
         { []
         }
     {offset
       c2BIC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BIU; else goto c2BIT;
       c2BIU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BIT: // global
           (_c2BII::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BII::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BIC_info" {
     block_c2BIC_info:
         const _c2BIC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.464297036 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2BJf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BJq; else goto c2BJr;
       c2BJq: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BJr: // global
           I64[Sp - 8] = block_c2BJc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BJv; else goto c2BJd;
       u2BJv: // global
           call _c2BJc(R1) args: 0, res: 0, upd: 0;
       c2BJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BJc() //  [R1]
         { []
         }
     {offset
       c2BJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BJu; else goto c2BJt;
       c2BJu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BJt: // global
           (_c2BJi::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BJi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BJc_info" {
     block_c2BJc_info:
         const _c2BJc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.469964774 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.47206099 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2BJN: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.476318489 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2BK1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BK8; else goto c2BK9;
       c2BK8: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BK9: // global
           I64[Sp - 8] = block_c2BJZ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cfromInteger_info" {
     GHC.Word.$fNumWord32_$cfromInteger_info:
         const GHC.Word.$fNumWord32_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BJZ() //  [R1]
         { []
         }
     {offset
       c2BJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BKc; else goto c2BKb;
       c2BKc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BKb: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BJZ_info" {
     block_c2BJZ_info:
         const _c2BJZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.482405637 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2BKr: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cabs_info" {
     GHC.Word.$fNumWord32_$cabs_info:
         const GHC.Word.$fNumWord32_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.486649056 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2BKH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BKX; else goto c2BKY;
       c2BKX: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BKY: // global
           I64[Sp - 8] = block_c2BKE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BL2; else goto c2BKF;
       u2BL2: // global
           call _c2BKE(R1) args: 0, res: 0, upd: 0;
       c2BKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cnegate_info" {
     GHC.Word.$fNumWord32_$cnegate_info:
         const GHC.Word.$fNumWord32_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BKE() //  [R1]
         { []
         }
     {offset
       c2BKE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BL1; else goto c2BL0;
       c2BL1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BL0: // global
           _s2uWj::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BKE_info" {
     block_c2BKE_info:
         const _c2BKE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.493730612 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BLl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BLA; else goto c2BLB;
       c2BLA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BLB: // global
           I64[Sp - 16] = block_c2BLi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BLH; else goto c2BLj;
       u2BLH: // global
           call _c2BLi(R1) args: 0, res: 0, upd: 0;
       c2BLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c*_info" {
     GHC.Word.$fNumWord32_$c*_info:
         const GHC.Word.$fNumWord32_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BLi() //  [R1]
         { []
         }
     {offset
       c2BLi: // global
           I64[Sp] = block_c2BLo_info;
           _s2uWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWn::I64;
           if (R1 & 7 != 0) goto u2BLG; else goto c2BLp;
       u2BLG: // global
           call _c2BLo(R1) args: 0, res: 0, upd: 0;
       c2BLp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BLi_info" {
     block_c2BLi_info:
         const _c2BLi;
         const 1;
         const 30;
 },
 _c2BLo() //  [R1]
         { []
         }
     {offset
       c2BLo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BLF; else goto c2BLE;
       c2BLF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BLE: // global
           _s2uWr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BLo_info" {
     block_c2BLo_info:
         const _c2BLo;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.502911429 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BM6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BMl; else goto c2BMm;
       c2BMl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BMm: // global
           I64[Sp - 16] = block_c2BM3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BMs; else goto c2BM4;
       u2BMs: // global
           call _c2BM3(R1) args: 0, res: 0, upd: 0;
       c2BM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c-_info" {
     GHC.Word.$fNumWord32_$c-_info:
         const GHC.Word.$fNumWord32_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BM3() //  [R1]
         { []
         }
     {offset
       c2BM3: // global
           I64[Sp] = block_c2BM9_info;
           _s2uWv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWv::I64;
           if (R1 & 7 != 0) goto u2BMr; else goto c2BMa;
       u2BMr: // global
           call _c2BM9(R1) args: 0, res: 0, upd: 0;
       c2BMa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BM3_info" {
     block_c2BM3_info:
         const _c2BM3;
         const 1;
         const 30;
 },
 _c2BM9() //  [R1]
         { []
         }
     {offset
       c2BM9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BMq; else goto c2BMp;
       c2BMq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BMp: // global
           _s2uWz::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWz::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BM9_info" {
     block_c2BM9_info:
         const _c2BM9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.510983396 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BMR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BN6; else goto c2BN7;
       c2BN6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BN7: // global
           I64[Sp - 16] = block_c2BMO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BNd; else goto c2BMP;
       u2BNd: // global
           call _c2BMO(R1) args: 0, res: 0, upd: 0;
       c2BMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c+_info" {
     GHC.Word.$fNumWord32_$c+_info:
         const GHC.Word.$fNumWord32_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BMO() //  [R1]
         { []
         }
     {offset
       c2BMO: // global
           I64[Sp] = block_c2BMU_info;
           _s2uWD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWD::I64;
           if (R1 & 7 != 0) goto u2BNc; else goto c2BMV;
       u2BNc: // global
           call _c2BMU(R1) args: 0, res: 0, upd: 0;
       c2BMV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BMO_info" {
     block_c2BMO_info:
         const _c2BMO;
         const 1;
         const 30;
 },
 _c2BMU() //  [R1]
         { []
         }
     {offset
       c2BMU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BNb; else goto c2BNa;
       c2BNb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BNa: // global
           _s2uWH::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BMU_info" {
     block_c2BMU_info:
         const _c2BMU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.520083766 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { []
         }
     {offset
       c2BNC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BND; else goto c2BNE;
       c2BND: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BNE: // global
           I64[Sp - 8] = block_c2BNz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BNJ; else goto c2BNA;
       u2BNJ: // global
           call _c2BNz(R1) args: 0, res: 0, upd: 0;
       c2BNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger2_info" {
     GHC.Word.$ctoInteger2_info:
         const GHC.Word.$ctoInteger2_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BNz() //  [R1]
         { []
         }
     {offset
       c2BNz: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BNz_info" {
     block_c2BNz_info:
         const _c2BNz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.526108643 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2BO0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BOb; else goto c2BOc;
       c2BOb: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BOc: // global
           I64[Sp - 8] = block_c2BNX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BOg; else goto c2BNY;
       u2BOg: // global
           call _c2BNX(R1) args: 0, res: 0, upd: 0;
       c2BNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cpopCount_info" {
     GHC.Word.$fBitsWord32_$cpopCount_info:
         const GHC.Word.$fBitsWord32_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BNX() //  [R1]
         { []
         }
     {offset
       c2BNX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BOf; else goto c2BOe;
       c2BOf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BOe: // global
           (_c2BO3::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BO3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BNX_info" {
     block_c2BNX_info:
         const _c2BNX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.533481083 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BOy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BOK; else goto c2BOL;
       c2BOK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BOL: // global
           I64[Sp - 16] = block_c2BOv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BOR; else goto c2BOw;
       u2BOR: // global
           call _c2BOv(R1) args: 0, res: 0, upd: 0;
       c2BOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BOv() //  [R1]
         { []
         }
     {offset
       c2BOv: // global
           I64[Sp] = block_c2BOB_info;
           _s2uWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uWU::I64;
           if (R1 & 7 != 0) goto u2BOQ; else goto c2BOC;
       u2BOQ: // global
           call _c2BOB(R1) args: 0, res: 0, upd: 0;
       c2BOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BOv_info" {
     block_c2BOv_info:
         const _c2BOv;
         const 1;
         const 30;
 },
 _c2BOB() //  [R1]
         { []
         }
     {offset
       c2BOB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BOP; else goto c2BOO;
       c2BOP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BOO: // global
           _s2uWX::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BOB_info" {
     block_c2BOB_info:
         const _c2BOB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.542114514 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BPe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BPi; else goto c2BPj;
       c2BPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BPj: // global
           I64[Sp - 16] = block_c2BPb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BPD; else goto c2BPc;
       u2BPD: // global
           call _c2BPb(R1) args: 0, res: 0, upd: 0;
       c2BPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshiftR_info" {
     GHC.Word.$fBitsWord32_$cshiftR_info:
         const GHC.Word.$fBitsWord32_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BPb() //  [R1]
         { []
         }
     {offset
       c2BPb: // global
           I64[Sp] = block_c2BPh_info;
           _s2uX1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX1::I64;
           if (R1 & 7 != 0) goto u2BPC; else goto c2BPl;
       u2BPC: // global
           call _c2BPh(R1) args: 0, res: 0, upd: 0;
       c2BPl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BPb_info" {
     block_c2BPb_info:
         const _c2BPb;
         const 1;
         const 30;
 },
 _c2BPh() //  [R1]
         { []
         }
     {offset
       c2BPh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BPr; else goto c2BPq;
       c2BPr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BPq: // global
           _s2uX3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uX3::I64, 64)) goto c2BPA; else goto c2BPB;
       c2BPA: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uX3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BPB: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BPh_info" {
     block_c2BPh_info:
         const _c2BPh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.5513978 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BQg; else goto c2BQh;
       c2BQg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BQh: // global
           I64[Sp - 16] = block_c2BPY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BQn; else goto c2BPZ;
       u2BQn: // global
           call _c2BPY(R1) args: 0, res: 0, upd: 0;
       c2BPZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BPY() //  [R1]
         { []
         }
     {offset
       c2BPY: // global
           I64[Sp] = block_c2BQ4_info;
           _s2uX9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uX9::I64;
           if (R1 & 7 != 0) goto u2BQm; else goto c2BQ5;
       u2BQm: // global
           call _c2BQ4(R1) args: 0, res: 0, upd: 0;
       c2BQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BPY_info" {
     block_c2BPY_info:
         const _c2BPY;
         const 1;
         const 30;
 },
 _c2BQ4() //  [R1]
         { []
         }
     {offset
       c2BQ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BQl; else goto c2BQk;
       c2BQl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BQk: // global
           _s2uXd::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BQ4_info" {
     block_c2BQ4_info:
         const _c2BQ4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.560706171 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BQO; else goto c2BQP;
       c2BQO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BQP: // global
           I64[Sp - 16] = block_c2BQH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BRc; else goto c2BQI;
       u2BRc: // global
           call _c2BQH(R1) args: 0, res: 0, upd: 0;
       c2BQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshiftL_info" {
     GHC.Word.$fBitsWord32_$cshiftL_info:
         const GHC.Word.$fBitsWord32_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BQH() //  [R1]
         { []
         }
     {offset
       c2BQH: // global
           I64[Sp] = block_c2BQN_info;
           _s2uXh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXh::I64;
           if (R1 & 7 != 0) goto u2BRb; else goto c2BQR;
       u2BRb: // global
           call _c2BQN(R1) args: 0, res: 0, upd: 0;
       c2BQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BQH_info" {
     block_c2BQH_info:
         const _c2BQH;
         const 1;
         const 30;
 },
 _c2BQN() //  [R1]
         { []
         }
     {offset
       c2BQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BQX; else goto c2BQW;
       c2BQX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BQW: // global
           _s2uXj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXj::I64, 64)) goto c2BR9; else goto c2BRa;
       c2BR9: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2uXj::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BRa: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BQN_info" {
     block_c2BQN_info:
         const _c2BQN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.568272783 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2BRy: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cisSigned_info" {
     GHC.Word.$fBitsWord32_$cisSigned_info:
         const GHC.Word.$fBitsWord32_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.574286979 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BRN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2BRR; else goto c2BRS;
       c2BRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BRS: // global
           I64[Sp - 16] = block_c2BRK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BSF; else goto c2BRL;
       u2BSF: // global
           call _c2BRK(R1) args: 0, res: 0, upd: 0;
       c2BRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotate_info" {
     GHC.Word.$fBitsWord32_$crotate_info:
         const GHC.Word.$fBitsWord32_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BRK() //  [R1]
         { []
         }
     {offset
       c2BRK: // global
           I64[Sp - 8] = block_c2BRQ_info;
           _s2uXq::P64 = R1;
           _s2uXr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uXr::I64;
           P64[Sp + 8] = _s2uXq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BSE; else goto c2BRU;
       u2BSE: // global
           call _c2BRQ(R1) args: 0, res: 0, upd: 0;
       c2BRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BRK_info" {
     block_c2BRK_info:
         const _c2BRK;
         const 1;
         const 30;
 },
 _c2BRQ() //  [R1]
         { []
         }
     {offset
       c2BRQ: // global
           _s2uXw::I64 = I64[R1 + 7] & 31;
           if (_s2uXw::I64 != 0) goto u2BSC; else goto c2BSy;
       u2BSC: // global
           I64[Sp + 16] = _s2uXw::I64;
           Sp = Sp + 8;
           call _c2BS9() args: 0, res: 0, upd: 0;
       c2BSy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BRQ_info" {
     block_c2BRQ_info:
         const _c2BRQ;
         const 66;
         const 30;
 },
 _c2BS9() //  []
         { []
         }
     {offset
       c2BS9: // global
           Hp = Hp + 16;
           _s2uXw::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2BSv; else goto c2BSu;
       c2BSv: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2BS8_info;
           R1 = _s2uXw::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2BSu: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2uXr::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2uXr::I64 << _s2uXw::I64) | (_s2uXr::I64 >> 32 - _s2uXw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2BS8() //  [R1]
         { []
         }
     {offset
       c2BS8: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2BS9() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2BS8_info" {
     block_c2BS8_info:
         const _c2BS8;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.586065468 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BTh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BTl; else goto c2BTm;
       c2BTl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BTm: // global
           I64[Sp - 16] = block_c2BTe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BU3; else goto c2BTf;
       u2BU3: // global
           call _c2BTe(R1) args: 0, res: 0, upd: 0;
       c2BTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshift_info" {
     GHC.Word.$fBitsWord32_$cshift_info:
         const GHC.Word.$fBitsWord32_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BTe() //  [R1]
         { []
         }
     {offset
       c2BTe: // global
           I64[Sp] = block_c2BTk_info;
           _s2uXF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXF::I64;
           if (R1 & 7 != 0) goto u2BU2; else goto c2BTo;
       u2BU2: // global
           call _c2BTk(R1) args: 0, res: 0, upd: 0;
       c2BTo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BTe_info" {
     block_c2BTe_info:
         const _c2BTe;
         const 1;
         const 30;
 },
 _c2BTk() //  [R1]
         { []
         }
     {offset
       c2BTk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BTu; else goto c2BTt;
       c2BTu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BTt: // global
           _s2uXF::I64 = I64[Sp + 8];
           _s2uXH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uXH::I64, 0)) goto c2BTM; else goto c2BU1;
       c2BTM: // global
           _s2uXJ::I64 = -_s2uXH::I64;
           if (%MO_S_Ge_W64(_s2uXJ::I64, 64)) goto c2BU0; else goto c2BTJ;
       c2BTJ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXF::I64 >> _s2uXJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BU1: // global
           if (%MO_S_Ge_W64(_s2uXH::I64, 64)) goto c2BU0; else goto c2BTZ;
       c2BU0: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BTZ: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2uXF::I64 << _s2uXH::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BTk_info" {
     block_c2BTk_info:
         const _c2BTk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.595614806 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BUu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BUG; else goto c2BUH;
       c2BUG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BUH: // global
           I64[Sp - 16] = block_c2BUr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BUN; else goto c2BUs;
       u2BUN: // global
           call _c2BUr(R1) args: 0, res: 0, upd: 0;
       c2BUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cxor_info" {
     GHC.Word.$fBitsWord32_$cxor_info:
         const GHC.Word.$fBitsWord32_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BUr() //  [R1]
         { []
         }
     {offset
       c2BUr: // global
           I64[Sp] = block_c2BUx_info;
           _s2uXS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXS::I64;
           if (R1 & 7 != 0) goto u2BUM; else goto c2BUy;
       u2BUM: // global
           call _c2BUx(R1) args: 0, res: 0, upd: 0;
       c2BUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BUr_info" {
     block_c2BUr_info:
         const _c2BUr;
         const 1;
         const 30;
 },
 _c2BUx() //  [R1]
         { []
         }
     {offset
       c2BUx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BUL; else goto c2BUK;
       c2BUL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BUK: // global
           _s2uXV::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uXV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BUx_info" {
     block_c2BUx_info:
         const _c2BUx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.603992598 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2BVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BVn; else goto c2BVo;
       c2BVn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BVo: // global
           I64[Sp - 16] = block_c2BV8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BVu; else goto c2BV9;
       u2BVu: // global
           call _c2BV8(R1) args: 0, res: 0, upd: 0;
       c2BV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$c.|._info" {
     GHC.Word.$fBitsWord32_$c.|._info:
         const GHC.Word.$fBitsWord32_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BV8() //  [R1]
         { []
         }
     {offset
       c2BV8: // global
           I64[Sp] = block_c2BVe_info;
           _s2uXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uXZ::I64;
           if (R1 & 7 != 0) goto u2BVt; else goto c2BVf;
       u2BVt: // global
           call _c2BVe(R1) args: 0, res: 0, upd: 0;
       c2BVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BV8_info" {
     block_c2BV8_info:
         const _c2BV8;
         const 1;
         const 30;
 },
 _c2BVe() //  [R1]
         { []
         }
     {offset
       c2BVe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BVs; else goto c2BVr;
       c2BVs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BVr: // global
           _s2uY2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BVe_info" {
     block_c2BVe_info:
         const _c2BVe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.612811714 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2BVS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BW4; else goto c2BW5;
       c2BW4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BW5: // global
           I64[Sp - 16] = block_c2BVP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BWb; else goto c2BVQ;
       u2BWb: // global
           call _c2BVP(R1) args: 0, res: 0, upd: 0;
       c2BVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$c.&._info" {
     GHC.Word.$fBitsWord32_$c.&._info:
         const GHC.Word.$fBitsWord32_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BVP() //  [R1]
         { []
         }
     {offset
       c2BVP: // global
           I64[Sp] = block_c2BVV_info;
           _s2uY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uY6::I64;
           if (R1 & 7 != 0) goto u2BWa; else goto c2BVW;
       u2BWa: // global
           call _c2BVV(R1) args: 0, res: 0, upd: 0;
       c2BVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BVP_info" {
     block_c2BVP_info:
         const _c2BVP;
         const 1;
         const 30;
 },
 _c2BVV() //  [R1]
         { []
         }
     {offset
       c2BVV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BW9; else goto c2BW8;
       c2BW9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BW8: // global
           _s2uY9::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2uY9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BVV_info" {
     block_c2BVV_info:
         const _c2BVV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.621401093 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2BWz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BWK; else goto c2BWL;
       c2BWK: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BWL: // global
           I64[Sp - 8] = block_c2BWw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BWP; else goto c2BWx;
       u2BWP: // global
           call _c2BWw(R1) args: 0, res: 0, upd: 0;
       c2BWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BWw() //  [R1]
         { []
         }
     {offset
       c2BWw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BWO; else goto c2BWN;
       c2BWO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BWN: // global
           (_c2BWC::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BWC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BWw_info" {
     block_c2BWw_info:
         const _c2BWw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.628098931 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2BX9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BXk; else goto c2BXl;
       c2BXk: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BXl: // global
           I64[Sp - 8] = block_c2BX6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BXp; else goto c2BX7;
       u2BXp: // global
           call _c2BX6(R1) args: 0, res: 0, upd: 0;
       c2BX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BX6() //  [R1]
         { []
         }
     {offset
       c2BX6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BXo; else goto c2BXn;
       c2BXo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BXn: // global
           (_c2BXc::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BXc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BX6_info" {
     block_c2BX6_info:
         const _c2BX6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.633790374 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.636330341 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2BXH: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.640572211 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2BXW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2BY7; else goto c2BY8;
       c2BY7: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2BY8: // global
           I64[Sp - 8] = block_c2BXT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2BYc; else goto c2BXU;
       u2BYc: // global
           call _c2BXT(R1) args: 0, res: 0, upd: 0;
       c2BXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cpopCount_info" {
     GHC.Word.$fBitsWord64_$cpopCount_info:
         const GHC.Word.$fBitsWord64_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2BXT() //  [R1]
         { []
         }
     {offset
       c2BXT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BYb; else goto c2BYa;
       c2BYb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BYa: // global
           (_c2BXZ::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2BXZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BXT_info" {
     block_c2BXT_info:
         const _c2BXT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.647669563 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BYu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BYG; else goto c2BYH;
       c2BYG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BYH: // global
           I64[Sp - 16] = block_c2BYr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BYN; else goto c2BYs;
       u2BYN: // global
           call _c2BYr(R1) args: 0, res: 0, upd: 0;
       c2BYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BYr() //  [R1]
         { []
         }
     {offset
       c2BYr: // global
           I64[Sp] = block_c2BYx_info;
           _s2uYt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYt::I64;
           if (R1 & 7 != 0) goto u2BYM; else goto c2BYy;
       u2BYM: // global
           call _c2BYx(R1) args: 0, res: 0, upd: 0;
       c2BYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BYr_info" {
     block_c2BYr_info:
         const _c2BYr;
         const 1;
         const 30;
 },
 _c2BYx() //  [R1]
         { []
         }
     {offset
       c2BYx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BYL; else goto c2BYK;
       c2BYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BYK: // global
           _s2uYw::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BYx_info" {
     block_c2BYx_info:
         const _c2BYx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.656611034 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BZa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2BZe; else goto c2BZf;
       c2BZe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2BZf: // global
           I64[Sp - 16] = block_c2BZ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2BZz; else goto c2BZ8;
       u2BZz: // global
           call _c2BZ7(R1) args: 0, res: 0, upd: 0;
       c2BZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshiftR_info" {
     GHC.Word.$fBitsWord64_$cshiftR_info:
         const GHC.Word.$fBitsWord64_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BZ7() //  [R1]
         { []
         }
     {offset
       c2BZ7: // global
           I64[Sp] = block_c2BZd_info;
           _s2uYA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYA::I64;
           if (R1 & 7 != 0) goto u2BZy; else goto c2BZh;
       u2BZy: // global
           call _c2BZd(R1) args: 0, res: 0, upd: 0;
       c2BZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BZ7_info" {
     block_c2BZ7_info:
         const _c2BZ7;
         const 1;
         const 30;
 },
 _c2BZd() //  [R1]
         { []
         }
     {offset
       c2BZd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2BZn; else goto c2BZm;
       c2BZn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2BZm: // global
           _s2uYC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYC::I64, 64)) goto c2BZw; else goto c2BZx;
       c2BZw: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2uYC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2BZx: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BZd_info" {
     block_c2BZd_info:
         const _c2BZd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.665974555 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2BZX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C09; else goto c2C0a;
       c2C09: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C0a: // global
           I64[Sp - 16] = block_c2BZU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C0g; else goto c2BZV;
       u2C0g: // global
           call _c2BZU(R1) args: 0, res: 0, upd: 0;
       c2BZV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2BZU() //  [R1]
         { []
         }
     {offset
       c2BZU: // global
           I64[Sp] = block_c2C00_info;
           _s2uYI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYI::I64;
           if (R1 & 7 != 0) goto u2C0f; else goto c2C01;
       u2C0f: // global
           call _c2C00(R1) args: 0, res: 0, upd: 0;
       c2C01: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2BZU_info" {
     block_c2BZU_info:
         const _c2BZU;
         const 1;
         const 30;
 },
 _c2C00() //  [R1]
         { []
         }
     {offset
       c2C00: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C0e; else goto c2C0d;
       c2C0e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C0d: // global
           _s2uYL::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uYL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C00_info" {
     block_c2C00_info:
         const _c2C00;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.67436799 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2C0D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C0H; else goto c2C0I;
       c2C0H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C0I: // global
           I64[Sp - 16] = block_c2C0A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C12; else goto c2C0B;
       u2C12: // global
           call _c2C0A(R1) args: 0, res: 0, upd: 0;
       c2C0B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshiftL_info" {
     GHC.Word.$fBitsWord64_$cshiftL_info:
         const GHC.Word.$fBitsWord64_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C0A() //  [R1]
         { []
         }
     {offset
       c2C0A: // global
           I64[Sp] = block_c2C0G_info;
           _s2uYP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uYP::I64;
           if (R1 & 7 != 0) goto u2C11; else goto c2C0K;
       u2C11: // global
           call _c2C0G(R1) args: 0, res: 0, upd: 0;
       c2C0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C0A_info" {
     block_c2C0A_info:
         const _c2C0A;
         const 1;
         const 30;
 },
 _c2C0G() //  [R1]
         { []
         }
     {offset
       c2C0G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C0Q; else goto c2C0P;
       c2C0Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C0P: // global
           _s2uYR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uYR::I64, 64)) goto c2C0Z; else goto c2C10;
       c2C0Z: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2uYR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C10: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C0G_info" {
     block_c2C0G_info:
         const _c2C0G;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.682295544 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2C1n: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cisSigned_info" {
     GHC.Word.$fBitsWord64_$cisSigned_info:
         const GHC.Word.$fBitsWord64_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.687876947 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2C1C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2C1G; else goto c2C1H;
       c2C1G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C1H: // global
           I64[Sp - 16] = block_c2C1z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C2r; else goto c2C1A;
       u2C2r: // global
           call _c2C1z(R1) args: 0, res: 0, upd: 0;
       c2C1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotate_info" {
     GHC.Word.$fBitsWord64_$crotate_info:
         const GHC.Word.$fBitsWord64_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C1z() //  [R1]
         { []
         }
     {offset
       c2C1z: // global
           I64[Sp - 8] = block_c2C1F_info;
           _s2uYX::P64 = R1;
           _s2uYY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2uYY::I64;
           P64[Sp + 8] = _s2uYX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C2q; else goto c2C1J;
       u2C2q: // global
           call _c2C1F(R1) args: 0, res: 0, upd: 0;
       c2C1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C1z_info" {
     block_c2C1z_info:
         const _c2C1z;
         const 1;
         const 30;
 },
 _c2C1F() //  [R1]
         { []
         }
     {offset
       c2C1F: // global
           _s2uZ3::I64 = I64[R1 + 7] & 63;
           if (_s2uZ3::I64 != 0) goto u2C2o; else goto c2C2k;
       u2C2o: // global
           I64[Sp + 16] = _s2uZ3::I64;
           Sp = Sp + 8;
           call _c2C1Y() args: 0, res: 0, upd: 0;
       c2C2k: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C1F_info" {
     block_c2C1F_info:
         const _c2C1F;
         const 66;
         const 30;
 },
 _c2C1Y() //  []
         { []
         }
     {offset
       c2C1Y: // global
           Hp = Hp + 16;
           _s2uZ3::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2C2h; else goto c2C2g;
       c2C2h: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2C1X_info;
           R1 = _s2uZ3::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2C2g: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2uYY::I64 = I64[Sp];
           I64[Hp] = (_s2uYY::I64 << _s2uZ3::I64) | (_s2uYY::I64 >> 64 - _s2uZ3::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2C1X() //  [R1]
         { []
         }
     {offset
       c2C1X: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2C1Y() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2C1X_info" {
     block_c2C1X_info:
         const _c2C1X;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.699686804 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2C32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C36; else goto c2C37;
       c2C36: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C37: // global
           I64[Sp - 16] = block_c2C2Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C3L; else goto c2C30;
       u2C3L: // global
           call _c2C2Z(R1) args: 0, res: 0, upd: 0;
       c2C30: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshift_info" {
     GHC.Word.$fBitsWord64_$cshift_info:
         const GHC.Word.$fBitsWord64_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C2Z() //  [R1]
         { []
         }
     {offset
       c2C2Z: // global
           I64[Sp] = block_c2C35_info;
           _s2uZb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZb::I64;
           if (R1 & 7 != 0) goto u2C3K; else goto c2C39;
       u2C3K: // global
           call _c2C35(R1) args: 0, res: 0, upd: 0;
       c2C39: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C2Z_info" {
     block_c2C2Z_info:
         const _c2C2Z;
         const 1;
         const 30;
 },
 _c2C35() //  [R1]
         { []
         }
     {offset
       c2C35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C3f; else goto c2C3e;
       c2C3f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C3e: // global
           _s2uZb::I64 = I64[Sp + 8];
           _s2uZd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2uZd::I64, 0)) goto c2C3x; else goto c2C3J;
       c2C3x: // global
           _s2uZf::I64 = -_s2uZd::I64;
           if (%MO_S_Ge_W64(_s2uZf::I64, 64)) goto c2C3I; else goto c2C3u;
       c2C3u: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 >> _s2uZf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C3J: // global
           if (%MO_S_Ge_W64(_s2uZd::I64, 64)) goto c2C3I; else goto c2C3H;
       c2C3I: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C3H: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZb::I64 << _s2uZd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C35_info" {
     block_c2C35_info:
         const _c2C35;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.708780161 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2C4b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C4n; else goto c2C4o;
       c2C4n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C4o: // global
           I64[Sp - 16] = block_c2C48_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C4u; else goto c2C49;
       u2C4u: // global
           call _c2C48(R1) args: 0, res: 0, upd: 0;
       c2C49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cxor_info" {
     GHC.Word.$fBitsWord64_$cxor_info:
         const GHC.Word.$fBitsWord64_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C48() //  [R1]
         { []
         }
     {offset
       c2C48: // global
           I64[Sp] = block_c2C4e_info;
           _s2uZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZn::I64;
           if (R1 & 7 != 0) goto u2C4t; else goto c2C4f;
       u2C4t: // global
           call _c2C4e(R1) args: 0, res: 0, upd: 0;
       c2C4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C48_info" {
     block_c2C48_info:
         const _c2C48;
         const 1;
         const 30;
 },
 _c2C4e() //  [R1]
         { []
         }
     {offset
       c2C4e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C4s; else goto c2C4r;
       c2C4s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C4r: // global
           _s2uZq::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C4e_info" {
     block_c2C4e_info:
         const _c2C4e;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.717659811 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2C4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C54; else goto c2C55;
       c2C54: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C55: // global
           I64[Sp - 16] = block_c2C4P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C5b; else goto c2C4Q;
       u2C5b: // global
           call _c2C4P(R1) args: 0, res: 0, upd: 0;
       c2C4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$c.|._info" {
     GHC.Word.$fBitsWord64_$c.|._info:
         const GHC.Word.$fBitsWord64_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C4P() //  [R1]
         { []
         }
     {offset
       c2C4P: // global
           I64[Sp] = block_c2C4V_info;
           _s2uZu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZu::I64;
           if (R1 & 7 != 0) goto u2C5a; else goto c2C4W;
       u2C5a: // global
           call _c2C4V(R1) args: 0, res: 0, upd: 0;
       c2C4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C4P_info" {
     block_c2C4P_info:
         const _c2C4P;
         const 1;
         const 30;
 },
 _c2C4V() //  [R1]
         { []
         }
     {offset
       c2C4V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C59; else goto c2C58;
       c2C59: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C58: // global
           _s2uZx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C4V_info" {
     block_c2C4V_info:
         const _c2C4V;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.72634789 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2C5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C5L; else goto c2C5M;
       c2C5L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C5M: // global
           I64[Sp - 16] = block_c2C5w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C5S; else goto c2C5x;
       u2C5S: // global
           call _c2C5w(R1) args: 0, res: 0, upd: 0;
       c2C5x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$c.&._info" {
     GHC.Word.$fBitsWord64_$c.&._info:
         const GHC.Word.$fBitsWord64_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C5w() //  [R1]
         { []
         }
     {offset
       c2C5w: // global
           I64[Sp] = block_c2C5C_info;
           _s2uZB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZB::I64;
           if (R1 & 7 != 0) goto u2C5R; else goto c2C5D;
       u2C5R: // global
           call _c2C5C(R1) args: 0, res: 0, upd: 0;
       c2C5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C5w_info" {
     block_c2C5w_info:
         const _c2C5w;
         const 1;
         const 30;
 },
 _c2C5C() //  [R1]
         { []
         }
     {offset
       c2C5C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C5Q; else goto c2C5P;
       c2C5Q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C5P: // global
           _s2uZE::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2uZE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C5C_info" {
     block_c2C5C_info:
         const _c2C5C;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.734373958 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2C6g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C6r; else goto c2C6s;
       c2C6r: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C6s: // global
           I64[Sp - 8] = block_c2C6d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C6w; else goto c2C6e;
       u2C6w: // global
           call _c2C6d(R1) args: 0, res: 0, upd: 0;
       c2C6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2C6d() //  [R1]
         { []
         }
     {offset
       c2C6d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C6v; else goto c2C6u;
       c2C6v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C6u: // global
           (_c2C6j::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2C6j::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C6d_info" {
     block_c2C6d_info:
         const _c2C6d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.740839925 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2C6Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C71; else goto c2C72;
       c2C71: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C72: // global
           I64[Sp - 8] = block_c2C6N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C76; else goto c2C6O;
       u2C76: // global
           call _c2C6N(R1) args: 0, res: 0, upd: 0;
       c2C6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2C6N() //  [R1]
         { []
         }
     {offset
       c2C6N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C75; else goto c2C74;
       c2C75: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C74: // global
           (_c2C6T::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2C6T::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C6N_info" {
     block_c2C6N_info:
         const _c2C6N;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.746188844 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.748297878 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2C7o: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.752476591 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2C7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2C7H; else goto c2C7I;
       c2C7H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2C7I: // global
           I64[Sp - 16] = block_c2C7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2C7R; else goto c2C7B;
       u2C7R: // global
           call _c2C7A(R1) args: 0, res: 0, upd: 0;
       c2C7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord8_info" {
     GHC.Word.eqWord8_info:
         const GHC.Word.eqWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2C7A() //  [R1]
         { []
         }
     {offset
       c2C7A: // global
           I64[Sp] = block_c2C7G_info;
           _s2uZT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2uZT::I64;
           if (R1 & 7 != 0) goto u2C7Q; else goto c2C7K;
       u2C7Q: // global
           call _c2C7G(R1) args: 0, res: 0, upd: 0;
       c2C7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C7A_info" {
     block_c2C7A_info:
         const _c2C7A;
         const 1;
         const 30;
 },
 _c2C7G() //  [R1]
         { []
         }
     {offset
       c2C7G: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C7G_info" {
     block_c2C7G_info:
         const _c2C7G;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.759705083 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.761482778 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.764175729 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2C8i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C8j; else goto c2C8k;
       c2C8j: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C8k: // global
           I64[Sp - 8] = block_c2C8f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C8s; else goto c2C8g;
       u2C8s: // global
           call _c2C8f(R1) args: 0, res: 0, upd: 0;
       c2C8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$csignum_info" {
     GHC.Word.$fNumWord8_$csignum_info:
         const GHC.Word.$fNumWord8_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2C8f() //  [R1]
         { []
         }
     {offset
       c2C8f: // global
           if (I64[R1 + 7] == 0) goto c2C8r; else goto c2C8q;
       c2C8r: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C8q: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C8f_info" {
     block_c2C8f_info:
         const _c2C8f;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.769952064 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.772715782 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2C8M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C8T; else goto c2C8U;
       c2C8T: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C8U: // global
           I64[Sp - 8] = block_c2C8J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C8Y; else goto c2C8K;
       u2C8Y: // global
           call _c2C8J(R1) args: 0, res: 0, upd: 0;
       c2C8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ccomplement_info" {
     GHC.Word.$fBitsWord8_$ccomplement_info:
         const GHC.Word.$fBitsWord8_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2C8J() //  [R1]
         { []
         }
     {offset
       c2C8J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C8X; else goto c2C8W;
       c2C8X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C8W: // global
           _s2v04::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v04::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C8J_info" {
     block_c2C8J_info:
         const _c2C8J;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.778165354 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.780412762 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2C9f: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.785466871 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2C9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2C9v; else goto c2C9w;
       c2C9v: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2C9w: // global
           I64[Sp - 8] = block_c2C9r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2C9P; else goto c2C9s;
       u2C9P: // global
           call _c2C9r(R1) args: 0, res: 0, upd: 0;
       c2C9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cbit_info" {
     GHC.Word.$fBitsWord8_$cbit_info:
         const GHC.Word.$fBitsWord8_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2C9r() //  [R1]
         { []
         }
     {offset
       c2C9r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2C9B; else goto c2C9A;
       c2C9B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2C9A: // global
           _s2v08::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v08::I64, 64)) goto c2C9N; else goto c2C9O;
       c2C9N: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v08::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2C9O: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2C9r_info" {
     block_c2C9r_info:
         const _c2C9r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.792562331 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Caf; else goto c2Cag;
       c2Caf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cag: // global
           I64[Sp - 16] = block_c2Ca8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CaP; else goto c2Ca9;
       u2CaP: // global
           call _c2Ca8(R1) args: 0, res: 0, upd: 0;
       c2Ca9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ctestBit_info" {
     GHC.Word.$fBitsWord8_$ctestBit_info:
         const GHC.Word.$fBitsWord8_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Ca8() //  [R1]
         { []
         }
     {offset
       c2Ca8: // global
           I64[Sp] = block_c2Cae_info;
           _s2v0f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0f::I64;
           if (R1 & 7 != 0) goto u2CaO; else goto c2Cai;
       u2CaO: // global
           call _c2Cae(R1) args: 0, res: 0, upd: 0;
       c2Cai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ca8_info" {
     block_c2Ca8_info:
         const _c2Ca8;
         const 1;
         const 30;
 },
 _c2Cae() //  [R1]
         { []
         }
     {offset
       c2Cae: // global
           _s2v0h::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v0h::I64, 64)) goto c2CaN; else goto c2CaM;
       c2CaM: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0h::I64)) == 0) goto c2CaN; else goto c2CaB;
       c2CaN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CaB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cae_info" {
     block_c2Cae_info:
         const _c2Cae;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.802434504 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cbh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cbl; else goto c2Cbm;
       c2Cbl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cbm: // global
           I64[Sp - 16] = block_c2Cbe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ccc; else goto c2Cbf;
       u2Ccc: // global
           call _c2Cbe(R1) args: 0, res: 0, upd: 0;
       c2Cbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotateR_info" {
     GHC.Word.$fBitsWord8_$crotateR_info:
         const GHC.Word.$fBitsWord8_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cbe() //  [R1]
         { []
         }
     {offset
       c2Cbe: // global
           I64[Sp - 8] = block_c2Cbk_info;
           _s2v0o::P64 = R1;
           _s2v0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0p::I64;
           P64[Sp + 8] = _s2v0o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ccb; else goto c2Cbo;
       u2Ccb: // global
           call _c2Cbk(R1) args: 0, res: 0, upd: 0;
       c2Cbo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cbe_info" {
     block_c2Cbe_info:
         const _c2Cbe;
         const 1;
         const 30;
 },
 _c2Cbk() //  [R1]
         { []
         }
     {offset
       c2Cbk: // global
           _s2v0v::I64 = -I64[R1 + 7] & 7;
           if (_s2v0v::I64 != 0) goto u2Cc9; else goto c2Cc5;
       u2Cc9: // global
           I64[Sp + 16] = _s2v0v::I64;
           Sp = Sp + 8;
           call _c2CbG() args: 0, res: 0, upd: 0;
       c2Cc5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cbk_info" {
     block_c2Cbk_info:
         const _c2Cbk;
         const 66;
         const 30;
 },
 _c2CbG() //  []
         { []
         }
     {offset
       c2CbG: // global
           Hp = Hp + 16;
           _s2v0v::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Cc2; else goto c2Cc1;
       c2Cc2: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2CbF_info;
           R1 = _s2v0v::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Cc1: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2v0p::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2v0p::I64 << _s2v0v::I64) | (_s2v0p::I64 >> 8 - _s2v0v::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CbF() //  [R1]
         { []
         }
     {offset
       c2CbF: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2CbG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2CbF_info" {
     block_c2CbF_info:
         const _c2CbF;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.812525349 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CcL: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotateL_info" {
     GHC.Word.$fBitsWord8_$crotateL_info:
         const GHC.Word.$fBitsWord8_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.817682078 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CcZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cd3; else goto c2Cd4;
       c2Cd3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cd4: // global
           I64[Sp - 16] = block_c2CcW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cdu; else goto c2CcX;
       u2Cdu: // global
           call _c2CcW(R1) args: 0, res: 0, upd: 0;
       c2CcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ccomplementBit_info" {
     GHC.Word.$fBitsWord8_$ccomplementBit_info:
         const GHC.Word.$fBitsWord8_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CcW() //  [R1]
         { []
         }
     {offset
       c2CcW: // global
           I64[Sp - 8] = block_c2Cd2_info;
           _s2v0D::P64 = R1;
           _s2v0E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v0E::I64;
           P64[Sp + 8] = _s2v0D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cdt; else goto c2Cd6;
       u2Cdt: // global
           call _c2Cd2(R1) args: 0, res: 0, upd: 0;
       c2Cd6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CcW_info" {
     block_c2CcW_info:
         const _c2CcW;
         const 1;
         const 30;
 },
 _c2Cd2() //  [R1]
         { []
         }
     {offset
       c2Cd2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cdc; else goto c2Cdb;
       c2Cdc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cdb: // global
           _s2v0G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0G::I64, 64)) goto c2Cdr; else goto c2Cds;
       c2Cdr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0G::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cds: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cd2_info" {
     block_c2Cd2_info:
         const _c2Cd2;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.82643311 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CdX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ce1; else goto c2Ce2;
       c2Ce1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ce2: // global
           I64[Sp - 16] = block_c2CdU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CeA; else goto c2CdV;
       u2CeA: // global
           call _c2CdU(R1) args: 0, res: 0, upd: 0;
       c2CdV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cclearBit_info" {
     GHC.Word.$fBitsWord8_$cclearBit_info:
         const GHC.Word.$fBitsWord8_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CdU() //  [R1]
         { []
         }
     {offset
       c2CdU: // global
           I64[Sp] = block_c2Ce0_info;
           _s2v0O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v0O::I64;
           if (R1 & 7 != 0) goto u2Cez; else goto c2Ce4;
       u2Cez: // global
           call _c2Ce0(R1) args: 0, res: 0, upd: 0;
       c2Ce4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CdU_info" {
     block_c2CdU_info:
         const _c2CdU;
         const 1;
         const 30;
 },
 _c2Ce0() //  [R1]
         { []
         }
     {offset
       c2Ce0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cea; else goto c2Ce9;
       c2Cea: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ce9: // global
           _s2v0O::I64 = I64[Sp + 8];
           _s2v0Q::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v0Q::I64, 64)) goto c2Ces; else goto c2Cey;
       c2Ces: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v0Q::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cey: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v0O::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ce0_info" {
     block_c2Ce0_info:
         const _c2Ce0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.835432846 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cf5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cf9; else goto c2Cfa;
       c2Cf9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cfa: // global
           I64[Sp - 16] = block_c2Cf2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CfA; else goto c2Cf3;
       u2CfA: // global
           call _c2Cf2(R1) args: 0, res: 0, upd: 0;
       c2Cf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$csetBit_info" {
     GHC.Word.$fBitsWord8_$csetBit_info:
         const GHC.Word.$fBitsWord8_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cf2() //  [R1]
         { []
         }
     {offset
       c2Cf2: // global
           I64[Sp - 8] = block_c2Cf8_info;
           _s2v0Z::P64 = R1;
           _s2v10::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v10::I64;
           P64[Sp + 8] = _s2v0Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cfz; else goto c2Cfc;
       u2Cfz: // global
           call _c2Cf8(R1) args: 0, res: 0, upd: 0;
       c2Cfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cf2_info" {
     block_c2Cf2_info:
         const _c2Cf2;
         const 1;
         const 30;
 },
 _c2Cf8() //  [R1]
         { []
         }
     {offset
       c2Cf8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cfi; else goto c2Cfh;
       c2Cfi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cfh: // global
           _s2v12::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v12::I64, 64)) goto c2Cfx; else goto c2Cfy;
       c2Cfx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2v12::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cfy: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cf8_info" {
     block_c2Cf8_info:
         const _c2Cf8;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.843694633 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.845830749 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.849156934 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cg5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cg9; else goto c2Cga;
       c2Cg9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cga: // global
           I64[Sp - 16] = block_c2Cg2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cgt; else goto c2Cg3;
       u2Cgt: // global
           call _c2Cg2(R1) args: 0, res: 0, upd: 0;
       c2Cg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cquot_info" {
     GHC.Word.$fIntegralWord8_$cquot_info:
         const GHC.Word.$fIntegralWord8_$cquot_entry;
         const 0;
         const 2251804108652558;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2Cg2() //  [R1]
         { []
         }
     {offset
       c2Cg2: // global
           I64[Sp] = block_c2Cg8_info;
           _s2v1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1a::I64;
           if (R1 & 7 != 0) goto u2Cgs; else goto c2Cgc;
       u2Cgs: // global
           call _c2Cg8(R1) args: 0, res: 0, upd: 0;
       c2Cgc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cg2_info" {
     block_c2Cg2_info:
         const _c2Cg2;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2Cg8() //  [R1]
         { []
         }
     {offset
       c2Cg8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cgi; else goto c2Cgh;
       c2Cgi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cgh: // global
           _s2v1d::I64 = I64[R1 + 7];
           if (_s2v1d::I64 != 0) goto c2Cgq; else goto c2Cgr;
       c2Cgq: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v1d::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cgr: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cg8_info" {
     block_c2Cg8_info:
         const _c2Cg8;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.859856508 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CgQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CgU; else goto c2CgV;
       c2CgU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CgV: // global
           I64[Sp - 16] = block_c2CgN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Che; else goto c2CgO;
       u2Che: // global
           call _c2CgN(R1) args: 0, res: 0, upd: 0;
       c2CgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$crem_info" {
     GHC.Word.$fIntegralWord8_$crem_info:
         const GHC.Word.$fIntegralWord8_$crem_entry;
         const 0;
         const 4503603922337806;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2CgN() //  [R1]
         { []
         }
     {offset
       c2CgN: // global
           I64[Sp] = block_c2CgT_info;
           _s2v1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1i::I64;
           if (R1 & 7 != 0) goto u2Chd; else goto c2CgX;
       u2Chd: // global
           call _c2CgT(R1) args: 0, res: 0, upd: 0;
       c2CgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CgN_info" {
     block_c2CgN_info:
         const _c2CgN;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2CgT() //  [R1]
         { []
         }
     {offset
       c2CgT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ch3; else goto c2Ch2;
       c2Ch3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ch2: // global
           _s2v1l::I64 = I64[R1 + 7];
           if (_s2v1l::I64 != 0) goto c2Chb; else goto c2Chc;
       c2Chb: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v1l::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Chc: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CgT_info" {
     block_c2CgT_info:
         const _c2CgT;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.868761332 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ChB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ChF; else goto c2ChG;
       c2ChF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ChG: // global
           I64[Sp - 16] = block_c2Chy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ChY; else goto c2Chz;
       u2ChY: // global
           call _c2Chy(R1) args: 0, res: 0, upd: 0;
       c2Chz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cquotRem_info" {
     GHC.Word.$fIntegralWord8_$cquotRem_info:
         const GHC.Word.$fIntegralWord8_$cquotRem_entry;
         const 0;
         const 9007203549708302;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2Chy() //  [R1]
         { []
         }
     {offset
       c2Chy: // global
           I64[Sp] = block_c2ChE_info;
           _s2v1q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1q::I64;
           if (R1 & 7 != 0) goto u2ChX; else goto c2ChI;
       u2ChX: // global
           call _c2ChE(R1) args: 0, res: 0, upd: 0;
       c2ChI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Chy_info" {
     block_c2Chy_info:
         const _c2Chy;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2ChE() //  [R1]
         { []
         }
     {offset
       c2ChE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2ChO; else goto c2ChN;
       c2ChO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2ChN: // global
           _s2v1t::I64 = I64[R1 + 7];
           if (_s2v1t::I64 != 0) goto c2ChV; else goto c2ChW;
       c2ChV: // global
           (_s2v1v::I64, _s2v1w::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v1t::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2v1w::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2v1v::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2ChW: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ChE_info" {
     block_c2ChE_info:
         const _c2ChE;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.879680613 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2v1J_entry() //  [R1]
         { []
         }
     {offset
       c2CiB: // global
           _s2v1J::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiE; else goto c2CiF;
       c2CiF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CiH; else goto c2CiG;
       c2CiH: // global
           HpAlloc = 16;
           goto c2CiE;
       c2CiE: // global
           R1 = _s2v1J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1J::P64;
           _s2v1I::I64 = I64[_s2v1J::P64 + 16] % I64[_s2v1J::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1I::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v1J_info" {
     sat_s2v1J_info:
         const sat_s2v1J_entry;
         const 8589934592;
         const 20;
 },
 sat_s2v1H_entry() //  [R1]
         { []
         }
     {offset
       c2CiO: // global
           _s2v1H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiR; else goto c2CiS;
       c2CiS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CiU; else goto c2CiT;
       c2CiU: // global
           HpAlloc = 16;
           goto c2CiR;
       c2CiR: // global
           R1 = _s2v1H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CiT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v1H::P64;
           _s2v1G::I64 = I64[_s2v1H::P64 + 16] / I64[_s2v1H::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2v1G::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v1H_info" {
     sat_s2v1H_info:
         const sat_s2v1H_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CiV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CiW; else goto c2CiX;
       c2CiW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CiX: // global
           I64[Sp - 16] = block_c2Cij_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cj7; else goto c2Cik;
       u2Cj7: // global
           call _c2Cij(R1) args: 0, res: 0, upd: 0;
       c2Cik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cdivMod_info" {
     GHC.Word.$fIntegralWord8_$cdivMod_info:
         const GHC.Word.$fIntegralWord8_$cdivMod_entry;
         const 0;
         const 18014402804449294;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2Cij() //  [R1]
         { []
         }
     {offset
       c2Cij: // global
           I64[Sp] = block_c2Cio_info;
           _s2v1C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1C::I64;
           if (R1 & 7 != 0) goto u2Cj6; else goto c2Cip;
       u2Cj6: // global
           call _c2Cio(R1) args: 0, res: 0, upd: 0;
       c2Cip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cij_info" {
     block_c2Cij_info:
         const _c2Cij;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2Cio() //  [R1]
         { []
         }
     {offset
       c2Cio: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Cj1; else goto c2Cj0;
       c2Cj1: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cj0: // global
           _s2v1F::I64 = I64[R1 + 7];
           if (_s2v1F::I64 != 0) goto c2Cj4; else goto c2Cj5;
       c2Cj4: // global
           I64[Hp - 80] = sat_s2v1J_info;
           _s2v1C::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v1C::I64;
           I64[Hp - 56] = _s2v1F::I64;
           I64[Hp - 48] = sat_s2v1H_info;
           I64[Hp - 32] = _s2v1C::I64;
           I64[Hp - 24] = _s2v1F::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cj5: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cio_info" {
     block_c2Cio_info:
         const _c2Cio;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.892527743 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CjJ; else goto c2CjK;
       c2CjJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CjK: // global
           I64[Sp - 16] = block_c2CjC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CjT; else goto c2CjD;
       u2CjT: // global
           call _c2CjC(R1) args: 0, res: 0, upd: 0;
       c2CjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord8_info" {
     GHC.Word.gtWord8_info:
         const GHC.Word.gtWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CjC() //  [R1]
         { []
         }
     {offset
       c2CjC: // global
           I64[Sp] = block_c2CjI_info;
           _s2v1N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1N::I64;
           if (R1 & 7 != 0) goto u2CjS; else goto c2CjM;
       u2CjS: // global
           call _c2CjI(R1) args: 0, res: 0, upd: 0;
       c2CjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CjC_info" {
     block_c2CjC_info:
         const _c2CjC;
         const 1;
         const 30;
 },
 _c2CjI() //  [R1]
         { []
         }
     {offset
       c2CjI: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CjI_info" {
     block_c2CjI_info:
         const _c2CjI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.900654528 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ckm; else goto c2Ckn;
       c2Ckm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ckn: // global
           I64[Sp - 16] = block_c2Ckf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ckw; else goto c2Ckg;
       u2Ckw: // global
           call _c2Ckf(R1) args: 0, res: 0, upd: 0;
       c2Ckg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord8_info" {
     GHC.Word.geWord8_info:
         const GHC.Word.geWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Ckf() //  [R1]
         { []
         }
     {offset
       c2Ckf: // global
           I64[Sp] = block_c2Ckl_info;
           _s2v1U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v1U::I64;
           if (R1 & 7 != 0) goto u2Ckv; else goto c2Ckp;
       u2Ckv: // global
           call _c2Ckl(R1) args: 0, res: 0, upd: 0;
       c2Ckp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ckf_info" {
     block_c2Ckf_info:
         const _c2Ckf;
         const 1;
         const 30;
 },
 _c2Ckl() //  [R1]
         { []
         }
     {offset
       c2Ckl: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ckl_info" {
     block_c2Ckl_info:
         const _c2Ckl;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.908844015 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CkV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CkZ; else goto c2Cl0;
       c2CkZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cl0: // global
           I64[Sp - 16] = block_c2CkS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cl9; else goto c2CkT;
       u2Cl9: // global
           call _c2CkS(R1) args: 0, res: 0, upd: 0;
       c2CkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord8_info" {
     GHC.Word.ltWord8_info:
         const GHC.Word.ltWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CkS() //  [R1]
         { []
         }
     {offset
       c2CkS: // global
           I64[Sp] = block_c2CkY_info;
           _s2v21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v21::I64;
           if (R1 & 7 != 0) goto u2Cl8; else goto c2Cl2;
       u2Cl8: // global
           call _c2CkY(R1) args: 0, res: 0, upd: 0;
       c2Cl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CkS_info" {
     block_c2CkS_info:
         const _c2CkS;
         const 1;
         const 30;
 },
 _c2CkY() //  [R1]
         { []
         }
     {offset
       c2CkY: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CkY_info" {
     block_c2CkY_info:
         const _c2CkY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.9172041 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ClC; else goto c2ClD;
       c2ClC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ClD: // global
           I64[Sp - 16] = block_c2Clv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ClM; else goto c2Clw;
       u2ClM: // global
           call _c2Clv(R1) args: 0, res: 0, upd: 0;
       c2Clw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord8_info" {
     GHC.Word.leWord8_info:
         const GHC.Word.leWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Clv() //  [R1]
         { []
         }
     {offset
       c2Clv: // global
           I64[Sp] = block_c2ClB_info;
           _s2v28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v28::I64;
           if (R1 & 7 != 0) goto u2ClL; else goto c2ClF;
       u2ClL: // global
           call _c2ClB(R1) args: 0, res: 0, upd: 0;
       c2ClF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Clv_info" {
     block_c2Clv_info:
         const _c2Clv;
         const 1;
         const 30;
 },
 _c2ClB() //  [R1]
         { []
         }
     {offset
       c2ClB: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ClB_info" {
     block_c2ClB_info:
         const _c2ClB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.925285469 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cmf; else goto c2Cmg;
       c2Cmf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cmg: // global
           I64[Sp - 16] = block_c2Cm8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cmz; else goto c2Cm9;
       u2Cmz: // global
           call _c2Cm8(R1) args: 0, res: 0, upd: 0;
       c2Cm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$ccompare_info" {
     GHC.Word.$fOrdWord8_$ccompare_info:
         const GHC.Word.$fOrdWord8_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cm8() //  [R1]
         { []
         }
     {offset
       c2Cm8: // global
           I64[Sp] = block_c2Cme_info;
           _s2v2f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v2f::I64;
           if (R1 & 7 != 0) goto u2Cmy; else goto c2Cmi;
       u2Cmy: // global
           call _c2Cme(R1) args: 0, res: 0, upd: 0;
       c2Cmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cm8_info" {
     block_c2Cm8_info:
         const _c2Cm8;
         const 1;
         const 30;
 },
 _c2Cme() //  [R1]
         { []
         }
     {offset
       c2Cme: // global
           _s2v2f::I64 = I64[Sp + 8];
           _s2v2h::I64 = I64[R1 + 7];
           if (_s2v2f::I64 == _s2v2h::I64) goto c2Cmx; else goto c2Cmw;
       c2Cmx: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cmw: // global
           if (_s2v2f::I64 > _s2v2h::I64) goto c2Cmt; else goto c2Cmu;
       c2Cmt: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cmu: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cme_info" {
     block_c2Cme_info:
         const _c2Cme;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.934566917 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CmX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cn1; else goto c2Cn2;
       c2Cn1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cn2: // global
           I64[Sp - 16] = block_c2CmU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Cnf; else goto c2CmV;
       u2Cnf: // global
           call _c2CmU(R1) args: 0, res: 0, upd: 0;
       c2CmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$cmax_info" {
     GHC.Word.$fOrdWord8_$cmax_info:
         const GHC.Word.$fOrdWord8_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CmU() //  [R1]
         { []
         }
     {offset
       c2CmU: // global
           I64[Sp - 8] = block_c2Cn0_info;
           _s2v2m::P64 = R1;
           _s2v2n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2n::I64;
           P64[Sp + 8] = _s2v2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cne; else goto c2Cn4;
       u2Cne: // global
           call _c2Cn0(R1) args: 0, res: 0, upd: 0;
       c2Cn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CmU_info" {
     block_c2CmU_info:
         const _c2CmU;
         const 1;
         const 30;
 },
 _c2Cn0() //  [R1]
         { []
         }
     {offset
       c2Cn0: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Cnc; else goto c2Cnd;
       c2Cnc: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Cnd: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cn0_info" {
     block_c2Cn0_info:
         const _c2Cn0;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.942929043 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CnF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CnJ; else goto c2CnK;
       c2CnJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CnK: // global
           I64[Sp - 16] = block_c2CnC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CnX; else goto c2CnD;
       u2CnX: // global
           call _c2CnC(R1) args: 0, res: 0, upd: 0;
       c2CnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$cmin_info" {
     GHC.Word.$fOrdWord8_$cmin_info:
         const GHC.Word.$fOrdWord8_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CnC() //  [R1]
         { []
         }
     {offset
       c2CnC: // global
           I64[Sp - 8] = block_c2CnI_info;
           _s2v2t::P64 = R1;
           _s2v2u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v2u::I64;
           P64[Sp + 8] = _s2v2t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CnW; else goto c2CnM;
       u2CnW: // global
           call _c2CnI(R1) args: 0, res: 0, upd: 0;
       c2CnM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CnC_info" {
     block_c2CnC_info:
         const _c2CnC;
         const 1;
         const 30;
 },
 _c2CnI() //  [R1]
         { []
         }
     {offset
       c2CnI: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CnU; else goto c2CnV;
       c2CnU: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CnV: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CnI_info" {
     block_c2CnI_info:
         const _c2CnI;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.950821442 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.954564057 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Coo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cox; else goto c2Coy;
       c2Cox: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Coy: // global
           I64[Sp - 16] = block_c2Col_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CoV; else goto c2Com;
       u2CoV: // global
           call _c2Col(R1) args: 0, res: 0, upd: 0;
       c2Com: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cinRange_info" {
     GHC.Word.$fIxWord8_$cinRange_info:
         const GHC.Word.$fIxWord8_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Col() //  [R1]
         { []
         }
     {offset
       c2Col: // global
           I64[Sp - 8] = block_c2Cor_info;
           _s2v2C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CoU; else goto c2Cos;
       u2CoU: // global
           call _c2Cor(R1) args: 0, res: 0, upd: 0;
       c2Cos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Col_info" {
     block_c2Col_info:
         const _c2Col;
         const 1;
         const 30;
 },
 _c2Cor() //  [R1]
         { []
         }
     {offset
       c2Cor: // global
           I64[Sp] = block_c2Cow_info;
           _s2v2E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v2E::I64;
           if (R1 & 7 != 0) goto u2CoW; else goto c2CoB;
       u2CoW: // global
           call _c2Cow(R1) args: 0, res: 0, upd: 0;
       c2CoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cor_info" {
     block_c2Cor_info:
         const _c2Cor;
         const 2;
         const 30;
 },
 _c2Cow() //  [R1]
         { []
         }
     {offset
       c2Cow: // global
           _s2v2G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v2G::I64) goto c2CoJ; else goto c2CoN;
       c2CoJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CoN: // global
           _s2v2C::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2CoM_info;
           R1 = _s2v2C::P64;
           I64[Sp + 16] = _s2v2G::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2CoX; else goto c2CoO;
       u2CoX: // global
           call _c2CoM(R1) args: 0, res: 0, upd: 0;
       c2CoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cow_info" {
     block_c2Cow_info:
         const _c2Cow;
         const 130;
         const 30;
 },
 _c2CoM() //  [R1]
         { []
         }
     {offset
       c2CoM: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CoM_info" {
     block_c2CoM_info:
         const _c2CoM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.966629315 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2Cpv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CpM; else goto c2CpN;
       c2CpM: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CpN: // global
           I64[Sp - 8] = block_c2Cps_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CpU; else goto c2Cpt;
       u2CpU: // global
           call _c2Cps(R1) args: 0, res: 0, upd: 0;
       c2Cpt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord8_$ctoRational_info" {
     GHC.Word.$fRealWord8_$ctoRational_info:
         const GHC.Word.$fRealWord8_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S2vim_srt+728;
 },
 _c2Cps() //  [R1]
         { []
         }
     {offset
       c2Cps: // global
           I64[Sp] = block_c2CpB_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cps_info" {
     block_c2Cps_info:
         const _c2Cps;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2CpB() //  [R1]
         { []
         }
     {offset
       c2CpB: // global
           I64[Sp] = block_c2CpF_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CpB_info" {
     block_c2CpB_info:
         const _c2CpB;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2CpF() //  [R1]
         { []
         }
     {offset
       c2CpF: // global
           I64[Sp] = block_c2CpJ_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CpF_info" {
     block_c2CpF_info:
         const _c2CpF;
         const 0;
         const 12884901918;
         const S2vim_srt+736;
 },
 _c2CpJ() //  [R1, R2]
         { []
         }
     {offset
       c2CpJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2CpT; else goto c2CpS;
       c2CpT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2CpS: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CpJ_info" {
     block_c2CpJ_info:
         const _c2CpJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.976589254 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.978661376 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.982232341 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cqn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CqK; else goto c2CqL;
       c2CqK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CqL: // global
           I64[Sp - 16] = block_c2Cqk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CqS; else goto c2Cql;
       u2CqS: // global
           call _c2Cqk(R1) args: 0, res: 0, upd: 0;
       c2Cql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cunsafeIndex_info" {
     GHC.Word.$fIxWord8_$cunsafeIndex_info:
         const GHC.Word.$fIxWord8_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cqk() //  [R1]
         { []
         }
     {offset
       c2Cqk: // global
           I64[Sp] = block_c2Cqq_info;
           _s2v2X::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v2X::P64;
           if (R1 & 7 != 0) goto u2CqR; else goto c2Cqr;
       u2CqR: // global
           call _c2Cqq(R1) args: 0, res: 0, upd: 0;
       c2Cqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cqk_info" {
     block_c2Cqk_info:
         const _c2Cqk;
         const 1;
         const 30;
 },
 _c2Cqq() //  [R1]
         { []
         }
     {offset
       c2Cqq: // global
           I64[Sp] = block_c2Cqv_info;
           _s2v30::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v30::I64;
           if (R1 & 7 != 0) goto u2CqT; else goto c2Cqw;
       u2CqT: // global
           call _c2Cqv(R1) args: 0, res: 0, upd: 0;
       c2Cqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cqq_info" {
     block_c2Cqq_info:
         const _c2Cqq;
         const 1;
         const 30;
 },
 _c2Cqv() //  [R1]
         { []
         }
     {offset
       c2Cqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CqQ; else goto c2CqP;
       c2CqQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CqP: // global
           _s2v35::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v35::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cqv_info" {
     block_c2Cqv_info:
         const _c2Cqv;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.992243203 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2Crm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Crn; else goto c2Cro;
       c2Crn: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cro: // global
           I64[Sp - 8] = block_c2Crj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Crs; else goto c2Crk;
       u2Crs: // global
           call _c2Crj(R1) args: 0, res: 0, upd: 0;
       c2Crk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$crange_info" {
     GHC.Word.$fIxWord8_$crange_info:
         const GHC.Word.$fIxWord8_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+760;
 },
 _c2Crj() //  [R1]
         { []
         }
     {offset
       c2Crj: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Crj_info" {
     block_c2Crj_info:
         const _c2Crj;
         const 0;
         const 4294967326;
         const S2vim_srt+768;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:12.997528998 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.001065096 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2CrK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CrT; else goto c2CrU;
       c2CrT: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CrU: // global
           I64[Sp - 8] = block_c2CrH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Csp; else goto c2CrI;
       u2Csp: // global
           call _c2CrH(R1) args: 0, res: 0, upd: 0;
       c2CrI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$crangeSize_info" {
     GHC.Word.$fIxWord8_$crangeSize_info:
         const GHC.Word.$fIxWord8_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CrH() //  [R1]
         { []
         }
     {offset
       c2CrH: // global
           I64[Sp - 8] = block_c2CrN_info;
           _s2v3d::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cso; else goto c2CrO;
       u2Cso: // global
           call _c2CrN(R1) args: 0, res: 0, upd: 0;
       c2CrO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CrH_info" {
     block_c2CrH_info:
         const _c2CrH;
         const 0;
         const 30;
 },
 _c2CrN() //  [R1]
         { []
         }
     {offset
       c2CrN: // global
           I64[Sp] = block_c2CrS_info;
           _s2v3f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3f::I64;
           if (R1 & 7 != 0) goto u2Csq; else goto c2CrX;
       u2Csq: // global
           call _c2CrS(R1) args: 0, res: 0, upd: 0;
       c2CrX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CrN_info" {
     block_c2CrN_info:
         const _c2CrN;
         const 1;
         const 30;
 },
 _c2CrS() //  [R1]
         { []
         }
     {offset
       c2CrS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cs3; else goto c2Cs2;
       c2Cs3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cs2: // global
           _s2v3f::I64 = I64[Sp + 8];
           _s2v3h::I64 = I64[R1 + 7];
           if (_s2v3f::I64 > _s2v3h::I64) goto c2Cs7; else goto c2Csn;
       c2Cs7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Csn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3h::I64 - _s2v3f::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CrS_info" {
     block_c2CrS_info:
         const _c2CrS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.011704131 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2CsV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ctl; else goto c2Ctm;
       c2Ctl: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ctm: // global
           I64[Sp - 8] = block_c2CsS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ctt; else goto c2CsT;
       u2Ctt: // global
           call _c2CsS(R1) args: 0, res: 0, upd: 0;
       c2CsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CsS() //  [R1]
         { []
         }
     {offset
       c2CsS: // global
           I64[Sp - 8] = block_c2CsY_info;
           _s2v3p::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v3p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cts; else goto c2CsZ;
       u2Cts: // global
           call _c2CsY(R1) args: 0, res: 0, upd: 0;
       c2CsZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CsS_info" {
     block_c2CsS_info:
         const _c2CsS;
         const 0;
         const 30;
 },
 _c2CsY() //  [R1]
         { []
         }
     {offset
       c2CsY: // global
           I64[Sp] = block_c2Ct3_info;
           _s2v3s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3s::I64;
           if (R1 & 7 != 0) goto u2Ctu; else goto c2Ct4;
       u2Ctu: // global
           call _c2Ct3(R1) args: 0, res: 0, upd: 0;
       c2Ct4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CsY_info" {
     block_c2CsY_info:
         const _c2CsY;
         const 1;
         const 30;
 },
 _c2Ct3() //  [R1]
         { []
         }
     {offset
       c2Ct3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ctr; else goto c2Ctq;
       c2Ctr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ctq: // global
           _s2v3y::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v3y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ct3_info" {
     block_c2Ct3_info:
         const _c2Ct3;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.023519178 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CtY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cu7; else goto c2Cu8;
       c2Cu7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cu8: // global
           I64[Sp - 16] = block_c2CtV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CuN; else goto c2CtW;
       u2CuN: // global
           call _c2CtV(R1) args: 0, res: 0, upd: 0;
       c2CtW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cindex_info" {
     GHC.Word.$fIxWord8_$cindex_info:
         const GHC.Word.$fIxWord8_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+776;
 },
 _c2CtV() //  [R1]
         { []
         }
     {offset
       c2CtV: // global
           I64[Sp - 8] = block_c2Cu1_info;
           _s2v3D::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v3D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CuM; else goto c2Cu2;
       u2CuM: // global
           call _c2Cu1(R1) args: 0, res: 0, upd: 0;
       c2Cu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CtV_info" {
     block_c2CtV_info:
         const _c2CtV;
         const 1;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Cu1() //  [R1]
         { []
         }
     {offset
       c2Cu1: // global
           I64[Sp] = block_c2Cu6_info;
           _s2v3F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v3F::I64;
           if (R1 & 7 != 0) goto u2CuO; else goto c2Cub;
       u2CuO: // global
           call _c2Cu6(R1) args: 0, res: 0, upd: 0;
       c2Cub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cu1_info" {
     block_c2Cu1_info:
         const _c2Cu1;
         const 2;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Cu6() //  [R1]
         { []
         }
     {offset
       c2Cu6: // global
           _s2v3H::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v3H::I64) goto c2Cuj; else goto c2Cun;
       c2Cuj: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Cun: // global
           I64[Sp] = block_c2Cum_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3H::I64;
           if (R1 & 7 != 0) goto u2CuP; else goto c2Cuo;
       u2CuP: // global
           call _c2Cum(R1) args: 0, res: 0, upd: 0;
       c2Cuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cu6_info" {
     block_c2Cu6_info:
         const _c2Cu6;
         const 130;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Cum() //  [R1]
         { []
         }
     {offset
       c2Cum: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cuu; else goto c2Cut;
       c2Cuu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cut: // global
           _s2v3H::I64 = I64[Sp + 8];
           if (_s2v3H::I64 > I64[R1 + 7]) goto c2Cuy; else goto c2CuL;
       c2Cuy: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CuL: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2v3H::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cum_info" {
     block_c2Cum_info:
         const _c2Cum;
         const 194;
         const 4294967326;
         const S2vim_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.034639746 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.038075159 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cvt; else goto c2Cvu;
       c2Cvt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cvu: // global
           I64[Sp - 16] = block_c2Cvm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CvD; else goto c2Cvn;
       u2CvD: // global
           call _c2Cvm(R1) args: 0, res: 0, upd: 0;
       c2Cvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord16_info" {
     GHC.Word.eqWord16_info:
         const GHC.Word.eqWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cvm() //  [R1]
         { []
         }
     {offset
       c2Cvm: // global
           I64[Sp] = block_c2Cvs_info;
           _s2v3S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v3S::I64;
           if (R1 & 7 != 0) goto u2CvC; else goto c2Cvw;
       u2CvC: // global
           call _c2Cvs(R1) args: 0, res: 0, upd: 0;
       c2Cvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cvm_info" {
     block_c2Cvm_info:
         const _c2Cvm;
         const 1;
         const 30;
 },
 _c2Cvs() //  [R1]
         { []
         }
     {offset
       c2Cvs: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cvs_info" {
     block_c2Cvs_info:
         const _c2Cvs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.044617748 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.0463919 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.049771245 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2Cw4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Cw5; else goto c2Cw6;
       c2Cw5: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cw6: // global
           I64[Sp - 8] = block_c2Cw1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Cwe; else goto c2Cw2;
       u2Cwe: // global
           call _c2Cw1(R1) args: 0, res: 0, upd: 0;
       c2Cw2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$csignum_info" {
     GHC.Word.$fNumWord16_$csignum_info:
         const GHC.Word.$fNumWord16_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Cw1() //  [R1]
         { []
         }
     {offset
       c2Cw1: // global
           if (I64[R1 + 7] == 0) goto c2Cwd; else goto c2Cwc;
       c2Cwd: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cwc: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cw1_info" {
     block_c2Cw1_info:
         const _c2Cw1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.054801326 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.057666368 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2Cwy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CwF; else goto c2CwG;
       c2CwF: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CwG: // global
           I64[Sp - 8] = block_c2Cwv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CwK; else goto c2Cww;
       u2CwK: // global
           call _c2Cwv(R1) args: 0, res: 0, upd: 0;
       c2Cww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ccomplement_info" {
     GHC.Word.$fBitsWord16_$ccomplement_info:
         const GHC.Word.$fBitsWord16_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Cwv() //  [R1]
         { []
         }
     {offset
       c2Cwv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CwJ; else goto c2CwI;
       c2CwJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CwI: // global
           _s2v43::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v43::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cwv_info" {
     block_c2Cwv_info:
         const _c2Cwv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.063526412 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.06572618 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2Cx1: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.070351281 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2Cxg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Cxh; else goto c2Cxi;
       c2Cxh: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Cxi: // global
           I64[Sp - 8] = block_c2Cxd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CxB; else goto c2Cxe;
       u2CxB: // global
           call _c2Cxd(R1) args: 0, res: 0, upd: 0;
       c2Cxe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cbit_info" {
     GHC.Word.$fBitsWord16_$cbit_info:
         const GHC.Word.$fBitsWord16_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Cxd() //  [R1]
         { []
         }
     {offset
       c2Cxd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Cxn; else goto c2Cxm;
       c2Cxn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Cxm: // global
           _s2v47::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v47::I64, 64)) goto c2Cxz; else goto c2CxA;
       c2Cxz: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v47::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CxA: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cxd_info" {
     block_c2Cxd_info:
         const _c2Cxd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.077404895 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Cy1; else goto c2Cy2;
       c2Cy1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cy2: // global
           I64[Sp - 16] = block_c2CxU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CyB; else goto c2CxV;
       u2CyB: // global
           call _c2CxU(R1) args: 0, res: 0, upd: 0;
       c2CxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ctestBit_info" {
     GHC.Word.$fBitsWord16_$ctestBit_info:
         const GHC.Word.$fBitsWord16_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CxU() //  [R1]
         { []
         }
     {offset
       c2CxU: // global
           I64[Sp] = block_c2Cy0_info;
           _s2v4e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4e::I64;
           if (R1 & 7 != 0) goto u2CyA; else goto c2Cy4;
       u2CyA: // global
           call _c2Cy0(R1) args: 0, res: 0, upd: 0;
       c2Cy4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CxU_info" {
     block_c2CxU_info:
         const _c2CxU;
         const 1;
         const 30;
 },
 _c2Cy0() //  [R1]
         { []
         }
     {offset
       c2Cy0: // global
           _s2v4g::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v4g::I64, 64)) goto c2Cyz; else goto c2Cyy;
       c2Cyy: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4g::I64)) == 0) goto c2Cyz; else goto c2Cyn;
       c2Cyz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Cyn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cy0_info" {
     block_c2Cy0_info:
         const _c2Cy0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.087072154 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Cz3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Cz7; else goto c2Cz8;
       c2Cz7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Cz8: // global
           I64[Sp - 16] = block_c2Cz0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CzY; else goto c2Cz1;
       u2CzY: // global
           call _c2Cz0(R1) args: 0, res: 0, upd: 0;
       c2Cz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotateR_info" {
     GHC.Word.$fBitsWord16_$crotateR_info:
         const GHC.Word.$fBitsWord16_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Cz0() //  [R1]
         { []
         }
     {offset
       c2Cz0: // global
           I64[Sp - 8] = block_c2Cz6_info;
           _s2v4n::P64 = R1;
           _s2v4o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4o::I64;
           P64[Sp + 8] = _s2v4n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CzX; else goto c2Cza;
       u2CzX: // global
           call _c2Cz6(R1) args: 0, res: 0, upd: 0;
       c2Cza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cz0_info" {
     block_c2Cz0_info:
         const _c2Cz0;
         const 1;
         const 30;
 },
 _c2Cz6() //  [R1]
         { []
         }
     {offset
       c2Cz6: // global
           _s2v4u::I64 = -I64[R1 + 7] & 15;
           if (_s2v4u::I64 != 0) goto u2CzV; else goto c2CzR;
       u2CzV: // global
           I64[Sp + 16] = _s2v4u::I64;
           Sp = Sp + 8;
           call _c2Czs() args: 0, res: 0, upd: 0;
       c2CzR: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Cz6_info" {
     block_c2Cz6_info:
         const _c2Cz6;
         const 66;
         const 30;
 },
 _c2Czs() //  []
         { []
         }
     {offset
       c2Czs: // global
           Hp = Hp + 16;
           _s2v4u::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2CzO; else goto c2CzN;
       c2CzO: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Czr_info;
           R1 = _s2v4u::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2CzN: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2v4o::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2v4o::I64 << _s2v4u::I64) | (_s2v4o::I64 >> 16 - _s2v4u::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Czr() //  [R1]
         { []
         }
     {offset
       c2Czr: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Czs() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2Czr_info" {
     block_c2Czr_info:
         const _c2Czr;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.097844601 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CAx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotateL_info" {
     GHC.Word.$fBitsWord16_$crotateL_info:
         const GHC.Word.$fBitsWord16_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.102649733 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CAL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CAP; else goto c2CAQ;
       c2CAP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CAQ: // global
           I64[Sp - 16] = block_c2CAI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CBg; else goto c2CAJ;
       u2CBg: // global
           call _c2CAI(R1) args: 0, res: 0, upd: 0;
       c2CAJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ccomplementBit_info" {
     GHC.Word.$fBitsWord16_$ccomplementBit_info:
         const GHC.Word.$fBitsWord16_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CAI() //  [R1]
         { []
         }
     {offset
       c2CAI: // global
           I64[Sp - 8] = block_c2CAO_info;
           _s2v4C::P64 = R1;
           _s2v4D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4D::I64;
           P64[Sp + 8] = _s2v4C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CBf; else goto c2CAS;
       u2CBf: // global
           call _c2CAO(R1) args: 0, res: 0, upd: 0;
       c2CAS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CAI_info" {
     block_c2CAI_info:
         const _c2CAI;
         const 1;
         const 30;
 },
 _c2CAO() //  [R1]
         { []
         }
     {offset
       c2CAO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CAY; else goto c2CAX;
       c2CAY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CAX: // global
           _s2v4F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4F::I64, 64)) goto c2CBd; else goto c2CBe;
       c2CBd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CBe: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CAO_info" {
     block_c2CAO_info:
         const _c2CAO;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.11208978 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CBJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CBN; else goto c2CBO;
       c2CBN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CBO: // global
           I64[Sp - 16] = block_c2CBG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CCm; else goto c2CBH;
       u2CCm: // global
           call _c2CBG(R1) args: 0, res: 0, upd: 0;
       c2CBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cclearBit_info" {
     GHC.Word.$fBitsWord16_$cclearBit_info:
         const GHC.Word.$fBitsWord16_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CBG() //  [R1]
         { []
         }
     {offset
       c2CBG: // global
           I64[Sp] = block_c2CBM_info;
           _s2v4N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v4N::I64;
           if (R1 & 7 != 0) goto u2CCl; else goto c2CBQ;
       u2CCl: // global
           call _c2CBM(R1) args: 0, res: 0, upd: 0;
       c2CBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CBG_info" {
     block_c2CBG_info:
         const _c2CBG;
         const 1;
         const 30;
 },
 _c2CBM() //  [R1]
         { []
         }
     {offset
       c2CBM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CBW; else goto c2CBV;
       c2CBW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CBV: // global
           _s2v4N::I64 = I64[Sp + 8];
           _s2v4P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v4P::I64, 64)) goto c2CCe; else goto c2CCk;
       c2CCe: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v4P::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CCk: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v4N::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CBM_info" {
     block_c2CBM_info:
         const _c2CBM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.121109696 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CCR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CCV; else goto c2CCW;
       c2CCV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CCW: // global
           I64[Sp - 16] = block_c2CCO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CDm; else goto c2CCP;
       u2CDm: // global
           call _c2CCO(R1) args: 0, res: 0, upd: 0;
       c2CCP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$csetBit_info" {
     GHC.Word.$fBitsWord16_$csetBit_info:
         const GHC.Word.$fBitsWord16_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CCO() //  [R1]
         { []
         }
     {offset
       c2CCO: // global
           I64[Sp - 8] = block_c2CCU_info;
           _s2v4Y::P64 = R1;
           _s2v4Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v4Z::I64;
           P64[Sp + 8] = _s2v4Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CDl; else goto c2CCY;
       u2CDl: // global
           call _c2CCU(R1) args: 0, res: 0, upd: 0;
       c2CCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CCO_info" {
     block_c2CCO_info:
         const _c2CCO;
         const 1;
         const 30;
 },
 _c2CCU() //  [R1]
         { []
         }
     {offset
       c2CCU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CD4; else goto c2CD3;
       c2CD4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CD3: // global
           _s2v51::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v51::I64, 64)) goto c2CDj; else goto c2CDk;
       c2CDj: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2v51::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CDk: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CCU_info" {
     block_c2CCU_info:
         const _c2CCU;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.129071543 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.13126337 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.134815198 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CDR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CDV; else goto c2CDW;
       c2CDV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CDW: // global
           I64[Sp - 16] = block_c2CDO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CEf; else goto c2CDP;
       u2CEf: // global
           call _c2CDO(R1) args: 0, res: 0, upd: 0;
       c2CDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cquot_info" {
     GHC.Word.$fIntegralWord16_$cquot_info:
         const GHC.Word.$fIntegralWord16_$cquot_entry;
         const 0;
         const 9223372041149743118;
         const 8589934607;
         const S2vim_srt+544;
 },
 _c2CDO() //  [R1]
         { []
         }
     {offset
       c2CDO: // global
           I64[Sp] = block_c2CDU_info;
           _s2v59::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v59::I64;
           if (R1 & 7 != 0) goto u2CEe; else goto c2CDY;
       u2CEe: // global
           call _c2CDU(R1) args: 0, res: 0, upd: 0;
       c2CDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CDO_info" {
     block_c2CDO_info:
         const _c2CDO;
         const 1;
         const 4294967326;
         const S2vim_srt+544;
 },
 _c2CDU() //  [R1]
         { []
         }
     {offset
       c2CDU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CE4; else goto c2CE3;
       c2CE4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CE3: // global
           _s2v5c::I64 = I64[R1 + 7];
           if (_s2v5c::I64 != 0) goto c2CEc; else goto c2CEd;
       c2CEc: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v5c::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CEd: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CDU_info" {
     block_c2CDU_info:
         const _c2CDU;
         const 65;
         const 4294967326;
         const S2vim_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.144211427 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CEC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CEG; else goto c2CEH;
       c2CEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CEH: // global
           I64[Sp - 16] = block_c2CEz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CF0; else goto c2CEA;
       u2CF0: // global
           call _c2CEz(R1) args: 0, res: 0, upd: 0;
       c2CEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$crem_info" {
     GHC.Word.$fIntegralWord16_$crem_info:
         const GHC.Word.$fIntegralWord16_$crem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+800;
 },
 _c2CEz() //  [R1]
         { []
         }
     {offset
       c2CEz: // global
           I64[Sp] = block_c2CEF_info;
           _s2v5h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5h::I64;
           if (R1 & 7 != 0) goto u2CEZ; else goto c2CEJ;
       u2CEZ: // global
           call _c2CEF(R1) args: 0, res: 0, upd: 0;
       c2CEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CEz_info" {
     block_c2CEz_info:
         const _c2CEz;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2CEF() //  [R1]
         { []
         }
     {offset
       c2CEF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CEP; else goto c2CEO;
       c2CEP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CEO: // global
           _s2v5k::I64 = I64[R1 + 7];
           if (_s2v5k::I64 != 0) goto c2CEX; else goto c2CEY;
       c2CEX: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v5k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CEY: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CEF_info" {
     block_c2CEF_info:
         const _c2CEF;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.154103945 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CFn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CFr; else goto c2CFs;
       c2CFr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CFs: // global
           I64[Sp - 16] = block_c2CFk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CFK; else goto c2CFl;
       u2CFK: // global
           call _c2CFk(R1) args: 0, res: 0, upd: 0;
       c2CFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cquotRem_info" {
     GHC.Word.$fIntegralWord16_$cquotRem_info:
         const GHC.Word.$fIntegralWord16_$cquotRem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2CFk() //  [R1]
         { []
         }
     {offset
       c2CFk: // global
           I64[Sp] = block_c2CFq_info;
           _s2v5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5p::I64;
           if (R1 & 7 != 0) goto u2CFJ; else goto c2CFu;
       u2CFJ: // global
           call _c2CFq(R1) args: 0, res: 0, upd: 0;
       c2CFu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CFk_info" {
     block_c2CFk_info:
         const _c2CFk;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2CFq() //  [R1]
         { []
         }
     {offset
       c2CFq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2CFA; else goto c2CFz;
       c2CFA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CFz: // global
           _s2v5s::I64 = I64[R1 + 7];
           if (_s2v5s::I64 != 0) goto c2CFH; else goto c2CFI;
       c2CFH: // global
           (_s2v5u::I64, _s2v5v::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v5s::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2v5v::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2v5u::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CFI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CFq_info" {
     block_c2CFq_info:
         const _c2CFq;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.163998488 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2v5I_entry() //  [R1]
         { []
         }
     {offset
       c2CGn: // global
           _s2v5I::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGq; else goto c2CGr;
       c2CGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CGt; else goto c2CGs;
       c2CGt: // global
           HpAlloc = 16;
           goto c2CGq;
       c2CGq: // global
           R1 = _s2v5I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CGs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5I::P64;
           _s2v5H::I64 = I64[_s2v5I::P64 + 16] % I64[_s2v5I::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5H::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v5I_info" {
     sat_s2v5I_info:
         const sat_s2v5I_entry;
         const 8589934592;
         const 20;
 },
 sat_s2v5G_entry() //  [R1]
         { []
         }
     {offset
       c2CGA: // global
           _s2v5G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGD; else goto c2CGE;
       c2CGE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CGG; else goto c2CGF;
       c2CGG: // global
           HpAlloc = 16;
           goto c2CGD;
       c2CGD: // global
           R1 = _s2v5G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2CGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v5G::P64;
           _s2v5F::I64 = I64[_s2v5G::P64 + 16] / I64[_s2v5G::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2v5F::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v5G_info" {
     sat_s2v5G_info:
         const sat_s2v5G_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CGH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CGI; else goto c2CGJ;
       c2CGI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CGJ: // global
           I64[Sp - 16] = block_c2CG5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CGT; else goto c2CG6;
       u2CGT: // global
           call _c2CG5(R1) args: 0, res: 0, upd: 0;
       c2CG6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cdivMod_info" {
     GHC.Word.$fIntegralWord16_$cdivMod_info:
         const GHC.Word.$fIntegralWord16_$cdivMod_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2CG5() //  [R1]
         { []
         }
     {offset
       c2CG5: // global
           I64[Sp] = block_c2CGa_info;
           _s2v5B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5B::I64;
           if (R1 & 7 != 0) goto u2CGS; else goto c2CGb;
       u2CGS: // global
           call _c2CGa(R1) args: 0, res: 0, upd: 0;
       c2CGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CG5_info" {
     block_c2CG5_info:
         const _c2CG5;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2CGa() //  [R1]
         { []
         }
     {offset
       c2CGa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2CGN; else goto c2CGM;
       c2CGN: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CGM: // global
           _s2v5E::I64 = I64[R1 + 7];
           if (_s2v5E::I64 != 0) goto c2CGQ; else goto c2CGR;
       c2CGQ: // global
           I64[Hp - 80] = sat_s2v5I_info;
           _s2v5B::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v5B::I64;
           I64[Hp - 56] = _s2v5E::I64;
           I64[Hp - 48] = sat_s2v5G_info;
           I64[Hp - 32] = _s2v5B::I64;
           I64[Hp - 24] = _s2v5E::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CGR: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CGa_info" {
     block_c2CGa_info:
         const _c2CGa;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.176506148 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CHv; else goto c2CHw;
       c2CHv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CHw: // global
           I64[Sp - 16] = block_c2CHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CHF; else goto c2CHp;
       u2CHF: // global
           call _c2CHo(R1) args: 0, res: 0, upd: 0;
       c2CHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord16_info" {
     GHC.Word.gtWord16_info:
         const GHC.Word.gtWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CHo() //  [R1]
         { []
         }
     {offset
       c2CHo: // global
           I64[Sp] = block_c2CHu_info;
           _s2v5M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5M::I64;
           if (R1 & 7 != 0) goto u2CHE; else goto c2CHy;
       u2CHE: // global
           call _c2CHu(R1) args: 0, res: 0, upd: 0;
       c2CHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CHo_info" {
     block_c2CHo_info:
         const _c2CHo;
         const 1;
         const 30;
 },
 _c2CHu() //  [R1]
         { []
         }
     {offset
       c2CHu: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CHu_info" {
     block_c2CHu_info:
         const _c2CHu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.184943792 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CI8; else goto c2CI9;
       c2CI8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CI9: // global
           I64[Sp - 16] = block_c2CI1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CIi; else goto c2CI2;
       u2CIi: // global
           call _c2CI1(R1) args: 0, res: 0, upd: 0;
       c2CI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord16_info" {
     GHC.Word.geWord16_info:
         const GHC.Word.geWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CI1() //  [R1]
         { []
         }
     {offset
       c2CI1: // global
           I64[Sp] = block_c2CI7_info;
           _s2v5T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v5T::I64;
           if (R1 & 7 != 0) goto u2CIh; else goto c2CIb;
       u2CIh: // global
           call _c2CI7(R1) args: 0, res: 0, upd: 0;
       c2CIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CI1_info" {
     block_c2CI1_info:
         const _c2CI1;
         const 1;
         const 30;
 },
 _c2CI7() //  [R1]
         { []
         }
     {offset
       c2CI7: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CI7_info" {
     block_c2CI7_info:
         const _c2CI7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.192677268 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CIH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CIL; else goto c2CIM;
       c2CIL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CIM: // global
           I64[Sp - 16] = block_c2CIE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CIV; else goto c2CIF;
       u2CIV: // global
           call _c2CIE(R1) args: 0, res: 0, upd: 0;
       c2CIF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord16_info" {
     GHC.Word.ltWord16_info:
         const GHC.Word.ltWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CIE() //  [R1]
         { []
         }
     {offset
       c2CIE: // global
           I64[Sp] = block_c2CIK_info;
           _s2v60::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v60::I64;
           if (R1 & 7 != 0) goto u2CIU; else goto c2CIO;
       u2CIU: // global
           call _c2CIK(R1) args: 0, res: 0, upd: 0;
       c2CIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CIE_info" {
     block_c2CIE_info:
         const _c2CIE;
         const 1;
         const 30;
 },
 _c2CIK() //  [R1]
         { []
         }
     {offset
       c2CIK: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CIK_info" {
     block_c2CIK_info:
         const _c2CIK;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.200903814 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CJk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CJo; else goto c2CJp;
       c2CJo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CJp: // global
           I64[Sp - 16] = block_c2CJh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CJy; else goto c2CJi;
       u2CJy: // global
           call _c2CJh(R1) args: 0, res: 0, upd: 0;
       c2CJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord16_info" {
     GHC.Word.leWord16_info:
         const GHC.Word.leWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CJh() //  [R1]
         { []
         }
     {offset
       c2CJh: // global
           I64[Sp] = block_c2CJn_info;
           _s2v67::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v67::I64;
           if (R1 & 7 != 0) goto u2CJx; else goto c2CJr;
       u2CJx: // global
           call _c2CJn(R1) args: 0, res: 0, upd: 0;
       c2CJr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CJh_info" {
     block_c2CJh_info:
         const _c2CJh;
         const 1;
         const 30;
 },
 _c2CJn() //  [R1]
         { []
         }
     {offset
       c2CJn: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CJn_info" {
     block_c2CJn_info:
         const _c2CJn;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.208728518 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CJX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CK1; else goto c2CK2;
       c2CK1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CK2: // global
           I64[Sp - 16] = block_c2CJU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CKl; else goto c2CJV;
       u2CKl: // global
           call _c2CJU(R1) args: 0, res: 0, upd: 0;
       c2CJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$ccompare_info" {
     GHC.Word.$fOrdWord16_$ccompare_info:
         const GHC.Word.$fOrdWord16_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CJU() //  [R1]
         { []
         }
     {offset
       c2CJU: // global
           I64[Sp] = block_c2CK0_info;
           _s2v6e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6e::I64;
           if (R1 & 7 != 0) goto u2CKk; else goto c2CK4;
       u2CKk: // global
           call _c2CK0(R1) args: 0, res: 0, upd: 0;
       c2CK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CJU_info" {
     block_c2CJU_info:
         const _c2CJU;
         const 1;
         const 30;
 },
 _c2CK0() //  [R1]
         { []
         }
     {offset
       c2CK0: // global
           _s2v6e::I64 = I64[Sp + 8];
           _s2v6g::I64 = I64[R1 + 7];
           if (_s2v6e::I64 == _s2v6g::I64) goto c2CKj; else goto c2CKi;
       c2CKj: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CKi: // global
           if (_s2v6e::I64 > _s2v6g::I64) goto c2CKf; else goto c2CKg;
       c2CKf: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CKg: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CK0_info" {
     block_c2CK0_info:
         const _c2CK0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.21745569 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CKJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CKN; else goto c2CKO;
       c2CKN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CKO: // global
           I64[Sp - 16] = block_c2CKG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CL1; else goto c2CKH;
       u2CL1: // global
           call _c2CKG(R1) args: 0, res: 0, upd: 0;
       c2CKH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$cmax_info" {
     GHC.Word.$fOrdWord16_$cmax_info:
         const GHC.Word.$fOrdWord16_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CKG() //  [R1]
         { []
         }
     {offset
       c2CKG: // global
           I64[Sp - 8] = block_c2CKM_info;
           _s2v6l::P64 = R1;
           _s2v6m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6m::I64;
           P64[Sp + 8] = _s2v6l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CL0; else goto c2CKQ;
       u2CL0: // global
           call _c2CKM(R1) args: 0, res: 0, upd: 0;
       c2CKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CKG_info" {
     block_c2CKG_info:
         const _c2CKG;
         const 1;
         const 30;
 },
 _c2CKM() //  [R1]
         { []
         }
     {offset
       c2CKM: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CKY; else goto c2CKZ;
       c2CKY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CKZ: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CKM_info" {
     block_c2CKM_info:
         const _c2CKM;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.225630252 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CLr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CLv; else goto c2CLw;
       c2CLv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CLw: // global
           I64[Sp - 16] = block_c2CLo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CLJ; else goto c2CLp;
       u2CLJ: // global
           call _c2CLo(R1) args: 0, res: 0, upd: 0;
       c2CLp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$cmin_info" {
     GHC.Word.$fOrdWord16_$cmin_info:
         const GHC.Word.$fOrdWord16_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CLo() //  [R1]
         { []
         }
     {offset
       c2CLo: // global
           I64[Sp - 8] = block_c2CLu_info;
           _s2v6s::P64 = R1;
           _s2v6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v6t::I64;
           P64[Sp + 8] = _s2v6s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CLI; else goto c2CLy;
       u2CLI: // global
           call _c2CLu(R1) args: 0, res: 0, upd: 0;
       c2CLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CLo_info" {
     block_c2CLo_info:
         const _c2CLo;
         const 1;
         const 30;
 },
 _c2CLu() //  [R1]
         { []
         }
     {offset
       c2CLu: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2CLG; else goto c2CLH;
       c2CLG: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CLH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CLu_info" {
     block_c2CLu_info:
         const _c2CLu;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.232980297 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.237201229 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CMa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CMj; else goto c2CMk;
       c2CMj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CMk: // global
           I64[Sp - 16] = block_c2CM7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CMH; else goto c2CM8;
       u2CMH: // global
           call _c2CM7(R1) args: 0, res: 0, upd: 0;
       c2CM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cinRange_info" {
     GHC.Word.$fIxWord16_$cinRange_info:
         const GHC.Word.$fIxWord16_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CM7() //  [R1]
         { []
         }
     {offset
       c2CM7: // global
           I64[Sp - 8] = block_c2CMd_info;
           _s2v6B::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v6B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CMG; else goto c2CMe;
       u2CMG: // global
           call _c2CMd(R1) args: 0, res: 0, upd: 0;
       c2CMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CM7_info" {
     block_c2CM7_info:
         const _c2CM7;
         const 1;
         const 30;
 },
 _c2CMd() //  [R1]
         { []
         }
     {offset
       c2CMd: // global
           I64[Sp] = block_c2CMi_info;
           _s2v6D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v6D::I64;
           if (R1 & 7 != 0) goto u2CMI; else goto c2CMn;
       u2CMI: // global
           call _c2CMi(R1) args: 0, res: 0, upd: 0;
       c2CMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CMd_info" {
     block_c2CMd_info:
         const _c2CMd;
         const 2;
         const 30;
 },
 _c2CMi() //  [R1]
         { []
         }
     {offset
       c2CMi: // global
           _s2v6F::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v6F::I64) goto c2CMv; else goto c2CMz;
       c2CMv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CMz: // global
           _s2v6B::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2CMy_info;
           R1 = _s2v6B::P64;
           I64[Sp + 16] = _s2v6F::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2CMJ; else goto c2CMA;
       u2CMJ: // global
           call _c2CMy(R1) args: 0, res: 0, upd: 0;
       c2CMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CMi_info" {
     block_c2CMi_info:
         const _c2CMi;
         const 130;
         const 30;
 },
 _c2CMy() //  [R1]
         { []
         }
     {offset
       c2CMy: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CMy_info" {
     block_c2CMy_info:
         const _c2CMy;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.249339002 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2CNh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CNy; else goto c2CNz;
       c2CNy: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CNz: // global
           I64[Sp - 8] = block_c2CNe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CNG; else goto c2CNf;
       u2CNG: // global
           call _c2CNe(R1) args: 0, res: 0, upd: 0;
       c2CNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord16_$ctoRational_info" {
     GHC.Word.$fRealWord16_$ctoRational_info:
         const GHC.Word.$fRealWord16_$ctoRational_entry;
         const 0;
         const 17622250815502;
         const 4294967301;
         const S2vim_srt+736;
 },
 _c2CNe() //  [R1]
         { []
         }
     {offset
       c2CNe: // global
           I64[Sp] = block_c2CNn_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CNe_info" {
     block_c2CNe_info:
         const _c2CNe;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2CNn() //  [R1]
         { []
         }
     {offset
       c2CNn: // global
           I64[Sp] = block_c2CNr_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CNn_info" {
     block_c2CNn_info:
         const _c2CNn;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2CNr() //  [R1]
         { []
         }
     {offset
       c2CNr: // global
           I64[Sp] = block_c2CNv_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CNr_info" {
     block_c2CNr_info:
         const _c2CNr;
         const 0;
         const 12884901918;
         const S2vim_srt+736;
 },
 _c2CNv() //  [R1, R2]
         { []
         }
     {offset
       c2CNv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2CNF; else goto c2CNE;
       c2CNF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2CNE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CNv_info" {
     block_c2CNv_info:
         const _c2CNv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.260338021 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.262221449 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.265717486 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CO9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2COw; else goto c2COx;
       c2COw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2COx: // global
           I64[Sp - 16] = block_c2CO6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2COE; else goto c2CO7;
       u2COE: // global
           call _c2CO6(R1) args: 0, res: 0, upd: 0;
       c2CO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cunsafeIndex_info" {
     GHC.Word.$fIxWord16_$cunsafeIndex_info:
         const GHC.Word.$fIxWord16_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CO6() //  [R1]
         { []
         }
     {offset
       c2CO6: // global
           I64[Sp] = block_c2COc_info;
           _s2v6W::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2v6W::P64;
           if (R1 & 7 != 0) goto u2COD; else goto c2COd;
       u2COD: // global
           call _c2COc(R1) args: 0, res: 0, upd: 0;
       c2COd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CO6_info" {
     block_c2CO6_info:
         const _c2CO6;
         const 1;
         const 30;
 },
 _c2COc() //  [R1]
         { []
         }
     {offset
       c2COc: // global
           I64[Sp] = block_c2COh_info;
           _s2v6Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v6Z::I64;
           if (R1 & 7 != 0) goto u2COF; else goto c2COi;
       u2COF: // global
           call _c2COh(R1) args: 0, res: 0, upd: 0;
       c2COi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2COc_info" {
     block_c2COc_info:
         const _c2COc;
         const 1;
         const 30;
 },
 _c2COh() //  [R1]
         { []
         }
     {offset
       c2COh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2COC; else goto c2COB;
       c2COC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2COB: // global
           _s2v74::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v74::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2COh_info" {
     block_c2COh_info:
         const _c2COh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.27541716 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2CP8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CP9; else goto c2CPa;
       c2CP9: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CPa: // global
           I64[Sp - 8] = block_c2CP5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CPe; else goto c2CP6;
       u2CPe: // global
           call _c2CP5(R1) args: 0, res: 0, upd: 0;
       c2CP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$crange_info" {
     GHC.Word.$fIxWord16_$crange_info:
         const GHC.Word.$fIxWord16_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+840;
 },
 _c2CP5() //  [R1]
         { []
         }
     {offset
       c2CP5: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CP5_info" {
     block_c2CP5_info:
         const _c2CP5;
         const 0;
         const 4294967326;
         const S2vim_srt+848;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.282328342 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2CPv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CPE; else goto c2CPF;
       c2CPE: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CPF: // global
           I64[Sp - 8] = block_c2CPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CQa; else goto c2CPt;
       u2CQa: // global
           call _c2CPs(R1) args: 0, res: 0, upd: 0;
       c2CPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$crangeSize_info" {
     GHC.Word.$fIxWord16_$crangeSize_info:
         const GHC.Word.$fIxWord16_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CPs() //  [R1]
         { []
         }
     {offset
       c2CPs: // global
           I64[Sp - 8] = block_c2CPy_info;
           _s2v7c::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7c::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CQ9; else goto c2CPz;
       u2CQ9: // global
           call _c2CPy(R1) args: 0, res: 0, upd: 0;
       c2CPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CPs_info" {
     block_c2CPs_info:
         const _c2CPs;
         const 0;
         const 30;
 },
 _c2CPy() //  [R1]
         { []
         }
     {offset
       c2CPy: // global
           I64[Sp] = block_c2CPD_info;
           _s2v7e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7e::I64;
           if (R1 & 7 != 0) goto u2CQb; else goto c2CPI;
       u2CQb: // global
           call _c2CPD(R1) args: 0, res: 0, upd: 0;
       c2CPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CPy_info" {
     block_c2CPy_info:
         const _c2CPy;
         const 1;
         const 30;
 },
 _c2CPD() //  [R1]
         { []
         }
     {offset
       c2CPD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CPO; else goto c2CPN;
       c2CPO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CPN: // global
           _s2v7e::I64 = I64[Sp + 8];
           _s2v7g::I64 = I64[R1 + 7];
           if (_s2v7e::I64 > _s2v7g::I64) goto c2CPS; else goto c2CQ8;
       c2CPS: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CQ8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7g::I64 - _s2v7e::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CPD_info" {
     block_c2CPD_info:
         const _c2CPD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.292435189 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2CQG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CR6; else goto c2CR7;
       c2CR6: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CR7: // global
           I64[Sp - 8] = block_c2CQD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CRe; else goto c2CQE;
       u2CRe: // global
           call _c2CQD(R1) args: 0, res: 0, upd: 0;
       c2CQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CQD() //  [R1]
         { []
         }
     {offset
       c2CQD: // global
           I64[Sp - 8] = block_c2CQJ_info;
           _s2v7o::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2v7o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CRd; else goto c2CQK;
       u2CRd: // global
           call _c2CQJ(R1) args: 0, res: 0, upd: 0;
       c2CQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CQD_info" {
     block_c2CQD_info:
         const _c2CQD;
         const 0;
         const 30;
 },
 _c2CQJ() //  [R1]
         { []
         }
     {offset
       c2CQJ: // global
           I64[Sp] = block_c2CQO_info;
           _s2v7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7r::I64;
           if (R1 & 7 != 0) goto u2CRf; else goto c2CQP;
       u2CRf: // global
           call _c2CQO(R1) args: 0, res: 0, upd: 0;
       c2CQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CQJ_info" {
     block_c2CQJ_info:
         const _c2CQJ;
         const 1;
         const 30;
 },
 _c2CQO() //  [R1]
         { []
         }
     {offset
       c2CQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CRc; else goto c2CRb;
       c2CRc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CRb: // global
           _s2v7x::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2v7x::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CQO_info" {
     block_c2CQO_info:
         const _c2CQO;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.303577872 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CRJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CRS; else goto c2CRT;
       c2CRS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CRT: // global
           I64[Sp - 16] = block_c2CRG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CSy; else goto c2CRH;
       u2CSy: // global
           call _c2CRG(R1) args: 0, res: 0, upd: 0;
       c2CRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cindex_info" {
     GHC.Word.$fIxWord16_$cindex_info:
         const GHC.Word.$fIxWord16_$cindex_entry;
         const 0;
         const 4402341478414;
         const 8589934607;
         const S2vim_srt+776;
 },
 _c2CRG() //  [R1]
         { []
         }
     {offset
       c2CRG: // global
           I64[Sp - 8] = block_c2CRM_info;
           _s2v7C::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2v7C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CSx; else goto c2CRN;
       u2CSx: // global
           call _c2CRM(R1) args: 0, res: 0, upd: 0;
       c2CRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CRG_info" {
     block_c2CRG_info:
         const _c2CRG;
         const 1;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2CRM() //  [R1]
         { []
         }
     {offset
       c2CRM: // global
           I64[Sp] = block_c2CRR_info;
           _s2v7E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2v7E::I64;
           if (R1 & 7 != 0) goto u2CSz; else goto c2CRW;
       u2CSz: // global
           call _c2CRR(R1) args: 0, res: 0, upd: 0;
       c2CRW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CRM_info" {
     block_c2CRM_info:
         const _c2CRM;
         const 2;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2CRR() //  [R1]
         { []
         }
     {offset
       c2CRR: // global
           _s2v7G::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2v7G::I64) goto c2CS4; else goto c2CS8;
       c2CS4: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CS8: // global
           I64[Sp] = block_c2CS7_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7G::I64;
           if (R1 & 7 != 0) goto u2CSA; else goto c2CS9;
       u2CSA: // global
           call _c2CS7(R1) args: 0, res: 0, upd: 0;
       c2CS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CRR_info" {
     block_c2CRR_info:
         const _c2CRR;
         const 130;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2CS7() //  [R1]
         { []
         }
     {offset
       c2CS7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CSf; else goto c2CSe;
       c2CSf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CSe: // global
           _s2v7G::I64 = I64[Sp + 8];
           if (_s2v7G::I64 > I64[R1 + 7]) goto c2CSj; else goto c2CSw;
       c2CSj: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2CSw: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2v7G::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CS7_info" {
     block_c2CS7_info:
         const _c2CS7;
         const 194;
         const 4294967326;
         const S2vim_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.314344806 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.317284172 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { []
         }
     {offset
       c2CTa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CTl; else goto c2CTm;
       c2CTl: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CTm: // global
           I64[Sp - 8] = block_c2CT7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CTq; else goto c2CT8;
       u2CTq: // global
           call _c2CT7(R1) args: 0, res: 0, upd: 0;
       c2CT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap16_info" {
     GHC.Word.byteSwap16_info:
         const GHC.Word.byteSwap16_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CT7() //  [R1]
         { []
         }
     {offset
       c2CT7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CTp; else goto c2CTo;
       c2CTp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CTo: // global
           (_c2CTd::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2CTd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CT7_info" {
     block_c2CT7_info:
         const _c2CT7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.323431911 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CTO; else goto c2CTP;
       c2CTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CTP: // global
           I64[Sp - 16] = block_c2CTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CTY; else goto c2CTI;
       u2CTY: // global
           call _c2CTH(R1) args: 0, res: 0, upd: 0;
       c2CTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord32_info" {
     GHC.Word.eqWord32_info:
         const GHC.Word.eqWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CTH() //  [R1]
         { []
         }
     {offset
       c2CTH: // global
           I64[Sp] = block_c2CTN_info;
           _s2v7W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v7W::I64;
           if (R1 & 7 != 0) goto u2CTX; else goto c2CTR;
       u2CTX: // global
           call _c2CTN(R1) args: 0, res: 0, upd: 0;
       c2CTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CTH_info" {
     block_c2CTH_info:
         const _c2CTH;
         const 1;
         const 30;
 },
 _c2CTN() //  [R1]
         { []
         }
     {offset
       c2CTN: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CTN_info" {
     block_c2CTN_info:
         const _c2CTN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.330826073 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.332501679 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.3351259 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2CUp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CUq; else goto c2CUr;
       c2CUq: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CUr: // global
           I64[Sp - 8] = block_c2CUm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CUz; else goto c2CUn;
       u2CUz: // global
           call _c2CUm(R1) args: 0, res: 0, upd: 0;
       c2CUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$csignum_info" {
     GHC.Word.$fNumWord32_$csignum_info:
         const GHC.Word.$fNumWord32_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CUm() //  [R1]
         { []
         }
     {offset
       c2CUm: // global
           if (I64[R1 + 7] == 0) goto c2CUy; else goto c2CUx;
       c2CUy: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CUx: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CUm_info" {
     block_c2CUm_info:
         const _c2CUm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.340324691 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.343844592 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2CUT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CV0; else goto c2CV1;
       c2CV0: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CV1: // global
           I64[Sp - 8] = block_c2CUQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CV5; else goto c2CUR;
       u2CV5: // global
           call _c2CUQ(R1) args: 0, res: 0, upd: 0;
       c2CUR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ccomplement_info" {
     GHC.Word.$fBitsWord32_$ccomplement_info:
         const GHC.Word.$fBitsWord32_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CUQ() //  [R1]
         { []
         }
     {offset
       c2CUQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CV4; else goto c2CV3;
       c2CV4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CV3: // global
           _s2v87::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v87::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CUQ_info" {
     block_c2CUQ_info:
         const _c2CUQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.348843244 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.350932483 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2CVn: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.35530533 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2CVC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2CVD; else goto c2CVE;
       c2CVD: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2CVE: // global
           I64[Sp - 8] = block_c2CVz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CVX; else goto c2CVA;
       u2CVX: // global
           call _c2CVz(R1) args: 0, res: 0, upd: 0;
       c2CVA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cbit_info" {
     GHC.Word.$fBitsWord32_$cbit_info:
         const GHC.Word.$fBitsWord32_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2CVz() //  [R1]
         { []
         }
     {offset
       c2CVz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CVJ; else goto c2CVI;
       c2CVJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CVI: // global
           _s2v8b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8b::I64, 64)) goto c2CVV; else goto c2CVW;
       c2CVV: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8b::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CVW: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CVz_info" {
     block_c2CVz_info:
         const _c2CVz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.363114422 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CWi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CWm; else goto c2CWn;
       c2CWm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CWn: // global
           I64[Sp - 16] = block_c2CWf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CWW; else goto c2CWg;
       u2CWW: // global
           call _c2CWf(R1) args: 0, res: 0, upd: 0;
       c2CWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ctestBit_info" {
     GHC.Word.$fBitsWord32_$ctestBit_info:
         const GHC.Word.$fBitsWord32_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CWf() //  [R1]
         { []
         }
     {offset
       c2CWf: // global
           I64[Sp] = block_c2CWl_info;
           _s2v8i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8i::I64;
           if (R1 & 7 != 0) goto u2CWV; else goto c2CWp;
       u2CWV: // global
           call _c2CWl(R1) args: 0, res: 0, upd: 0;
       c2CWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CWf_info" {
     block_c2CWf_info:
         const _c2CWf;
         const 1;
         const 30;
 },
 _c2CWl() //  [R1]
         { []
         }
     {offset
       c2CWl: // global
           _s2v8k::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2v8k::I64, 64)) goto c2CWU; else goto c2CWT;
       c2CWT: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8k::I64)) == 0) goto c2CWU; else goto c2CWI;
       c2CWU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CWI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CWl_info" {
     block_c2CWl_info:
         const _c2CWl;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.372867472 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CXn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CXr; else goto c2CXs;
       c2CXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CXs: // global
           I64[Sp - 16] = block_c2CXk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CYi; else goto c2CXl;
       u2CYi: // global
           call _c2CXk(R1) args: 0, res: 0, upd: 0;
       c2CXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotateR_info" {
     GHC.Word.$fBitsWord32_$crotateR_info:
         const GHC.Word.$fBitsWord32_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CXk() //  [R1]
         { []
         }
     {offset
       c2CXk: // global
           I64[Sp - 8] = block_c2CXq_info;
           _s2v8r::P64 = R1;
           _s2v8s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8s::I64;
           P64[Sp + 8] = _s2v8r::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CYh; else goto c2CXu;
       u2CYh: // global
           call _c2CXq(R1) args: 0, res: 0, upd: 0;
       c2CXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CXk_info" {
     block_c2CXk_info:
         const _c2CXk;
         const 1;
         const 30;
 },
 _c2CXq() //  [R1]
         { []
         }
     {offset
       c2CXq: // global
           _s2v8y::I64 = -I64[R1 + 7] & 31;
           if (_s2v8y::I64 != 0) goto u2CYf; else goto c2CYb;
       u2CYf: // global
           I64[Sp + 16] = _s2v8y::I64;
           Sp = Sp + 8;
           call _c2CXM() args: 0, res: 0, upd: 0;
       c2CYb: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CXq_info" {
     block_c2CXq_info:
         const _c2CXq;
         const 66;
         const 30;
 },
 _c2CXM() //  []
         { []
         }
     {offset
       c2CXM: // global
           Hp = Hp + 16;
           _s2v8y::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2CY8; else goto c2CY7;
       c2CY8: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2CXL_info;
           R1 = _s2v8y::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2CY7: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2v8s::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2v8s::I64 << _s2v8y::I64) | (_s2v8s::I64 >> 32 - _s2v8y::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2CXL() //  [R1]
         { []
         }
     {offset
       c2CXL: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2CXM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2CXL_info" {
     block_c2CXL_info:
         const _c2CXL;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.3837604 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CYU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2CYY; else goto c2CYZ;
       c2CYY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CYZ: // global
           I64[Sp - 16] = block_c2CYR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2CZp; else goto c2CYS;
       u2CZp: // global
           call _c2CYR(R1) args: 0, res: 0, upd: 0;
       c2CYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ccomplementBit_info" {
     GHC.Word.$fBitsWord32_$ccomplementBit_info:
         const GHC.Word.$fBitsWord32_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CYR() //  [R1]
         { []
         }
     {offset
       c2CYR: // global
           I64[Sp - 8] = block_c2CYX_info;
           _s2v8G::P64 = R1;
           _s2v8H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v8H::I64;
           P64[Sp + 8] = _s2v8G::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2CZo; else goto c2CZ1;
       u2CZo: // global
           call _c2CYX(R1) args: 0, res: 0, upd: 0;
       c2CZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CYR_info" {
     block_c2CYR_info:
         const _c2CYR;
         const 1;
         const 30;
 },
 _c2CYX() //  [R1]
         { []
         }
     {offset
       c2CYX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2CZ7; else goto c2CZ6;
       c2CZ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2CZ6: // global
           _s2v8J::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8J::I64, 64)) goto c2CZm; else goto c2CZn;
       c2CZm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8J::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2CZn: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CYX_info" {
     block_c2CYX_info:
         const _c2CYX;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.392611829 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2CZR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2CZV; else goto c2CZW;
       c2CZV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2CZW: // global
           I64[Sp - 16] = block_c2CZO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D0u; else goto c2CZP;
       u2D0u: // global
           call _c2CZO(R1) args: 0, res: 0, upd: 0;
       c2CZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cclearBit_info" {
     GHC.Word.$fBitsWord32_$cclearBit_info:
         const GHC.Word.$fBitsWord32_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2CZO() //  [R1]
         { []
         }
     {offset
       c2CZO: // global
           I64[Sp] = block_c2CZU_info;
           _s2v8R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v8R::I64;
           if (R1 & 7 != 0) goto u2D0t; else goto c2CZY;
       u2D0t: // global
           call _c2CZU(R1) args: 0, res: 0, upd: 0;
       c2CZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CZO_info" {
     block_c2CZO_info:
         const _c2CZO;
         const 1;
         const 30;
 },
 _c2CZU() //  [R1]
         { []
         }
     {offset
       c2CZU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D04; else goto c2D03;
       c2D04: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D03: // global
           _s2v8R::I64 = I64[Sp + 8];
           _s2v8T::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v8T::I64, 64)) goto c2D0m; else goto c2D0s;
       c2D0m: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v8T::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D0s: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v8R::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2CZU_info" {
     block_c2CZU_info:
         const _c2CZU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.401781097 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D10: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D14; else goto c2D15;
       c2D14: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D15: // global
           I64[Sp - 16] = block_c2D0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D1v; else goto c2D0Y;
       u2D1v: // global
           call _c2D0X(R1) args: 0, res: 0, upd: 0;
       c2D0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$csetBit_info" {
     GHC.Word.$fBitsWord32_$csetBit_info:
         const GHC.Word.$fBitsWord32_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D0X() //  [R1]
         { []
         }
     {offset
       c2D0X: // global
           I64[Sp - 8] = block_c2D13_info;
           _s2v92::P64 = R1;
           _s2v93::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2v93::I64;
           P64[Sp + 8] = _s2v92::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2D1u; else goto c2D17;
       u2D1u: // global
           call _c2D13(R1) args: 0, res: 0, upd: 0;
       c2D17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D0X_info" {
     block_c2D0X_info:
         const _c2D0X;
         const 1;
         const 30;
 },
 _c2D13() //  [R1]
         { []
         }
     {offset
       c2D13: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D1d; else goto c2D1c;
       c2D1d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D1c: // global
           _s2v95::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2v95::I64, 64)) goto c2D1s; else goto c2D1t;
       c2D1s: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2v95::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D1t: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D13_info" {
     block_c2D13_info:
         const _c2D13;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.408829297 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D1U: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotateL_info" {
     GHC.Word.$fBitsWord32_$crotateL_info:
         const GHC.Word.$fBitsWord32_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.412205481 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.415091974 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.418439176 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D2a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D2e; else goto c2D2f;
       c2D2e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D2f: // global
           I64[Sp - 16] = block_c2D27_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D2y; else goto c2D28;
       u2D2y: // global
           call _c2D27(R1) args: 0, res: 0, upd: 0;
       c2D28: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cquot_info" {
     GHC.Word.$fIntegralWord32_$cquot_info:
         const GHC.Word.$fIntegralWord32_$cquot_entry;
         const 0;
         const 554050781198;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2D27() //  [R1]
         { []
         }
     {offset
       c2D27: // global
           I64[Sp] = block_c2D2d_info;
           _s2v9d::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9d::I64;
           if (R1 & 7 != 0) goto u2D2x; else goto c2D2h;
       u2D2x: // global
           call _c2D2d(R1) args: 0, res: 0, upd: 0;
       c2D2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D27_info" {
     block_c2D27_info:
         const _c2D27;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2D2d() //  [R1]
         { []
         }
     {offset
       c2D2d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D2n; else goto c2D2m;
       c2D2n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D2m: // global
           _s2v9g::I64 = I64[R1 + 7];
           if (_s2v9g::I64 != 0) goto c2D2v; else goto c2D2w;
       c2D2v: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2v9g::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D2w: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D2d_info" {
     block_c2D2d_info:
         const _c2D2d;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.426979694 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D2V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D2Z; else goto c2D30;
       c2D2Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D30: // global
           I64[Sp - 16] = block_c2D2S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D3j; else goto c2D2T;
       u2D3j: // global
           call _c2D2S(R1) args: 0, res: 0, upd: 0;
       c2D2T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$crem_info" {
     GHC.Word.$fIntegralWord32_$crem_info:
         const GHC.Word.$fIntegralWord32_$crem_entry;
         const 0;
         const 1103806595086;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2D2S() //  [R1]
         { []
         }
     {offset
       c2D2S: // global
           I64[Sp] = block_c2D2Y_info;
           _s2v9l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9l::I64;
           if (R1 & 7 != 0) goto u2D3i; else goto c2D32;
       u2D3i: // global
           call _c2D2Y(R1) args: 0, res: 0, upd: 0;
       c2D32: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D2S_info" {
     block_c2D2S_info:
         const _c2D2S;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2D2Y() //  [R1]
         { []
         }
     {offset
       c2D2Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D38; else goto c2D37;
       c2D38: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D37: // global
           _s2v9o::I64 = I64[R1 + 7];
           if (_s2v9o::I64 != 0) goto c2D3g; else goto c2D3h;
       c2D3g: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2v9o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D3h: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D2Y_info" {
     block_c2D2Y_info:
         const _c2D2Y;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.436120063 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D3G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D3K; else goto c2D3L;
       c2D3K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D3L: // global
           I64[Sp - 16] = block_c2D3D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D43; else goto c2D3E;
       u2D43: // global
           call _c2D3D(R1) args: 0, res: 0, upd: 0;
       c2D3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cquotRem_info" {
     GHC.Word.$fIntegralWord32_$cquotRem_info:
         const GHC.Word.$fIntegralWord32_$cquotRem_entry;
         const 0;
         const 2203318222862;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2D3D() //  [R1]
         { []
         }
     {offset
       c2D3D: // global
           I64[Sp] = block_c2D3J_info;
           _s2v9t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9t::I64;
           if (R1 & 7 != 0) goto u2D42; else goto c2D3N;
       u2D42: // global
           call _c2D3J(R1) args: 0, res: 0, upd: 0;
       c2D3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D3D_info" {
     block_c2D3D_info:
         const _c2D3D;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2D3J() //  [R1]
         { []
         }
     {offset
       c2D3J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2D3T; else goto c2D3S;
       c2D3T: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D3S: // global
           _s2v9w::I64 = I64[R1 + 7];
           if (_s2v9w::I64 != 0) goto c2D40; else goto c2D41;
       c2D40: // global
           (_s2v9y::I64, _s2v9z::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2v9w::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2v9z::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2v9y::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D41: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D3J_info" {
     block_c2D3J_info:
         const _c2D3J;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.44642186 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2v9M_entry() //  [R1]
         { []
         }
     {offset
       c2D4G: // global
           _s2v9M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2D4J; else goto c2D4K;
       c2D4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D4M; else goto c2D4L;
       c2D4M: // global
           HpAlloc = 16;
           goto c2D4J;
       c2D4J: // global
           R1 = _s2v9M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2D4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9M::P64;
           _s2v9L::I64 = I64[_s2v9M::P64 + 16] % I64[_s2v9M::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9L::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v9M_info" {
     sat_s2v9M_info:
         const sat_s2v9M_entry;
         const 8589934592;
         const 20;
 },
 sat_s2v9K_entry() //  [R1]
         { []
         }
     {offset
       c2D4T: // global
           _s2v9K::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2D4W; else goto c2D4X;
       c2D4X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2D4Z; else goto c2D4Y;
       c2D4Z: // global
           HpAlloc = 16;
           goto c2D4W;
       c2D4W: // global
           R1 = _s2v9K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2D4Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2v9K::P64;
           _s2v9J::I64 = I64[_s2v9K::P64 + 16] / I64[_s2v9K::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2v9J::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2v9K_info" {
     sat_s2v9K_info:
         const sat_s2v9K_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D51; else goto c2D52;
       c2D51: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D52: // global
           I64[Sp - 16] = block_c2D4o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D5c; else goto c2D4p;
       u2D5c: // global
           call _c2D4o(R1) args: 0, res: 0, upd: 0;
       c2D4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cdivMod_info" {
     GHC.Word.$fIntegralWord32_$cdivMod_info:
         const GHC.Word.$fIntegralWord32_$cdivMod_entry;
         const 0;
         const 4402341478414;
         const 8589934607;
         const S2vim_srt+808;
 },
 _c2D4o() //  [R1]
         { []
         }
     {offset
       c2D4o: // global
           I64[Sp] = block_c2D4t_info;
           _s2v9F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9F::I64;
           if (R1 & 7 != 0) goto u2D5b; else goto c2D4u;
       u2D5b: // global
           call _c2D4t(R1) args: 0, res: 0, upd: 0;
       c2D4u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D4o_info" {
     block_c2D4o_info:
         const _c2D4o;
         const 1;
         const 4294967326;
         const S2vim_srt+808;
 },
 _c2D4t() //  [R1]
         { []
         }
     {offset
       c2D4t: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2D56; else goto c2D55;
       c2D56: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2D55: // global
           _s2v9I::I64 = I64[R1 + 7];
           if (_s2v9I::I64 != 0) goto c2D59; else goto c2D5a;
       c2D59: // global
           I64[Hp - 80] = sat_s2v9M_info;
           _s2v9F::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2v9F::I64;
           I64[Hp - 56] = _s2v9I::I64;
           I64[Hp - 48] = sat_s2v9K_info;
           I64[Hp - 32] = _s2v9F::I64;
           I64[Hp - 24] = _s2v9I::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D5a: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D4t_info" {
     block_c2D4t_info:
         const _c2D4t;
         const 65;
         const 4294967326;
         const S2vim_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.459364332 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D5K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D5O; else goto c2D5P;
       c2D5O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D5P: // global
           I64[Sp - 16] = block_c2D5H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D5Y; else goto c2D5I;
       u2D5Y: // global
           call _c2D5H(R1) args: 0, res: 0, upd: 0;
       c2D5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord32_info" {
     GHC.Word.gtWord32_info:
         const GHC.Word.gtWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D5H() //  [R1]
         { []
         }
     {offset
       c2D5H: // global
           I64[Sp] = block_c2D5N_info;
           _s2v9Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9Q::I64;
           if (R1 & 7 != 0) goto u2D5X; else goto c2D5R;
       u2D5X: // global
           call _c2D5N(R1) args: 0, res: 0, upd: 0;
       c2D5R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D5H_info" {
     block_c2D5H_info:
         const _c2D5H;
         const 1;
         const 30;
 },
 _c2D5N() //  [R1]
         { []
         }
     {offset
       c2D5N: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D5N_info" {
     block_c2D5N_info:
         const _c2D5N;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.467062508 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D6n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D6r; else goto c2D6s;
       c2D6r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D6s: // global
           I64[Sp - 16] = block_c2D6k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D6B; else goto c2D6l;
       u2D6B: // global
           call _c2D6k(R1) args: 0, res: 0, upd: 0;
       c2D6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord32_info" {
     GHC.Word.geWord32_info:
         const GHC.Word.geWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D6k() //  [R1]
         { []
         }
     {offset
       c2D6k: // global
           I64[Sp] = block_c2D6q_info;
           _s2v9X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2v9X::I64;
           if (R1 & 7 != 0) goto u2D6A; else goto c2D6u;
       u2D6A: // global
           call _c2D6q(R1) args: 0, res: 0, upd: 0;
       c2D6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D6k_info" {
     block_c2D6k_info:
         const _c2D6k;
         const 1;
         const 30;
 },
 _c2D6q() //  [R1]
         { []
         }
     {offset
       c2D6q: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D6q_info" {
     block_c2D6q_info:
         const _c2D6q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.475378285 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D74; else goto c2D75;
       c2D74: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D75: // global
           I64[Sp - 16] = block_c2D6X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D7e; else goto c2D6Y;
       u2D7e: // global
           call _c2D6X(R1) args: 0, res: 0, upd: 0;
       c2D6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord32_info" {
     GHC.Word.ltWord32_info:
         const GHC.Word.ltWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D6X() //  [R1]
         { []
         }
     {offset
       c2D6X: // global
           I64[Sp] = block_c2D73_info;
           _s2va4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2va4::I64;
           if (R1 & 7 != 0) goto u2D7d; else goto c2D77;
       u2D7d: // global
           call _c2D73(R1) args: 0, res: 0, upd: 0;
       c2D77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D6X_info" {
     block_c2D6X_info:
         const _c2D6X;
         const 1;
         const 30;
 },
 _c2D73() //  [R1]
         { []
         }
     {offset
       c2D73: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D73_info" {
     block_c2D73_info:
         const _c2D73;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.483153189 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D7H; else goto c2D7I;
       c2D7H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D7I: // global
           I64[Sp - 16] = block_c2D7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D7R; else goto c2D7B;
       u2D7R: // global
           call _c2D7A(R1) args: 0, res: 0, upd: 0;
       c2D7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord32_info" {
     GHC.Word.leWord32_info:
         const GHC.Word.leWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D7A() //  [R1]
         { []
         }
     {offset
       c2D7A: // global
           I64[Sp] = block_c2D7G_info;
           _s2vab::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vab::I64;
           if (R1 & 7 != 0) goto u2D7Q; else goto c2D7K;
       u2D7Q: // global
           call _c2D7G(R1) args: 0, res: 0, upd: 0;
       c2D7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D7A_info" {
     block_c2D7A_info:
         const _c2D7A;
         const 1;
         const 30;
 },
 _c2D7G() //  [R1]
         { []
         }
     {offset
       c2D7G: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D7G_info" {
     block_c2D7G_info:
         const _c2D7G;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.491442493 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D8g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2D8k; else goto c2D8l;
       c2D8k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D8l: // global
           I64[Sp - 16] = block_c2D8d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D8E; else goto c2D8e;
       u2D8E: // global
           call _c2D8d(R1) args: 0, res: 0, upd: 0;
       c2D8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$ccompare_info" {
     GHC.Word.$fOrdWord32_$ccompare_info:
         const GHC.Word.$fOrdWord32_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D8d() //  [R1]
         { []
         }
     {offset
       c2D8d: // global
           I64[Sp] = block_c2D8j_info;
           _s2vai::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vai::I64;
           if (R1 & 7 != 0) goto u2D8D; else goto c2D8n;
       u2D8D: // global
           call _c2D8j(R1) args: 0, res: 0, upd: 0;
       c2D8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D8d_info" {
     block_c2D8d_info:
         const _c2D8d;
         const 1;
         const 30;
 },
 _c2D8j() //  [R1]
         { []
         }
     {offset
       c2D8j: // global
           _s2vai::I64 = I64[Sp + 8];
           _s2vak::I64 = I64[R1 + 7];
           if (_s2vai::I64 == _s2vak::I64) goto c2D8C; else goto c2D8B;
       c2D8C: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D8B: // global
           if (_s2vai::I64 > _s2vak::I64) goto c2D8y; else goto c2D8z;
       c2D8y: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2D8z: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D8j_info" {
     block_c2D8j_info:
         const _c2D8j;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.499734099 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D92: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D96; else goto c2D97;
       c2D96: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D97: // global
           I64[Sp - 16] = block_c2D8Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2D9k; else goto c2D90;
       u2D9k: // global
           call _c2D8Z(R1) args: 0, res: 0, upd: 0;
       c2D90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$cmax_info" {
     GHC.Word.$fOrdWord32_$cmax_info:
         const GHC.Word.$fOrdWord32_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D8Z() //  [R1]
         { []
         }
     {offset
       c2D8Z: // global
           I64[Sp - 8] = block_c2D95_info;
           _s2vap::P64 = R1;
           _s2vaq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vaq::I64;
           P64[Sp + 8] = _s2vap::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2D9j; else goto c2D99;
       u2D9j: // global
           call _c2D95(R1) args: 0, res: 0, upd: 0;
       c2D99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D8Z_info" {
     block_c2D8Z_info:
         const _c2D8Z;
         const 1;
         const 30;
 },
 _c2D95() //  [R1]
         { []
         }
     {offset
       c2D95: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2D9h; else goto c2D9i;
       c2D9h: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2D9i: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D95_info" {
     block_c2D95_info:
         const _c2D95;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.508225259 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2D9K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2D9O; else goto c2D9P;
       c2D9O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2D9P: // global
           I64[Sp - 16] = block_c2D9H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Da2; else goto c2D9I;
       u2Da2: // global
           call _c2D9H(R1) args: 0, res: 0, upd: 0;
       c2D9I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$cmin_info" {
     GHC.Word.$fOrdWord32_$cmin_info:
         const GHC.Word.$fOrdWord32_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2D9H() //  [R1]
         { []
         }
     {offset
       c2D9H: // global
           I64[Sp - 8] = block_c2D9N_info;
           _s2vaw::P64 = R1;
           _s2vax::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vax::I64;
           P64[Sp + 8] = _s2vaw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Da1; else goto c2D9R;
       u2Da1: // global
           call _c2D9N(R1) args: 0, res: 0, upd: 0;
       c2D9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D9H_info" {
     block_c2D9H_info:
         const _c2D9H;
         const 1;
         const 30;
 },
 _c2D9N() //  [R1]
         { []
         }
     {offset
       c2D9N: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2D9Z; else goto c2Da0;
       c2D9Z: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Da0: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2D9N_info" {
     block_c2D9N_info:
         const _c2D9N;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.51588041 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.519746195 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dat: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DaC; else goto c2DaD;
       c2DaC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DaD: // global
           I64[Sp - 16] = block_c2Daq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Db0; else goto c2Dar;
       u2Db0: // global
           call _c2Daq(R1) args: 0, res: 0, upd: 0;
       c2Dar: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cinRange_info" {
     GHC.Word.$fIxWord32_$cinRange_info:
         const GHC.Word.$fIxWord32_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Daq() //  [R1]
         { []
         }
     {offset
       c2Daq: // global
           I64[Sp - 8] = block_c2Daw_info;
           _s2vaF::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vaF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DaZ; else goto c2Dax;
       u2DaZ: // global
           call _c2Daw(R1) args: 0, res: 0, upd: 0;
       c2Dax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Daq_info" {
     block_c2Daq_info:
         const _c2Daq;
         const 1;
         const 30;
 },
 _c2Daw() //  [R1]
         { []
         }
     {offset
       c2Daw: // global
           I64[Sp] = block_c2DaB_info;
           _s2vaH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vaH::I64;
           if (R1 & 7 != 0) goto u2Db1; else goto c2DaG;
       u2Db1: // global
           call _c2DaB(R1) args: 0, res: 0, upd: 0;
       c2DaG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Daw_info" {
     block_c2Daw_info:
         const _c2Daw;
         const 2;
         const 30;
 },
 _c2DaB() //  [R1]
         { []
         }
     {offset
       c2DaB: // global
           _s2vaJ::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vaJ::I64) goto c2DaO; else goto c2DaS;
       c2DaO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DaS: // global
           _s2vaF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2DaR_info;
           R1 = _s2vaF::P64;
           I64[Sp + 16] = _s2vaJ::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2Db2; else goto c2DaT;
       u2Db2: // global
           call _c2DaR(R1) args: 0, res: 0, upd: 0;
       c2DaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DaB_info" {
     block_c2DaB_info:
         const _c2DaB;
         const 130;
         const 30;
 },
 _c2DaR() //  [R1]
         { []
         }
     {offset
       c2DaR: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DaR_info" {
     block_c2DaR_info:
         const _c2DaR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.532046186 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2DbA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DbR; else goto c2DbS;
       c2DbR: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DbS: // global
           I64[Sp - 8] = block_c2Dbx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DbZ; else goto c2Dby;
       u2DbZ: // global
           call _c2Dbx(R1) args: 0, res: 0, upd: 0;
       c2Dby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord32_$ctoRational_info" {
     GHC.Word.$fRealWord32_$ctoRational_info:
         const GHC.Word.$fRealWord32_$ctoRational_entry;
         const 0;
         const 4503629692141582;
         const 4294967301;
         const S2vim_srt+736;
 },
 _c2Dbx() //  [R1]
         { []
         }
     {offset
       c2Dbx: // global
           I64[Sp] = block_c2DbG_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dbx_info" {
     block_c2Dbx_info:
         const _c2Dbx;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2DbG() //  [R1]
         { []
         }
     {offset
       c2DbG: // global
           I64[Sp] = block_c2DbK_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DbG_info" {
     block_c2DbG_info:
         const _c2DbG;
         const 0;
         const 30064771102;
         const S2vim_srt+736;
 },
 _c2DbK() //  [R1]
         { []
         }
     {offset
       c2DbK: // global
           I64[Sp] = block_c2DbO_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DbK_info" {
     block_c2DbK_info:
         const _c2DbK;
         const 0;
         const 12884901918;
         const S2vim_srt+736;
 },
 _c2DbO() //  [R1, R2]
         { []
         }
     {offset
       c2DbO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2DbY; else goto c2DbX;
       c2DbY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2DbX: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DbO_info" {
     block_c2DbO_info:
         const _c2DbO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.542502059 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.544902056 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.548417855 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dcs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DcP; else goto c2DcQ;
       c2DcP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DcQ: // global
           I64[Sp - 16] = block_c2Dcp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DcX; else goto c2Dcq;
       u2DcX: // global
           call _c2Dcp(R1) args: 0, res: 0, upd: 0;
       c2Dcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cunsafeIndex_info" {
     GHC.Word.$fIxWord32_$cunsafeIndex_info:
         const GHC.Word.$fIxWord32_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Dcp() //  [R1]
         { []
         }
     {offset
       c2Dcp: // global
           I64[Sp] = block_c2Dcv_info;
           _s2vb0::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vb0::P64;
           if (R1 & 7 != 0) goto u2DcW; else goto c2Dcw;
       u2DcW: // global
           call _c2Dcv(R1) args: 0, res: 0, upd: 0;
       c2Dcw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dcp_info" {
     block_c2Dcp_info:
         const _c2Dcp;
         const 1;
         const 30;
 },
 _c2Dcv() //  [R1]
         { []
         }
     {offset
       c2Dcv: // global
           I64[Sp] = block_c2DcA_info;
           _s2vb3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vb3::I64;
           if (R1 & 7 != 0) goto u2DcY; else goto c2DcB;
       u2DcY: // global
           call _c2DcA(R1) args: 0, res: 0, upd: 0;
       c2DcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dcv_info" {
     block_c2Dcv_info:
         const _c2Dcv;
         const 1;
         const 30;
 },
 _c2DcA() //  [R1]
         { []
         }
     {offset
       c2DcA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DcV; else goto c2DcU;
       c2DcV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DcU: // global
           _s2vb8::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vb8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DcA_info" {
     block_c2DcA_info:
         const _c2DcA;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.558279191 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2Ddr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dds; else goto c2Ddt;
       c2Dds: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ddt: // global
           I64[Sp - 8] = block_c2Ddo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ddx; else goto c2Ddp;
       u2Ddx: // global
           call _c2Ddo(R1) args: 0, res: 0, upd: 0;
       c2Ddp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$crange_info" {
     GHC.Word.$fIxWord32_$crange_info:
         const GHC.Word.$fIxWord32_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+904;
 },
 _c2Ddo() //  [R1]
         { []
         }
     {offset
       c2Ddo: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ddo_info" {
     block_c2Ddo_info:
         const _c2Ddo;
         const 0;
         const 4294967326;
         const S2vim_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.565155403 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2DdO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DdX; else goto c2DdY;
       c2DdX: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DdY: // global
           I64[Sp - 8] = block_c2DdL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Det; else goto c2DdM;
       u2Det: // global
           call _c2DdL(R1) args: 0, res: 0, upd: 0;
       c2DdM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$crangeSize_info" {
     GHC.Word.$fIxWord32_$crangeSize_info:
         const GHC.Word.$fIxWord32_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2DdL() //  [R1]
         { []
         }
     {offset
       c2DdL: // global
           I64[Sp - 8] = block_c2DdR_info;
           _s2vbg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Des; else goto c2DdS;
       u2Des: // global
           call _c2DdR(R1) args: 0, res: 0, upd: 0;
       c2DdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DdL_info" {
     block_c2DdL_info:
         const _c2DdL;
         const 0;
         const 30;
 },
 _c2DdR() //  [R1]
         { []
         }
     {offset
       c2DdR: // global
           I64[Sp] = block_c2DdW_info;
           _s2vbi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbi::I64;
           if (R1 & 7 != 0) goto u2Deu; else goto c2De1;
       u2Deu: // global
           call _c2DdW(R1) args: 0, res: 0, upd: 0;
       c2De1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DdR_info" {
     block_c2DdR_info:
         const _c2DdR;
         const 1;
         const 30;
 },
 _c2DdW() //  [R1]
         { []
         }
     {offset
       c2DdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2De7; else goto c2De6;
       c2De7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2De6: // global
           _s2vbi::I64 = I64[Sp + 8];
           _s2vbk::I64 = I64[R1 + 7];
           if (_s2vbi::I64 > _s2vbk::I64) goto c2Deb; else goto c2Der;
       c2Deb: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Der: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbk::I64 - _s2vbi::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DdW_info" {
     block_c2DdW_info:
         const _c2DdW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.575633588 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2DeZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Dfp; else goto c2Dfq;
       c2Dfp: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dfq: // global
           I64[Sp - 8] = block_c2DeW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dfx; else goto c2DeX;
       u2Dfx: // global
           call _c2DeW(R1) args: 0, res: 0, upd: 0;
       c2DeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2DeW() //  [R1]
         { []
         }
     {offset
       c2DeW: // global
           I64[Sp - 8] = block_c2Df2_info;
           _s2vbs::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vbs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dfw; else goto c2Df3;
       u2Dfw: // global
           call _c2Df2(R1) args: 0, res: 0, upd: 0;
       c2Df3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DeW_info" {
     block_c2DeW_info:
         const _c2DeW;
         const 0;
         const 30;
 },
 _c2Df2() //  [R1]
         { []
         }
     {offset
       c2Df2: // global
           I64[Sp] = block_c2Df7_info;
           _s2vbv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbv::I64;
           if (R1 & 7 != 0) goto u2Dfy; else goto c2Df8;
       u2Dfy: // global
           call _c2Df7(R1) args: 0, res: 0, upd: 0;
       c2Df8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Df2_info" {
     block_c2Df2_info:
         const _c2Df2;
         const 1;
         const 30;
 },
 _c2Df7() //  [R1]
         { []
         }
     {offset
       c2Df7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dfv; else goto c2Dfu;
       c2Dfv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dfu: // global
           _s2vbB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vbB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Df7_info" {
     block_c2Df7_info:
         const _c2Df7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.586727527 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dg2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dgb; else goto c2Dgc;
       c2Dgb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dgc: // global
           I64[Sp - 16] = block_c2DfZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DgR; else goto c2Dg0;
       u2DgR: // global
           call _c2DfZ(R1) args: 0, res: 0, upd: 0;
       c2Dg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cindex_info" {
     GHC.Word.$fIxWord32_$cindex_info:
         const GHC.Word.$fIxWord32_$cindex_entry;
         const 0;
         const 1125904201809934;
         const 8589934607;
         const S2vim_srt+776;
 },
 _c2DfZ() //  [R1]
         { []
         }
     {offset
       c2DfZ: // global
           I64[Sp - 8] = block_c2Dg5_info;
           _s2vbG::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vbG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DgQ; else goto c2Dg6;
       u2DgQ: // global
           call _c2Dg5(R1) args: 0, res: 0, upd: 0;
       c2Dg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DfZ_info" {
     block_c2DfZ_info:
         const _c2DfZ;
         const 1;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Dg5() //  [R1]
         { []
         }
     {offset
       c2Dg5: // global
           I64[Sp] = block_c2Dga_info;
           _s2vbI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vbI::I64;
           if (R1 & 7 != 0) goto u2DgS; else goto c2Dgf;
       u2DgS: // global
           call _c2Dga(R1) args: 0, res: 0, upd: 0;
       c2Dgf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dg5_info" {
     block_c2Dg5_info:
         const _c2Dg5;
         const 2;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Dga() //  [R1]
         { []
         }
     {offset
       c2Dga: // global
           _s2vbK::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vbK::I64) goto c2Dgn; else goto c2Dgr;
       c2Dgn: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Dgr: // global
           I64[Sp] = block_c2Dgq_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vbK::I64;
           if (R1 & 7 != 0) goto u2DgT; else goto c2Dgs;
       u2DgT: // global
           call _c2Dgq(R1) args: 0, res: 0, upd: 0;
       c2Dgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dga_info" {
     block_c2Dga_info:
         const _c2Dga;
         const 130;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Dgq() //  [R1]
         { []
         }
     {offset
       c2Dgq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dgy; else goto c2Dgx;
       c2Dgy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dgx: // global
           _s2vbK::I64 = I64[Sp + 8];
           if (_s2vbK::I64 > I64[R1 + 7]) goto c2DgC; else goto c2DgP;
       c2DgC: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2DgP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2vbK::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dgq_info" {
     block_c2Dgq_info:
         const _c2Dgq;
         const 194;
         const 4294967326;
         const S2vim_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.597354363 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.600809329 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { []
         }
     {offset
       c2Dht: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DhE; else goto c2DhF;
       c2DhE: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DhF: // global
           I64[Sp - 8] = block_c2Dhq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DhJ; else goto c2Dhr;
       u2DhJ: // global
           call _c2Dhq(R1) args: 0, res: 0, upd: 0;
       c2Dhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap32_info" {
     GHC.Word.byteSwap32_info:
         const GHC.Word.byteSwap32_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Dhq() //  [R1]
         { []
         }
     {offset
       c2Dhq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DhI; else goto c2DhH;
       c2DhI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DhH: // global
           (_c2Dhw::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2Dhw::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dhq_info" {
     block_c2Dhq_info:
         const _c2Dhq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.607437748 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2Di2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Di9; else goto c2Dia;
       c2Di9: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dia: // global
           I64[Sp - 8] = block_c2DhZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Die; else goto c2Di0;
       u2Die: // global
           call _c2DhZ(R1) args: 0, res: 0, upd: 0;
       c2Di0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ccomplement_info" {
     GHC.Word.$fBitsWord64_$ccomplement_info:
         const GHC.Word.$fBitsWord64_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2DhZ() //  [R1]
         { []
         }
     {offset
       c2DhZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Did; else goto c2Dic;
       c2Did: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dic: // global
           _s2vc0::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vc0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DhZ_info" {
     block_c2DhZ_info:
         const _c2DhZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.613708304 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.61633917 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2Div: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.620749955 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2DiK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2DiL; else goto c2DiM;
       c2DiL: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DiM: // global
           I64[Sp - 8] = block_c2DiH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dj2; else goto c2DiI;
       u2Dj2: // global
           call _c2DiH(R1) args: 0, res: 0, upd: 0;
       c2DiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cbit_info" {
     GHC.Word.$fBitsWord64_$cbit_info:
         const GHC.Word.$fBitsWord64_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2DiH() //  [R1]
         { []
         }
     {offset
       c2DiH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DiR; else goto c2DiQ;
       c2DiR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DiQ: // global
           _s2vc4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vc4::I64, 64)) goto c2Dj0; else goto c2Dj1;
       c2Dj0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2vc4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dj1: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DiH_info" {
     block_c2DiH_info:
         const _c2DiH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.627722998 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Djm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Djq; else goto c2Djr;
       c2Djq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Djr: // global
           I64[Sp - 16] = block_c2Djj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DjX; else goto c2Djk;
       u2DjX: // global
           call _c2Djj(R1) args: 0, res: 0, upd: 0;
       c2Djk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ctestBit_info" {
     GHC.Word.$fBitsWord64_$ctestBit_info:
         const GHC.Word.$fBitsWord64_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Djj() //  [R1]
         { []
         }
     {offset
       c2Djj: // global
           I64[Sp] = block_c2Djp_info;
           _s2vca::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vca::I64;
           if (R1 & 7 != 0) goto u2DjW; else goto c2Djt;
       u2DjW: // global
           call _c2Djp(R1) args: 0, res: 0, upd: 0;
       c2Djt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Djj_info" {
     block_c2Djj_info:
         const _c2Djj;
         const 1;
         const 30;
 },
 _c2Djp() //  [R1]
         { []
         }
     {offset
       c2Djp: // global
           _s2vcc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2vcc::I64, 64)) goto c2DjV; else goto c2DjU;
       c2DjU: // global
           if (I64[Sp + 8] & (1 << _s2vcc::I64) == 0) goto c2DjV; else goto c2DjJ;
       c2DjV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DjJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Djp_info" {
     block_c2Djp_info:
         const _c2Djp;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.636794606 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dkn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dkr; else goto c2Dks;
       c2Dkr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dks: // global
           I64[Sp - 16] = block_c2Dkk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dlf; else goto c2Dkl;
       u2Dlf: // global
           call _c2Dkk(R1) args: 0, res: 0, upd: 0;
       c2Dkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotateR_info" {
     GHC.Word.$fBitsWord64_$crotateR_info:
         const GHC.Word.$fBitsWord64_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Dkk() //  [R1]
         { []
         }
     {offset
       c2Dkk: // global
           I64[Sp - 8] = block_c2Dkq_info;
           _s2vci::P64 = R1;
           _s2vcj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcj::I64;
           P64[Sp + 8] = _s2vci::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dle; else goto c2Dku;
       u2Dle: // global
           call _c2Dkq(R1) args: 0, res: 0, upd: 0;
       c2Dku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dkk_info" {
     block_c2Dkk_info:
         const _c2Dkk;
         const 1;
         const 30;
 },
 _c2Dkq() //  [R1]
         { []
         }
     {offset
       c2Dkq: // global
           _s2vcp::I64 = -I64[R1 + 7] & 63;
           if (_s2vcp::I64 != 0) goto u2Dlc; else goto c2Dl8;
       u2Dlc: // global
           I64[Sp + 16] = _s2vcp::I64;
           Sp = Sp + 8;
           call _c2DkM() args: 0, res: 0, upd: 0;
       c2Dl8: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dkq_info" {
     block_c2Dkq_info:
         const _c2Dkq;
         const 66;
         const 30;
 },
 _c2DkM() //  []
         { []
         }
     {offset
       c2DkM: // global
           Hp = Hp + 16;
           _s2vcp::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Dl5; else goto c2Dl4;
       c2Dl5: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2DkL_info;
           R1 = _s2vcp::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Dl4: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2vcj::I64 = I64[Sp];
           I64[Hp] = (_s2vcj::I64 << _s2vcp::I64) | (_s2vcj::I64 >> 64 - _s2vcp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2DkL() //  [R1]
         { []
         }
     {offset
       c2DkL: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2DkM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2DkL_info" {
     block_c2DkL_info:
         const _c2DkL;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.648202378 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DlQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DlU; else goto c2DlV;
       c2DlU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DlV: // global
           I64[Sp - 16] = block_c2DlN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dmi; else goto c2DlO;
       u2Dmi: // global
           call _c2DlN(R1) args: 0, res: 0, upd: 0;
       c2DlO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ccomplementBit_info" {
     GHC.Word.$fBitsWord64_$ccomplementBit_info:
         const GHC.Word.$fBitsWord64_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2DlN() //  [R1]
         { []
         }
     {offset
       c2DlN: // global
           I64[Sp - 8] = block_c2DlT_info;
           _s2vcw::P64 = R1;
           _s2vcx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcx::I64;
           P64[Sp + 8] = _s2vcw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dmh; else goto c2DlX;
       u2Dmh: // global
           call _c2DlT(R1) args: 0, res: 0, upd: 0;
       c2DlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DlN_info" {
     block_c2DlN_info:
         const _c2DlN;
         const 1;
         const 30;
 },
 _c2DlT() //  [R1]
         { []
         }
     {offset
       c2DlT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dm3; else goto c2Dm2;
       c2Dm3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dm2: // global
           _s2vcz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcz::I64, 64)) goto c2Dmf; else goto c2Dmg;
       c2Dmf: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2vcz::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dmg: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DlT_info" {
     block_c2DlT_info:
         const _c2DlT;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.657425166 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DmJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DmN; else goto c2DmO;
       c2DmN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DmO: // global
           I64[Sp - 16] = block_c2DmG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dnj; else goto c2DmH;
       u2Dnj: // global
           call _c2DmG(R1) args: 0, res: 0, upd: 0;
       c2DmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cclearBit_info" {
     GHC.Word.$fBitsWord64_$cclearBit_info:
         const GHC.Word.$fBitsWord64_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2DmG() //  [R1]
         { []
         }
     {offset
       c2DmG: // global
           I64[Sp] = block_c2DmM_info;
           _s2vcG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vcG::I64;
           if (R1 & 7 != 0) goto u2Dni; else goto c2DmQ;
       u2Dni: // global
           call _c2DmM(R1) args: 0, res: 0, upd: 0;
       c2DmQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DmG_info" {
     block_c2DmG_info:
         const _c2DmG;
         const 1;
         const 30;
 },
 _c2DmM() //  [R1]
         { []
         }
     {offset
       c2DmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DmW; else goto c2DmV;
       c2DmW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DmV: // global
           _s2vcG::I64 = I64[Sp + 8];
           _s2vcI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcI::I64, 64)) goto c2Dnb; else goto c2Dnh;
       c2Dnb: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & (1 << _s2vcI::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dnh: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2vcG::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DmM_info" {
     block_c2DmM_info:
         const _c2DmM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.66629274 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DnN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2DnR; else goto c2DnS;
       c2DnR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DnS: // global
           I64[Sp - 16] = block_c2DnK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dof; else goto c2DnL;
       u2Dof: // global
           call _c2DnK(R1) args: 0, res: 0, upd: 0;
       c2DnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$csetBit_info" {
     GHC.Word.$fBitsWord64_$csetBit_info:
         const GHC.Word.$fBitsWord64_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2DnK() //  [R1]
         { []
         }
     {offset
       c2DnK: // global
           I64[Sp - 8] = block_c2DnQ_info;
           _s2vcQ::P64 = R1;
           _s2vcR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2vcR::I64;
           P64[Sp + 8] = _s2vcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Doe; else goto c2DnU;
       u2Doe: // global
           call _c2DnQ(R1) args: 0, res: 0, upd: 0;
       c2DnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DnK_info" {
     block_c2DnK_info:
         const _c2DnK;
         const 1;
         const 30;
 },
 _c2DnQ() //  [R1]
         { []
         }
     {offset
       c2DnQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Do0; else goto c2DnZ;
       c2Do0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DnZ: // global
           _s2vcT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2vcT::I64, 64)) goto c2Doc; else goto c2Dod;
       c2Doc: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2vcT::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dod: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DnQ_info" {
     block_c2DnQ_info:
         const _c2DnQ;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.674186395 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DoD: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotateL_info" {
     GHC.Word.$fBitsWord64_$crotateL_info:
         const GHC.Word.$fBitsWord64_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.677594167 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.679671803 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.683930725 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DoT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dp2; else goto c2Dp3;
       c2Dp2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dp3: // global
           I64[Sp - 16] = block_c2DoQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dpq; else goto c2DoR;
       u2Dpq: // global
           call _c2DoQ(R1) args: 0, res: 0, upd: 0;
       c2DoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cinRange_info" {
     GHC.Word.$fIxWord64_$cinRange_info:
         const GHC.Word.$fIxWord64_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2DoQ() //  [R1]
         { []
         }
     {offset
       c2DoQ: // global
           I64[Sp - 8] = block_c2DoW_info;
           _s2vd1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vd1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dpp; else goto c2DoX;
       u2Dpp: // global
           call _c2DoW(R1) args: 0, res: 0, upd: 0;
       c2DoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DoQ_info" {
     block_c2DoQ_info:
         const _c2DoQ;
         const 1;
         const 30;
 },
 _c2DoW() //  [R1]
         { []
         }
     {offset
       c2DoW: // global
           I64[Sp] = block_c2Dp1_info;
           _s2vd3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vd3::I64;
           if (R1 & 7 != 0) goto u2Dpr; else goto c2Dp6;
       u2Dpr: // global
           call _c2Dp1(R1) args: 0, res: 0, upd: 0;
       c2Dp6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DoW_info" {
     block_c2DoW_info:
         const _c2DoW;
         const 2;
         const 30;
 },
 _c2Dp1() //  [R1]
         { []
         }
     {offset
       c2Dp1: // global
           _s2vd5::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vd5::I64) goto c2Dpe; else goto c2Dpi;
       c2Dpe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Dpi: // global
           _s2vd1::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Dph_info;
           R1 = _s2vd1::P64;
           I64[Sp + 16] = _s2vd5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2Dps; else goto c2Dpj;
       u2Dps: // global
           call _c2Dph(R1) args: 0, res: 0, upd: 0;
       c2Dpj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dp1_info" {
     block_c2Dp1_info:
         const _c2Dp1;
         const 130;
         const 30;
 },
 _c2Dph() //  [R1]
         { []
         }
     {offset
       c2Dph: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dph_info" {
     block_c2Dph_info:
         const _c2Dph;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.695654565 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2Dq0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dq1; else goto c2Dq2;
       c2Dq1: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dq2: // global
           I64[Sp - 8] = block_c2DpX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dq6; else goto c2DpY;
       u2Dq6: // global
           call _c2DpX(R1) args: 0, res: 0, upd: 0;
       c2DpY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$crange_info" {
     GHC.Word.$fIxWord64_$crange_info:
         const GHC.Word.$fIxWord64_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2vim_srt+928;
 },
 _c2DpX() //  [R1]
         { []
         }
     {offset
       c2DpX: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DpX_info" {
     block_c2DpX_info:
         const _c2DpX;
         const 0;
         const 4294967326;
         const S2vim_srt+928;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.702420148 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dqn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DqH; else goto c2DqI;
       c2DqH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2DqI: // global
           I64[Sp - 16] = block_c2Dqk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2DqP; else goto c2Dql;
       u2DqP: // global
           call _c2Dqk(R1) args: 0, res: 0, upd: 0;
       c2Dql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cunsafeIndex_info" {
     GHC.Word.$fIxWord64_$cunsafeIndex_info:
         const GHC.Word.$fIxWord64_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Dqk() //  [R1]
         { []
         }
     {offset
       c2Dqk: // global
           I64[Sp] = block_c2Dqq_info;
           _s2vdh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2vdh::P64;
           if (R1 & 7 != 0) goto u2DqO; else goto c2Dqr;
       u2DqO: // global
           call _c2Dqq(R1) args: 0, res: 0, upd: 0;
       c2Dqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dqk_info" {
     block_c2Dqk_info:
         const _c2Dqk;
         const 1;
         const 30;
 },
 _c2Dqq() //  [R1]
         { []
         }
     {offset
       c2Dqq: // global
           I64[Sp] = block_c2Dqv_info;
           _s2vdk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdk::I64;
           if (R1 & 7 != 0) goto u2DqQ; else goto c2Dqw;
       u2DqQ: // global
           call _c2Dqv(R1) args: 0, res: 0, upd: 0;
       c2Dqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dqq_info" {
     block_c2Dqq_info:
         const _c2Dqq;
         const 1;
         const 30;
 },
 _c2Dqv() //  [R1]
         { []
         }
     {offset
       c2Dqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DqN; else goto c2DqM;
       c2DqN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DqM: // global
           _s2vdo::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dqv_info" {
     block_c2Dqv_info:
         const _c2Dqv;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.712963806 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2Dri: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Drr; else goto c2Drs;
       c2Drr: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Drs: // global
           I64[Sp - 8] = block_c2Drf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DrU; else goto c2Drg;
       u2DrU: // global
           call _c2Drf(R1) args: 0, res: 0, upd: 0;
       c2Drg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$crangeSize_info" {
     GHC.Word.$fIxWord64_$crangeSize_info:
         const GHC.Word.$fIxWord64_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Drf() //  [R1]
         { []
         }
     {offset
       c2Drf: // global
           I64[Sp - 8] = block_c2Drl_info;
           _s2vds::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vds::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DrT; else goto c2Drm;
       u2DrT: // global
           call _c2Drl(R1) args: 0, res: 0, upd: 0;
       c2Drm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Drf_info" {
     block_c2Drf_info:
         const _c2Drf;
         const 0;
         const 30;
 },
 _c2Drl() //  [R1]
         { []
         }
     {offset
       c2Drl: // global
           I64[Sp] = block_c2Drq_info;
           _s2vdu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdu::I64;
           if (R1 & 7 != 0) goto u2DrV; else goto c2Drv;
       u2DrV: // global
           call _c2Drq(R1) args: 0, res: 0, upd: 0;
       c2Drv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Drl_info" {
     block_c2Drl_info:
         const _c2Drl;
         const 1;
         const 30;
 },
 _c2Drq() //  [R1]
         { []
         }
     {offset
       c2Drq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DrB; else goto c2DrA;
       c2DrB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DrA: // global
           _s2vdu::I64 = I64[Sp + 8];
           _s2vdw::I64 = I64[R1 + 7];
           if (_s2vdu::I64 > _s2vdw::I64) goto c2DrF; else goto c2DrS;
       c2DrF: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2DrS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdw::I64 - _s2vdu::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Drq_info" {
     block_c2Drq_info:
         const _c2Drq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.723606579 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2Dsp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2DsM; else goto c2DsN;
       c2DsM: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DsN: // global
           I64[Sp - 8] = block_c2Dsm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DsU; else goto c2Dsn;
       u2DsU: // global
           call _c2Dsm(R1) args: 0, res: 0, upd: 0;
       c2Dsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Dsm() //  [R1]
         { []
         }
     {offset
       c2Dsm: // global
           I64[Sp - 8] = block_c2Dss_info;
           _s2vdD::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2vdD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2DsT; else goto c2Dst;
       u2DsT: // global
           call _c2Dss(R1) args: 0, res: 0, upd: 0;
       c2Dst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dsm_info" {
     block_c2Dsm_info:
         const _c2Dsm;
         const 0;
         const 30;
 },
 _c2Dss() //  [R1]
         { []
         }
     {offset
       c2Dss: // global
           I64[Sp] = block_c2Dsx_info;
           _s2vdG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdG::I64;
           if (R1 & 7 != 0) goto u2DsV; else goto c2Dsy;
       u2DsV: // global
           call _c2Dsx(R1) args: 0, res: 0, upd: 0;
       c2Dsy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dss_info" {
     block_c2Dss_info:
         const _c2Dss;
         const 1;
         const 30;
 },
 _c2Dsx() //  [R1]
         { []
         }
     {offset
       c2Dsx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DsS; else goto c2DsR;
       c2DsS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DsR: // global
           _s2vdL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dsx_info" {
     block_c2Dsx_info:
         const _c2Dsx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.734484189 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Dto: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Dtx; else goto c2Dty;
       c2Dtx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Dty: // global
           I64[Sp - 16] = block_c2Dtl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Dua; else goto c2Dtm;
       u2Dua: // global
           call _c2Dtl(R1) args: 0, res: 0, upd: 0;
       c2Dtm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cindex_info" {
     GHC.Word.$fIxWord64_$cindex_info:
         const GHC.Word.$fIxWord64_$cindex_entry;
         const 0;
         const 9007203549708302;
         const 8589934607;
         const S2vim_srt+776;
 },
 _c2Dtl() //  [R1]
         { []
         }
     {offset
       c2Dtl: // global
           I64[Sp - 8] = block_c2Dtr_info;
           _s2vdQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2vdQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Du9; else goto c2Dts;
       u2Du9: // global
           call _c2Dtr(R1) args: 0, res: 0, upd: 0;
       c2Dts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dtl_info" {
     block_c2Dtl_info:
         const _c2Dtl;
         const 1;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Dtr() //  [R1]
         { []
         }
     {offset
       c2Dtr: // global
           I64[Sp] = block_c2Dtw_info;
           _s2vdS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2vdS::I64;
           if (R1 & 7 != 0) goto u2Dub; else goto c2DtB;
       u2Dub: // global
           call _c2Dtw(R1) args: 0, res: 0, upd: 0;
       c2DtB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dtr_info" {
     block_c2Dtr_info:
         const _c2Dtr;
         const 2;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2Dtw() //  [R1]
         { []
         }
     {offset
       c2Dtw: // global
           _s2vdU::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2vdU::I64) goto c2DtJ; else goto c2DtN;
       c2DtJ: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2DtN: // global
           I64[Sp] = block_c2DtM_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2vdU::I64;
           if (R1 & 7 != 0) goto u2Duc; else goto c2DtO;
       u2Duc: // global
           call _c2DtM(R1) args: 0, res: 0, upd: 0;
       c2DtO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dtw_info" {
     block_c2Dtw_info:
         const _c2Dtw;
         const 130;
         const 4294967326;
         const S2vim_srt+776;
 },
 _c2DtM() //  [R1]
         { []
         }
     {offset
       c2DtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DtU; else goto c2DtT;
       c2DtU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2DtT: // global
           _s2vdU::I64 = I64[Sp + 8];
           if (_s2vdU::I64 > I64[R1 + 7]) goto c2DtY; else goto c2Du8;
       c2DtY: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Du8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2vdU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2DtM_info" {
     block_c2DtM_info:
         const _c2DtM;
         const 194;
         const 4294967326;
         const S2vim_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.745344544 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.747535342 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DuJ: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.uncheckedShiftL64#_info" {
     GHC.Word.uncheckedShiftL64#_info:
         const GHC.Word.uncheckedShiftL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.751058079 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c2DuX: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.uncheckedShiftRL64#_info" {
     GHC.Word.uncheckedShiftRL64#_info:
         const GHC.Word.uncheckedShiftRL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.756062202 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { []
         }
     {offset
       c2Dvd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Dvl; else goto c2Dvm;
       c2Dvl: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dvm: // global
           I64[Sp - 8] = block_c2Dva_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Dvq; else goto c2Dvb;
       u2Dvq: // global
           call _c2Dva(R1) args: 0, res: 0, upd: 0;
       c2Dvb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap64_info" {
     GHC.Word.byteSwap64_info:
         const GHC.Word.byteSwap64_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Dva() //  [R1]
         { []
         }
     {offset
       c2Dva: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dvp; else goto c2Dvo;
       c2Dvp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Dvo: // global
           (_c2Dvg::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2Dvg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Dva_info" {
     block_c2Dva_info:
         const _c2Dva;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.761093937 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.762791936 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.764459191 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.767242389 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.769063854 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.770836336 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.772490757 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.774294776 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.776084414 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.778026483 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.780234283 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.781995979 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.783764655 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.785628086 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.787389439 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.789383128 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.791643328 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.7934599 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.795132604 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.796883057 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.799065801 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.800800984 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.802822828 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.805037447 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.80677742 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.808439581 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.810267241 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.812147243 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.814412244 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.816706136 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.818465099 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.820206853 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.821983159 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.823762104 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.82686161 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { []
         }
     {offset
       c2Dwe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dwi; else goto c2Dwh;
       c2Dwi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dwh: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W8#_info" {
     GHC.Word.W8#_info:
         const GHC.Word.W8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.831339977 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { []
         }
     {offset
       c2Dwt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dwx; else goto c2Dww;
       c2Dwx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dww: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W16#_info" {
     GHC.Word.W16#_info:
         const GHC.Word.W16#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.835053396 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { []
         }
     {offset
       c2DwI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2DwM; else goto c2DwL;
       c2DwM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2DwL: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W32#_info" {
     GHC.Word.W32#_info:
         const GHC.Word.W32#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.838776935 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { []
         }
     {offset
       c2DwX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Dx1; else goto c2Dx0;
       c2Dx1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Dx0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W64#_info" {
     GHC.Word.W64#_info:
         const GHC.Word.W64#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.843213377 UTC

[section ""cstring" . i2zXT_str" {
     i2zXT_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]
 },
 GHC.Word.W8#_con_entry() //  [R1]
         { []
         }
     {offset
       c2Dx7: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W8#_con_info" {
     GHC.Word.W8#_con_info:
         const GHC.Word.W8#_con_entry;
         const 4294967296;
         const 3;
         const i2zXT_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.846348309 UTC

[section ""cstring" . i2zXV_str" {
     i2zXV_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]
 },
 GHC.Word.W16#_con_entry() //  [R1]
         { []
         }
     {offset
       c2Dxd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W16#_con_info" {
     GHC.Word.W16#_con_info:
         const GHC.Word.W16#_con_entry;
         const 4294967296;
         const 3;
         const i2zXV_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.849518577 UTC

[section ""cstring" . i2zXX_str" {
     i2zXX_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]
 },
 GHC.Word.W32#_con_entry() //  [R1]
         { []
         }
     {offset
       c2Dxj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W32#_con_info" {
     GHC.Word.W32#_con_info:
         const GHC.Word.W32#_con_entry;
         const 4294967296;
         const 3;
         const i2zXX_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.85269354 UTC

[section ""cstring" . i2zXZ_str" {
     i2zXZ_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]
 },
 GHC.Word.W64#_con_entry() //  [R1]
         { []
         }
     {offset
       c2Dxp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W64#_con_info" {
     GHC.Word.W64#_con_info:
         const GHC.Word.W64#_con_entry;
         const 4294967296;
         const 3;
         const i2zXZ_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:13.856966625 UTC

[section ""relreadonly" . S2vim_srt" {
     S2vim_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2uHi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.610464862 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:57:22.612613947 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cfromEnum_closure" {
     GHC.Word.$fEnumWord8_$cfromEnum_closure:
         const GHC.Word.$fEnumWord8_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord8_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2E5P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E5W; else goto c2E5X;
       c2E5W: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E5X: // global
           I64[Sp - 8] = block_c2E5M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E61; else goto c2E5N;
       u2E61: // global
           call _c2E5M(R1) args: 0, res: 0, upd: 0;
       c2E5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cfromEnum_info" {
     GHC.Word.$fEnumWord8_$cfromEnum_info:
         const GHC.Word.$fEnumWord8_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2E5M() //  [R1]
         { []
         }
     {offset
       c2E5M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E60; else goto c2E5Z;
       c2E60: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E5Z: // global
           _s2Dxz::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2Dxz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E5M_info" {
     block_c2E5M_info:
         const _c2E5M;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.618690733 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cfromEnum_closure" {
     GHC.Word.$fEnumWord16_$cfromEnum_closure:
         const GHC.Word.$fEnumWord16_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord16_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2E6l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E6s; else goto c2E6t;
       c2E6s: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E6t: // global
           I64[Sp - 8] = block_c2E6i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E6x; else goto c2E6j;
       u2E6x: // global
           call _c2E6i(R1) args: 0, res: 0, upd: 0;
       c2E6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cfromEnum_info" {
     GHC.Word.$fEnumWord16_$cfromEnum_info:
         const GHC.Word.$fEnumWord16_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2E6i() //  [R1]
         { []
         }
     {offset
       c2E6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E6w; else goto c2E6v;
       c2E6w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E6v: // global
           _s2DxD::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DxD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E6i_info" {
     block_c2E6i_info:
         const _c2E6i;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.624730544 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cfromEnum_closure" {
     GHC.Word.$fEnumWord32_$cfromEnum_closure:
         const GHC.Word.$fEnumWord32_$cfromEnum_info;
 },
 GHC.Word.$fEnumWord32_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2E6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E6Y; else goto c2E6Z;
       c2E6Y: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E6Z: // global
           I64[Sp - 8] = block_c2E6O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E73; else goto c2E6P;
       u2E73: // global
           call _c2E6O(R1) args: 0, res: 0, upd: 0;
       c2E6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cfromEnum_info" {
     GHC.Word.$fEnumWord32_$cfromEnum_info:
         const GHC.Word.$fEnumWord32_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2E6O() //  [R1]
         { []
         }
     {offset
       c2E6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E72; else goto c2E71;
       c2E72: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E71: // global
           _s2DxH::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DxH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E6O_info" {
     block_c2E6O_info:
         const _c2E6O;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.631905231 UTC

[section ""data" . GHC.Word.$fNumWord64_$cfromInteger_closure" {
     GHC.Word.$fNumWord64_$cfromInteger_closure:
         const GHC.Word.$fNumWord64_$cfromInteger_info;
 },
 GHC.Word.$fNumWord64_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2E7m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E7q; else goto c2E7r;
       c2E7q: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E7r: // global
           I64[Sp - 8] = block_c2E7k_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cfromInteger_info" {
     GHC.Word.$fNumWord64_$cfromInteger_info:
         const GHC.Word.$fNumWord64_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2E7k() //  [R1]
         { []
         }
     {offset
       c2E7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E7u; else goto c2E7t;
       c2E7u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2E7t: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E7k_info" {
     block_c2E7k_info:
         const _c2E7k;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.637266591 UTC

[section ""data" . GHC.Word.$fNumWord64_$cabs_closure" {
     GHC.Word.$fNumWord64_$cabs_closure:
         const GHC.Word.$fNumWord64_$cabs_info;
 },
 GHC.Word.$fNumWord64_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2E7K: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cabs_info" {
     GHC.Word.$fNumWord64_$cabs_info:
         const GHC.Word.$fNumWord64_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.641123603 UTC

[section ""data" . GHC.Word.$fNumWord64_$cnegate_closure" {
     GHC.Word.$fNumWord64_$cnegate_closure:
         const GHC.Word.$fNumWord64_$cnegate_info;
 },
 GHC.Word.$fNumWord64_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2E80: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2E8d; else goto c2E8e;
       c2E8d: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2E8e: // global
           I64[Sp - 8] = block_c2E7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2E8i; else goto c2E7Y;
       u2E8i: // global
           call _c2E7X(R1) args: 0, res: 0, upd: 0;
       c2E7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$cnegate_info" {
     GHC.Word.$fNumWord64_$cnegate_info:
         const GHC.Word.$fNumWord64_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2E7X() //  [R1]
         { []
         }
     {offset
       c2E7X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E8h; else goto c2E8g;
       c2E8h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E8g: // global
           _s2DxQ::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DxQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E7X_info" {
     block_c2E7X_info:
         const _c2E7X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.647737717 UTC

[section ""data" . GHC.Word.$fNumWord64_$c*_closure" {
     GHC.Word.$fNumWord64_$c*_closure:
         const GHC.Word.$fNumWord64_$c*_info;
 },
 GHC.Word.$fNumWord64_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2E8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2E8O; else goto c2E8P;
       c2E8O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2E8P: // global
           I64[Sp - 16] = block_c2E8z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2E8V; else goto c2E8A;
       u2E8V: // global
           call _c2E8z(R1) args: 0, res: 0, upd: 0;
       c2E8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c*_info" {
     GHC.Word.$fNumWord64_$c*_info:
         const GHC.Word.$fNumWord64_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2E8z() //  [R1]
         { []
         }
     {offset
       c2E8z: // global
           I64[Sp] = block_c2E8F_info;
           _s2DxU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DxU::I64;
           if (R1 & 7 != 0) goto u2E8U; else goto c2E8G;
       u2E8U: // global
           call _c2E8F(R1) args: 0, res: 0, upd: 0;
       c2E8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E8z_info" {
     block_c2E8z_info:
         const _c2E8z;
         const 1;
         const 30;
 },
 _c2E8F() //  [R1]
         { []
         }
     {offset
       c2E8F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E8T; else goto c2E8S;
       c2E8T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E8S: // global
           _s2DxX::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DxX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E8F_info" {
     block_c2E8F_info:
         const _c2E8F;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.655595927 UTC

[section ""data" . GHC.Word.$fNumWord64_$c-_closure" {
     GHC.Word.$fNumWord64_$c-_closure:
         const GHC.Word.$fNumWord64_$c-_info;
 },
 GHC.Word.$fNumWord64_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2E9m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2E9y; else goto c2E9z;
       c2E9y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2E9z: // global
           I64[Sp - 16] = block_c2E9j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2E9F; else goto c2E9k;
       u2E9F: // global
           call _c2E9j(R1) args: 0, res: 0, upd: 0;
       c2E9k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c-_info" {
     GHC.Word.$fNumWord64_$c-_info:
         const GHC.Word.$fNumWord64_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2E9j() //  [R1]
         { []
         }
     {offset
       c2E9j: // global
           I64[Sp] = block_c2E9p_info;
           _s2Dy1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dy1::I64;
           if (R1 & 7 != 0) goto u2E9E; else goto c2E9q;
       u2E9E: // global
           call _c2E9p(R1) args: 0, res: 0, upd: 0;
       c2E9q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E9j_info" {
     block_c2E9j_info:
         const _c2E9j;
         const 1;
         const 30;
 },
 _c2E9p() //  [R1]
         { []
         }
     {offset
       c2E9p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2E9D; else goto c2E9C;
       c2E9D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2E9C: // global
           _s2Dy4::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2Dy4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2E9p_info" {
     block_c2E9p_info:
         const _c2E9p;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.663538163 UTC

[section ""data" . GHC.Word.$fNumWord64_$c+_closure" {
     GHC.Word.$fNumWord64_$c+_closure:
         const GHC.Word.$fNumWord64_$c+_info;
 },
 GHC.Word.$fNumWord64_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Ea6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eai; else goto c2Eaj;
       c2Eai: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Eaj: // global
           I64[Sp - 16] = block_c2Ea3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Eap; else goto c2Ea4;
       u2Eap: // global
           call _c2Ea3(R1) args: 0, res: 0, upd: 0;
       c2Ea4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$c+_info" {
     GHC.Word.$fNumWord64_$c+_info:
         const GHC.Word.$fNumWord64_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Ea3() //  [R1]
         { []
         }
     {offset
       c2Ea3: // global
           I64[Sp] = block_c2Ea9_info;
           _s2Dy8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dy8::I64;
           if (R1 & 7 != 0) goto u2Eao; else goto c2Eaa;
       u2Eao: // global
           call _c2Ea9(R1) args: 0, res: 0, upd: 0;
       c2Eaa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ea3_info" {
     block_c2Ea3_info:
         const _c2Ea3;
         const 1;
         const 30;
 },
 _c2Ea9() //  [R1]
         { []
         }
     {offset
       c2Ea9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ean; else goto c2Eam;
       c2Ean: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Eam: // global
           _s2Dyb::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2Dyb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ea9_info" {
     block_c2Ea9_info:
         const _c2Ea9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.670535831 UTC

[section ""cstring" . GHC.Word.$tcWord6_bytes" {
     GHC.Word.$tcWord6_bytes:
         I8[] [87,111,114,100,54,52]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.67285018 UTC

[section ""data" . lvl_r2uFF_closure" {
     lvl_r2uFF_closure:
         const lvl_r2uFF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r2uFF_entry() //  [R1]
         { []
         }
     {offset
       c2EaQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EaR; else goto c2EaS;
       c2EaR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EaS: // global
           (_c2EaN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EaN::I64 == 0) goto c2EaP; else goto c2EaO;
       c2EaP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EaO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EaN::I64;
           R2 = GHC.Word.$tcWord6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r2uFF_info" {
     lvl_r2uFF_info:
         const lvl_r2uFF_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.677434539 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$ctoInteger_closure" {
     GHC.Word.$fIntegralWord64_$ctoInteger_closure:
         const GHC.Word.$fIntegralWord64_$ctoInteger_info;
 },
 GHC.Word.$fIntegralWord64_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c2Eb8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Eb9; else goto c2Eba;
       c2Eb9: // global
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eba: // global
           I64[Sp - 8] = block_c2Eb5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ebm; else goto c2Eb6;
       u2Ebm: // global
           call _c2Eb5(R1) args: 0, res: 0, upd: 0;
       c2Eb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$ctoInteger_info" {
     GHC.Word.$fIntegralWord64_$ctoInteger_info:
         const GHC.Word.$fIntegralWord64_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Eb5() //  [R1]
         { []
         }
     {offset
       c2Eb5: // global
           _s2Dye::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2Dye::I64, 0)) goto c2Ebk; else goto c2Ebl;
       c2Ebk: // global
           R2 = _s2Dye::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 0, upd: 8;
       c2Ebl: // global
           R2 = _s2Dye::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Eb5_info" {
     block_c2Eb5_info:
         const _c2Eb5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.684596629 UTC

[section ""data" . GHC.Word.$fShowWord3_closure" {
     GHC.Word.$fShowWord3_closure:
         const GHC.Word.$fShowWord3_info;
         const 0;
 },
 w1_s2Dyi_entry() //  [R1]
         { []
         }
     {offset
       c2EbI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EbJ; else goto c2EbK;
       c2EbJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EbK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2EbF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EbW; else goto c2EbG;
       u2EbW: // global
           call _c2EbF(R1) args: 0, res: 0, upd: 0;
       c2EbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . w1_s2Dyi_info" {
     w1_s2Dyi_info:
         const w1_s2Dyi_entry;
         const 1;
         const 16;
 },
 _c2EbF() //  [R1]
         { []
         }
     {offset
       c2EbF: // global
           _s2Dyk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2Dyk::I64, 0)) goto c2EbU; else goto c2EbV;
       c2EbU: // global
           R2 = _s2Dyk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2EbV: // global
           R2 = _s2Dyk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EbF_info" {
     block_c2EbF_info:
         const _c2EbF;
         const 0;
         const 30;
 },
 sat_s2Dyr_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Ec5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ec6; else goto c2Ec7;
       c2Ec6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ec7: // global
           I64[Sp - 8] = block_c2Ec2_info;
           R4 = R2;
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s2Dyr_info" {
     sat_s2Dyr_info:
         const sat_s2Dyr_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S2Ecg_srt;
 },
 _c2Ec2() //  [R1, R2]
         { []
         }
     {offset
       c2Ec2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Eca; else goto c2Ec9;
       c2Eca: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ec9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ec2_info" {
     block_c2Ec2_info:
         const _c2Ec2;
         const 0;
         const 30;
 },
 GHC.Word.$fShowWord3_entry() //  [R2]
         { []
         }
     {offset
       c2Ecb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c2Ecf; else goto c2Ece;
       c2Ecf: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Word.$fShowWord3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ece: // global
           I64[Hp - 32] = w1_s2Dyi_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s2Dyr_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord3_info" {
     GHC.Word.$fShowWord3_info:
         const GHC.Word.$fShowWord3_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.694956646 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowList_closure" {
     GHC.Word.$fShowWord64_$cshowList_closure:
         const GHC.Word.$fShowWord64_$cshowList_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EcN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord3_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshowList_info" {
     GHC.Word.$fShowWord64_$cshowList_info:
         const GHC.Word.$fShowWord64_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2Ecg_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.6992179 UTC

[section ""data" . GHC.Word.$w$cshow_closure" {
     GHC.Word.$w$cshow_closure:
         const GHC.Word.$w$cshow_info;
         const 0;
 },
 GHC.Word.$w$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2Ed0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ed1; else goto c2Ed2;
       c2Ed1: // global
           R2 = R2;
           R1 = GHC.Word.$w$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ed2: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2Ed9; else goto c2Edg;
       c2Ed9: // global
           I64[Sp - 8] = block_c2Ed7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2Edg: // global
           I64[Sp - 8] = block_c2Edf_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cshow_info" {
     GHC.Word.$w$cshow_info:
         const GHC.Word.$w$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967300;
         const S2Ecg_srt;
 },
 _c2Ed7() //  [R1]
         { []
         }
     {offset
       c2Ed7: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ed7_info" {
     block_c2Ed7_info:
         const _c2Ed7;
         const 0;
         const 4294967326;
         const S2Ecg_srt;
 },
 _c2Edf() //  [R1]
         { []
         }
     {offset
       c2Edf: // global
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Edf_info" {
     block_c2Edf_info:
         const _c2Edf;
         const 0;
         const 4294967326;
         const S2Ecg_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.707471968 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshow_closure" {
     GHC.Word.$fShowWord64_$cshow_closure:
         const GHC.Word.$fShowWord64_$cshow_info;
         const 0;
 },
 GHC.Word.$fShowWord64_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2EdH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EdN; else goto c2EdO;
       c2EdN: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EdO: // global
           I64[Sp - 8] = block_c2EdE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EdT; else goto c2EdF;
       u2EdT: // global
           call _c2EdE(R1) args: 0, res: 0, upd: 0;
       c2EdF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshow_info" {
     GHC.Word.$fShowWord64_$cshow_info:
         const GHC.Word.$fShowWord64_$cshow_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+16;
 },
 _c2EdE() //  [R1]
         { []
         }
     {offset
       c2EdE: // global
           I64[Sp] = block_c2EdK_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$cshow_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EdE_info" {
     block_c2EdE_info:
         const _c2EdE;
         const 0;
         const 4294967326;
         const S2Ecg_srt+16;
 },
 _c2EdK() //  [R1, R2]
         { []
         }
     {offset
       c2EdK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EdS; else goto c2EdR;
       c2EdS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EdR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EdK_info" {
     block_c2EdK_info:
         const _c2EdK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.716689593 UTC

[section ""data" . GHC.Word.$fShowWord64_$cshowsPrec_closure" {
     GHC.Word.$fShowWord64_$cshowsPrec_closure:
         const GHC.Word.$fShowWord64_$cshowsPrec_info;
         const 0;
 },
 w1_s2DyH_entry() //  [R1]
         { []
         }
     {offset
       c2Eel: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Eem; else goto c2Een;
       c2Eem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Een: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c2Eei_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Eez; else goto c2Eej;
       u2Eez: // global
           call _c2Eei(R1) args: 0, res: 0, upd: 0;
       c2Eej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . w1_s2DyH_info" {
     w1_s2DyH_info:
         const w1_s2DyH_entry;
         const 1;
         const 16;
 },
 _c2Eei() //  [R1]
         { []
         }
     {offset
       c2Eei: // global
           _s2DyJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DyJ::I64, 0)) goto c2Eex; else goto c2Eey;
       c2Eex: // global
           R2 = _s2DyJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       c2Eey: // global
           R2 = _s2DyJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2Eei_info" {
     block_c2Eei_info:
         const _c2Eei;
         const 0;
         const 30;
 },
 sat_s2DyS_entry() //  [R1, R2]
         { []
         }
     {offset
       c2EeI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EeO; else goto c2EeP;
       c2EeO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EeP: // global
           I64[Sp - 24] = block_c2EeF_info;
           _s2DyH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s2DyH::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EeU; else goto c2EeG;
       u2EeU: // global
           call _c2EeF(R1) args: 0, res: 0, upd: 0;
       c2EeG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s2DyS_info" {
     sat_s2DyS_info:
         const sat_s2DyS_entry;
         const 2;
         const 4294967307;
         const 4294967301;
         const S2Ecg_srt;
 },
 _c2EeF() //  [R1]
         { []
         }
     {offset
       c2EeF: // global
           _s2DyM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EeL_info;
           R4 = _s2DyM::P64;
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EeF_info" {
     block_c2EeF_info:
         const _c2EeF;
         const 2;
         const 4294967326;
         const S2Ecg_srt;
 },
 _c2EeL() //  [R1, R2]
         { []
         }
     {offset
       c2EeL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EeT; else goto c2EeS;
       c2EeT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EeS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EeL_info" {
     block_c2EeL_info:
         const _c2EeL;
         const 0;
         const 30;
 },
 GHC.Word.$fShowWord64_$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EeV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EeZ; else goto c2EeY;
       c2EeZ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord64_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EeY: // global
           I64[Hp - 40] = w1_s2DyH_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s2DyS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord64_$cshowsPrec_info" {
     GHC.Word.$fShowWord64_$cshowsPrec_info:
         const GHC.Word.$fShowWord64_$cshowsPrec_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S2Ecg_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.728647241 UTC

[section ""data" . GHC.Word.$fShowWord64_closure" {
     GHC.Word.$fShowWord64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure+2;
         const GHC.Word.$fShowWord64_$cshow_closure+1;
         const GHC.Word.$fShowWord64_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.731003253 UTC

[section ""data" . GHC.Word.$fEnumWord5_closure" {
     GHC.Word.$fEnumWord5_closure:
         const GHC.Word.$fEnumWord5_info;
         const 0;
 },
 GHC.Word.$fEnumWord5_entry() //  [R2]
         { []
         }
     {offset
       c2EfC: // global
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.fromEnumError_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord5_info" {
     GHC.Word.$fEnumWord5_info:
         const GHC.Word.$fEnumWord5_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const S2Ecg_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.734276079 UTC

[section ""data" . sat_s2DyU_closure" {
     sat_s2DyU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.736064611 UTC

[section ""data" . sat_s2DyV_closure" {
     sat_s2DyV_closure:
         const :_con_info;
         const sat_s2DyU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.738846242 UTC

[section ""data" . GHC.Word.$fRealWord1_closure" {
     GHC.Word.$fRealWord1_closure:
         const GHC.Word.$fRealWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fRealWord1_entry() //  [R1]
         { []
         }
     {offset
       c2EfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EfS; else goto c2EfT;
       c2EfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EfT: // global
           (_c2EfO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EfO::I64 == 0) goto c2EfQ; else goto c2EfP;
       c2EfQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EfP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EfO::I64;
           R3 = sat_s2DyV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord1_info" {
     GHC.Word.$fRealWord1_info:
         const GHC.Word.$fRealWord1_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.74431617 UTC

[section ""data" . GHC.Word.$w$ctoRational_closure" {
     GHC.Word.$w$ctoRational_closure:
         const GHC.Word.$w$ctoRational_info;
         const 0;
 },
 GHC.Word.$w$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2Eg9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ega; else goto c2Egb;
       c2Ega: // global
           R2 = R2;
           R1 = GHC.Word.$w$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Egb: // global
           if (%MO_S_Lt_W64(R2, 0)) goto c2Egm; else goto c2Egy;
       c2Egm: // global
           I64[Sp - 8] = block_c2Egg_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 8, res: 8, upd: 8;
       c2Egy: // global
           I64[Sp - 8] = block_c2Egt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoRational_info" {
     GHC.Word.$w$ctoRational_info:
         const GHC.Word.$w$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967300;
         const S2Ecg_srt+72;
 },
 _c2Egg() //  [R1]
         { []
         }
     {offset
       c2Egg: // global
           I64[Sp] = block_c2Egk_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Egg_info" {
     block_c2Egg_info:
         const _c2Egg;
         const 0;
         const 30064771102;
         const S2Ecg_srt+72;
 },
 _c2Egk() //  [R1]
         { []
         }
     {offset
       c2Egk: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Egk_info" {
     block_c2Egk_info:
         const _c2Egk;
         const 0;
         const 12884901918;
         const S2Ecg_srt+80;
 },
 _c2Egt() //  [R1]
         { []
         }
     {offset
       c2Egt: // global
           I64[Sp] = block_c2Egx_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Egt_info" {
     block_c2Egt_info:
         const _c2Egt;
         const 0;
         const 30064771102;
         const S2Ecg_srt+72;
 },
 _c2Egx() //  [R1]
         { []
         }
     {offset
       c2Egx: // global
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Egx_info" {
     block_c2Egx_info:
         const _c2Egx;
         const 0;
         const 12884901918;
         const S2Ecg_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.754662275 UTC

[section ""data" . GHC.Word.$fRealWord64_$ctoRational_closure" {
     GHC.Word.$fRealWord64_$ctoRational_closure:
         const GHC.Word.$fRealWord64_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord64_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2Eh6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ehc; else goto c2Ehd;
       c2Ehc: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ehd: // global
           I64[Sp - 8] = block_c2Eh3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ehi; else goto c2Eh4;
       u2Ehi: // global
           call _c2Eh3(R1) args: 0, res: 0, upd: 0;
       c2Eh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord64_$ctoRational_info" {
     GHC.Word.$fRealWord64_$ctoRational_info:
         const GHC.Word.$fRealWord64_$ctoRational_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+96;
 },
 _c2Eh3() //  [R1]
         { []
         }
     {offset
       c2Eh3: // global
           I64[Sp] = block_c2Eh9_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoRational_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Eh3_info" {
     block_c2Eh3_info:
         const _c2Eh3;
         const 0;
         const 4294967326;
         const S2Ecg_srt+96;
 },
 _c2Eh9() //  [R1, R2]
         { []
         }
     {offset
       c2Eh9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Ehh; else goto c2Ehg;
       c2Ehh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ehg: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Eh9_info" {
     block_c2Eh9_info:
         const _c2Eh9;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.761278679 UTC

[section ""cstring" . GHC.Word.$tcWord9_bytes" {
     GHC.Word.$tcWord9_bytes:
         I8[] [87,111,114,100,56]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.763727659 UTC

[section ""data" . GHC.Word.$fEnumWord10_closure" {
     GHC.Word.$fEnumWord10_closure:
         const GHC.Word.$fEnumWord10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord10_entry() //  [R1]
         { []
         }
     {offset
       c2EhI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EhJ; else goto c2EhK;
       c2EhJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EhK: // global
           (_c2EhD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EhD::I64 == 0) goto c2EhF; else goto c2EhE;
       c2EhF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EhE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EhD::I64;
           I64[Sp - 24] = block_c2EhG_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord10_info" {
     GHC.Word.$fEnumWord10_info:
         const GHC.Word.$fEnumWord10_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+112;
 },
 _c2EhG() //  [R1]
         { []
         }
     {offset
       c2EhG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EhG_info" {
     block_c2EhG_info:
         const _c2EhG;
         const 0;
         const 4294967326;
         const S2Ecg_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.769705727 UTC

[section ""data" . GHC.Word.$fEnumWord11_closure" {
     GHC.Word.$fEnumWord11_closure:
         const GHC.Word.$fEnumWord11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord11_entry() //  [R1]
         { []
         }
     {offset
       c2Ei8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Ei9; else goto c2Eia;
       c2Ei9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eia: // global
           (_c2Ei3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Ei3::I64 == 0) goto c2Ei5; else goto c2Ei4;
       c2Ei5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Ei4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Ei3::I64;
           I64[Sp - 24] = block_c2Ei6_info;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord11_info" {
     GHC.Word.$fEnumWord11_info:
         const GHC.Word.$fEnumWord11_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+120;
 },
 _c2Ei6() //  [R1]
         { []
         }
     {offset
       c2Ei6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2Ei6_info" {
     block_c2Ei6_info:
         const _c2Ei6;
         const 0;
         const 4294967326;
         const S2Ecg_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.776202885 UTC

[section ""data" . GHC.Word.neWord8_closure" {
     GHC.Word.neWord8_closure:
         const GHC.Word.neWord8_info;
 },
 GHC.Word.neWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Eix: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EiB; else goto c2EiC;
       c2EiB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EiC: // global
           I64[Sp - 16] = block_c2Eiu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EiL; else goto c2Eiv;
       u2EiL: // global
           call _c2Eiu(R1) args: 0, res: 0, upd: 0;
       c2Eiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord8_info" {
     GHC.Word.neWord8_info:
         const GHC.Word.neWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Eiu() //  [R1]
         { []
         }
     {offset
       c2Eiu: // global
           I64[Sp] = block_c2EiA_info;
           _s2Dze::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dze::I64;
           if (R1 & 7 != 0) goto u2EiK; else goto c2EiE;
       u2EiK: // global
           call _c2EiA(R1) args: 0, res: 0, upd: 0;
       c2EiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Eiu_info" {
     block_c2Eiu_info:
         const _c2Eiu;
         const 1;
         const 30;
 },
 _c2EiA() //  [R1]
         { []
         }
     {offset
       c2EiA: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EiA_info" {
     block_c2EiA_info:
         const _c2EiA;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.78330036 UTC

[section ""data" . lvl2_r2uFH_closure" {
     lvl2_r2uFH_closure:
         const lvl2_r2uFH_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r2uFH_entry() //  [R1]
         { []
         }
     {offset
       c2Ejc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ejd; else goto c2Eje;
       c2Ejd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eje: // global
           (_c2Ej9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Ej9::I64 == 0) goto c2Ejb; else goto c2Eja;
       c2Ejb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Eja: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Ej9::I64;
           R2 = GHC.Word.$tcWord9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_r2uFH_info" {
     lvl2_r2uFH_info:
         const lvl2_r2uFH_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.786774127 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cminBound_closure" {
     GHC.Word.$fBitsWord8_$cminBound_closure:
         const GHC.Word.W8#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.790186579 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cpred_closure" {
     GHC.Word.$fEnumWord8_$cpred_closure:
         const GHC.Word.$fEnumWord8_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2Ejv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ejw; else goto c2Ejx;
       c2Ejw: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ejx: // global
           I64[Sp - 8] = block_c2Ejs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EjP; else goto c2Ejt;
       u2EjP: // global
           call _c2Ejs(R1) args: 0, res: 0, upd: 0;
       c2Ejt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cpred_info" {
     GHC.Word.$fEnumWord8_$cpred_info:
         const GHC.Word.$fEnumWord8_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+128;
 },
 _c2Ejs() //  [R1]
         { []
         }
     {offset
       c2Ejs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EjC; else goto c2EjB;
       c2EjC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EjB: // global
           _s2Dzl::I64 = I64[R1 + 7];
           if (_s2Dzl::I64 != 0) goto c2EjN; else goto c2EjO;
       c2EjN: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2Dzl::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EjO: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ejs_info" {
     block_c2Ejs_info:
         const _c2Ejs;
         const 0;
         const 4294967326;
         const S2Ecg_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.795493764 UTC

[section ""data" . GHC.Word.$fBoundedWord8_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord8_$cmaxBound_closure:
         const GHC.Word.W8#_con_info;
         const 255;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.797336472 UTC

[section ""data" . GHC.Word.$fBoundedWord8_closure" {
     GHC.Word.$fBoundedWord8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.800164279 UTC

[section ""data" . GHC.Word.$fEnumWord8_$csucc_closure" {
     GHC.Word.$fEnumWord8_$csucc_closure:
         const GHC.Word.$fEnumWord8_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2Eke: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Ekf; else goto c2Ekg;
       c2Ekf: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ekg: // global
           I64[Sp - 8] = block_c2Ekb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Eky; else goto c2Ekc;
       u2Eky: // global
           call _c2Ekb(R1) args: 0, res: 0, upd: 0;
       c2Ekc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$csucc_info" {
     GHC.Word.$fEnumWord8_$csucc_info:
         const GHC.Word.$fEnumWord8_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+144;
 },
 _c2Ekb() //  [R1]
         { []
         }
     {offset
       c2Ekb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ekl; else goto c2Ekk;
       c2Ekl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ekk: // global
           _s2Dzr::I64 = I64[R1 + 7];
           if (_s2Dzr::I64 != 255) goto c2Ekw; else goto c2Ekx;
       c2Ekw: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2Dzr::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ekx: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ekb_info" {
     block_c2Ekb_info:
         const _c2Ekb;
         const 0;
         const 4294967326;
         const S2Ecg_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.807398573 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowsPrec_closure" {
     GHC.Word.$fShowWord8_$cshowsPrec_closure:
         const GHC.Word.$fShowWord8_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord8_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EkV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2El9; else goto c2Ela;
       c2El9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ela: // global
           I64[Sp - 24] = block_c2EkS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2Elh; else goto c2EkT;
       u2Elh: // global
           call _c2EkS(R1) args: 0, res: 0, upd: 0;
       c2EkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshowsPrec_info" {
     GHC.Word.$fShowWord8_$cshowsPrec_info:
         const GHC.Word.$fShowWord8_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2EkS() //  [R1]
         { []
         }
     {offset
       c2EkS: // global
           I64[Sp] = block_c2EkY_info;
           _s2Dzy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2Dzy::I64;
           if (R1 & 7 != 0) goto u2Elg; else goto c2EkZ;
       u2Elg: // global
           call _c2EkY(R1) args: 0, res: 0, upd: 0;
       c2EkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EkS_info" {
     block_c2EkS_info:
         const _c2EkS;
         const 2;
         const 30;
 },
 _c2EkY() //  [R1]
         { []
         }
     {offset
       c2EkY: // global
           _s2Dzw::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2El6_info;
           R4 = _s2Dzw::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EkY_info" {
     block_c2EkY_info:
         const _c2EkY;
         const 66;
         const 30;
 },
 _c2El6() //  [R1, R2]
         { []
         }
     {offset
       c2El6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Elf; else goto c2Ele;
       c2Elf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Ele: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2El6_info" {
     block_c2El6_info:
         const _c2El6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.817761186 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshow_closure" {
     GHC.Word.$fShowWord8_$cshow_closure:
         const GHC.Word.$fShowWord8_$cshow_info;
 },
 GHC.Word.$fShowWord8_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2ElK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2ElT; else goto c2ElU;
       c2ElT: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ElU: // global
           I64[Sp - 8] = block_c2ElH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2ElZ; else goto c2ElI;
       u2ElZ: // global
           call _c2ElH(R1) args: 0, res: 0, upd: 0;
       c2ElI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshow_info" {
     GHC.Word.$fShowWord8_$cshow_info:
         const GHC.Word.$fShowWord8_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2ElH() //  [R1]
         { []
         }
     {offset
       c2ElH: // global
           I64[Sp] = block_c2ElQ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ElH_info" {
     block_c2ElH_info:
         const _c2ElH;
         const 0;
         const 30;
 },
 _c2ElQ() //  [R1, R2]
         { []
         }
     {offset
       c2ElQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ElY; else goto c2ElX;
       c2ElY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2ElX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ElQ_info" {
     block_c2ElQ_info:
         const _c2ElQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.825538955 UTC

[section ""data" . GHC.Word.$fShowWord4_closure" {
     GHC.Word.$fShowWord4_closure:
         const GHC.Word.$fShowWord4_info;
 },
 GHC.Word.$fShowWord4_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Emo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Emx; else goto c2Emy;
       c2Emx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Emy: // global
           I64[Sp - 16] = block_c2Eml_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EmD; else goto c2Emm;
       u2EmD: // global
           call _c2Eml(R1) args: 0, res: 0, upd: 0;
       c2Emm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord4_info" {
     GHC.Word.$fShowWord4_info:
         const GHC.Word.$fShowWord4_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Eml() //  [R1]
         { []
         }
     {offset
       c2Eml: // global
           _s2DzN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Emu_info;
           R4 = _s2DzN::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Eml_info" {
     block_c2Eml_info:
         const _c2Eml;
         const 1;
         const 30;
 },
 _c2Emu() //  [R1, R2]
         { []
         }
     {offset
       c2Emu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EmC; else goto c2EmB;
       c2EmC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EmB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Emu_info" {
     block_c2Emu_info:
         const _c2Emu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.832515713 UTC

[section ""data" . GHC.Word.$fShowWord8_$cshowList_closure" {
     GHC.Word.$fShowWord8_$cshowList_closure:
         const GHC.Word.$fShowWord8_$cshowList_info;
 },
 GHC.Word.$fShowWord8_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EmY: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord8_$cshowList_info" {
     GHC.Word.$fShowWord8_$cshowList_info:
         const GHC.Word.$fShowWord8_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.836215603 UTC

[section ""data" . GHC.Word.$fShowWord8_closure" {
     GHC.Word.$fShowWord8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord8_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord8_$cshow_closure+1;
         const GHC.Word.$fShowWord8_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.838385731 UTC

[section ""data" . GHC.Word.$wlvl3_closure" {
     GHC.Word.$wlvl3_closure:
         const GHC.Word.$wlvl3_info;
         const 0;
 },
 GHC.Word.$wlvl3_entry() //  [R2]
         { []
         }
     {offset
       c2Ena: // global
           R6 = GHC.Word.$fBoundedWord8_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r2uFH_closure;
           R2 = GHC.Word.$fShowWord8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl3_info" {
     GHC.Word.$wlvl3_info:
         const GHC.Word.$wlvl3_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2Ecg_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.842095265 UTC

[section ""data" . GHC.Word.$w$ctoEnum2_closure" {
     GHC.Word.$w$ctoEnum2_closure:
         const GHC.Word.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum2_entry() //  [R2]
         { []
         }
     {offset
       c2Enq: // global
           _s2DzX::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2Eny; else goto c2Enp;
       c2Enp: // global
           if (%MO_S_Gt_W64(_s2DzX::I64, 255)) goto c2Eny; else goto c2EnC;
       c2Eny: // global
           R2 = _s2DzX::I64;
           call GHC.Word.$wlvl3_entry(R2) args: 8, res: 0, upd: 8;
       c2EnC: // global
           R1 = _s2DzX::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum2_info" {
     GHC.Word.$w$ctoEnum2_info:
         const GHC.Word.$w$ctoEnum2_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2Ecg_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.846448725 UTC

[section ""data" . GHC.Word.$fEnumWord8_$ctoEnum_closure" {
     GHC.Word.$fEnumWord8_$ctoEnum_closure:
         const GHC.Word.$fEnumWord8_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2EnP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EnX; else goto c2EnY;
       c2EnX: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EnY: // global
           I64[Sp - 8] = block_c2EnM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Eo3; else goto c2EnN;
       u2Eo3: // global
           call _c2EnM(R1) args: 0, res: 0, upd: 0;
       c2EnN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$ctoEnum_info" {
     GHC.Word.$fEnumWord8_$ctoEnum_info:
         const GHC.Word.$fEnumWord8_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+184;
 },
 _c2EnM() //  [R1]
         { []
         }
     {offset
       c2EnM: // global
           I64[Sp] = block_c2EnS_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EnM_info" {
     block_c2EnM_info:
         const _c2EnM;
         const 0;
         const 4294967326;
         const S2Ecg_srt+192;
 },
 _c2EnS() //  [R1]
         { []
         }
     {offset
       c2EnS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eo2; else goto c2Eo1;
       c2Eo2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Eo1: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EnS_info" {
     block_c2EnS_info:
         const _c2EnS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.864200999 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo2_closure" {
     GHC.Word.$w$cenumFromThenTo2_closure:
         const GHC.Word.$w$cenumFromThenTo2_info;
         const 0;
 },
 sat_s2DAs_entry() //  [R1]
         { []
         }
     {offset
       c2Ep1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ep2; else goto c2Ep3;
       c2Ep2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ep3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DAk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAs_info" {
     sat_s2DAs_info:
         const sat_s2DAs_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+176;
 },
 sat_s2DAq_entry() //  [R1]
         { []
         }
     {offset
       c2Epd: // global
           _s2DAq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Epe; else goto c2Epf;
       c2Epf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eph; else goto c2Epg;
       c2Eph: // global
           HpAlloc = 16;
           goto c2Epe;
       c2Epe: // global
           R1 = _s2DAq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Epg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAq::P64;
           _s2DAl::I64 = I64[_s2DAq::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAl::I64, 0)) goto c2Epn; else goto c2Epc;
       c2Epc: // global
           if (%MO_S_Gt_W64(_s2DAl::I64, 255)) goto c2Epn; else goto c2Epu;
       c2Epn: // global
           Hp = Hp - 16;
           R2 = _s2DAl::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Epu: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAq_info" {
     sat_s2DAq_info:
         const sat_s2DAq_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 sat_s2DAw_entry() //  [R1]
         { []
         }
     {offset
       c2EpF: // global
           _s2DAw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EpG; else goto c2EpH;
       c2EpH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EpJ; else goto c2EpI;
       c2EpJ: // global
           HpAlloc = 16;
           goto c2EpG;
       c2EpG: // global
           R1 = _s2DAw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EpI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAw::P64;
           _s2DAl::I64 = I64[_s2DAw::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAl::I64, 0)) goto c2EpP; else goto c2EpE;
       c2EpE: // global
           if (%MO_S_Gt_W64(_s2DAl::I64, 255)) goto c2EpP; else goto c2EpW;
       c2EpP: // global
           Hp = Hp - 16;
           R2 = _s2DAl::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EpW: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAw_info" {
     sat_s2DAw_info:
         const sat_s2DAw_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 go_dn_s2DAk_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Eq0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Eq4; else goto c2Eq3;
       c2Eq4: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eq3: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2EpY; else goto c2EpZ;
       c2EpY: // global
           _s2DAi::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DAs_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DAi::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DAq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EpZ: // global
           I64[Hp - 80] = sat_s2DAw_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Eq6::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Eq6::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2DAk_info" {
     go_dn_s2DAk_info:
         const go_dn_s2DAk_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+176;
 },
 sat_s2DAx_entry() //  [R1]
         { []
         }
     {offset
       c2Eq7: // global
           _s2DAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eq8; else goto c2Eq9;
       c2Eq9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Eqb; else goto c2Eqa;
       c2Eqb: // global
           HpAlloc = 24;
           goto c2Eq8;
       c2Eq8: // global
           R1 = _s2DAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAx::P64;
           _s2DAa::I64 = I64[_s2DAx::P64 + 24];
           _s2DAi::I64 = _s2DAa::I64 - I64[_s2DAx::P64 + 16];
           _s2DAj::I64 = I64[_s2DAx::P64 + 32] - _s2DAi::I64;
           I64[Hp - 16] = go_dn_s2DAk_info;
           I64[Hp - 8] = _s2DAi::I64;
           I64[Hp] = _s2DAj::I64;
           R2 = _s2DAa::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DAk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAx_info" {
     sat_s2DAx_info:
         const sat_s2DAx_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+176;
 },
 sat_s2DAh_entry() //  [R1]
         { []
         }
     {offset
       c2Eql: // global
           _s2DAh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Eqm; else goto c2Eqn;
       c2Eqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eqp; else goto c2Eqo;
       c2Eqp: // global
           HpAlloc = 16;
           goto c2Eqm;
       c2Eqm: // global
           R1 = _s2DAh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Eqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAh::P64;
           _s2DA9::I64 = I64[_s2DAh::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Eqv; else goto c2Eqk;
       c2Eqk: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Eqv; else goto c2EqC;
       c2Eqv: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EqC: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAh_info" {
     sat_s2DAh_info:
         const sat_s2DAh_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 sat_s2DAC_entry() //  [R1]
         { []
         }
     {offset
       c2EqQ: // global
           _s2DAC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EqR; else goto c2EqS;
       c2EqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EqU; else goto c2EqT;
       c2EqU: // global
           HpAlloc = 16;
           goto c2EqR;
       c2EqR: // global
           R1 = _s2DAC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EqT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAC::P64;
           _s2DA9::I64 = I64[_s2DAC::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Er0; else goto c2EqP;
       c2EqP: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Er0; else goto c2Er7;
       c2Er0: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Er7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAC_info" {
     sat_s2DAC_info:
         const sat_s2DAC_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 sat_s2DAT_entry() //  [R1]
         { []
         }
     {offset
       c2ErD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ErE; else goto c2ErF;
       c2ErE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ErF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DAL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAT_info" {
     sat_s2DAT_info:
         const sat_s2DAT_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+176;
 },
 sat_s2DAR_entry() //  [R1]
         { []
         }
     {offset
       c2ErP: // global
           _s2DAR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ErQ; else goto c2ErR;
       c2ErR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ErT; else goto c2ErS;
       c2ErT: // global
           HpAlloc = 16;
           goto c2ErQ;
       c2ErQ: // global
           R1 = _s2DAR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ErS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAR::P64;
           _s2DAM::I64 = I64[_s2DAR::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAM::I64, 0)) goto c2ErZ; else goto c2ErO;
       c2ErO: // global
           if (%MO_S_Gt_W64(_s2DAM::I64, 255)) goto c2ErZ; else goto c2Es6;
       c2ErZ: // global
           Hp = Hp - 16;
           R2 = _s2DAM::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Es6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAM::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAR_info" {
     sat_s2DAR_info:
         const sat_s2DAR_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 sat_s2DAX_entry() //  [R1]
         { []
         }
     {offset
       c2Esh: // global
           _s2DAX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Esi; else goto c2Esj;
       c2Esj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Esl; else goto c2Esk;
       c2Esl: // global
           HpAlloc = 16;
           goto c2Esi;
       c2Esi: // global
           R1 = _s2DAX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Esk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAX::P64;
           _s2DAM::I64 = I64[_s2DAX::P64 + 16];
           if (%MO_S_Lt_W64(_s2DAM::I64, 0)) goto c2Esr; else goto c2Esg;
       c2Esg: // global
           if (%MO_S_Gt_W64(_s2DAM::I64, 255)) goto c2Esr; else goto c2Esy;
       c2Esr: // global
           Hp = Hp - 16;
           R2 = _s2DAM::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Esy: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DAM::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAX_info" {
     sat_s2DAX_info:
         const sat_s2DAX_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 go_up_s2DAL_entry() //  [R1, R2]
         { []
         }
     {offset
       c2EsC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EsG; else goto c2EsF;
       c2EsG: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EsF: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2EsA; else goto c2EsB;
       c2EsA: // global
           _s2DAJ::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DAT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DAJ::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DAR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EsB: // global
           I64[Hp - 80] = sat_s2DAX_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EsI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EsI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2DAL_info" {
     go_up_s2DAL_info:
         const go_up_s2DAL_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+176;
 },
 sat_s2DAY_entry() //  [R1]
         { []
         }
     {offset
       c2EsJ: // global
           _s2DAY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EsK; else goto c2EsL;
       c2EsL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EsN; else goto c2EsM;
       c2EsN: // global
           HpAlloc = 24;
           goto c2EsK;
       c2EsK: // global
           R1 = _s2DAY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAY::P64;
           _s2DAa::I64 = I64[_s2DAY::P64 + 24];
           _s2DAJ::I64 = _s2DAa::I64 - I64[_s2DAY::P64 + 16];
           _s2DAK::I64 = I64[_s2DAY::P64 + 32] - _s2DAJ::I64;
           I64[Hp - 16] = go_up_s2DAL_info;
           I64[Hp - 8] = _s2DAJ::I64;
           I64[Hp] = _s2DAK::I64;
           R2 = _s2DAa::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DAL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAY_info" {
     sat_s2DAY_info:
         const sat_s2DAY_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+176;
 },
 sat_s2DAI_entry() //  [R1]
         { []
         }
     {offset
       c2EsX: // global
           _s2DAI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EsY; else goto c2EsZ;
       c2EsZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Et1; else goto c2Et0;
       c2Et1: // global
           HpAlloc = 16;
           goto c2EsY;
       c2EsY: // global
           R1 = _s2DAI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Et0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DAI::P64;
           _s2DA9::I64 = I64[_s2DAI::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2Et7; else goto c2EsW;
       c2EsW: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2Et7; else goto c2Ete;
       c2Et7: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Ete: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DAI_info" {
     sat_s2DAI_info:
         const sat_s2DAI_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 sat_s2DB3_entry() //  [R1]
         { []
         }
     {offset
       c2Ets: // global
           _s2DB3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ett; else goto c2Etu;
       c2Etu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Etw; else goto c2Etv;
       c2Etw: // global
           HpAlloc = 16;
           goto c2Ett;
       c2Ett: // global
           R1 = _s2DB3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Etv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DB3::P64;
           _s2DA9::I64 = I64[_s2DB3::P64 + 16];
           if (%MO_S_Lt_W64(_s2DA9::I64, 0)) goto c2EtC; else goto c2Etr;
       c2Etr: // global
           if (%MO_S_Gt_W64(_s2DA9::I64, 255)) goto c2EtC; else goto c2EtJ;
       c2EtC: // global
           Hp = Hp - 16;
           R2 = _s2DA9::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EtJ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DA9::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DB3_info" {
     sat_s2DB3_info:
         const sat_s2DB3_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 GHC.Word.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EtK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EtO; else goto c2EtN;
       c2EtO: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EtN: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2EtY; else goto c2Eu7;
       c2EtY: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2EtR; else goto c2EtW;
       c2EtR: // global
           I64[Hp - 80] = sat_s2DAx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DAh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EtW: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2Eu5; else goto c2EtU;
       c2EtU: // global
           I64[Hp - 80] = sat_s2DAC_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EtS::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EtS::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu7: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2Eu1; else goto c2Eu6;
       c2Eu1: // global
           I64[Hp - 80] = sat_s2DAY_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DAI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu6: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2Eu5; else goto c2Eu4;
       c2Eu5: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Eu4: // global
           I64[Hp - 80] = sat_s2DB3_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2Eu2::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2Eu2::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo2_info" {
     GHC.Word.$w$cenumFromThenTo2_info:
         const GHC.Word.$w$cenumFromThenTo2_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2Ecg_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.898773732 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EwB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EwK; else goto c2EwL;
       c2EwK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EwL: // global
           I64[Sp - 24] = block_c2Ewy_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EwU; else goto c2Ewz;
       u2EwU: // global
           call _c2Ewy(R1) args: 0, res: 0, upd: 0;
       c2Ewz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord8_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2Ecg_srt+200;
 },
 _c2Ewy() //  [R1]
         { []
         }
     {offset
       c2Ewy: // global
           I64[Sp] = block_c2EwE_info;
           _s2DB8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DB8::I64;
           if (R1 & 7 != 0) goto u2EwT; else goto c2EwF;
       u2EwT: // global
           call _c2EwE(R1) args: 0, res: 0, upd: 0;
       c2EwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ewy_info" {
     block_c2Ewy_info:
         const _c2Ewy;
         const 2;
         const 4294967326;
         const S2Ecg_srt+200;
 },
 _c2EwE() //  [R1]
         { []
         }
     {offset
       c2EwE: // global
           I64[Sp] = block_c2EwJ_info;
           _s2DBa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DBa::I64;
           if (R1 & 7 != 0) goto u2EwV; else goto c2EwO;
       u2EwV: // global
           call _c2EwJ(R1) args: 0, res: 0, upd: 0;
       c2EwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EwE_info" {
     block_c2EwE_info:
         const _c2EwE;
         const 66;
         const 4294967326;
         const S2Ecg_srt+200;
 },
 _c2EwJ() //  [R1]
         { []
         }
     {offset
       c2EwJ: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo2_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EwJ_info" {
     block_c2EwJ_info:
         const _c2EwJ;
         const 194;
         const 4294967326;
         const S2Ecg_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.910031099 UTC

[section ""data" . GHC.Word.$w$cenumFromTo2_closure" {
     GHC.Word.$w$cenumFromTo2_closure:
         const GHC.Word.$w$cenumFromTo2_info;
         const 0;
 },
 sat_s2DBq_entry() //  [R1]
         { []
         }
     {offset
       c2ExH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ExI; else goto c2ExJ;
       c2ExI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ExJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DBj::I64 = I64[R1 + 32];
           if (_s2DBj::I64 == I64[R1 + 24]) goto c2ExG; else goto c2ExF;
       c2ExG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2ExF: // global
           R2 = _s2DBj::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DBi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DBq_info" {
     sat_s2DBq_info:
         const sat_s2DBq_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+176;
 },
 sat_s2DBn_entry() //  [R1]
         { []
         }
     {offset
       c2ExV: // global
           _s2DBn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ExW; else goto c2ExX;
       c2ExX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ExZ; else goto c2ExY;
       c2ExZ: // global
           HpAlloc = 16;
           goto c2ExW;
       c2ExW: // global
           R1 = _s2DBn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ExY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DBn::P64;
           _s2DBj::I64 = I64[_s2DBn::P64 + 16];
           if (%MO_S_Lt_W64(_s2DBj::I64, 0)) goto c2Ey5; else goto c2ExU;
       c2ExU: // global
           if (%MO_S_Gt_W64(_s2DBj::I64, 255)) goto c2Ey5; else goto c2Eyc;
       c2Ey5: // global
           Hp = Hp - 16;
           R2 = _s2DBj::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2Eyc: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DBj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DBn_info" {
     sat_s2DBn_info:
         const sat_s2DBn_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 go_s2DBi_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Eye: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Eyi; else goto c2Eyh;
       c2Eyi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Eyh: // global
           _s2DBg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DBq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DBg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DBn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2DBi_info" {
     go_s2DBi_info:
         const go_s2DBi_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2Ecg_srt+176;
 },
 GHC.Word.$w$cenumFromTo2_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Eyj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Eyn; else goto c2Eym;
       c2Eyn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Eym: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2Eyp; else goto c2Eyq;
       c2Eyp: // global
           I64[Hp - 8] = go_s2DBi_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DBi_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2Eyq: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo2_info" {
     GHC.Word.$w$cenumFromTo2_info:
         const GHC.Word.$w$cenumFromTo2_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2Ecg_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.920708044 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord8_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord8_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Ez2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ez6; else goto c2Ez7;
       c2Ez6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ez7: // global
           I64[Sp - 16] = block_c2EyZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ezf; else goto c2Ez0;
       u2Ezf: // global
           call _c2EyZ(R1) args: 0, res: 0, upd: 0;
       c2Ez0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromTo_info" {
     GHC.Word.$fEnumWord8_$cenumFromTo_info:
         const GHC.Word.$fEnumWord8_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+216;
 },
 _c2EyZ() //  [R1]
         { []
         }
     {offset
       c2EyZ: // global
           I64[Sp] = block_c2Ez5_info;
           _s2DBu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DBu::I64;
           if (R1 & 7 != 0) goto u2Eze; else goto c2Ez9;
       u2Eze: // global
           call _c2Ez5(R1) args: 0, res: 0, upd: 0;
       c2Ez9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EyZ_info" {
     block_c2EyZ_info:
         const _c2EyZ;
         const 1;
         const 4294967326;
         const S2Ecg_srt+216;
 },
 _c2Ez5() //  [R1]
         { []
         }
     {offset
       c2Ez5: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo2_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ez5_info" {
     block_c2Ez5_info:
         const _c2Ez5;
         const 65;
         const 4294967326;
         const S2Ecg_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.929656806 UTC

[section ""data" . GHC.Word.$wgo2_closure" {
     GHC.Word.$wgo2_closure:
         const GHC.Word.$wgo2_info;
         const 0;
 },
 sat_s2DBH_entry() //  [R1]
         { []
         }
     {offset
       c2EzH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EzI; else goto c2EzT;
       c2EzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EzT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DBC::I64 = I64[R1 + 16];
           if (_s2DBC::I64 != 255) goto c2EzF; else goto c2EzG;
       c2EzF: // global
           I64[Sp - 24] = block_c2EzN_info;
           R2 = _s2DBC::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c2EzG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DBH_info" {
     sat_s2DBH_info:
         const sat_s2DBH_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+232;
 },
 _c2EzN() //  [R1, R2]
         { []
         }
     {offset
       c2EzN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EzS; else goto c2EzR;
       c2EzS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2EzR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EzN_info" {
     block_c2EzN_info:
         const _c2EzN;
         const 0;
         const 30;
 },
 sat_s2DBB_entry() //  [R1]
         { []
         }
     {offset
       c2EA3: // global
           _s2DBB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EA4; else goto c2EA5;
       c2EA5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EA7; else goto c2EA6;
       c2EA7: // global
           HpAlloc = 16;
           goto c2EA4;
       c2EA4: // global
           R1 = _s2DBB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DBB::P64;
           _s2DBx::I64 = I64[_s2DBB::P64 + 16];
           if (%MO_S_Lt_W64(_s2DBx::I64, 0)) goto c2EAd; else goto c2EA2;
       c2EA2: // global
           if (%MO_S_Gt_W64(_s2DBx::I64, 255)) goto c2EAd; else goto c2EAk;
       c2EAd: // global
           Hp = Hp - 16;
           R2 = _s2DBx::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl3_entry(R2) args: 24, res: 0, upd: 24;
       c2EAk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DBx::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DBB_info" {
     sat_s2DBB_info:
         const sat_s2DBB_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+176;
 },
 GHC.Word.$wgo2_entry() //  [R2]
         { []
         }
     {offset
       c2EAl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EAp; else goto c2EAo;
       c2EAp: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EAo: // global
           I64[Hp - 40] = sat_s2DBH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DBB_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo2_info" {
     GHC.Word.$wgo2_info:
         const GHC.Word.$wgo2_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2Ecg_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.940148015 UTC

[section ""data" . GHC.Word.$fEnumWord8_go_closure" {
     GHC.Word.$fEnumWord8_go_closure:
         const GHC.Word.$fEnumWord8_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_go_entry() //  [R2]
         { []
         }
     {offset
       c2EAY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EAZ; else goto c2EB0;
       c2EAZ: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EB0: // global
           I64[Sp - 8] = block_c2EAV_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_go_info" {
     GHC.Word.$fEnumWord8_go_info:
         const GHC.Word.$fEnumWord8_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2Ecg_srt+232;
 },
 _c2EAV() //  [R1, R2]
         { []
         }
     {offset
       c2EAV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EB3; else goto c2EB2;
       c2EB3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EB2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EAV_info" {
     block_c2EAV_info:
         const _c2EAV;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.946889265 UTC

[section ""data" . GHC.Word.$fEnumWord8_$cenumFrom_closure" {
     GHC.Word.$fEnumWord8_$cenumFrom_closure:
         const GHC.Word.$fEnumWord8_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2EBm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EBn; else goto c2EBo;
       c2EBn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EBo: // global
           I64[Sp - 8] = block_c2EBj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EBA; else goto c2EBk;
       u2EBA: // global
           call _c2EBj(R1) args: 0, res: 0, upd: 0;
       c2EBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFrom_info" {
     GHC.Word.$fEnumWord8_$cenumFrom_info:
         const GHC.Word.$fEnumWord8_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+240;
 },
 _c2EBj() //  [R1]
         { []
         }
     {offset
       c2EBj: // global
           _s2DBP::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DBP::I64, 255)) goto c2EBy; else goto c2EBz;
       c2EBy: // global
           R2 = _s2DBP::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_go_entry(R2) args: 8, res: 0, upd: 8;
       c2EBz: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EBj_info" {
     block_c2EBj_info:
         const _c2EBj;
         const 0;
         const 4294967326;
         const S2Ecg_srt+240;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.952426135 UTC

[section ""data" . GHC.Word.$fEnumWord8_closure" {
     GHC.Word.$fEnumWord8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord8_$csucc_closure+1;
         const GHC.Word.$fEnumWord8_$cpred_closure+1;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord8_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord8_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord8_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord8_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord8_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EBR: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord8_closure+1;
           R2 = GHC.Word.$fEnumWord8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord8_$cenumFromThen_info" {
     GHC.Word.$fEnumWord8_$cenumFromThen_info:
         const GHC.Word.$fEnumWord8_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2Ecg_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.95644005 UTC

[section ""cstring" . GHC.Word.$tcWord2_bytes" {
     GHC.Word.$tcWord2_bytes:
         I8[] [87,111,114,100,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.959078602 UTC

[section ""data" . GHC.Word.$fEnumWord1_closure" {
     GHC.Word.$fEnumWord1_closure:
         const GHC.Word.$fEnumWord1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord1_entry() //  [R1]
         { []
         }
     {offset
       c2EC8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EC9; else goto c2ECa;
       c2EC9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ECa: // global
           (_c2EC3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EC3::I64 == 0) goto c2EC5; else goto c2EC4;
       c2EC5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EC4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EC3::I64;
           I64[Sp - 24] = block_c2EC6_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord1_info" {
     GHC.Word.$fEnumWord1_info:
         const GHC.Word.$fEnumWord1_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+112;
 },
 _c2EC6() //  [R1]
         { []
         }
     {offset
       c2EC6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EC6_info" {
     block_c2EC6_info:
         const _c2EC6;
         const 0;
         const 4294967326;
         const S2Ecg_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.964741506 UTC

[section ""data" . GHC.Word.$fEnumWord2_closure" {
     GHC.Word.$fEnumWord2_closure:
         const GHC.Word.$fEnumWord2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord2_entry() //  [R1]
         { []
         }
     {offset
       c2ECy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ECz; else goto c2ECA;
       c2ECz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ECA: // global
           (_c2ECt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2ECt::I64 == 0) goto c2ECv; else goto c2ECu;
       c2ECv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2ECu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2ECt::I64;
           I64[Sp - 24] = block_c2ECw_info;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord2_info" {
     GHC.Word.$fEnumWord2_info:
         const GHC.Word.$fEnumWord2_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+120;
 },
 _c2ECw() //  [R1]
         { []
         }
     {offset
       c2ECw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2ECw_info" {
     block_c2ECw_info:
         const _c2ECw;
         const 0;
         const 4294967326;
         const S2Ecg_srt+120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.971015661 UTC

[section ""data" . GHC.Word.neWord16_closure" {
     GHC.Word.neWord16_closure:
         const GHC.Word.neWord16_info;
 },
 GHC.Word.neWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ECX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ED1; else goto c2ED2;
       c2ED1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ED2: // global
           I64[Sp - 16] = block_c2ECU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EDb; else goto c2ECV;
       u2EDb: // global
           call _c2ECU(R1) args: 0, res: 0, upd: 0;
       c2ECV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord16_info" {
     GHC.Word.neWord16_info:
         const GHC.Word.neWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2ECU() //  [R1]
         { []
         }
     {offset
       c2ECU: // global
           I64[Sp] = block_c2ED0_info;
           _s2DBW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DBW::I64;
           if (R1 & 7 != 0) goto u2EDa; else goto c2ED4;
       u2EDa: // global
           call _c2ED0(R1) args: 0, res: 0, upd: 0;
       c2ED4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ECU_info" {
     block_c2ECU_info:
         const _c2ECU;
         const 1;
         const 30;
 },
 _c2ED0() //  [R1]
         { []
         }
     {offset
       c2ED0: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ED0_info" {
     block_c2ED0_info:
         const _c2ED0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.978572737 UTC

[section ""data" . lvl4_r2uFJ_closure" {
     lvl4_r2uFJ_closure:
         const lvl4_r2uFJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r2uFJ_entry() //  [R1]
         { []
         }
     {offset
       c2EDC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EDD; else goto c2EDE;
       c2EDD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EDE: // global
           (_c2EDz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EDz::I64 == 0) goto c2EDB; else goto c2EDA;
       c2EDB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EDA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EDz::I64;
           R2 = GHC.Word.$tcWord2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_r2uFJ_info" {
     lvl4_r2uFJ_info:
         const lvl4_r2uFJ_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.982067926 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cminBound_closure" {
     GHC.Word.$fBitsWord16_$cminBound_closure:
         const GHC.Word.W16#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.984953685 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cpred_closure" {
     GHC.Word.$fEnumWord16_$cpred_closure:
         const GHC.Word.$fEnumWord16_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2EDV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EDW; else goto c2EDX;
       c2EDW: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EDX: // global
           I64[Sp - 8] = block_c2EDS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EEf; else goto c2EDT;
       u2EEf: // global
           call _c2EDS(R1) args: 0, res: 0, upd: 0;
       c2EDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cpred_info" {
     GHC.Word.$fEnumWord16_$cpred_info:
         const GHC.Word.$fEnumWord16_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+264;
 },
 _c2EDS() //  [R1]
         { []
         }
     {offset
       c2EDS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EE2; else goto c2EE1;
       c2EE2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EE1: // global
           _s2DC3::I64 = I64[R1 + 7];
           if (_s2DC3::I64 != 0) goto c2EEd; else goto c2EEe;
       c2EEd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DC3::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EEe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EDS_info" {
     block_c2EDS_info:
         const _c2EDS;
         const 0;
         const 4294967326;
         const S2Ecg_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.990663838 UTC

[section ""data" . GHC.Word.$fBoundedWord16_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord16_$cmaxBound_closure:
         const GHC.Word.W16#_con_info;
         const 65535;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.992359643 UTC

[section ""data" . GHC.Word.$fBoundedWord16_closure" {
     GHC.Word.$fBoundedWord16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:22.995461826 UTC

[section ""data" . GHC.Word.$fEnumWord16_$csucc_closure" {
     GHC.Word.$fEnumWord16_$csucc_closure:
         const GHC.Word.$fEnumWord16_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2EEE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EEF; else goto c2EEG;
       c2EEF: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EEG: // global
           I64[Sp - 8] = block_c2EEB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EEY; else goto c2EEC;
       u2EEY: // global
           call _c2EEB(R1) args: 0, res: 0, upd: 0;
       c2EEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$csucc_info" {
     GHC.Word.$fEnumWord16_$csucc_info:
         const GHC.Word.$fEnumWord16_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+280;
 },
 _c2EEB() //  [R1]
         { []
         }
     {offset
       c2EEB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EEL; else goto c2EEK;
       c2EEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EEK: // global
           _s2DC9::I64 = I64[R1 + 7];
           if (_s2DC9::I64 != 65535) goto c2EEW; else goto c2EEX;
       c2EEW: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DC9::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EEX: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EEB_info" {
     block_c2EEB_info:
         const _c2EEB;
         const 0;
         const 4294967326;
         const S2Ecg_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.002233508 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowsPrec_closure" {
     GHC.Word.$fShowWord16_$cshowsPrec_closure:
         const GHC.Word.$fShowWord16_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord16_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EFl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EFz; else goto c2EFA;
       c2EFz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EFA: // global
           I64[Sp - 24] = block_c2EFi_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2EFH; else goto c2EFj;
       u2EFH: // global
           call _c2EFi(R1) args: 0, res: 0, upd: 0;
       c2EFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshowsPrec_info" {
     GHC.Word.$fShowWord16_$cshowsPrec_info:
         const GHC.Word.$fShowWord16_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2EFi() //  [R1]
         { []
         }
     {offset
       c2EFi: // global
           I64[Sp] = block_c2EFo_info;
           _s2DCg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DCg::I64;
           if (R1 & 7 != 0) goto u2EFG; else goto c2EFp;
       u2EFG: // global
           call _c2EFo(R1) args: 0, res: 0, upd: 0;
       c2EFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EFi_info" {
     block_c2EFi_info:
         const _c2EFi;
         const 2;
         const 30;
 },
 _c2EFo() //  [R1]
         { []
         }
     {offset
       c2EFo: // global
           _s2DCe::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EFw_info;
           R4 = _s2DCe::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EFo_info" {
     block_c2EFo_info:
         const _c2EFo;
         const 66;
         const 30;
 },
 _c2EFw() //  [R1, R2]
         { []
         }
     {offset
       c2EFw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EFF; else goto c2EFE;
       c2EFF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EFE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EFw_info" {
     block_c2EFw_info:
         const _c2EFw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.01173452 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshow_closure" {
     GHC.Word.$fShowWord16_$cshow_closure:
         const GHC.Word.$fShowWord16_$cshow_info;
 },
 GHC.Word.$fShowWord16_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2EGa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EGj; else goto c2EGk;
       c2EGj: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EGk: // global
           I64[Sp - 8] = block_c2EG7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EGp; else goto c2EG8;
       u2EGp: // global
           call _c2EG7(R1) args: 0, res: 0, upd: 0;
       c2EG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshow_info" {
     GHC.Word.$fShowWord16_$cshow_info:
         const GHC.Word.$fShowWord16_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2EG7() //  [R1]
         { []
         }
     {offset
       c2EG7: // global
           I64[Sp] = block_c2EGg_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EG7_info" {
     block_c2EG7_info:
         const _c2EG7;
         const 0;
         const 30;
 },
 _c2EGg() //  [R1, R2]
         { []
         }
     {offset
       c2EGg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EGo; else goto c2EGn;
       c2EGo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EGn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EGg_info" {
     block_c2EGg_info:
         const _c2EGg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.020002052 UTC

[section ""data" . GHC.Word.$fShowWord1_closure" {
     GHC.Word.$fShowWord1_closure:
         const GHC.Word.$fShowWord1_info;
 },
 GHC.Word.$fShowWord1_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EGO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EGX; else goto c2EGY;
       c2EGX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EGY: // global
           I64[Sp - 16] = block_c2EGL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EH3; else goto c2EGM;
       u2EH3: // global
           call _c2EGL(R1) args: 0, res: 0, upd: 0;
       c2EGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord1_info" {
     GHC.Word.$fShowWord1_info:
         const GHC.Word.$fShowWord1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2EGL() //  [R1]
         { []
         }
     {offset
       c2EGL: // global
           _s2DCv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2EGU_info;
           R4 = _s2DCv::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EGL_info" {
     block_c2EGL_info:
         const _c2EGL;
         const 1;
         const 30;
 },
 _c2EGU() //  [R1, R2]
         { []
         }
     {offset
       c2EGU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EH2; else goto c2EH1;
       c2EH2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EH1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EGU_info" {
     block_c2EGU_info:
         const _c2EGU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.027349056 UTC

[section ""data" . GHC.Word.$fShowWord16_$cshowList_closure" {
     GHC.Word.$fShowWord16_$cshowList_closure:
         const GHC.Word.$fShowWord16_$cshowList_info;
 },
 GHC.Word.$fShowWord16_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EHo: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord16_$cshowList_info" {
     GHC.Word.$fShowWord16_$cshowList_info:
         const GHC.Word.$fShowWord16_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.030532627 UTC

[section ""data" . GHC.Word.$fShowWord16_closure" {
     GHC.Word.$fShowWord16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord16_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord16_$cshow_closure+1;
         const GHC.Word.$fShowWord16_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.032645063 UTC

[section ""data" . GHC.Word.$wlvl_closure" {
     GHC.Word.$wlvl_closure:
         const GHC.Word.$wlvl_info;
         const 0;
 },
 GHC.Word.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       c2EHA: // global
           R6 = GHC.Word.$fBoundedWord16_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r2uFJ_closure;
           R2 = GHC.Word.$fShowWord16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl_info" {
     GHC.Word.$wlvl_info:
         const GHC.Word.$wlvl_entry;
         const 0;
         const 562954248388622;
         const 4294967300;
         const S2Ecg_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.036719409 UTC

[section ""data" . GHC.Word.$w$ctoEnum_closure" {
     GHC.Word.$w$ctoEnum_closure:
         const GHC.Word.$w$ctoEnum_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2EHQ: // global
           _s2DCF::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2EHY; else goto c2EHP;
       c2EHP: // global
           if (%MO_S_Gt_W64(_s2DCF::I64, 65535)) goto c2EHY; else goto c2EI2;
       c2EHY: // global
           R2 = _s2DCF::I64;
           call GHC.Word.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c2EI2: // global
           R1 = _s2DCF::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum_info" {
     GHC.Word.$w$ctoEnum_info:
         const GHC.Word.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2Ecg_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.041065569 UTC

[section ""data" . GHC.Word.$fEnumWord16_$ctoEnum_closure" {
     GHC.Word.$fEnumWord16_$ctoEnum_closure:
         const GHC.Word.$fEnumWord16_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2EIf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EIn; else goto c2EIo;
       c2EIn: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EIo: // global
           I64[Sp - 8] = block_c2EIc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EIt; else goto c2EId;
       u2EIt: // global
           call _c2EIc(R1) args: 0, res: 0, upd: 0;
       c2EId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$ctoEnum_info" {
     GHC.Word.$fEnumWord16_$ctoEnum_info:
         const GHC.Word.$fEnumWord16_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+312;
 },
 _c2EIc() //  [R1]
         { []
         }
     {offset
       c2EIc: // global
           I64[Sp] = block_c2EIi_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EIc_info" {
     block_c2EIc_info:
         const _c2EIc;
         const 0;
         const 4294967326;
         const S2Ecg_srt+320;
 },
 _c2EIi() //  [R1]
         { []
         }
     {offset
       c2EIi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EIs; else goto c2EIr;
       c2EIs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2EIr: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EIi_info" {
     block_c2EIi_info:
         const _c2EIi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.058552693 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo_closure" {
     GHC.Word.$w$cenumFromThenTo_closure:
         const GHC.Word.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s2DDa_entry() //  [R1]
         { []
         }
     {offset
       c2EJr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EJs; else goto c2EJt;
       c2EJs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EJt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DD2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDa_info" {
     sat_s2DDa_info:
         const sat_s2DDa_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+304;
 },
 sat_s2DD8_entry() //  [R1]
         { []
         }
     {offset
       c2EJD: // global
           _s2DD8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EJE; else goto c2EJF;
       c2EJF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EJH; else goto c2EJG;
       c2EJH: // global
           HpAlloc = 16;
           goto c2EJE;
       c2EJE: // global
           R1 = _s2DD8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EJG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DD8::P64;
           _s2DD3::I64 = I64[_s2DD8::P64 + 16];
           if (%MO_S_Lt_W64(_s2DD3::I64, 0)) goto c2EJN; else goto c2EJC;
       c2EJC: // global
           if (%MO_S_Gt_W64(_s2DD3::I64, 65535)) goto c2EJN; else goto c2EJU;
       c2EJN: // global
           Hp = Hp - 16;
           R2 = _s2DD3::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EJU: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DD3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DD8_info" {
     sat_s2DD8_info:
         const sat_s2DD8_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 sat_s2DDe_entry() //  [R1]
         { []
         }
     {offset
       c2EK5: // global
           _s2DDe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EK6; else goto c2EK7;
       c2EK7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EK9; else goto c2EK8;
       c2EK9: // global
           HpAlloc = 16;
           goto c2EK6;
       c2EK6: // global
           R1 = _s2DDe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EK8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDe::P64;
           _s2DD3::I64 = I64[_s2DDe::P64 + 16];
           if (%MO_S_Lt_W64(_s2DD3::I64, 0)) goto c2EKf; else goto c2EK4;
       c2EK4: // global
           if (%MO_S_Gt_W64(_s2DD3::I64, 65535)) goto c2EKf; else goto c2EKm;
       c2EKf: // global
           Hp = Hp - 16;
           R2 = _s2DD3::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EKm: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DD3::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDe_info" {
     sat_s2DDe_info:
         const sat_s2DDe_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 go_dn_s2DD2_entry() //  [R1, R2]
         { []
         }
     {offset
       c2EKq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EKu; else goto c2EKt;
       c2EKu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EKt: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2EKo; else goto c2EKp;
       c2EKo: // global
           _s2DD0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DDa_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DD0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DD8_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EKp: // global
           I64[Hp - 80] = sat_s2DDe_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EKw::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EKw::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2DD2_info" {
     go_dn_s2DD2_info:
         const go_dn_s2DD2_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+304;
 },
 sat_s2DDf_entry() //  [R1]
         { []
         }
     {offset
       c2EKx: // global
           _s2DDf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EKy; else goto c2EKz;
       c2EKz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EKB; else goto c2EKA;
       c2EKB: // global
           HpAlloc = 24;
           goto c2EKy;
       c2EKy: // global
           R1 = _s2DDf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EKA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDf::P64;
           _s2DCS::I64 = I64[_s2DDf::P64 + 24];
           _s2DD0::I64 = _s2DCS::I64 - I64[_s2DDf::P64 + 16];
           _s2DD1::I64 = I64[_s2DDf::P64 + 32] - _s2DD0::I64;
           I64[Hp - 16] = go_dn_s2DD2_info;
           I64[Hp - 8] = _s2DD0::I64;
           I64[Hp] = _s2DD1::I64;
           R2 = _s2DCS::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DD2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDf_info" {
     sat_s2DDf_info:
         const sat_s2DDf_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+304;
 },
 sat_s2DCZ_entry() //  [R1]
         { []
         }
     {offset
       c2EKL: // global
           _s2DCZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EKM; else goto c2EKN;
       c2EKN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EKP; else goto c2EKO;
       c2EKP: // global
           HpAlloc = 16;
           goto c2EKM;
       c2EKM: // global
           R1 = _s2DCZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EKO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DCZ::P64;
           _s2DCR::I64 = I64[_s2DCZ::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2EKV; else goto c2EKK;
       c2EKK: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2EKV; else goto c2EL2;
       c2EKV: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EL2: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DCZ_info" {
     sat_s2DCZ_info:
         const sat_s2DCZ_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 sat_s2DDk_entry() //  [R1]
         { []
         }
     {offset
       c2ELg: // global
           _s2DDk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ELh; else goto c2ELi;
       c2ELi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ELk; else goto c2ELj;
       c2ELk: // global
           HpAlloc = 16;
           goto c2ELh;
       c2ELh: // global
           R1 = _s2DDk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ELj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDk::P64;
           _s2DCR::I64 = I64[_s2DDk::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2ELq; else goto c2ELf;
       c2ELf: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2ELq; else goto c2ELx;
       c2ELq: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ELx: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDk_info" {
     sat_s2DDk_info:
         const sat_s2DDk_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 sat_s2DDB_entry() //  [R1]
         { []
         }
     {offset
       c2EM3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EM4; else goto c2EM5;
       c2EM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EM5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DDt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDB_info" {
     sat_s2DDB_info:
         const sat_s2DDB_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+304;
 },
 sat_s2DDz_entry() //  [R1]
         { []
         }
     {offset
       c2EMf: // global
           _s2DDz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EMg; else goto c2EMh;
       c2EMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EMj; else goto c2EMi;
       c2EMj: // global
           HpAlloc = 16;
           goto c2EMg;
       c2EMg: // global
           R1 = _s2DDz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDz::P64;
           _s2DDu::I64 = I64[_s2DDz::P64 + 16];
           if (%MO_S_Lt_W64(_s2DDu::I64, 0)) goto c2EMp; else goto c2EMe;
       c2EMe: // global
           if (%MO_S_Gt_W64(_s2DDu::I64, 65535)) goto c2EMp; else goto c2EMw;
       c2EMp: // global
           Hp = Hp - 16;
           R2 = _s2DDu::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EMw: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DDu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDz_info" {
     sat_s2DDz_info:
         const sat_s2DDz_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 sat_s2DDF_entry() //  [R1]
         { []
         }
     {offset
       c2EMH: // global
           _s2DDF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EMI; else goto c2EMJ;
       c2EMJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EML; else goto c2EMK;
       c2EML: // global
           HpAlloc = 16;
           goto c2EMI;
       c2EMI: // global
           R1 = _s2DDF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EMK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDF::P64;
           _s2DDu::I64 = I64[_s2DDF::P64 + 16];
           if (%MO_S_Lt_W64(_s2DDu::I64, 0)) goto c2EMR; else goto c2EMG;
       c2EMG: // global
           if (%MO_S_Gt_W64(_s2DDu::I64, 65535)) goto c2EMR; else goto c2EMY;
       c2EMR: // global
           Hp = Hp - 16;
           R2 = _s2DDu::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EMY: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DDu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDF_info" {
     sat_s2DDF_info:
         const sat_s2DDF_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 go_up_s2DDt_entry() //  [R1, R2]
         { []
         }
     {offset
       c2EN2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EN6; else goto c2EN5;
       c2EN6: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EN5: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2EN0; else goto c2EN1;
       c2EN0: // global
           _s2DDr::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DDB_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DDr::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DDz_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EN1: // global
           I64[Hp - 80] = sat_s2DDF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EN8::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EN8::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2DDt_info" {
     go_up_s2DDt_info:
         const go_up_s2DDt_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+304;
 },
 sat_s2DDG_entry() //  [R1]
         { []
         }
     {offset
       c2EN9: // global
           _s2DDG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENa; else goto c2ENb;
       c2ENb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2ENd; else goto c2ENc;
       c2ENd: // global
           HpAlloc = 24;
           goto c2ENa;
       c2ENa: // global
           R1 = _s2DDG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDG::P64;
           _s2DCS::I64 = I64[_s2DDG::P64 + 24];
           _s2DDr::I64 = _s2DCS::I64 - I64[_s2DDG::P64 + 16];
           _s2DDs::I64 = I64[_s2DDG::P64 + 32] - _s2DDr::I64;
           I64[Hp - 16] = go_up_s2DDt_info;
           I64[Hp - 8] = _s2DDr::I64;
           I64[Hp] = _s2DDs::I64;
           R2 = _s2DCS::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DDt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDG_info" {
     sat_s2DDG_info:
         const sat_s2DDG_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+304;
 },
 sat_s2DDq_entry() //  [R1]
         { []
         }
     {offset
       c2ENn: // global
           _s2DDq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENo; else goto c2ENp;
       c2ENp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ENr; else goto c2ENq;
       c2ENr: // global
           HpAlloc = 16;
           goto c2ENo;
       c2ENo: // global
           R1 = _s2DDq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDq::P64;
           _s2DCR::I64 = I64[_s2DDq::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2ENx; else goto c2ENm;
       c2ENm: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2ENx; else goto c2ENE;
       c2ENx: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ENE: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDq_info" {
     sat_s2DDq_info:
         const sat_s2DDq_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 sat_s2DDL_entry() //  [R1]
         { []
         }
     {offset
       c2ENS: // global
           _s2DDL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ENT; else goto c2ENU;
       c2ENU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ENW; else goto c2ENV;
       c2ENW: // global
           HpAlloc = 16;
           goto c2ENT;
       c2ENT: // global
           R1 = _s2DDL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ENV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DDL::P64;
           _s2DCR::I64 = I64[_s2DDL::P64 + 16];
           if (%MO_S_Lt_W64(_s2DCR::I64, 0)) goto c2EO2; else goto c2ENR;
       c2ENR: // global
           if (%MO_S_Gt_W64(_s2DCR::I64, 65535)) goto c2EO2; else goto c2EO9;
       c2EO2: // global
           Hp = Hp - 16;
           R2 = _s2DCR::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EO9: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DCR::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DDL_info" {
     sat_s2DDL_info:
         const sat_s2DDL_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 GHC.Word.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EOa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2EOe; else goto c2EOd;
       c2EOe: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EOd: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2EOo; else goto c2EOx;
       c2EOo: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2EOh; else goto c2EOm;
       c2EOh: // global
           I64[Hp - 80] = sat_s2DDf_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DCZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOm: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2EOv; else goto c2EOk;
       c2EOk: // global
           I64[Hp - 80] = sat_s2DDk_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EOi::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EOi::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOx: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2EOr; else goto c2EOw;
       c2EOr: // global
           I64[Hp - 80] = sat_s2DDG_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DDq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOw: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2EOv; else goto c2EOu;
       c2EOv: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EOu: // global
           I64[Hp - 80] = sat_s2DDL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2EOs::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2EOs::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo_info" {
     GHC.Word.$w$cenumFromThenTo_info:
         const GHC.Word.$w$cenumFromThenTo_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2Ecg_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.092443936 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2ER1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2ERa; else goto c2ERb;
       c2ERa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ERb: // global
           I64[Sp - 24] = block_c2EQY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2ERk; else goto c2EQZ;
       u2ERk: // global
           call _c2EQY(R1) args: 0, res: 0, upd: 0;
       c2EQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord16_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2Ecg_srt+328;
 },
 _c2EQY() //  [R1]
         { []
         }
     {offset
       c2EQY: // global
           I64[Sp] = block_c2ER4_info;
           _s2DDQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DDQ::I64;
           if (R1 & 7 != 0) goto u2ERj; else goto c2ER5;
       u2ERj: // global
           call _c2ER4(R1) args: 0, res: 0, upd: 0;
       c2ER5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EQY_info" {
     block_c2EQY_info:
         const _c2EQY;
         const 2;
         const 4294967326;
         const S2Ecg_srt+328;
 },
 _c2ER4() //  [R1]
         { []
         }
     {offset
       c2ER4: // global
           I64[Sp] = block_c2ER9_info;
           _s2DDS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DDS::I64;
           if (R1 & 7 != 0) goto u2ERl; else goto c2ERe;
       u2ERl: // global
           call _c2ER9(R1) args: 0, res: 0, upd: 0;
       c2ERe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ER4_info" {
     block_c2ER4_info:
         const _c2ER4;
         const 66;
         const 4294967326;
         const S2Ecg_srt+328;
 },
 _c2ER9() //  [R1]
         { []
         }
     {offset
       c2ER9: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ER9_info" {
     block_c2ER9_info:
         const _c2ER9;
         const 194;
         const 4294967326;
         const S2Ecg_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.103575466 UTC

[section ""data" . GHC.Word.$w$cenumFromTo_closure" {
     GHC.Word.$w$cenumFromTo_closure:
         const GHC.Word.$w$cenumFromTo_info;
         const 0;
 },
 sat_s2DE8_entry() //  [R1]
         { []
         }
     {offset
       c2ES7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ES8; else goto c2ES9;
       c2ES8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ES9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DE1::I64 = I64[R1 + 32];
           if (_s2DE1::I64 == I64[R1 + 24]) goto c2ES6; else goto c2ES5;
       c2ES6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2ES5: // global
           R2 = _s2DE1::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DE0_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DE8_info" {
     sat_s2DE8_info:
         const sat_s2DE8_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+304;
 },
 sat_s2DE5_entry() //  [R1]
         { []
         }
     {offset
       c2ESl: // global
           _s2DE5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2ESm; else goto c2ESn;
       c2ESn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ESp; else goto c2ESo;
       c2ESp: // global
           HpAlloc = 16;
           goto c2ESm;
       c2ESm: // global
           R1 = _s2DE5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2ESo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DE5::P64;
           _s2DE1::I64 = I64[_s2DE5::P64 + 16];
           if (%MO_S_Lt_W64(_s2DE1::I64, 0)) goto c2ESv; else goto c2ESk;
       c2ESk: // global
           if (%MO_S_Gt_W64(_s2DE1::I64, 65535)) goto c2ESv; else goto c2ESC;
       c2ESv: // global
           Hp = Hp - 16;
           R2 = _s2DE1::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2ESC: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DE1::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DE5_info" {
     sat_s2DE5_info:
         const sat_s2DE5_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 go_s2DE0_entry() //  [R1, R2]
         { []
         }
     {offset
       c2ESE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2ESI; else goto c2ESH;
       c2ESI: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2ESH: // global
           _s2DDY::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DE8_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DDY::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DE5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2DE0_info" {
     go_s2DE0_info:
         const go_s2DE0_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2Ecg_srt+304;
 },
 GHC.Word.$w$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ESJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2ESN; else goto c2ESM;
       c2ESN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ESM: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2ESP; else goto c2ESQ;
       c2ESP: // global
           I64[Hp - 8] = go_s2DE0_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DE0_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2ESQ: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo_info" {
     GHC.Word.$w$cenumFromTo_info:
         const GHC.Word.$w$cenumFromTo_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2Ecg_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.11446401 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord16_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord16_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2ETs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2ETw; else goto c2ETx;
       c2ETw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2ETx: // global
           I64[Sp - 16] = block_c2ETp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2ETF; else goto c2ETq;
       u2ETF: // global
           call _c2ETp(R1) args: 0, res: 0, upd: 0;
       c2ETq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromTo_info" {
     GHC.Word.$fEnumWord16_$cenumFromTo_info:
         const GHC.Word.$fEnumWord16_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+344;
 },
 _c2ETp() //  [R1]
         { []
         }
     {offset
       c2ETp: // global
           I64[Sp] = block_c2ETv_info;
           _s2DEc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEc::I64;
           if (R1 & 7 != 0) goto u2ETE; else goto c2ETz;
       u2ETE: // global
           call _c2ETv(R1) args: 0, res: 0, upd: 0;
       c2ETz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ETp_info" {
     block_c2ETp_info:
         const _c2ETp;
         const 1;
         const 4294967326;
         const S2Ecg_srt+344;
 },
 _c2ETv() //  [R1]
         { []
         }
     {offset
       c2ETv: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2ETv_info" {
     block_c2ETv_info:
         const _c2ETv;
         const 65;
         const 4294967326;
         const S2Ecg_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.123209029 UTC

[section ""data" . GHC.Word.$wgo_closure" {
     GHC.Word.$wgo_closure:
         const GHC.Word.$wgo_info;
         const 0;
 },
 sat_s2DEp_entry() //  [R1]
         { []
         }
     {offset
       c2EU7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EU8; else goto c2EUj;
       c2EU8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EUj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DEk::I64 = I64[R1 + 16];
           if (_s2DEk::I64 != 65535) goto c2EU5; else goto c2EU6;
       c2EU5: // global
           I64[Sp - 24] = block_c2EUd_info;
           R2 = _s2DEk::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c2EU6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DEp_info" {
     sat_s2DEp_info:
         const sat_s2DEp_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+360;
 },
 _c2EUd() //  [R1, R2]
         { []
         }
     {offset
       c2EUd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EUi; else goto c2EUh;
       c2EUi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2EUh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EUd_info" {
     block_c2EUd_info:
         const _c2EUd;
         const 0;
         const 30;
 },
 sat_s2DEj_entry() //  [R1]
         { []
         }
     {offset
       c2EUt: // global
           _s2DEj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2EUu; else goto c2EUv;
       c2EUv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EUx; else goto c2EUw;
       c2EUx: // global
           HpAlloc = 16;
           goto c2EUu;
       c2EUu: // global
           R1 = _s2DEj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EUw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DEj::P64;
           _s2DEf::I64 = I64[_s2DEj::P64 + 16];
           if (%MO_S_Lt_W64(_s2DEf::I64, 0)) goto c2EUD; else goto c2EUs;
       c2EUs: // global
           if (%MO_S_Gt_W64(_s2DEf::I64, 65535)) goto c2EUD; else goto c2EUK;
       c2EUD: // global
           Hp = Hp - 16;
           R2 = _s2DEf::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c2EUK: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DEf::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DEj_info" {
     sat_s2DEj_info:
         const sat_s2DEj_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+304;
 },
 GHC.Word.$wgo_entry() //  [R2]
         { []
         }
     {offset
       c2EUL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2EUP; else goto c2EUO;
       c2EUP: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EUO: // global
           I64[Hp - 40] = sat_s2DEp_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DEj_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo_info" {
     GHC.Word.$wgo_info:
         const GHC.Word.$wgo_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2Ecg_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.133022731 UTC

[section ""data" . GHC.Word.$fEnumWord16_go_closure" {
     GHC.Word.$fEnumWord16_go_closure:
         const GHC.Word.$fEnumWord16_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_go_entry() //  [R2]
         { []
         }
     {offset
       c2EVo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EVp; else goto c2EVq;
       c2EVp: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EVq: // global
           I64[Sp - 8] = block_c2EVl_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_go_info" {
     GHC.Word.$fEnumWord16_go_info:
         const GHC.Word.$fEnumWord16_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2Ecg_srt+360;
 },
 _c2EVl() //  [R1, R2]
         { []
         }
     {offset
       c2EVl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2EVt; else goto c2EVs;
       c2EVt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2EVs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EVl_info" {
     block_c2EVl_info:
         const _c2EVl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.139028035 UTC

[section ""data" . GHC.Word.$fEnumWord16_$cenumFrom_closure" {
     GHC.Word.$fEnumWord16_$cenumFrom_closure:
         const GHC.Word.$fEnumWord16_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2EVM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EVN; else goto c2EVO;
       c2EVN: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EVO: // global
           I64[Sp - 8] = block_c2EVJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EW0; else goto c2EVK;
       u2EW0: // global
           call _c2EVJ(R1) args: 0, res: 0, upd: 0;
       c2EVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFrom_info" {
     GHC.Word.$fEnumWord16_$cenumFrom_info:
         const GHC.Word.$fEnumWord16_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+368;
 },
 _c2EVJ() //  [R1]
         { []
         }
     {offset
       c2EVJ: // global
           _s2DEx::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DEx::I64, 65535)) goto c2EVY; else goto c2EVZ;
       c2EVY: // global
           R2 = _s2DEx::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_go_entry(R2) args: 8, res: 0, upd: 8;
       c2EVZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EVJ_info" {
     block_c2EVJ_info:
         const _c2EVJ;
         const 0;
         const 4294967326;
         const S2Ecg_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.145002008 UTC

[section ""data" . GHC.Word.$fEnumWord16_closure" {
     GHC.Word.$fEnumWord16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord16_$csucc_closure+1;
         const GHC.Word.$fEnumWord16_$cpred_closure+1;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord16_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord16_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord16_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord16_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord16_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EWh: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord16_closure+1;
           R2 = GHC.Word.$fEnumWord16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord16_$cenumFromThen_info" {
     GHC.Word.$fEnumWord16_$cenumFromThen_info:
         const GHC.Word.$fEnumWord16_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2Ecg_srt+384;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.148916391 UTC

[section ""cstring" . GHC.Word.$tcWord4_bytes" {
     GHC.Word.$tcWord4_bytes:
         I8[] [87,111,114,100,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.151941659 UTC

[section ""data" . GHC.Word.$fEnumWord3_closure" {
     GHC.Word.$fEnumWord3_closure:
         const GHC.Word.$fEnumWord3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord3_entry() //  [R1]
         { []
         }
     {offset
       c2EWy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EWz; else goto c2EWA;
       c2EWz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EWA: // global
           (_c2EWt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EWt::I64 == 0) goto c2EWv; else goto c2EWu;
       c2EWv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EWu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EWt::I64;
           I64[Sp - 24] = block_c2EWw_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord3_info" {
     GHC.Word.$fEnumWord3_info:
         const GHC.Word.$fEnumWord3_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+392;
 },
 _c2EWw() //  [R1]
         { []
         }
     {offset
       c2EWw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EWw_info" {
     block_c2EWw_info:
         const _c2EWw;
         const 0;
         const 4294967326;
         const S2Ecg_srt+392;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.158063011 UTC

[section ""data" . GHC.Word.$fEnumWord4_closure" {
     GHC.Word.$fEnumWord4_closure:
         const GHC.Word.$fEnumWord4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Word.$fEnumWord4_entry() //  [R1]
         { []
         }
     {offset
       c2EWY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2EWZ; else goto c2EX0;
       c2EWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EX0: // global
           (_c2EWT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EWT::I64 == 0) goto c2EWV; else goto c2EWU;
       c2EWV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EWU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EWT::I64;
           I64[Sp - 24] = block_c2EWW_info;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord4_info" {
     GHC.Word.$fEnumWord4_info:
         const GHC.Word.$fEnumWord4_entry;
         const 0;
         const 4294967317;
         const S2Ecg_srt+400;
 },
 _c2EWW() //  [R1]
         { []
         }
     {offset
       c2EWW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2EWW_info" {
     block_c2EWW_info:
         const _c2EWW;
         const 0;
         const 4294967326;
         const S2Ecg_srt+400;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.164200751 UTC

[section ""data" . GHC.Word.neWord32_closure" {
     GHC.Word.neWord32_closure:
         const GHC.Word.neWord32_info;
 },
 GHC.Word.neWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2EXn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EXr; else goto c2EXs;
       c2EXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2EXs: // global
           I64[Sp - 16] = block_c2EXk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2EXB; else goto c2EXl;
       u2EXB: // global
           call _c2EXk(R1) args: 0, res: 0, upd: 0;
       c2EXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord32_info" {
     GHC.Word.neWord32_info:
         const GHC.Word.neWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2EXk() //  [R1]
         { []
         }
     {offset
       c2EXk: // global
           I64[Sp] = block_c2EXq_info;
           _s2DEE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEE::I64;
           if (R1 & 7 != 0) goto u2EXA; else goto c2EXu;
       u2EXA: // global
           call _c2EXq(R1) args: 0, res: 0, upd: 0;
       c2EXu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EXk_info" {
     block_c2EXk_info:
         const _c2EXk;
         const 1;
         const 30;
 },
 _c2EXq() //  [R1]
         { []
         }
     {offset
       c2EXq: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EXq_info" {
     block_c2EXq_info:
         const _c2EXq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.171531639 UTC

[section ""data" . lvl6_r2uFL_closure" {
     lvl6_r2uFL_closure:
         const lvl6_r2uFL_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r2uFL_entry() //  [R1]
         { []
         }
     {offset
       c2EY2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2EY3; else goto c2EY4;
       c2EY3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2EY4: // global
           (_c2EXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2EXZ::I64 == 0) goto c2EY1; else goto c2EY0;
       c2EY1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2EY0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2EXZ::I64;
           R2 = GHC.Word.$tcWord4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl6_r2uFL_info" {
     lvl6_r2uFL_info:
         const lvl6_r2uFL_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.175087786 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cminBound_closure" {
     GHC.Word.$fBitsWord32_$cminBound_closure:
         const GHC.Word.W32#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.178490918 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cpred_closure" {
     GHC.Word.$fEnumWord32_$cpred_closure:
         const GHC.Word.$fEnumWord32_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2EYl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EYm; else goto c2EYn;
       c2EYm: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EYn: // global
           I64[Sp - 8] = block_c2EYi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EYF; else goto c2EYj;
       u2EYF: // global
           call _c2EYi(R1) args: 0, res: 0, upd: 0;
       c2EYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cpred_info" {
     GHC.Word.$fEnumWord32_$cpred_info:
         const GHC.Word.$fEnumWord32_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+408;
 },
 _c2EYi() //  [R1]
         { []
         }
     {offset
       c2EYi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EYs; else goto c2EYr;
       c2EYs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EYr: // global
           _s2DEL::I64 = I64[R1 + 7];
           if (_s2DEL::I64 != 0) goto c2EYD; else goto c2EYE;
       c2EYD: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DEL::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EYE: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EYi_info" {
     block_c2EYi_info:
         const _c2EYi;
         const 0;
         const 4294967326;
         const S2Ecg_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.183887726 UTC

[section ""data" . GHC.Word.$fBoundedWord32_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord32_$cmaxBound_closure:
         const GHC.Word.W32#_con_info;
         const 4294967295;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.186248428 UTC

[section ""data" . GHC.Word.$fBoundedWord32_closure" {
     GHC.Word.$fBoundedWord32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.189121202 UTC

[section ""data" . GHC.Word.$fEnumWord32_$csucc_closure" {
     GHC.Word.$fEnumWord32_$csucc_closure:
         const GHC.Word.$fEnumWord32_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2EZ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2EZ5; else goto c2EZ6;
       c2EZ5: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2EZ6: // global
           I64[Sp - 8] = block_c2EZ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2EZo; else goto c2EZ2;
       u2EZo: // global
           call _c2EZ1(R1) args: 0, res: 0, upd: 0;
       c2EZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$csucc_info" {
     GHC.Word.$fEnumWord32_$csucc_info:
         const GHC.Word.$fEnumWord32_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+424;
 },
 _c2EZ1() //  [R1]
         { []
         }
     {offset
       c2EZ1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2EZb; else goto c2EZa;
       c2EZb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2EZa: // global
           _s2DER::I64 = I64[R1 + 7];
           if (_s2DER::I64 != 4294967295) goto c2EZm; else goto c2EZn;
       c2EZm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DER::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2EZn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EZ1_info" {
     block_c2EZ1_info:
         const _c2EZ1;
         const 0;
         const 4294967326;
         const S2Ecg_srt+432;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.195909011 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowsPrec_closure" {
     GHC.Word.$fShowWord32_$cshowsPrec_closure:
         const GHC.Word.$fShowWord32_$cshowsPrec_info;
 },
 GHC.Word.$fShowWord32_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2EZM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2F00; else goto c2F01;
       c2F00: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F01: // global
           I64[Sp - 24] = block_c2EZJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2F08; else goto c2EZK;
       u2F08: // global
           call _c2EZJ(R1) args: 0, res: 0, upd: 0;
       c2EZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshowsPrec_info" {
     GHC.Word.$fShowWord32_$cshowsPrec_info:
         const GHC.Word.$fShowWord32_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c2EZJ() //  [R1]
         { []
         }
     {offset
       c2EZJ: // global
           I64[Sp] = block_c2EZP_info;
           _s2DEY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DEY::I64;
           if (R1 & 7 != 0) goto u2F07; else goto c2EZQ;
       u2F07: // global
           call _c2EZP(R1) args: 0, res: 0, upd: 0;
       c2EZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EZJ_info" {
     block_c2EZJ_info:
         const _c2EZJ;
         const 2;
         const 30;
 },
 _c2EZP() //  [R1]
         { []
         }
     {offset
       c2EZP: // global
           _s2DEW::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c2EZX_info;
           R4 = _s2DEW::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EZP_info" {
     block_c2EZP_info:
         const _c2EZP;
         const 66;
         const 30;
 },
 _c2EZX() //  [R1, R2]
         { []
         }
     {offset
       c2EZX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F06; else goto c2F05;
       c2F06: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F05: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2EZX_info" {
     block_c2EZX_info:
         const _c2EZX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.205558227 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshow_closure" {
     GHC.Word.$fShowWord32_$cshow_closure:
         const GHC.Word.$fShowWord32_$cshow_info;
 },
 GHC.Word.$fShowWord32_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c2F0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2F0K; else goto c2F0L;
       c2F0K: // global
           R2 = R2;
           R1 = GHC.Word.$fShowWord32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F0L: // global
           I64[Sp - 8] = block_c2F0y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2F0Q; else goto c2F0z;
       u2F0Q: // global
           call _c2F0y(R1) args: 0, res: 0, upd: 0;
       c2F0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshow_info" {
     GHC.Word.$fShowWord32_$cshow_info:
         const GHC.Word.$fShowWord32_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2F0y() //  [R1]
         { []
         }
     {offset
       c2F0y: // global
           I64[Sp] = block_c2F0H_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F0y_info" {
     block_c2F0y_info:
         const _c2F0y;
         const 0;
         const 30;
 },
 _c2F0H() //  [R1, R2]
         { []
         }
     {offset
       c2F0H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F0P; else goto c2F0O;
       c2F0P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F0O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F0H_info" {
     block_c2F0H_info:
         const _c2F0H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.213909112 UTC

[section ""data" . GHC.Word.$fShowWord2_closure" {
     GHC.Word.$fShowWord2_closure:
         const GHC.Word.$fShowWord2_info;
 },
 GHC.Word.$fShowWord2_entry() //  [R2, R3]
         { []
         }
     {offset
       c2F1f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F1o; else goto c2F1p;
       c2F1o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fShowWord2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F1p: // global
           I64[Sp - 16] = block_c2F1c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2F1u; else goto c2F1d;
       u2F1u: // global
           call _c2F1c(R1) args: 0, res: 0, upd: 0;
       c2F1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord2_info" {
     GHC.Word.$fShowWord2_info:
         const GHC.Word.$fShowWord2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2F1c() //  [R1]
         { []
         }
     {offset
       c2F1c: // global
           _s2DFd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2F1l_info;
           R4 = _s2DFd::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F1c_info" {
     block_c2F1c_info:
         const _c2F1c;
         const 1;
         const 30;
 },
 _c2F1l() //  [R1, R2]
         { []
         }
     {offset
       c2F1l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F1t; else goto c2F1s;
       c2F1t: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2F1s: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F1l_info" {
     block_c2F1l_info:
         const _c2F1l;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.221610989 UTC

[section ""data" . GHC.Word.$fShowWord32_$cshowList_closure" {
     GHC.Word.$fShowWord32_$cshowList_closure:
         const GHC.Word.$fShowWord32_$cshowList_info;
 },
 GHC.Word.$fShowWord32_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c2F1P: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fShowWord2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fShowWord32_$cshowList_info" {
     GHC.Word.$fShowWord32_$cshowList_info:
         const GHC.Word.$fShowWord32_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.22474339 UTC

[section ""data" . GHC.Word.$fShowWord32_closure" {
     GHC.Word.$fShowWord32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Word.$fShowWord32_$cshowsPrec_closure+3;
         const GHC.Word.$fShowWord32_$cshow_closure+1;
         const GHC.Word.$fShowWord32_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.226927591 UTC

[section ""data" . GHC.Word.$wlvl1_closure" {
     GHC.Word.$wlvl1_closure:
         const GHC.Word.$wlvl1_info;
         const 0;
 },
 GHC.Word.$wlvl1_entry() //  [R2]
         { []
         }
     {offset
       c2F21: // global
           R6 = GHC.Word.$fBoundedWord32_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl6_r2uFL_closure;
           R2 = GHC.Word.$fShowWord32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl1_info" {
     GHC.Word.$wlvl1_info:
         const GHC.Word.$wlvl1_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2Ecg_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.230877528 UTC

[section ""data" . GHC.Word.$w$ctoEnum1_closure" {
     GHC.Word.$w$ctoEnum1_closure:
         const GHC.Word.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Word.$w$ctoEnum1_entry() //  [R2]
         { []
         }
     {offset
       c2F2h: // global
           _s2DFn::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto c2F2p; else goto c2F2g;
       c2F2g: // global
           if (%MO_S_Gt_W64(_s2DFn::I64,
                            4294967295)) goto c2F2p; else goto c2F2t;
       c2F2p: // global
           R2 = _s2DFn::I64;
           call GHC.Word.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c2F2t: // global
           R1 = _s2DFn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$ctoEnum1_info" {
     GHC.Word.$w$ctoEnum1_info:
         const GHC.Word.$w$ctoEnum1_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S2Ecg_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.235295565 UTC

[section ""data" . GHC.Word.$fEnumWord32_$ctoEnum_closure" {
     GHC.Word.$fEnumWord32_$ctoEnum_closure:
         const GHC.Word.$fEnumWord32_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2F2H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2F2P; else goto c2F2Q;
       c2F2P: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F2Q: // global
           I64[Sp - 8] = block_c2F2E_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2F2V; else goto c2F2F;
       u2F2V: // global
           call _c2F2E(R1) args: 0, res: 0, upd: 0;
       c2F2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$ctoEnum_info" {
     GHC.Word.$fEnumWord32_$ctoEnum_info:
         const GHC.Word.$fEnumWord32_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+464;
 },
 _c2F2E() //  [R1]
         { []
         }
     {offset
       c2F2E: // global
           I64[Sp] = block_c2F2K_info;
           R2 = I64[R1 + 7];
           call GHC.Word.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F2E_info" {
     block_c2F2E_info:
         const _c2F2E;
         const 0;
         const 4294967326;
         const S2Ecg_srt+472;
 },
 _c2F2K() //  [R1]
         { []
         }
     {offset
       c2F2K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F2U; else goto c2F2T;
       c2F2U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2F2T: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2F2K_info" {
     block_c2F2K_info:
         const _c2F2K;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.252477564 UTC

[section ""data" . GHC.Word.$w$cenumFromThenTo1_closure" {
     GHC.Word.$w$cenumFromThenTo1_closure:
         const GHC.Word.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s2DFS_entry() //  [R1]
         { []
         }
     {offset
       c2F3T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F3U; else goto c2F3V;
       c2F3U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F3V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s2DFK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DFS_info" {
     sat_s2DFS_info:
         const sat_s2DFS_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+456;
 },
 sat_s2DFQ_entry() //  [R1]
         { []
         }
     {offset
       c2F45: // global
           _s2DFQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F46; else goto c2F47;
       c2F47: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F49; else goto c2F48;
       c2F49: // global
           HpAlloc = 16;
           goto c2F46;
       c2F46: // global
           R1 = _s2DFQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F48: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFQ::P64;
           _s2DFL::I64 = I64[_s2DFQ::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFL::I64, 0)) goto c2F4f; else goto c2F44;
       c2F44: // global
           if (%MO_S_Gt_W64(_s2DFL::I64,
                            4294967295)) goto c2F4f; else goto c2F4m;
       c2F4f: // global
           Hp = Hp - 16;
           R2 = _s2DFL::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F4m: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFL::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DFQ_info" {
     sat_s2DFQ_info:
         const sat_s2DFQ_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 sat_s2DFW_entry() //  [R1]
         { []
         }
     {offset
       c2F4x: // global
           _s2DFW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F4y; else goto c2F4z;
       c2F4z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F4B; else goto c2F4A;
       c2F4B: // global
           HpAlloc = 16;
           goto c2F4y;
       c2F4y: // global
           R1 = _s2DFW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F4A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFW::P64;
           _s2DFL::I64 = I64[_s2DFW::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFL::I64, 0)) goto c2F4H; else goto c2F4w;
       c2F4w: // global
           if (%MO_S_Gt_W64(_s2DFL::I64,
                            4294967295)) goto c2F4H; else goto c2F4O;
       c2F4H: // global
           Hp = Hp - 16;
           R2 = _s2DFL::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F4O: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFL::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DFW_info" {
     sat_s2DFW_info:
         const sat_s2DFW_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 go_dn_s2DFK_entry() //  [R1, R2]
         { []
         }
     {offset
       c2F4S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F4W; else goto c2F4V;
       c2F4W: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F4V: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c2F4Q; else goto c2F4R;
       c2F4Q: // global
           _s2DFI::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DFS_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DFI::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DFQ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F4R: // global
           I64[Hp - 80] = sat_s2DFW_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F4Y::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F4Y::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s2DFK_info" {
     go_dn_s2DFK_info:
         const go_dn_s2DFK_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+456;
 },
 sat_s2DFX_entry() //  [R1]
         { []
         }
     {offset
       c2F4Z: // global
           _s2DFX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F50; else goto c2F51;
       c2F51: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F53; else goto c2F52;
       c2F53: // global
           HpAlloc = 24;
           goto c2F50;
       c2F50: // global
           R1 = _s2DFX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F52: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFX::P64;
           _s2DFA::I64 = I64[_s2DFX::P64 + 24];
           _s2DFI::I64 = _s2DFA::I64 - I64[_s2DFX::P64 + 16];
           _s2DFJ::I64 = I64[_s2DFX::P64 + 32] - _s2DFI::I64;
           I64[Hp - 16] = go_dn_s2DFK_info;
           I64[Hp - 8] = _s2DFI::I64;
           I64[Hp] = _s2DFJ::I64;
           R2 = _s2DFA::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s2DFK_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DFX_info" {
     sat_s2DFX_info:
         const sat_s2DFX_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+456;
 },
 sat_s2DFH_entry() //  [R1]
         { []
         }
     {offset
       c2F5d: // global
           _s2DFH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F5e; else goto c2F5f;
       c2F5f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F5h; else goto c2F5g;
       c2F5h: // global
           HpAlloc = 16;
           goto c2F5e;
       c2F5e: // global
           R1 = _s2DFH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F5g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DFH::P64;
           _s2DFz::I64 = I64[_s2DFH::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F5n; else goto c2F5c;
       c2F5c: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F5n; else goto c2F5u;
       c2F5n: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F5u: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DFH_info" {
     sat_s2DFH_info:
         const sat_s2DFH_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 sat_s2DG2_entry() //  [R1]
         { []
         }
     {offset
       c2F5I: // global
           _s2DG2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F5J; else goto c2F5K;
       c2F5K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F5M; else goto c2F5L;
       c2F5M: // global
           HpAlloc = 16;
           goto c2F5J;
       c2F5J: // global
           R1 = _s2DG2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F5L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DG2::P64;
           _s2DFz::I64 = I64[_s2DG2::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F5S; else goto c2F5H;
       c2F5H: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F5S; else goto c2F5Z;
       c2F5S: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F5Z: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DG2_info" {
     sat_s2DG2_info:
         const sat_s2DG2_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 sat_s2DGj_entry() //  [R1]
         { []
         }
     {offset
       c2F6v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2F6w; else goto c2F6x;
       c2F6w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F6x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s2DGb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGj_info" {
     sat_s2DGj_info:
         const sat_s2DGj_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+456;
 },
 sat_s2DGh_entry() //  [R1]
         { []
         }
     {offset
       c2F6H: // global
           _s2DGh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F6I; else goto c2F6J;
       c2F6J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F6L; else goto c2F6K;
       c2F6L: // global
           HpAlloc = 16;
           goto c2F6I;
       c2F6I: // global
           R1 = _s2DGh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGh::P64;
           _s2DGc::I64 = I64[_s2DGh::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGc::I64, 0)) goto c2F6R; else goto c2F6G;
       c2F6G: // global
           if (%MO_S_Gt_W64(_s2DGc::I64,
                            4294967295)) goto c2F6R; else goto c2F6Y;
       c2F6R: // global
           Hp = Hp - 16;
           R2 = _s2DGc::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F6Y: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGc::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGh_info" {
     sat_s2DGh_info:
         const sat_s2DGh_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 sat_s2DGn_entry() //  [R1]
         { []
         }
     {offset
       c2F79: // global
           _s2DGn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7a; else goto c2F7b;
       c2F7b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F7d; else goto c2F7c;
       c2F7d: // global
           HpAlloc = 16;
           goto c2F7a;
       c2F7a: // global
           R1 = _s2DGn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGn::P64;
           _s2DGc::I64 = I64[_s2DGn::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGc::I64, 0)) goto c2F7j; else goto c2F78;
       c2F78: // global
           if (%MO_S_Gt_W64(_s2DGc::I64,
                            4294967295)) goto c2F7j; else goto c2F7q;
       c2F7j: // global
           Hp = Hp - 16;
           R2 = _s2DGc::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F7q: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGc::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGn_info" {
     sat_s2DGn_info:
         const sat_s2DGn_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 go_up_s2DGb_entry() //  [R1, R2]
         { []
         }
     {offset
       c2F7u: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F7y; else goto c2F7x;
       c2F7y: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2F7x: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c2F7s; else goto c2F7t;
       c2F7s: // global
           _s2DG9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DGj_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DG9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DGh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F7t: // global
           I64[Hp - 80] = sat_s2DGn_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F7A::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F7A::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s2DGb_info" {
     go_up_s2DGb_info:
         const go_up_s2DGb_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S2Ecg_srt+456;
 },
 sat_s2DGo_entry() //  [R1]
         { []
         }
     {offset
       c2F7B: // global
           _s2DGo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7C; else goto c2F7D;
       c2F7D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2F7F; else goto c2F7E;
       c2F7F: // global
           HpAlloc = 24;
           goto c2F7C;
       c2F7C: // global
           R1 = _s2DGo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGo::P64;
           _s2DFA::I64 = I64[_s2DGo::P64 + 24];
           _s2DG9::I64 = _s2DFA::I64 - I64[_s2DGo::P64 + 16];
           _s2DGa::I64 = I64[_s2DGo::P64 + 32] - _s2DG9::I64;
           I64[Hp - 16] = go_up_s2DGb_info;
           I64[Hp - 8] = _s2DG9::I64;
           I64[Hp] = _s2DGa::I64;
           R2 = _s2DFA::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s2DGb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGo_info" {
     sat_s2DGo_info:
         const sat_s2DGo_entry;
         const 12884901888;
         const 4294967311;
         const S2Ecg_srt+456;
 },
 sat_s2DG8_entry() //  [R1]
         { []
         }
     {offset
       c2F7P: // global
           _s2DG8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F7Q; else goto c2F7R;
       c2F7R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F7T; else goto c2F7S;
       c2F7T: // global
           HpAlloc = 16;
           goto c2F7Q;
       c2F7Q: // global
           R1 = _s2DG8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F7S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DG8::P64;
           _s2DFz::I64 = I64[_s2DG8::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F7Z; else goto c2F7O;
       c2F7O: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F7Z; else goto c2F86;
       c2F7Z: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F86: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DG8_info" {
     sat_s2DG8_info:
         const sat_s2DG8_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 sat_s2DGt_entry() //  [R1]
         { []
         }
     {offset
       c2F8k: // global
           _s2DGt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2F8l; else goto c2F8m;
       c2F8m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2F8o; else goto c2F8n;
       c2F8o: // global
           HpAlloc = 16;
           goto c2F8l;
       c2F8l: // global
           R1 = _s2DGt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2F8n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGt::P64;
           _s2DFz::I64 = I64[_s2DGt::P64 + 16];
           if (%MO_S_Lt_W64(_s2DFz::I64, 0)) goto c2F8u; else goto c2F8j;
       c2F8j: // global
           if (%MO_S_Gt_W64(_s2DFz::I64,
                            4294967295)) goto c2F8u; else goto c2F8B;
       c2F8u: // global
           Hp = Hp - 16;
           R2 = _s2DFz::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2F8B: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DFz::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGt_info" {
     sat_s2DGt_info:
         const sat_s2DGt_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 GHC.Word.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2F8C: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2F8G; else goto c2F8F;
       c2F8G: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2F8F: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c2F8Q; else goto c2F8Z;
       c2F8Q: // global
           if (%MO_S_Le_W64(R4, R3)) goto c2F8J; else goto c2F8O;
       c2F8J: // global
           I64[Hp - 80] = sat_s2DFX_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DFH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8O: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c2F8X; else goto c2F8M;
       c2F8M: // global
           I64[Hp - 80] = sat_s2DG2_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F8K::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F8K::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8Z: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c2F8T; else goto c2F8Y;
       c2F8T: // global
           I64[Hp - 80] = sat_s2DGo_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s2DG8_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8Y: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c2F8X; else goto c2F8W;
       c2F8X: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2F8W: // global
           I64[Hp - 80] = sat_s2DGt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c2F8U::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c2F8U::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromThenTo1_info" {
     GHC.Word.$w$cenumFromThenTo1_info:
         const GHC.Word.$w$cenumFromThenTo1_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S2Ecg_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.2877947 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2FbB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FbK; else goto c2FbL;
       c2FbK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FbL: // global
           I64[Sp - 24] = block_c2Fby_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2FbU; else goto c2Fbz;
       u2FbU: // global
           call _c2Fby(R1) args: 0, res: 0, upd: 0;
       c2Fbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord32_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2Ecg_srt+480;
 },
 _c2Fby() //  [R1]
         { []
         }
     {offset
       c2Fby: // global
           I64[Sp] = block_c2FbE_info;
           _s2DGy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DGy::I64;
           if (R1 & 7 != 0) goto u2FbT; else goto c2FbF;
       u2FbT: // global
           call _c2FbE(R1) args: 0, res: 0, upd: 0;
       c2FbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fby_info" {
     block_c2Fby_info:
         const _c2Fby;
         const 2;
         const 4294967326;
         const S2Ecg_srt+480;
 },
 _c2FbE() //  [R1]
         { []
         }
     {offset
       c2FbE: // global
           I64[Sp] = block_c2FbJ_info;
           _s2DGA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DGA::I64;
           if (R1 & 7 != 0) goto u2FbV; else goto c2FbO;
       u2FbV: // global
           call _c2FbJ(R1) args: 0, res: 0, upd: 0;
       c2FbO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FbE_info" {
     block_c2FbE_info:
         const _c2FbE;
         const 66;
         const 4294967326;
         const S2Ecg_srt+480;
 },
 _c2FbJ() //  [R1]
         { []
         }
     {offset
       c2FbJ: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Word.$w$cenumFromThenTo1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FbJ_info" {
     block_c2FbJ_info:
         const _c2FbJ;
         const 194;
         const 4294967326;
         const S2Ecg_srt+480;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.298273064 UTC

[section ""data" . GHC.Word.$w$cenumFromTo1_closure" {
     GHC.Word.$w$cenumFromTo1_closure:
         const GHC.Word.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s2DGQ_entry() //  [R1]
         { []
         }
     {offset
       c2FcH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FcI; else goto c2FcJ;
       c2FcI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FcJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DGJ::I64 = I64[R1 + 32];
           if (_s2DGJ::I64 == I64[R1 + 24]) goto c2FcG; else goto c2FcF;
       c2FcG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c2FcF: // global
           R2 = _s2DGJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s2DGI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGQ_info" {
     sat_s2DGQ_info:
         const sat_s2DGQ_entry;
         const 8589934593;
         const 4294967311;
         const S2Ecg_srt+456;
 },
 sat_s2DGN_entry() //  [R1]
         { []
         }
     {offset
       c2FcV: // global
           _s2DGN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2FcW; else goto c2FcX;
       c2FcX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FcZ; else goto c2FcY;
       c2FcZ: // global
           HpAlloc = 16;
           goto c2FcW;
       c2FcW: // global
           R1 = _s2DGN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FcY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DGN::P64;
           _s2DGJ::I64 = I64[_s2DGN::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGJ::I64, 0)) goto c2Fd5; else goto c2FcU;
       c2FcU: // global
           if (%MO_S_Gt_W64(_s2DGJ::I64,
                            4294967295)) goto c2Fd5; else goto c2Fdc;
       c2Fd5: // global
           Hp = Hp - 16;
           R2 = _s2DGJ::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2Fdc: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DGN_info" {
     sat_s2DGN_info:
         const sat_s2DGN_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 go_s2DGI_entry() //  [R1, R2]
         { []
         }
     {offset
       c2Fde: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Fdi; else goto c2Fdh;
       c2Fdi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fdh: // global
           _s2DGG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s2DGQ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s2DGG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s2DGN_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s2DGI_info" {
     go_s2DGI_info:
         const go_s2DGI_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S2Ecg_srt+456;
 },
 GHC.Word.$w$cenumFromTo1_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fdj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fdn; else goto c2Fdm;
       c2Fdn: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fdm: // global
           if (%MO_S_Le_W64(R2, R3)) goto c2Fdp; else goto c2Fdq;
       c2Fdp: // global
           I64[Hp - 8] = go_s2DGI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s2DGI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c2Fdq: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$w$cenumFromTo1_info" {
     GHC.Word.$w$cenumFromTo1_info:
         const GHC.Word.$w$cenumFromTo1_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S2Ecg_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.309316787 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord32_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord32_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fe3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fe7; else goto c2Fe8;
       c2Fe7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fe8: // global
           I64[Sp - 16] = block_c2Fe0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Feg; else goto c2Fe1;
       u2Feg: // global
           call _c2Fe0(R1) args: 0, res: 0, upd: 0;
       c2Fe1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromTo_info" {
     GHC.Word.$fEnumWord32_$cenumFromTo_info:
         const GHC.Word.$fEnumWord32_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+496;
 },
 _c2Fe0() //  [R1]
         { []
         }
     {offset
       c2Fe0: // global
           I64[Sp] = block_c2Fe6_info;
           _s2DGU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DGU::I64;
           if (R1 & 7 != 0) goto u2Fef; else goto c2Fea;
       u2Fef: // global
           call _c2Fe6(R1) args: 0, res: 0, upd: 0;
       c2Fea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fe0_info" {
     block_c2Fe0_info:
         const _c2Fe0;
         const 1;
         const 4294967326;
         const S2Ecg_srt+496;
 },
 _c2Fe6() //  [R1]
         { []
         }
     {offset
       c2Fe6: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Word.$w$cenumFromTo1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fe6_info" {
     block_c2Fe6_info:
         const _c2Fe6;
         const 65;
         const 4294967326;
         const S2Ecg_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.318020383 UTC

[section ""data" . GHC.Word.$wgo1_closure" {
     GHC.Word.$wgo1_closure:
         const GHC.Word.$wgo1_info;
         const 0;
 },
 sat_s2DH7_entry() //  [R1]
         { []
         }
     {offset
       c2FeI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FeJ; else goto c2FeU;
       c2FeJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FeU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s2DH2::I64 = I64[R1 + 16];
           if (_s2DH2::I64 != 4294967295) goto c2FeG; else goto c2FeH;
       c2FeG: // global
           I64[Sp - 24] = block_c2FeO_info;
           R2 = _s2DH2::I64 + 1;
           Sp = Sp - 24;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c2FeH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DH7_info" {
     sat_s2DH7_info:
         const sat_s2DH7_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+512;
 },
 _c2FeO() //  [R1, R2]
         { []
         }
     {offset
       c2FeO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2FeT; else goto c2FeS;
       c2FeT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c2FeS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c2FeO_info" {
     block_c2FeO_info:
         const _c2FeO;
         const 0;
         const 30;
 },
 sat_s2DH1_entry() //  [R1]
         { []
         }
     {offset
       c2Ff4: // global
           _s2DH1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ff5; else goto c2Ff6;
       c2Ff6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ff8; else goto c2Ff7;
       c2Ff8: // global
           HpAlloc = 16;
           goto c2Ff5;
       c2Ff5: // global
           R1 = _s2DH1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Ff7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DH1::P64;
           _s2DGX::I64 = I64[_s2DH1::P64 + 16];
           if (%MO_S_Lt_W64(_s2DGX::I64, 0)) goto c2Ffe; else goto c2Ff3;
       c2Ff3: // global
           if (%MO_S_Gt_W64(_s2DGX::I64,
                            4294967295)) goto c2Ffe; else goto c2Ffl;
       c2Ffe: // global
           Hp = Hp - 16;
           R2 = _s2DGX::I64;
           Sp = Sp - 16;
           call GHC.Word.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c2Ffl: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DGX::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DH1_info" {
     sat_s2DH1_info:
         const sat_s2DH1_entry;
         const 4294967296;
         const 4294967313;
         const S2Ecg_srt+456;
 },
 GHC.Word.$wgo1_entry() //  [R2]
         { []
         }
     {offset
       c2Ffm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c2Ffq; else goto c2Ffp;
       c2Ffq: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Word.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ffp: // global
           I64[Hp - 40] = sat_s2DH7_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s2DH1_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wgo1_info" {
     GHC.Word.$wgo1_info:
         const GHC.Word.$wgo1_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S2Ecg_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.32758697 UTC

[section ""data" . GHC.Word.$fEnumWord32_go_closure" {
     GHC.Word.$fEnumWord32_go_closure:
         const GHC.Word.$fEnumWord32_go_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_go_entry() //  [R2]
         { []
         }
     {offset
       c2Fg1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fg2; else goto c2Fg3;
       c2Fg2: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fg3: // global
           I64[Sp - 8] = block_c2FfY_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Word.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_go_info" {
     GHC.Word.$fEnumWord32_go_info:
         const GHC.Word.$fEnumWord32_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S2Ecg_srt+512;
 },
 _c2FfY() //  [R1, R2]
         { []
         }
     {offset
       c2FfY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2Fg6; else goto c2Fg5;
       c2Fg6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2Fg5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FfY_info" {
     block_c2FfY_info:
         const _c2FfY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.333040938 UTC

[section ""data" . GHC.Word.$fEnumWord32_$cenumFrom_closure" {
     GHC.Word.$fEnumWord32_$cenumFrom_closure:
         const GHC.Word.$fEnumWord32_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2Fgp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fgq; else goto c2Fgr;
       c2Fgq: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fgr: // global
           I64[Sp - 8] = block_c2Fgm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FgD; else goto c2Fgn;
       u2FgD: // global
           call _c2Fgm(R1) args: 0, res: 0, upd: 0;
       c2Fgn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFrom_info" {
     GHC.Word.$fEnumWord32_$cenumFrom_info:
         const GHC.Word.$fEnumWord32_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+520;
 },
 _c2Fgm() //  [R1]
         { []
         }
     {offset
       c2Fgm: // global
           _s2DHf::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s2DHf::I64,
                            4294967295)) goto c2FgB; else goto c2FgC;
       c2FgB: // global
           R2 = _s2DHf::I64;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_go_entry(R2) args: 8, res: 0, upd: 8;
       c2FgC: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fgm_info" {
     block_c2Fgm_info:
         const _c2Fgm;
         const 0;
         const 4294967326;
         const S2Ecg_srt+520;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.338684128 UTC

[section ""data" . GHC.Word.$fEnumWord32_closure" {
     GHC.Word.$fEnumWord32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord32_$csucc_closure+1;
         const GHC.Word.$fEnumWord32_$cpred_closure+1;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord32_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord32_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord32_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord32_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord32_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FgV: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord32_closure+1;
           R2 = GHC.Word.$fEnumWord32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord32_$cenumFromThen_info" {
     GHC.Word.$fEnumWord32_$cenumFromThen_info:
         const GHC.Word.$fEnumWord32_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S2Ecg_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.343010683 UTC

[section ""data" . GHC.Word.$fBitsWord7_closure" {
     GHC.Word.$fBitsWord7_closure:
         const GHC.Word.W64#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.344657583 UTC

[section ""data" . GHC.Word.$fNumWord3_closure" {
     GHC.Word.$fNumWord3_closure:
         const GHC.Word.W64#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.347373205 UTC

[section ""data" . GHC.Word.eqWord64_closure" {
     GHC.Word.eqWord64_closure:
         const GHC.Word.eqWord64_info;
 },
 GHC.Word.eqWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fhc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fhg; else goto c2Fhh;
       c2Fhg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fhh: // global
           I64[Sp - 16] = block_c2Fh9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fhq; else goto c2Fha;
       u2Fhq: // global
           call _c2Fh9(R1) args: 0, res: 0, upd: 0;
       c2Fha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord64_info" {
     GHC.Word.eqWord64_info:
         const GHC.Word.eqWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Fh9() //  [R1]
         { []
         }
     {offset
       c2Fh9: // global
           I64[Sp] = block_c2Fhf_info;
           _s2DHk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHk::I64;
           if (R1 & 7 != 0) goto u2Fhp; else goto c2Fhj;
       u2Fhp: // global
           call _c2Fhf(R1) args: 0, res: 0, upd: 0;
       c2Fhj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fh9_info" {
     block_c2Fh9_info:
         const _c2Fh9;
         const 1;
         const 30;
 },
 _c2Fhf() //  [R1]
         { []
         }
     {offset
       c2Fhf: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fhf_info" {
     block_c2Fhf_info:
         const _c2Fhf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.354826015 UTC

[section ""data" . GHC.Word.$fNumWord64_$csignum_closure" {
     GHC.Word.$fNumWord64_$csignum_closure:
         const GHC.Word.$fNumWord64_$csignum_info;
 },
 GHC.Word.$fNumWord64_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2FhS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FhT; else goto c2FhU;
       c2FhT: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FhU: // global
           I64[Sp - 8] = block_c2FhP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fi2; else goto c2FhQ;
       u2Fi2: // global
           call _c2FhP(R1) args: 0, res: 0, upd: 0;
       c2FhQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord64_$csignum_info" {
     GHC.Word.$fNumWord64_$csignum_info:
         const GHC.Word.$fNumWord64_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FhP() //  [R1]
         { []
         }
     {offset
       c2FhP: // global
           if (I64[R1 + 7] == 0) goto c2Fi1; else goto c2Fi0;
       c2Fi1: // global
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fi0: // global
           R1 = GHC.Word.$fNumWord3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FhP_info" {
     block_c2FhP_info:
         const _c2FhP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.35981269 UTC

[section ""data" . GHC.Word.$fNumWord64_closure" {
     GHC.Word.$fNumWord64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord64_$c+_closure+2;
         const GHC.Word.$fNumWord64_$c-_closure+2;
         const GHC.Word.$fNumWord64_$c*_closure+2;
         const GHC.Word.$fNumWord64_$cnegate_closure+1;
         const GHC.Word.$fNumWord64_$cabs_closure+1;
         const GHC.Word.$fNumWord64_$csignum_closure+1;
         const GHC.Word.$fNumWord64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.362252499 UTC

[section ""data" . GHC.Word.$fEnumWord7_closure" {
     GHC.Word.$fEnumWord7_closure:
         const GHC.Word.$fEnumWord7_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2Fip_srtd" {
     u2Fip_srtd:
         const S2Ecg_srt+56;
         const 43;
         const 4398046511105;
 },
 GHC.Word.$fEnumWord7_entry() //  [R1]
         { []
         }
     {offset
       c2Fim: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fin; else goto c2Fio;
       c2Fin: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Fio: // global
           (_c2Fij::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2Fij::I64 == 0) goto c2Fil; else goto c2Fik;
       c2Fil: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2Fik: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2Fij::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord7_info" {
     GHC.Word.$fEnumWord7_info:
         const GHC.Word.$fEnumWord7_entry;
         const 0;
         const 18446744069414584341;
         const u2Fip_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.367009699 UTC

[section ""data" . GHC.Word.$fEnumWord9_closure" {
     GHC.Word.$fEnumWord9_closure:
         const GHC.Word.$fEnumWord9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u2FiI_srtd" {
     u2FiI_srtd:
         const S2Ecg_srt+56;
         const 44;
         const 8796093022209;
 },
 GHC.Word.$fEnumWord9_entry() //  [R1]
         { []
         }
     {offset
       c2FiF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FiG; else goto c2FiH;
       c2FiG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FiH: // global
           (_c2FiC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c2FiC::I64 == 0) goto c2FiE; else goto c2FiD;
       c2FiE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c2FiD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c2FiC::I64;
           R2 = lvl_r2uFF_closure;
           Sp = Sp - 16;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord9_info" {
     GHC.Word.$fEnumWord9_info:
         const GHC.Word.$fEnumWord9_entry;
         const 0;
         const 18446744069414584341;
         const u2FiI_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.372476104 UTC

[section ""data" . GHC.Word.neWord64_closure" {
     GHC.Word.neWord64_closure:
         const GHC.Word.neWord64_info;
 },
 GHC.Word.neWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FiZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fj3; else goto c2Fj4;
       c2Fj3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.neWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fj4: // global
           I64[Sp - 16] = block_c2FiW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fjd; else goto c2FiX;
       u2Fjd: // global
           call _c2FiW(R1) args: 0, res: 0, upd: 0;
       c2FiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.neWord64_info" {
     GHC.Word.neWord64_info:
         const GHC.Word.neWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FiW() //  [R1]
         { []
         }
     {offset
       c2FiW: // global
           I64[Sp] = block_c2Fj2_info;
           _s2DHv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHv::I64;
           if (R1 & 7 != 0) goto u2Fjc; else goto c2Fj6;
       u2Fjc: // global
           call _c2Fj2(R1) args: 0, res: 0, upd: 0;
       c2Fj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FiW_info" {
     block_c2FiW_info:
         const _c2FiW;
         const 1;
         const 30;
 },
 _c2Fj2() //  [R1]
         { []
         }
     {offset
       c2Fj2: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fj2_info" {
     block_c2Fj2_info:
         const _c2Fj2;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.382102052 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdivMod_closure" {
     GHC.Word.$fIntegralWord64_$cdivMod_closure:
         const GHC.Word.$fIntegralWord64_$cdivMod_info;
         const 0;
 },
 sat_s2DHJ_entry() //  [R1]
         { []
         }
     {offset
       c2FjU: // global
           _s2DHJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2FjX; else goto c2FjY;
       c2FjY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fk0; else goto c2FjZ;
       c2Fk0: // global
           HpAlloc = 16;
           goto c2FjX;
       c2FjX: // global
           R1 = _s2DHJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2FjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DHJ::P64;
           _s2DHI::I64 = I64[_s2DHJ::P64 + 16] % I64[_s2DHJ::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DHI::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DHJ_info" {
     sat_s2DHJ_info:
         const sat_s2DHJ_entry;
         const 8589934592;
         const 20;
 },
 sat_s2DHH_entry() //  [R1]
         { []
         }
     {offset
       c2Fk7: // global
           _s2DHH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fka; else goto c2Fkb;
       c2Fkb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fkd; else goto c2Fkc;
       c2Fkd: // global
           HpAlloc = 16;
           goto c2Fka;
       c2Fka: // global
           R1 = _s2DHH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Fkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DHH::P64;
           _s2DHG::I64 = I64[_s2DHH::P64 + 16] / I64[_s2DHH::P64 + 24];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DHG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DHH_info" {
     sat_s2DHH_info:
         const sat_s2DHH_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord64_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fkf; else goto c2Fkg;
       c2Fkf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fkg: // global
           I64[Sp - 16] = block_c2FjC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fkq; else goto c2FjD;
       u2Fkq: // global
           call _c2FjC(R1) args: 0, res: 0, upd: 0;
       c2FjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cdivMod_info" {
     GHC.Word.$fIntegralWord64_$cdivMod_info:
         const GHC.Word.$fIntegralWord64_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2FjC() //  [R1]
         { []
         }
     {offset
       c2FjC: // global
           I64[Sp] = block_c2FjH_info;
           _s2DHC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHC::I64;
           if (R1 & 7 != 0) goto u2Fkp; else goto c2FjI;
       u2Fkp: // global
           call _c2FjH(R1) args: 0, res: 0, upd: 0;
       c2FjI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FjC_info" {
     block_c2FjC_info:
         const _c2FjC;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2FjH() //  [R1]
         { []
         }
     {offset
       c2FjH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Fkk; else goto c2Fkj;
       c2Fkk: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fkj: // global
           _s2DHF::I64 = I64[R1 + 7];
           if (_s2DHF::I64 != 0) goto c2Fkn; else goto c2Fko;
       c2Fkn: // global
           I64[Hp - 80] = sat_s2DHJ_info;
           _s2DHC::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DHC::I64;
           I64[Hp - 56] = _s2DHF::I64;
           I64[Hp - 48] = sat_s2DHH_info;
           I64[Hp - 32] = _s2DHC::I64;
           I64[Hp - 24] = _s2DHF::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fko: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FjH_info" {
     block_c2FjH_info:
         const _c2FjH;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.394311392 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cquotRem_closure" {
     GHC.Word.$fIntegralWord64_$cquotRem_closure:
         const GHC.Word.$fIntegralWord64_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fl7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Flb; else goto c2Flc;
       c2Flb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Flc: // global
           I64[Sp - 16] = block_c2Fl4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Flu; else goto c2Fl5;
       u2Flu: // global
           call _c2Fl4(R1) args: 0, res: 0, upd: 0;
       c2Fl5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cquotRem_info" {
     GHC.Word.$fIntegralWord64_$cquotRem_info:
         const GHC.Word.$fIntegralWord64_$cquotRem_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2Fl4() //  [R1]
         { []
         }
     {offset
       c2Fl4: // global
           I64[Sp] = block_c2Fla_info;
           _s2DHN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHN::I64;
           if (R1 & 7 != 0) goto u2Flt; else goto c2Fle;
       u2Flt: // global
           call _c2Fla(R1) args: 0, res: 0, upd: 0;
       c2Fle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fl4_info" {
     block_c2Fl4_info:
         const _c2Fl4;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2Fla() //  [R1]
         { []
         }
     {offset
       c2Fla: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2Flk; else goto c2Flj;
       c2Flk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Flj: // global
           _s2DHQ::I64 = I64[R1 + 7];
           if (_s2DHQ::I64 != 0) goto c2Flr; else goto c2Fls;
       c2Flr: // global
           (_s2DHS::I64, _s2DHT::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DHQ::I64);
           I64[Hp - 48] = GHC.Word.W64#_con_info;
           I64[Hp - 40] = _s2DHT::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _s2DHS::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fls: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fla_info" {
     block_c2Fla_info:
         const _c2Fla;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.402715198 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cmod_closure" {
     GHC.Word.$fIntegralWord64_$cmod_closure:
         const GHC.Word.$fIntegralWord64_$cmod_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FlX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fm1; else goto c2Fm2;
       c2Fm1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fm2: // global
           I64[Sp - 16] = block_c2FlU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fml; else goto c2FlV;
       u2Fml: // global
           call _c2FlU(R1) args: 0, res: 0, upd: 0;
       c2FlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cmod_info" {
     GHC.Word.$fIntegralWord64_$cmod_info:
         const GHC.Word.$fIntegralWord64_$cmod_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2FlU() //  [R1]
         { []
         }
     {offset
       c2FlU: // global
           I64[Sp] = block_c2Fm0_info;
           _s2DHZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DHZ::I64;
           if (R1 & 7 != 0) goto u2Fmk; else goto c2Fm4;
       u2Fmk: // global
           call _c2Fm0(R1) args: 0, res: 0, upd: 0;
       c2Fm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FlU_info" {
     block_c2FlU_info:
         const _c2FlU;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2Fm0() //  [R1]
         { []
         }
     {offset
       c2Fm0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fma; else goto c2Fm9;
       c2Fma: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fm9: // global
           _s2DI2::I64 = I64[R1 + 7];
           if (_s2DI2::I64 != 0) goto c2Fmi; else goto c2Fmj;
       c2Fmi: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DI2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fmj: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fm0_info" {
     block_c2Fm0_info:
         const _c2Fm0;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.41121602 UTC

[section ""data" . GHC.Word.$fIntegralWord64_$cdiv_closure" {
     GHC.Word.$fIntegralWord64_$cdiv_closure:
         const GHC.Word.$fIntegralWord64_$cdiv_info;
         const 0;
 },
 GHC.Word.$fIntegralWord64_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FmL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FmP; else goto c2FmQ;
       c2FmP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FmQ: // global
           I64[Sp - 16] = block_c2FmI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fn9; else goto c2FmJ;
       u2Fn9: // global
           call _c2FmI(R1) args: 0, res: 0, upd: 0;
       c2FmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord64_$cdiv_info" {
     GHC.Word.$fIntegralWord64_$cdiv_info:
         const GHC.Word.$fIntegralWord64_$cdiv_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2FmI() //  [R1]
         { []
         }
     {offset
       c2FmI: // global
           I64[Sp] = block_c2FmO_info;
           _s2DI7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DI7::I64;
           if (R1 & 7 != 0) goto u2Fn8; else goto c2FmS;
       u2Fn8: // global
           call _c2FmO(R1) args: 0, res: 0, upd: 0;
       c2FmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FmI_info" {
     block_c2FmI_info:
         const _c2FmI;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2FmO() //  [R1]
         { []
         }
     {offset
       c2FmO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FmY; else goto c2FmX;
       c2FmY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FmX: // global
           _s2DIa::I64 = I64[R1 + 7];
           if (_s2DIa::I64 != 0) goto c2Fn6; else goto c2Fn7;
       c2Fn6: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DIa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fn7: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FmO_info" {
     block_c2FmO_info:
         const _c2FmO;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.420567022 UTC

[section ""data" . GHC.Word.$fEqWord64_closure" {
     GHC.Word.$fEqWord64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord64_closure+2;
         const GHC.Word.neWord64_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.423493346 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cpred_closure" {
     GHC.Word.$fEnumWord64_$cpred_closure:
         const GHC.Word.$fEnumWord64_$cpred_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c2FnA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FnB; else goto c2FnC;
       c2FnB: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FnC: // global
           I64[Sp - 8] = block_c2Fnx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FnR; else goto c2Fny;
       u2FnR: // global
           call _c2Fnx(R1) args: 0, res: 0, upd: 0;
       c2Fny: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cpred_info" {
     GHC.Word.$fEnumWord64_$cpred_info:
         const GHC.Word.$fEnumWord64_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+584;
 },
 _c2Fnx() //  [R1]
         { []
         }
     {offset
       c2Fnx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FnH; else goto c2FnG;
       c2FnH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FnG: // global
           _s2DIf::I64 = I64[R1 + 7];
           if (_s2DIf::I64 != 0) goto c2FnP; else goto c2FnQ;
       c2FnP: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIf::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FnQ: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fnx_info" {
     block_c2Fnx_info:
         const _c2Fnx;
         const 0;
         const 4294967326;
         const S2Ecg_srt+592;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.428720131 UTC

[section ""data" . GHC.Word.$fBoundedWord64_$cmaxBound_closure" {
     GHC.Word.$fBoundedWord64_$cmaxBound_closure:
         const GHC.Word.W64#_con_info;
         const 18446744073709551615;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.430764512 UTC

[section ""data" . GHC.Word.$fBoundedWord64_closure" {
     GHC.Word.$fBoundedWord64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.433676962 UTC

[section ""data" . GHC.Word.$fEnumWord64_$csucc_closure" {
     GHC.Word.$fEnumWord64_$csucc_closure:
         const GHC.Word.$fEnumWord64_$csucc_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c2Fof: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fog; else goto c2Foh;
       c2Fog: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Foh: // global
           I64[Sp - 8] = block_c2Foc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fow; else goto c2Fod;
       u2Fow: // global
           call _c2Foc(R1) args: 0, res: 0, upd: 0;
       c2Fod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$csucc_info" {
     GHC.Word.$fEnumWord64_$csucc_info:
         const GHC.Word.$fEnumWord64_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+600;
 },
 _c2Foc() //  [R1]
         { []
         }
     {offset
       c2Foc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fom; else goto c2Fol;
       c2Fom: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fol: // global
           _s2DIk::I64 = I64[R1 + 7];
           if (_s2DIk::I64 != 18446744073709551615) goto c2Fou; else goto c2Fov;
       c2Fou: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIk::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Fov: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Foc_info" {
     block_c2Foc_info:
         const _c2Foc;
         const 0;
         const 4294967326;
         const S2Ecg_srt+608;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.439422231 UTC

[section ""data" . GHC.Word.$wlvl2_closure" {
     GHC.Word.$wlvl2_closure:
         const GHC.Word.$wlvl2_info;
         const 0;
 },
 section ""relreadonly" . u2FoS_srtd" {
     u2FoS_srtd:
         const S2Ecg_srt+48;
         const 51;
         const 1125899906842627;
 },
 GHC.Word.$wlvl2_entry() //  [R2]
         { []
         }
     {offset
       c2FoP: // global
           R6 = GHC.Word.$fBoundedWord64_$cmaxBound_closure+1;
           R5 = GHC.Word.$fBitsWord7_closure+1;
           R4 = R2;
           R3 = lvl_r2uFF_closure;
           R2 = GHC.Word.$fShowWord64_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$wlvl2_info" {
     GHC.Word.$wlvl2_info:
         const GHC.Word.$wlvl2_entry;
         const 0;
         const 18446744069414584334;
         const 4294967300;
         const u2FoS_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.44400893 UTC

[section ""data" . GHC.Word.$fEnumWord6_closure" {
     GHC.Word.$fEnumWord6_closure:
         const GHC.Word.$fEnumWord6_info;
         const 0;
 },
 GHC.Word.$fEnumWord6_entry() //  [R2]
         { []
         }
     {offset
       c2Fp5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fp6; else goto c2Fp7;
       c2Fp6: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fp7: // global
           I64[Sp - 8] = block_c2Fp2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fpb; else goto c2Fp3;
       u2Fpb: // global
           call _c2Fp2(R1) args: 0, res: 0, upd: 0;
       c2Fp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord6_info" {
     GHC.Word.$fEnumWord6_info:
         const GHC.Word.$fEnumWord6_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+616;
 },
 _c2Fp2() //  [R1]
         { []
         }
     {offset
       c2Fp2: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fp2_info" {
     block_c2Fp2_info:
         const _c2Fp2;
         const 0;
         const 4294967326;
         const S2Ecg_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.450007689 UTC

[section ""data" . GHC.Word.$fEnumWord64_$ctoEnum_closure" {
     GHC.Word.$fEnumWord64_$ctoEnum_closure:
         const GHC.Word.$fEnumWord64_$ctoEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c2Fpt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fpu; else goto c2Fpv;
       c2Fpu: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fpv: // global
           I64[Sp - 8] = block_c2Fpq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FpM; else goto c2Fpr;
       u2FpM: // global
           call _c2Fpq(R1) args: 0, res: 0, upd: 0;
       c2Fpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$ctoEnum_info" {
     GHC.Word.$fEnumWord64_$ctoEnum_info:
         const GHC.Word.$fEnumWord64_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+624;
 },
 _c2Fpq() //  [R1]
         { []
         }
     {offset
       c2Fpq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FpA; else goto c2Fpz;
       c2FpA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fpz: // global
           _s2DIs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DIs::I64, 0)) goto c2FpE; else goto c2FpL;
       c2FpE: // global
           Hp = Hp - 16;
           R2 = _s2DIs::I64;
           Sp = Sp + 8;
           call GHC.Word.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c2FpL: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DIs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fpq_info" {
     block_c2Fpq_info:
         const _c2Fpq;
         const 0;
         const 4294967326;
         const S2Ecg_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.457048389 UTC

[section ""data" . GHC.Word.gtWord64_closure" {
     GHC.Word.gtWord64_closure:
         const GHC.Word.gtWord64_info;
 },
 GHC.Word.gtWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fq6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fqa; else goto c2Fqb;
       c2Fqa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fqb: // global
           I64[Sp - 16] = block_c2Fq3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fqk; else goto c2Fq4;
       u2Fqk: // global
           call _c2Fq3(R1) args: 0, res: 0, upd: 0;
       c2Fq4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord64_info" {
     GHC.Word.gtWord64_info:
         const GHC.Word.gtWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Fq3() //  [R1]
         { []
         }
     {offset
       c2Fq3: // global
           I64[Sp] = block_c2Fq9_info;
           _s2DIy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIy::I64;
           if (R1 & 7 != 0) goto u2Fqj; else goto c2Fqd;
       u2Fqj: // global
           call _c2Fq9(R1) args: 0, res: 0, upd: 0;
       c2Fqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fq3_info" {
     block_c2Fq3_info:
         const _c2Fq3;
         const 1;
         const 30;
 },
 _c2Fq9() //  [R1]
         { []
         }
     {offset
       c2Fq9: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fq9_info" {
     block_c2Fq9_info:
         const _c2Fq9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.464567114 UTC

[section ""data" . GHC.Word.geWord64_closure" {
     GHC.Word.geWord64_closure:
         const GHC.Word.geWord64_info;
 },
 GHC.Word.geWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FqM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FqQ; else goto c2FqR;
       c2FqQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FqR: // global
           I64[Sp - 16] = block_c2FqJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fr0; else goto c2FqK;
       u2Fr0: // global
           call _c2FqJ(R1) args: 0, res: 0, upd: 0;
       c2FqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord64_info" {
     GHC.Word.geWord64_info:
         const GHC.Word.geWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FqJ() //  [R1]
         { []
         }
     {offset
       c2FqJ: // global
           I64[Sp] = block_c2FqP_info;
           _s2DIF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIF::I64;
           if (R1 & 7 != 0) goto u2FqZ; else goto c2FqT;
       u2FqZ: // global
           call _c2FqP(R1) args: 0, res: 0, upd: 0;
       c2FqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FqJ_info" {
     block_c2FqJ_info:
         const _c2FqJ;
         const 1;
         const 30;
 },
 _c2FqP() //  [R1]
         { []
         }
     {offset
       c2FqP: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FqP_info" {
     block_c2FqP_info:
         const _c2FqP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.472261243 UTC

[section ""data" . GHC.Word.ltWord64_closure" {
     GHC.Word.ltWord64_closure:
         const GHC.Word.ltWord64_info;
 },
 GHC.Word.ltWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Frs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Frw; else goto c2Frx;
       c2Frw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Frx: // global
           I64[Sp - 16] = block_c2Frp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FrG; else goto c2Frq;
       u2FrG: // global
           call _c2Frp(R1) args: 0, res: 0, upd: 0;
       c2Frq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord64_info" {
     GHC.Word.ltWord64_info:
         const GHC.Word.ltWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Frp() //  [R1]
         { []
         }
     {offset
       c2Frp: // global
           I64[Sp] = block_c2Frv_info;
           _s2DIM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIM::I64;
           if (R1 & 7 != 0) goto u2FrF; else goto c2Frz;
       u2FrF: // global
           call _c2Frv(R1) args: 0, res: 0, upd: 0;
       c2Frz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Frp_info" {
     block_c2Frp_info:
         const _c2Frp;
         const 1;
         const 30;
 },
 _c2Frv() //  [R1]
         { []
         }
     {offset
       c2Frv: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Frv_info" {
     block_c2Frv_info:
         const _c2Frv;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.479590775 UTC

[section ""data" . GHC.Word.leWord64_closure" {
     GHC.Word.leWord64_closure:
         const GHC.Word.leWord64_info;
 },
 GHC.Word.leWord64_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fs8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fsc; else goto c2Fsd;
       c2Fsc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fsd: // global
           I64[Sp - 16] = block_c2Fs5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fsm; else goto c2Fs6;
       u2Fsm: // global
           call _c2Fs5(R1) args: 0, res: 0, upd: 0;
       c2Fs6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord64_info" {
     GHC.Word.leWord64_info:
         const GHC.Word.leWord64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Fs5() //  [R1]
         { []
         }
     {offset
       c2Fs5: // global
           I64[Sp] = block_c2Fsb_info;
           _s2DIT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DIT::I64;
           if (R1 & 7 != 0) goto u2Fsl; else goto c2Fsf;
       u2Fsl: // global
           call _c2Fsb(R1) args: 0, res: 0, upd: 0;
       c2Fsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fs5_info" {
     block_c2Fs5_info:
         const _c2Fs5;
         const 1;
         const 30;
 },
 _c2Fsb() //  [R1]
         { []
         }
     {offset
       c2Fsb: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fsb_info" {
     block_c2Fsb_info:
         const _c2Fsb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.487197253 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmin_closure" {
     GHC.Word.$fOrdWord64_$cmin_closure:
         const GHC.Word.$fOrdWord64_$cmin_info;
 },
 GHC.Word.$fOrdWord64_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FsO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FsS; else goto c2FsT;
       c2FsS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FsT: // global
           I64[Sp - 16] = block_c2FsL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ft6; else goto c2FsM;
       u2Ft6: // global
           call _c2FsL(R1) args: 0, res: 0, upd: 0;
       c2FsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$cmin_info" {
     GHC.Word.$fOrdWord64_$cmin_info:
         const GHC.Word.$fOrdWord64_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FsL() //  [R1]
         { []
         }
     {offset
       c2FsL: // global
           I64[Sp - 8] = block_c2FsR_info;
           _s2DIZ::P64 = R1;
           _s2DJ0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DJ0::I64;
           P64[Sp + 8] = _s2DIZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Ft5; else goto c2FsV;
       u2Ft5: // global
           call _c2FsR(R1) args: 0, res: 0, upd: 0;
       c2FsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FsL_info" {
     block_c2FsL_info:
         const _c2FsL;
         const 1;
         const 30;
 },
 _c2FsR() //  [R1]
         { []
         }
     {offset
       c2FsR: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2Ft3; else goto c2Ft4;
       c2Ft3: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Ft4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FsR_info" {
     block_c2FsR_info:
         const _c2FsR;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.49554555 UTC

[section ""data" . GHC.Word.$fOrdWord64_$cmax_closure" {
     GHC.Word.$fOrdWord64_$cmax_closure:
         const GHC.Word.$fOrdWord64_$cmax_info;
 },
 GHC.Word.$fOrdWord64_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fty: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FtC; else goto c2FtD;
       c2FtC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FtD: // global
           I64[Sp - 16] = block_c2Ftv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FtQ; else goto c2Ftw;
       u2FtQ: // global
           call _c2Ftv(R1) args: 0, res: 0, upd: 0;
       c2Ftw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$cmax_info" {
     GHC.Word.$fOrdWord64_$cmax_info:
         const GHC.Word.$fOrdWord64_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Ftv() //  [R1]
         { []
         }
     {offset
       c2Ftv: // global
           I64[Sp - 8] = block_c2FtB_info;
           _s2DJ6::P64 = R1;
           _s2DJ7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DJ7::I64;
           P64[Sp + 8] = _s2DJ6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FtP; else goto c2FtF;
       u2FtP: // global
           call _c2FtB(R1) args: 0, res: 0, upd: 0;
       c2FtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ftv_info" {
     block_c2Ftv_info:
         const _c2Ftv;
         const 1;
         const 30;
 },
 _c2FtB() //  [R1]
         { []
         }
     {offset
       c2FtB: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2FtN; else goto c2FtO;
       c2FtN: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2FtO: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FtB_info" {
     block_c2FtB_info:
         const _c2FtB;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.503104079 UTC

[section ""data" . GHC.Word.$fOrdWord64_$ccompare_closure" {
     GHC.Word.$fOrdWord64_$ccompare_closure:
         const GHC.Word.$fOrdWord64_$ccompare_info;
 },
 GHC.Word.$fOrdWord64_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fui: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fum; else goto c2Fun;
       c2Fum: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fun: // global
           I64[Sp - 16] = block_c2Fuf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FuG; else goto c2Fug;
       u2FuG: // global
           call _c2Fuf(R1) args: 0, res: 0, upd: 0;
       c2Fug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord64_$ccompare_info" {
     GHC.Word.$fOrdWord64_$ccompare_info:
         const GHC.Word.$fOrdWord64_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Fuf() //  [R1]
         { []
         }
     {offset
       c2Fuf: // global
           I64[Sp] = block_c2Ful_info;
           _s2DJe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJe::I64;
           if (R1 & 7 != 0) goto u2FuF; else goto c2Fup;
       u2FuF: // global
           call _c2Ful(R1) args: 0, res: 0, upd: 0;
       c2Fup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fuf_info" {
     block_c2Fuf_info:
         const _c2Fuf;
         const 1;
         const 30;
 },
 _c2Ful() //  [R1]
         { []
         }
     {offset
       c2Ful: // global
           _s2DJe::I64 = I64[Sp + 8];
           _s2DJg::I64 = I64[R1 + 7];
           if (_s2DJe::I64 == _s2DJg::I64) goto c2FuE; else goto c2FuD;
       c2FuE: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FuD: // global
           if (_s2DJe::I64 > _s2DJg::I64) goto c2FuA; else goto c2FuB;
       c2FuA: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FuB: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ful_info" {
     block_c2Ful_info:
         const _c2Ful;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.510244445 UTC

[section ""data" . GHC.Word.$fOrdWord64_closure" {
     GHC.Word.$fOrdWord64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fOrdWord64_$ccompare_closure+2;
         const GHC.Word.ltWord64_closure+2;
         const GHC.Word.leWord64_closure+2;
         const GHC.Word.gtWord64_closure+2;
         const GHC.Word.geWord64_closure+2;
         const GHC.Word.$fOrdWord64_$cmax_closure+2;
         const GHC.Word.$fOrdWord64_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.511973084 UTC

[section ""data" . GHC.Word.$fRealWord64_closure" {
     GHC.Word.$fRealWord64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord64_closure+1;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fRealWord64_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.514935972 UTC

[section ""data" . GHC.Word.$fEnumWord64_$cfromEnum_closure" {
     GHC.Word.$fEnumWord64_$cfromEnum_closure:
         const GHC.Word.$fEnumWord64_$cfromEnum_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c2Fvb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fvc; else goto c2Fvd;
       c2Fvc: // global
           R2 = R2;
           R1 = GHC.Word.$fEnumWord64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fvd: // global
           I64[Sp - 8] = block_c2Fv8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Fvu; else goto c2Fv9;
       u2Fvu: // global
           call _c2Fv8(R1) args: 0, res: 0, upd: 0;
       c2Fv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cfromEnum_info" {
     GHC.Word.$fEnumWord64_$cfromEnum_info:
         const GHC.Word.$fEnumWord64_$cfromEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+640;
 },
 _c2Fv8() //  [R1]
         { []
         }
     {offset
       c2Fv8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fvi; else goto c2Fvh;
       c2Fvi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fvh: // global
           _s2DJl::I64 = I64[R1 + 7];
           if (_s2DJl::I64 > 9223372036854775807) goto c2Fvm; else goto c2Fvt;
       c2Fvm: // global
           Hp = Hp - 16;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord5_entry(R2) args: 8, res: 0, upd: 8;
       c2Fvt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DJl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fv8_info" {
     block_c2Fv8_info:
         const _c2Fv8;
         const 0;
         const 4294967326;
         const S2Ecg_srt+648;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.521564523 UTC

[section ""data" . GHC.Word.$fEnumWord64_closure" {
     GHC.Word.$fEnumWord64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Word.$fEnumWord64_$csucc_closure+1;
         const GHC.Word.$fEnumWord64_$cpred_closure+1;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFrom_closure+1;
         const GHC.Word.$fEnumWord64_$cenumFromThen_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure+2;
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Word.$fIntegralWord64_closure" {
     GHC.Word.$fIntegralWord64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord64_closure+1;
         const GHC.Word.$fEnumWord64_closure+1;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cdiv_closure+2;
         const GHC.Word.$fIntegralWord64_$cmod_closure+2;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure+2;
         const GHC.Word.$fIntegralWord64_$ctoInteger_closure+1;
         const 0;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThenTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c2FvM: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThenTo_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromThenTo_info" {
     GHC.Word.$fEnumWord64_$cenumFromThenTo_info:
         const GHC.Word.$fEnumWord64_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S2Ecg_srt+656;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromTo_closure" {
     GHC.Word.$fEnumWord64_$cenumFromTo_closure:
         const GHC.Word.$fEnumWord64_$cenumFromTo_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FvT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromTo_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromTo_info" {
     GHC.Word.$fEnumWord64_$cenumFromTo_info:
         const GHC.Word.$fEnumWord64_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+664;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFrom_closure" {
     GHC.Word.$fEnumWord64_$cenumFrom_closure:
         const GHC.Word.$fEnumWord64_$cenumFrom_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c2Fw0: // global
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFrom_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFrom_info" {
     GHC.Word.$fEnumWord64_$cenumFrom_info:
         const GHC.Word.$fEnumWord64_$cenumFrom_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S2Ecg_srt+664;
 },
 section ""data" . GHC.Word.$fEnumWord64_$cenumFromThen_closure" {
     GHC.Word.$fEnumWord64_$cenumFromThen_closure:
         const GHC.Word.$fEnumWord64_$cenumFromThen_info;
         const 0;
 },
 GHC.Word.$fEnumWord64_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fw7: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Word.$fBoundedWord64_closure+1;
           R2 = GHC.Word.$fIntegralWord64_closure+1;
           call GHC.Real.integralEnumFromThen_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fEnumWord64_$cenumFromThen_info" {
     GHC.Word.$fEnumWord64_$cenumFromThen_info:
         const GHC.Word.$fEnumWord64_$cenumFromThen_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S2Ecg_srt+664;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.53415045 UTC

[section ""data" . GHC.Word.$fNumWord8_$cfromInteger_closure" {
     GHC.Word.$fNumWord8_$cfromInteger_closure:
         const GHC.Word.$fNumWord8_$cfromInteger_info;
 },
 GHC.Word.$fNumWord8_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2Fwy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FwF; else goto c2FwG;
       c2FwF: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FwG: // global
           I64[Sp - 8] = block_c2Fww_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cfromInteger_info" {
     GHC.Word.$fNumWord8_$cfromInteger_info:
         const GHC.Word.$fNumWord8_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Fww() //  [R1]
         { []
         }
     {offset
       c2Fww: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FwJ; else goto c2FwI;
       c2FwJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FwI: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fww_info" {
     block_c2Fww_info:
         const _c2Fww;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.539574504 UTC

[section ""data" . GHC.Word.$fNumWord8_$cabs_closure" {
     GHC.Word.$fNumWord8_$cabs_closure:
         const GHC.Word.$fNumWord8_$cabs_info;
 },
 GHC.Word.$fNumWord8_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2Fx1: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cabs_info" {
     GHC.Word.$fNumWord8_$cabs_info:
         const GHC.Word.$fNumWord8_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.543947306 UTC

[section ""data" . GHC.Word.$fNumWord8_$cnegate_closure" {
     GHC.Word.$fNumWord8_$cnegate_closure:
         const GHC.Word.$fNumWord8_$cnegate_info;
 },
 GHC.Word.$fNumWord8_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2Fxh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Fxx; else goto c2Fxy;
       c2Fxx: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Fxy: // global
           I64[Sp - 8] = block_c2Fxe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FxC; else goto c2Fxf;
       u2FxC: // global
           call _c2Fxe(R1) args: 0, res: 0, upd: 0;
       c2Fxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$cnegate_info" {
     GHC.Word.$fNumWord8_$cnegate_info:
         const GHC.Word.$fNumWord8_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Fxe() //  [R1]
         { []
         }
     {offset
       c2Fxe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FxB; else goto c2FxA;
       c2FxB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FxA: // global
           _s2DJy::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fxe_info" {
     block_c2Fxe_info:
         const _c2Fxe;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.550358093 UTC

[section ""data" . GHC.Word.$fNumWord8_$c*_closure" {
     GHC.Word.$fNumWord8_$c*_closure:
         const GHC.Word.$fNumWord8_$c*_info;
 },
 GHC.Word.$fNumWord8_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fyc; else goto c2Fyd;
       c2Fyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fyd: // global
           I64[Sp - 16] = block_c2FxU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fyj; else goto c2FxV;
       u2Fyj: // global
           call _c2FxU(R1) args: 0, res: 0, upd: 0;
       c2FxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c*_info" {
     GHC.Word.$fNumWord8_$c*_info:
         const GHC.Word.$fNumWord8_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FxU() //  [R1]
         { []
         }
     {offset
       c2FxU: // global
           I64[Sp] = block_c2Fy0_info;
           _s2DJC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJC::I64;
           if (R1 & 7 != 0) goto u2Fyi; else goto c2Fy1;
       u2Fyi: // global
           call _c2Fy0(R1) args: 0, res: 0, upd: 0;
       c2Fy1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FxU_info" {
     block_c2FxU_info:
         const _c2FxU;
         const 1;
         const 30;
 },
 _c2Fy0() //  [R1]
         { []
         }
     {offset
       c2Fy0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fyh; else goto c2Fyg;
       c2Fyh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fyg: // global
           _s2DJG::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fy0_info" {
     block_c2Fy0_info:
         const _c2Fy0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.558274058 UTC

[section ""data" . GHC.Word.$fNumWord8_$c-_closure" {
     GHC.Word.$fNumWord8_$c-_closure:
         const GHC.Word.$fNumWord8_$c-_info;
 },
 GHC.Word.$fNumWord8_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FyL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Fz0; else goto c2Fz1;
       c2Fz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Fz1: // global
           I64[Sp - 16] = block_c2FyI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Fz7; else goto c2FyJ;
       u2Fz7: // global
           call _c2FyI(R1) args: 0, res: 0, upd: 0;
       c2FyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c-_info" {
     GHC.Word.$fNumWord8_$c-_info:
         const GHC.Word.$fNumWord8_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FyI() //  [R1]
         { []
         }
     {offset
       c2FyI: // global
           I64[Sp] = block_c2FyO_info;
           _s2DJK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJK::I64;
           if (R1 & 7 != 0) goto u2Fz6; else goto c2FyP;
       u2Fz6: // global
           call _c2FyO(R1) args: 0, res: 0, upd: 0;
       c2FyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FyI_info" {
     block_c2FyI_info:
         const _c2FyI;
         const 1;
         const 30;
 },
 _c2FyO() //  [R1]
         { []
         }
     {offset
       c2FyO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Fz5; else goto c2Fz4;
       c2Fz5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Fz4: // global
           _s2DJO::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FyO_info" {
     block_c2FyO_info:
         const _c2FyO;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.567510224 UTC

[section ""data" . GHC.Word.$fNumWord8_$c+_closure" {
     GHC.Word.$fNumWord8_$c+_closure:
         const GHC.Word.$fNumWord8_$c+_info;
 },
 GHC.Word.$fNumWord8_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Fzz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FzO; else goto c2FzP;
       c2FzO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FzP: // global
           I64[Sp - 16] = block_c2Fzw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FzV; else goto c2Fzx;
       u2FzV: // global
           call _c2Fzw(R1) args: 0, res: 0, upd: 0;
       c2Fzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$c+_info" {
     GHC.Word.$fNumWord8_$c+_info:
         const GHC.Word.$fNumWord8_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Fzw() //  [R1]
         { []
         }
     {offset
       c2Fzw: // global
           I64[Sp] = block_c2FzC_info;
           _s2DJS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DJS::I64;
           if (R1 & 7 != 0) goto u2FzU; else goto c2FzD;
       u2FzU: // global
           call _c2FzC(R1) args: 0, res: 0, upd: 0;
       c2FzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Fzw_info" {
     block_c2Fzw_info:
         const _c2Fzw;
         const 1;
         const 30;
 },
 _c2FzC() //  [R1]
         { []
         }
     {offset
       c2FzC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FzT; else goto c2FzS;
       c2FzT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FzS: // global
           _s2DJW::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DJW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FzC_info" {
     block_c2FzC_info:
         const _c2FzC;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.574879645 UTC

[section ""data" . GHC.Word.$ctoInteger_closure" {
     GHC.Word.$ctoInteger_closure:
         const GHC.Word.$ctoInteger_info;
 },
 GHC.Word.$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c2FAn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FAo; else goto c2FAp;
       c2FAo: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FAp: // global
           I64[Sp - 8] = block_c2FAk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FAu; else goto c2FAl;
       u2FAu: // global
           call _c2FAk(R1) args: 0, res: 0, upd: 0;
       c2FAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger_info" {
     GHC.Word.$ctoInteger_info:
         const GHC.Word.$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FAk() //  [R1]
         { []
         }
     {offset
       c2FAk: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FAk_info" {
     block_c2FAk_info:
         const _c2FAk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.580549693 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cpopCount_closure" {
     GHC.Word.$fBitsWord8_$cpopCount_closure:
         const GHC.Word.$fBitsWord8_$cpopCount_info;
 },
 GHC.Word.$fBitsWord8_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2FAM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FAX; else goto c2FAY;
       c2FAX: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FAY: // global
           I64[Sp - 8] = block_c2FAJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FB2; else goto c2FAK;
       u2FB2: // global
           call _c2FAJ(R1) args: 0, res: 0, upd: 0;
       c2FAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cpopCount_info" {
     GHC.Word.$fBitsWord8_$cpopCount_info:
         const GHC.Word.$fBitsWord8_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FAJ() //  [R1]
         { []
         }
     {offset
       c2FAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FB1; else goto c2FB0;
       c2FB1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FB0: // global
           (_c2FAP::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FAP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FAJ_info" {
     block_c2FAJ_info:
         const _c2FAJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.587062926 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FBm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FBy; else goto c2FBz;
       c2FBy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FBz: // global
           I64[Sp - 16] = block_c2FBj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FBF; else goto c2FBk;
       u2FBF: // global
           call _c2FBj(R1) args: 0, res: 0, upd: 0;
       c2FBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord8_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FBj() //  [R1]
         { []
         }
     {offset
       c2FBj: // global
           I64[Sp] = block_c2FBp_info;
           _s2DK9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DK9::I64;
           if (R1 & 7 != 0) goto u2FBE; else goto c2FBq;
       u2FBE: // global
           call _c2FBp(R1) args: 0, res: 0, upd: 0;
       c2FBq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FBj_info" {
     block_c2FBj_info:
         const _c2FBj;
         const 1;
         const 30;
 },
 _c2FBp() //  [R1]
         { []
         }
     {offset
       c2FBp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FBD; else goto c2FBC;
       c2FBD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FBC: // global
           _s2DKc::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FBp_info" {
     block_c2FBp_info:
         const _c2FBp;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.595317597 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftR_closure" {
     GHC.Word.$fBitsWord8_$cshiftR_closure:
         const GHC.Word.$fBitsWord8_$cshiftR_info;
 },
 GHC.Word.$fBitsWord8_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FC5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FC9; else goto c2FCa;
       c2FC9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FCa: // global
           I64[Sp - 16] = block_c2FC2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FCu; else goto c2FC3;
       u2FCu: // global
           call _c2FC2(R1) args: 0, res: 0, upd: 0;
       c2FC3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshiftR_info" {
     GHC.Word.$fBitsWord8_$cshiftR_info:
         const GHC.Word.$fBitsWord8_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FC2() //  [R1]
         { []
         }
     {offset
       c2FC2: // global
           I64[Sp] = block_c2FC8_info;
           _s2DKg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKg::I64;
           if (R1 & 7 != 0) goto u2FCt; else goto c2FCc;
       u2FCt: // global
           call _c2FC8(R1) args: 0, res: 0, upd: 0;
       c2FCc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FC2_info" {
     block_c2FC2_info:
         const _c2FC2;
         const 1;
         const 30;
 },
 _c2FC8() //  [R1]
         { []
         }
     {offset
       c2FC8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FCi; else goto c2FCh;
       c2FCi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FCh: // global
           _s2DKi::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKi::I64, 64)) goto c2FCr; else goto c2FCs;
       c2FCr: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DKi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FCs: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FC8_info" {
     block_c2FC8_info:
         const _c2FC8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.604101938 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord8_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FCV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FDa; else goto c2FDb;
       c2FDa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FDb: // global
           I64[Sp - 16] = block_c2FCS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FDh; else goto c2FCT;
       u2FDh: // global
           call _c2FCS(R1) args: 0, res: 0, upd: 0;
       c2FCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord8_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FCS() //  [R1]
         { []
         }
     {offset
       c2FCS: // global
           I64[Sp] = block_c2FCY_info;
           _s2DKo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKo::I64;
           if (R1 & 7 != 0) goto u2FDg; else goto c2FCZ;
       u2FDg: // global
           call _c2FCY(R1) args: 0, res: 0, upd: 0;
       c2FCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FCS_info" {
     block_c2FCS_info:
         const _c2FCS;
         const 1;
         const 30;
 },
 _c2FCY() //  [R1]
         { []
         }
     {offset
       c2FCY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FDf; else goto c2FDe;
       c2FDf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FDe: // global
           _s2DKs::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FCY_info" {
     block_c2FCY_info:
         const _c2FCY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.612247405 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshiftL_closure" {
     GHC.Word.$fBitsWord8_$cshiftL_closure:
         const GHC.Word.$fBitsWord8_$cshiftL_info;
 },
 GHC.Word.$fBitsWord8_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FDM; else goto c2FDN;
       c2FDM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FDN: // global
           I64[Sp - 16] = block_c2FDF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FEa; else goto c2FDG;
       u2FEa: // global
           call _c2FDF(R1) args: 0, res: 0, upd: 0;
       c2FDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshiftL_info" {
     GHC.Word.$fBitsWord8_$cshiftL_info:
         const GHC.Word.$fBitsWord8_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FDF() //  [R1]
         { []
         }
     {offset
       c2FDF: // global
           I64[Sp] = block_c2FDL_info;
           _s2DKw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKw::I64;
           if (R1 & 7 != 0) goto u2FE9; else goto c2FDP;
       u2FE9: // global
           call _c2FDL(R1) args: 0, res: 0, upd: 0;
       c2FDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FDF_info" {
     block_c2FDF_info:
         const _c2FDF;
         const 1;
         const 30;
 },
 _c2FDL() //  [R1]
         { []
         }
     {offset
       c2FDL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FDV; else goto c2FDU;
       c2FDV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FDU: // global
           _s2DKy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKy::I64, 64)) goto c2FE7; else goto c2FE8;
       c2FE7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] << _s2DKy::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FE8: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FDL_info" {
     block_c2FDL_info:
         const _c2FDL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.620017117 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cisSigned_closure" {
     GHC.Word.$fBitsWord8_$cisSigned_closure:
         const GHC.Word.$fBitsWord8_$cisSigned_info;
 },
 GHC.Word.$fBitsWord8_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2FEA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cisSigned_info" {
     GHC.Word.$fBitsWord8_$cisSigned_info:
         const GHC.Word.$fBitsWord8_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.625085481 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotate_closure" {
     GHC.Word.$fBitsWord8_$crotate_closure:
         const GHC.Word.$fBitsWord8_$crotate_info;
 },
 GHC.Word.$fBitsWord8_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FEQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FEU; else goto c2FEV;
       c2FEU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FEV: // global
           I64[Sp - 16] = block_c2FEN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FFI; else goto c2FEO;
       u2FFI: // global
           call _c2FEN(R1) args: 0, res: 0, upd: 0;
       c2FEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotate_info" {
     GHC.Word.$fBitsWord8_$crotate_info:
         const GHC.Word.$fBitsWord8_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FEN() //  [R1]
         { []
         }
     {offset
       c2FEN: // global
           I64[Sp - 8] = block_c2FET_info;
           _s2DKF::P64 = R1;
           _s2DKG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DKG::I64;
           P64[Sp + 8] = _s2DKF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FFH; else goto c2FEX;
       u2FFH: // global
           call _c2FET(R1) args: 0, res: 0, upd: 0;
       c2FEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FEN_info" {
     block_c2FEN_info:
         const _c2FEN;
         const 1;
         const 30;
 },
 _c2FET() //  [R1]
         { []
         }
     {offset
       c2FET: // global
           _s2DKL::I64 = I64[R1 + 7] & 7;
           if (_s2DKL::I64 != 0) goto u2FFF; else goto c2FFB;
       u2FFF: // global
           I64[Sp + 16] = _s2DKL::I64;
           Sp = Sp + 8;
           call _c2FFc() args: 0, res: 0, upd: 0;
       c2FFB: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FET_info" {
     block_c2FET_info:
         const _c2FET;
         const 66;
         const 30;
 },
 _c2FFc() //  []
         { []
         }
     {offset
       c2FFc: // global
           Hp = Hp + 16;
           _s2DKL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2FFy; else goto c2FFx;
       c2FFy: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2FFb_info;
           R1 = _s2DKL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FFx: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2DKG::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2DKG::I64 << _s2DKL::I64) | (_s2DKG::I64 >> 8 - _s2DKL::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FFb() //  [R1]
         { []
         }
     {offset
       c2FFb: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2FFc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2FFb_info" {
     block_c2FFb_info:
         const _c2FFb;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.636456289 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cshift_closure" {
     GHC.Word.$fBitsWord8_$cshift_closure:
         const GHC.Word.$fBitsWord8_$cshift_info;
 },
 GHC.Word.$fBitsWord8_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FGo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FGs; else goto c2FGt;
       c2FGs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FGt: // global
           I64[Sp - 16] = block_c2FGl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FHa; else goto c2FGm;
       u2FHa: // global
           call _c2FGl(R1) args: 0, res: 0, upd: 0;
       c2FGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cshift_info" {
     GHC.Word.$fBitsWord8_$cshift_info:
         const GHC.Word.$fBitsWord8_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FGl() //  [R1]
         { []
         }
     {offset
       c2FGl: // global
           I64[Sp] = block_c2FGr_info;
           _s2DKU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DKU::I64;
           if (R1 & 7 != 0) goto u2FH9; else goto c2FGv;
       u2FH9: // global
           call _c2FGr(R1) args: 0, res: 0, upd: 0;
       c2FGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FGl_info" {
     block_c2FGl_info:
         const _c2FGl;
         const 1;
         const 30;
 },
 _c2FGr() //  [R1]
         { []
         }
     {offset
       c2FGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FGB; else goto c2FGA;
       c2FGB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FGA: // global
           _s2DKU::I64 = I64[Sp + 8];
           _s2DKW::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DKW::I64, 0)) goto c2FGT; else goto c2FH8;
       c2FGT: // global
           _s2DKY::I64 = -_s2DKW::I64;
           if (%MO_S_Ge_W64(_s2DKY::I64, 64)) goto c2FH7; else goto c2FGQ;
       c2FGQ: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DKU::I64 >> _s2DKY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FH8: // global
           if (%MO_S_Ge_W64(_s2DKW::I64, 64)) goto c2FH7; else goto c2FH6;
       c2FH7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FH6: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DKU::I64 << _s2DKW::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FGr_info" {
     block_c2FGr_info:
         const _c2FGr;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.646689058 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cxor_closure" {
     GHC.Word.$fBitsWord8_$cxor_closure:
         const GHC.Word.$fBitsWord8_$cxor_info;
 },
 GHC.Word.$fBitsWord8_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FHS; else goto c2FHT;
       c2FHS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FHT: // global
           I64[Sp - 16] = block_c2FHD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FHZ; else goto c2FHE;
       u2FHZ: // global
           call _c2FHD(R1) args: 0, res: 0, upd: 0;
       c2FHE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cxor_info" {
     GHC.Word.$fBitsWord8_$cxor_info:
         const GHC.Word.$fBitsWord8_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FHD() //  [R1]
         { []
         }
     {offset
       c2FHD: // global
           I64[Sp] = block_c2FHJ_info;
           _s2DL7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DL7::I64;
           if (R1 & 7 != 0) goto u2FHY; else goto c2FHK;
       u2FHY: // global
           call _c2FHJ(R1) args: 0, res: 0, upd: 0;
       c2FHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FHD_info" {
     block_c2FHD_info:
         const _c2FHD;
         const 1;
         const 30;
 },
 _c2FHJ() //  [R1]
         { []
         }
     {offset
       c2FHJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FHX; else goto c2FHW;
       c2FHX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FHW: // global
           _s2DLa::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FHJ_info" {
     block_c2FHJ_info:
         const _c2FHJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.654551047 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.|._closure" {
     GHC.Word.$fBitsWord8_$c.|._closure:
         const GHC.Word.$fBitsWord8_$c.|._info;
 },
 GHC.Word.$fBitsWord8_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2FIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FIC; else goto c2FID;
       c2FIC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FID: // global
           I64[Sp - 16] = block_c2FIn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FIJ; else goto c2FIo;
       u2FIJ: // global
           call _c2FIn(R1) args: 0, res: 0, upd: 0;
       c2FIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$c.|._info" {
     GHC.Word.$fBitsWord8_$c.|._info:
         const GHC.Word.$fBitsWord8_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FIn() //  [R1]
         { []
         }
     {offset
       c2FIn: // global
           I64[Sp] = block_c2FIt_info;
           _s2DLe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLe::I64;
           if (R1 & 7 != 0) goto u2FII; else goto c2FIu;
       u2FII: // global
           call _c2FIt(R1) args: 0, res: 0, upd: 0;
       c2FIu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FIn_info" {
     block_c2FIn_info:
         const _c2FIn;
         const 1;
         const 30;
 },
 _c2FIt() //  [R1]
         { []
         }
     {offset
       c2FIt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FIH; else goto c2FIG;
       c2FIH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FIG: // global
           _s2DLh::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FIt_info" {
     block_c2FIt_info:
         const _c2FIt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.662607468 UTC

[section ""data" . GHC.Word.$fBitsWord8_$c.&._closure" {
     GHC.Word.$fBitsWord8_$c.&._closure:
         const GHC.Word.$fBitsWord8_$c.&._info;
 },
 GHC.Word.$fBitsWord8_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2FJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FJm; else goto c2FJn;
       c2FJm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FJn: // global
           I64[Sp - 16] = block_c2FJ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FJt; else goto c2FJ8;
       u2FJt: // global
           call _c2FJ7(R1) args: 0, res: 0, upd: 0;
       c2FJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$c.&._info" {
     GHC.Word.$fBitsWord8_$c.&._info:
         const GHC.Word.$fBitsWord8_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FJ7() //  [R1]
         { []
         }
     {offset
       c2FJ7: // global
           I64[Sp] = block_c2FJd_info;
           _s2DLl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLl::I64;
           if (R1 & 7 != 0) goto u2FJs; else goto c2FJe;
       u2FJs: // global
           call _c2FJd(R1) args: 0, res: 0, upd: 0;
       c2FJe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FJ7_info" {
     block_c2FJ7_info:
         const _c2FJ7;
         const 1;
         const 30;
 },
 _c2FJd() //  [R1]
         { []
         }
     {offset
       c2FJd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FJr; else goto c2FJq;
       c2FJr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FJq: // global
           _s2DLo::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DLo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FJd_info" {
     block_c2FJd_info:
         const _c2FJd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.67035847 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2FJU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FK5; else goto c2FK6;
       c2FK5: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FK6: // global
           I64[Sp - 8] = block_c2FJR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FKa; else goto c2FJS;
       u2FKa: // global
           call _c2FJR(R1) args: 0, res: 0, upd: 0;
       c2FJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FJR() //  [R1]
         { []
         }
     {offset
       c2FJR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FK9; else goto c2FK8;
       c2FK9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FK8: // global
           (_c2FJX::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FJX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FJR_info" {
     block_c2FJR_info:
         const _c2FJR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.676309867 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2FKw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FKH; else goto c2FKI;
       c2FKH: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FKI: // global
           I64[Sp - 8] = block_c2FKt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FKM; else goto c2FKu;
       u2FKM: // global
           call _c2FKt(R1) args: 0, res: 0, upd: 0;
       c2FKu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FKt() //  [R1]
         { []
         }
     {offset
       c2FKt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FKL; else goto c2FKK;
       c2FKL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FKK: // global
           (_c2FKz::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FKz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FKt_info" {
     block_c2FKt_info:
         const _c2FKt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.681727358 UTC

[section ""data" . GHC.Word.$fBitsWord9_closure" {
     GHC.Word.$fBitsWord9_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.683804776 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord8_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2FL6: // global
           R1 = GHC.Word.$fBitsWord9_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord8_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.687722367 UTC

[section ""data" . GHC.Word.$fNumWord16_$cfromInteger_closure" {
     GHC.Word.$fNumWord16_$cfromInteger_closure:
         const GHC.Word.$fNumWord16_$cfromInteger_info;
 },
 GHC.Word.$fNumWord16_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2FLk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FLr; else goto c2FLs;
       c2FLr: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FLs: // global
           I64[Sp - 8] = block_c2FLi_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cfromInteger_info" {
     GHC.Word.$fNumWord16_$cfromInteger_info:
         const GHC.Word.$fNumWord16_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FLi() //  [R1]
         { []
         }
     {offset
       c2FLi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FLv; else goto c2FLu;
       c2FLv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FLu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FLi_info" {
     block_c2FLi_info:
         const _c2FLi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.692843225 UTC

[section ""data" . GHC.Word.$fNumWord16_$cabs_closure" {
     GHC.Word.$fNumWord16_$cabs_closure:
         const GHC.Word.$fNumWord16_$cabs_info;
 },
 GHC.Word.$fNumWord16_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2FLN: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cabs_info" {
     GHC.Word.$fNumWord16_$cabs_info:
         const GHC.Word.$fNumWord16_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.696745333 UTC

[section ""data" . GHC.Word.$fNumWord16_$cnegate_closure" {
     GHC.Word.$fNumWord16_$cnegate_closure:
         const GHC.Word.$fNumWord16_$cnegate_info;
 },
 GHC.Word.$fNumWord16_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2FM3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FMj; else goto c2FMk;
       c2FMj: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FMk: // global
           I64[Sp - 8] = block_c2FM0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FMo; else goto c2FM1;
       u2FMo: // global
           call _c2FM0(R1) args: 0, res: 0, upd: 0;
       c2FM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$cnegate_info" {
     GHC.Word.$fNumWord16_$cnegate_info:
         const GHC.Word.$fNumWord16_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FM0() //  [R1]
         { []
         }
     {offset
       c2FM0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FMn; else goto c2FMm;
       c2FMn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FMm: // global
           _s2DLK::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DLK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FM0_info" {
     block_c2FM0_info:
         const _c2FM0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.703270359 UTC

[section ""data" . GHC.Word.$fNumWord16_$c*_closure" {
     GHC.Word.$fNumWord16_$c*_closure:
         const GHC.Word.$fNumWord16_$c*_info;
 },
 GHC.Word.$fNumWord16_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FMY; else goto c2FMZ;
       c2FMY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FMZ: // global
           I64[Sp - 16] = block_c2FMG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FN5; else goto c2FMH;
       u2FN5: // global
           call _c2FMG(R1) args: 0, res: 0, upd: 0;
       c2FMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c*_info" {
     GHC.Word.$fNumWord16_$c*_info:
         const GHC.Word.$fNumWord16_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FMG() //  [R1]
         { []
         }
     {offset
       c2FMG: // global
           I64[Sp] = block_c2FMM_info;
           _s2DLO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLO::I64;
           if (R1 & 7 != 0) goto u2FN4; else goto c2FMN;
       u2FN4: // global
           call _c2FMM(R1) args: 0, res: 0, upd: 0;
       c2FMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FMG_info" {
     block_c2FMG_info:
         const _c2FMG;
         const 1;
         const 30;
 },
 _c2FMM() //  [R1]
         { []
         }
     {offset
       c2FMM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FN3; else goto c2FN2;
       c2FN3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FN2: // global
           _s2DLS::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DLS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FMM_info" {
     block_c2FMM_info:
         const _c2FMM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.712461828 UTC

[section ""data" . GHC.Word.$fNumWord16_$c-_closure" {
     GHC.Word.$fNumWord16_$c-_closure:
         const GHC.Word.$fNumWord16_$c-_info;
 },
 GHC.Word.$fNumWord16_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FNM; else goto c2FNN;
       c2FNM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FNN: // global
           I64[Sp - 16] = block_c2FNu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FNT; else goto c2FNv;
       u2FNT: // global
           call _c2FNu(R1) args: 0, res: 0, upd: 0;
       c2FNv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c-_info" {
     GHC.Word.$fNumWord16_$c-_info:
         const GHC.Word.$fNumWord16_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FNu() //  [R1]
         { []
         }
     {offset
       c2FNu: // global
           I64[Sp] = block_c2FNA_info;
           _s2DLW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DLW::I64;
           if (R1 & 7 != 0) goto u2FNS; else goto c2FNB;
       u2FNS: // global
           call _c2FNA(R1) args: 0, res: 0, upd: 0;
       c2FNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FNu_info" {
     block_c2FNu_info:
         const _c2FNu;
         const 1;
         const 30;
 },
 _c2FNA() //  [R1]
         { []
         }
     {offset
       c2FNA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FNR; else goto c2FNQ;
       c2FNR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FNQ: // global
           _s2DM0::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DM0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FNA_info" {
     block_c2FNA_info:
         const _c2FNA;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.721518582 UTC

[section ""data" . GHC.Word.$fNumWord16_$c+_closure" {
     GHC.Word.$fNumWord16_$c+_closure:
         const GHC.Word.$fNumWord16_$c+_info;
 },
 GHC.Word.$fNumWord16_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FOA; else goto c2FOB;
       c2FOA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FOB: // global
           I64[Sp - 16] = block_c2FOi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FOH; else goto c2FOj;
       u2FOH: // global
           call _c2FOi(R1) args: 0, res: 0, upd: 0;
       c2FOj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$c+_info" {
     GHC.Word.$fNumWord16_$c+_info:
         const GHC.Word.$fNumWord16_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FOi() //  [R1]
         { []
         }
     {offset
       c2FOi: // global
           I64[Sp] = block_c2FOo_info;
           _s2DM4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DM4::I64;
           if (R1 & 7 != 0) goto u2FOG; else goto c2FOp;
       u2FOG: // global
           call _c2FOo(R1) args: 0, res: 0, upd: 0;
       c2FOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FOi_info" {
     block_c2FOi_info:
         const _c2FOi;
         const 1;
         const 30;
 },
 _c2FOo() //  [R1]
         { []
         }
     {offset
       c2FOo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FOF; else goto c2FOE;
       c2FOF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FOE: // global
           _s2DM8::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DM8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FOo_info" {
     block_c2FOo_info:
         const _c2FOo;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.728835803 UTC

[section ""data" . GHC.Word.$ctoInteger1_closure" {
     GHC.Word.$ctoInteger1_closure:
         const GHC.Word.$ctoInteger1_info;
 },
 GHC.Word.$ctoInteger1_entry() //  [R2]
         { []
         }
     {offset
       c2FP9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FPa; else goto c2FPb;
       c2FPa: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FPb: // global
           I64[Sp - 8] = block_c2FP6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FPg; else goto c2FP7;
       u2FPg: // global
           call _c2FP6(R1) args: 0, res: 0, upd: 0;
       c2FP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger1_info" {
     GHC.Word.$ctoInteger1_info:
         const GHC.Word.$ctoInteger1_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FP6() //  [R1]
         { []
         }
     {offset
       c2FP6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FP6_info" {
     block_c2FP6_info:
         const _c2FP6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.734814243 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cpopCount_closure" {
     GHC.Word.$fBitsWord16_$cpopCount_closure:
         const GHC.Word.$fBitsWord16_$cpopCount_info;
 },
 GHC.Word.$fBitsWord16_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2FPy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FPJ; else goto c2FPK;
       c2FPJ: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FPK: // global
           I64[Sp - 8] = block_c2FPv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FPO; else goto c2FPw;
       u2FPO: // global
           call _c2FPv(R1) args: 0, res: 0, upd: 0;
       c2FPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cpopCount_info" {
     GHC.Word.$fBitsWord16_$cpopCount_info:
         const GHC.Word.$fBitsWord16_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FPv() //  [R1]
         { []
         }
     {offset
       c2FPv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FPN; else goto c2FPM;
       c2FPN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FPM: // global
           (_c2FPB::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FPB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FPv_info" {
     block_c2FPv_info:
         const _c2FPv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.741786931 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FQk; else goto c2FQl;
       c2FQk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FQl: // global
           I64[Sp - 16] = block_c2FQ5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FQr; else goto c2FQ6;
       u2FQr: // global
           call _c2FQ5(R1) args: 0, res: 0, upd: 0;
       c2FQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord16_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FQ5() //  [R1]
         { []
         }
     {offset
       c2FQ5: // global
           I64[Sp] = block_c2FQb_info;
           _s2DMl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMl::I64;
           if (R1 & 7 != 0) goto u2FQq; else goto c2FQc;
       u2FQq: // global
           call _c2FQb(R1) args: 0, res: 0, upd: 0;
       c2FQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FQ5_info" {
     block_c2FQ5_info:
         const _c2FQ5;
         const 1;
         const 30;
 },
 _c2FQb() //  [R1]
         { []
         }
     {offset
       c2FQb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FQp; else goto c2FQo;
       c2FQp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FQo: // global
           _s2DMo::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DMo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FQb_info" {
     block_c2FQb_info:
         const _c2FQb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.74987209 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftR_closure" {
     GHC.Word.$fBitsWord16_$cshiftR_closure:
         const GHC.Word.$fBitsWord16_$cshiftR_info;
 },
 GHC.Word.$fBitsWord16_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FQR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FQV; else goto c2FQW;
       c2FQV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FQW: // global
           I64[Sp - 16] = block_c2FQO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FRg; else goto c2FQP;
       u2FRg: // global
           call _c2FQO(R1) args: 0, res: 0, upd: 0;
       c2FQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshiftR_info" {
     GHC.Word.$fBitsWord16_$cshiftR_info:
         const GHC.Word.$fBitsWord16_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FQO() //  [R1]
         { []
         }
     {offset
       c2FQO: // global
           I64[Sp] = block_c2FQU_info;
           _s2DMs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMs::I64;
           if (R1 & 7 != 0) goto u2FRf; else goto c2FQY;
       u2FRf: // global
           call _c2FQU(R1) args: 0, res: 0, upd: 0;
       c2FQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FQO_info" {
     block_c2FQO_info:
         const _c2FQO;
         const 1;
         const 30;
 },
 _c2FQU() //  [R1]
         { []
         }
     {offset
       c2FQU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FR4; else goto c2FR3;
       c2FR4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FR3: // global
           _s2DMu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DMu::I64, 64)) goto c2FRd; else goto c2FRe;
       c2FRd: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DMu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FRe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FQU_info" {
     block_c2FQU_info:
         const _c2FQU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.758578259 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord16_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FRH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FRW; else goto c2FRX;
       c2FRW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FRX: // global
           I64[Sp - 16] = block_c2FRE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FS3; else goto c2FRF;
       u2FS3: // global
           call _c2FRE(R1) args: 0, res: 0, upd: 0;
       c2FRF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord16_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FRE() //  [R1]
         { []
         }
     {offset
       c2FRE: // global
           I64[Sp] = block_c2FRK_info;
           _s2DMA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMA::I64;
           if (R1 & 7 != 0) goto u2FS2; else goto c2FRL;
       u2FS2: // global
           call _c2FRK(R1) args: 0, res: 0, upd: 0;
       c2FRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FRE_info" {
     block_c2FRE_info:
         const _c2FRE;
         const 1;
         const 30;
 },
 _c2FRK() //  [R1]
         { []
         }
     {offset
       c2FRK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FS1; else goto c2FS0;
       c2FS1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FS0: // global
           _s2DME::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DME::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FRK_info" {
     block_c2FRK_info:
         const _c2FRK;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.767230947 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshiftL_closure" {
     GHC.Word.$fBitsWord16_$cshiftL_closure:
         const GHC.Word.$fBitsWord16_$cshiftL_info;
 },
 GHC.Word.$fBitsWord16_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FSy; else goto c2FSz;
       c2FSy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FSz: // global
           I64[Sp - 16] = block_c2FSr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FSW; else goto c2FSs;
       u2FSW: // global
           call _c2FSr(R1) args: 0, res: 0, upd: 0;
       c2FSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshiftL_info" {
     GHC.Word.$fBitsWord16_$cshiftL_info:
         const GHC.Word.$fBitsWord16_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FSr() //  [R1]
         { []
         }
     {offset
       c2FSr: // global
           I64[Sp] = block_c2FSx_info;
           _s2DMI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DMI::I64;
           if (R1 & 7 != 0) goto u2FSV; else goto c2FSB;
       u2FSV: // global
           call _c2FSx(R1) args: 0, res: 0, upd: 0;
       c2FSB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FSr_info" {
     block_c2FSr_info:
         const _c2FSr;
         const 1;
         const 30;
 },
 _c2FSx() //  [R1]
         { []
         }
     {offset
       c2FSx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FSH; else goto c2FSG;
       c2FSH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FSG: // global
           _s2DMK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DMK::I64, 64)) goto c2FST; else goto c2FSU;
       c2FST: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] << _s2DMK::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FSU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FSx_info" {
     block_c2FSx_info:
         const _c2FSx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.77447349 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cisSigned_closure" {
     GHC.Word.$fBitsWord16_$cisSigned_closure:
         const GHC.Word.$fBitsWord16_$cisSigned_info;
 },
 GHC.Word.$fBitsWord16_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2FTm: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cisSigned_info" {
     GHC.Word.$fBitsWord16_$cisSigned_info:
         const GHC.Word.$fBitsWord16_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.779372206 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotate_closure" {
     GHC.Word.$fBitsWord16_$crotate_closure:
         const GHC.Word.$fBitsWord16_$crotate_info;
 },
 GHC.Word.$fBitsWord16_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FTC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2FTG; else goto c2FTH;
       c2FTG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FTH: // global
           I64[Sp - 16] = block_c2FTz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FUu; else goto c2FTA;
       u2FUu: // global
           call _c2FTz(R1) args: 0, res: 0, upd: 0;
       c2FTA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotate_info" {
     GHC.Word.$fBitsWord16_$crotate_info:
         const GHC.Word.$fBitsWord16_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FTz() //  [R1]
         { []
         }
     {offset
       c2FTz: // global
           I64[Sp - 8] = block_c2FTF_info;
           _s2DMR::P64 = R1;
           _s2DMS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DMS::I64;
           P64[Sp + 8] = _s2DMR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FUt; else goto c2FTJ;
       u2FUt: // global
           call _c2FTF(R1) args: 0, res: 0, upd: 0;
       c2FTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FTz_info" {
     block_c2FTz_info:
         const _c2FTz;
         const 1;
         const 30;
 },
 _c2FTF() //  [R1]
         { []
         }
     {offset
       c2FTF: // global
           _s2DMX::I64 = I64[R1 + 7] & 15;
           if (_s2DMX::I64 != 0) goto u2FUr; else goto c2FUn;
       u2FUr: // global
           I64[Sp + 16] = _s2DMX::I64;
           Sp = Sp + 8;
           call _c2FTY() args: 0, res: 0, upd: 0;
       c2FUn: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FTF_info" {
     block_c2FTF_info:
         const _c2FTF;
         const 66;
         const 30;
 },
 _c2FTY() //  []
         { []
         }
     {offset
       c2FTY: // global
           Hp = Hp + 16;
           _s2DMX::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2FUk; else goto c2FUj;
       c2FUk: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2FTX_info;
           R1 = _s2DMX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2FUj: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2DMS::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2DMS::I64 << _s2DMX::I64) | (_s2DMS::I64 >> 16 - _s2DMX::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2FTX() //  [R1]
         { []
         }
     {offset
       c2FTX: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2FTY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2FTX_info" {
     block_c2FTX_info:
         const _c2FTX;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.790531868 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cshift_closure" {
     GHC.Word.$fBitsWord16_$cshift_closure:
         const GHC.Word.$fBitsWord16_$cshift_info;
 },
 GHC.Word.$fBitsWord16_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FVe; else goto c2FVf;
       c2FVe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FVf: // global
           I64[Sp - 16] = block_c2FV7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FVW; else goto c2FV8;
       u2FVW: // global
           call _c2FV7(R1) args: 0, res: 0, upd: 0;
       c2FV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cshift_info" {
     GHC.Word.$fBitsWord16_$cshift_info:
         const GHC.Word.$fBitsWord16_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FV7() //  [R1]
         { []
         }
     {offset
       c2FV7: // global
           I64[Sp] = block_c2FVd_info;
           _s2DN6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DN6::I64;
           if (R1 & 7 != 0) goto u2FVV; else goto c2FVh;
       u2FVV: // global
           call _c2FVd(R1) args: 0, res: 0, upd: 0;
       c2FVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FV7_info" {
     block_c2FV7_info:
         const _c2FV7;
         const 1;
         const 30;
 },
 _c2FVd() //  [R1]
         { []
         }
     {offset
       c2FVd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FVn; else goto c2FVm;
       c2FVn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FVm: // global
           _s2DN6::I64 = I64[Sp + 8];
           _s2DN8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DN8::I64, 0)) goto c2FVF; else goto c2FVU;
       c2FVF: // global
           _s2DNa::I64 = -_s2DN8::I64;
           if (%MO_S_Ge_W64(_s2DNa::I64, 64)) goto c2FVT; else goto c2FVC;
       c2FVC: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DN6::I64 >> _s2DNa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FVU: // global
           if (%MO_S_Ge_W64(_s2DN8::I64, 64)) goto c2FVT; else goto c2FVS;
       c2FVT: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2FVS: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DN6::I64 << _s2DN8::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FVd_info" {
     block_c2FVd_info:
         const _c2FVd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.799767174 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cxor_closure" {
     GHC.Word.$fBitsWord16_$cxor_closure:
         const GHC.Word.$fBitsWord16_$cxor_info;
 },
 GHC.Word.$fBitsWord16_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2FWs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FWE; else goto c2FWF;
       c2FWE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FWF: // global
           I64[Sp - 16] = block_c2FWp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FWL; else goto c2FWq;
       u2FWL: // global
           call _c2FWp(R1) args: 0, res: 0, upd: 0;
       c2FWq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cxor_info" {
     GHC.Word.$fBitsWord16_$cxor_info:
         const GHC.Word.$fBitsWord16_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FWp() //  [R1]
         { []
         }
     {offset
       c2FWp: // global
           I64[Sp] = block_c2FWv_info;
           _s2DNj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNj::I64;
           if (R1 & 7 != 0) goto u2FWK; else goto c2FWw;
       u2FWK: // global
           call _c2FWv(R1) args: 0, res: 0, upd: 0;
       c2FWw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FWp_info" {
     block_c2FWp_info:
         const _c2FWp;
         const 1;
         const 30;
 },
 _c2FWv() //  [R1]
         { []
         }
     {offset
       c2FWv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FWJ; else goto c2FWI;
       c2FWJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FWI: // global
           _s2DNm::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FWv_info" {
     block_c2FWv_info:
         const _c2FWv;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.80752842 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.|._closure" {
     GHC.Word.$fBitsWord16_$c.|._closure:
         const GHC.Word.$fBitsWord16_$c.|._info;
 },
 GHC.Word.$fBitsWord16_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2FXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FXo; else goto c2FXp;
       c2FXo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FXp: // global
           I64[Sp - 16] = block_c2FX9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FXv; else goto c2FXa;
       u2FXv: // global
           call _c2FX9(R1) args: 0, res: 0, upd: 0;
       c2FXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$c.|._info" {
     GHC.Word.$fBitsWord16_$c.|._info:
         const GHC.Word.$fBitsWord16_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FX9() //  [R1]
         { []
         }
     {offset
       c2FX9: // global
           I64[Sp] = block_c2FXf_info;
           _s2DNq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNq::I64;
           if (R1 & 7 != 0) goto u2FXu; else goto c2FXg;
       u2FXu: // global
           call _c2FXf(R1) args: 0, res: 0, upd: 0;
       c2FXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FX9_info" {
     block_c2FX9_info:
         const _c2FX9;
         const 1;
         const 30;
 },
 _c2FXf() //  [R1]
         { []
         }
     {offset
       c2FXf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FXt; else goto c2FXs;
       c2FXt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FXs: // global
           _s2DNt::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNt::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FXf_info" {
     block_c2FXf_info:
         const _c2FXf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.815502926 UTC

[section ""data" . GHC.Word.$fBitsWord16_$c.&._closure" {
     GHC.Word.$fBitsWord16_$c.&._closure:
         const GHC.Word.$fBitsWord16_$c.&._info;
 },
 GHC.Word.$fBitsWord16_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2FXW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2FY8; else goto c2FY9;
       c2FY8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2FY9: // global
           I64[Sp - 16] = block_c2FXT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2FYf; else goto c2FXU;
       u2FYf: // global
           call _c2FXT(R1) args: 0, res: 0, upd: 0;
       c2FXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$c.&._info" {
     GHC.Word.$fBitsWord16_$c.&._info:
         const GHC.Word.$fBitsWord16_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2FXT() //  [R1]
         { []
         }
     {offset
       c2FXT: // global
           I64[Sp] = block_c2FXZ_info;
           _s2DNx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DNx::I64;
           if (R1 & 7 != 0) goto u2FYe; else goto c2FY0;
       u2FYe: // global
           call _c2FXZ(R1) args: 0, res: 0, upd: 0;
       c2FY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FXT_info" {
     block_c2FXT_info:
         const _c2FXT;
         const 1;
         const 30;
 },
 _c2FXZ() //  [R1]
         { []
         }
     {offset
       c2FXZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FYd; else goto c2FYc;
       c2FYd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FYc: // global
           _s2DNA::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DNA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FXZ_info" {
     block_c2FXZ_info:
         const _c2FXZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.823248767 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2FYG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FYR; else goto c2FYS;
       c2FYR: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FYS: // global
           I64[Sp - 8] = block_c2FYD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FYW; else goto c2FYE;
       u2FYW: // global
           call _c2FYD(R1) args: 0, res: 0, upd: 0;
       c2FYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FYD() //  [R1]
         { []
         }
     {offset
       c2FYD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FYV; else goto c2FYU;
       c2FYV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FYU: // global
           (_c2FYJ::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FYJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FYD_info" {
     block_c2FYD_info:
         const _c2FYD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.82918005 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2FZi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2FZt; else goto c2FZu;
       c2FZt: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2FZu: // global
           I64[Sp - 8] = block_c2FZf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2FZy; else goto c2FZg;
       u2FZy: // global
           call _c2FZf(R1) args: 0, res: 0, upd: 0;
       c2FZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2FZf() //  [R1]
         { []
         }
     {offset
       c2FZf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2FZx; else goto c2FZw;
       c2FZx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2FZw: // global
           (_c2FZl::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2FZl::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2FZf_info" {
     block_c2FZf_info:
         const _c2FZf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.83483913 UTC

[section ""data" . GHC.Word.$fBitsWord1_closure" {
     GHC.Word.$fBitsWord1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.836874644 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord16_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2FZS: // global
           R1 = GHC.Word.$fBitsWord1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord16_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.840947288 UTC

[section ""data" . GHC.Word.$fNumWord32_$cfromInteger_closure" {
     GHC.Word.$fNumWord32_$cfromInteger_closure:
         const GHC.Word.$fNumWord32_$cfromInteger_info;
 },
 GHC.Word.$fNumWord32_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c2G06: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G0d; else goto c2G0e;
       c2G0d: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G0e: // global
           I64[Sp - 8] = block_c2G04_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cfromInteger_info" {
     GHC.Word.$fNumWord32_$cfromInteger_info:
         const GHC.Word.$fNumWord32_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2G04() //  [R1]
         { []
         }
     {offset
       c2G04: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G0h; else goto c2G0g;
       c2G0h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2G0g: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G04_info" {
     block_c2G04_info:
         const _c2G04;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.846125489 UTC

[section ""data" . GHC.Word.$fNumWord32_$cabs_closure" {
     GHC.Word.$fNumWord32_$cabs_closure:
         const GHC.Word.$fNumWord32_$cabs_info;
 },
 GHC.Word.$fNumWord32_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c2G0y: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cabs_info" {
     GHC.Word.$fNumWord32_$cabs_info:
         const GHC.Word.$fNumWord32_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.850263714 UTC

[section ""data" . GHC.Word.$fNumWord32_$cnegate_closure" {
     GHC.Word.$fNumWord32_$cnegate_closure:
         const GHC.Word.$fNumWord32_$cnegate_info;
 },
 GHC.Word.$fNumWord32_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c2G0O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G14; else goto c2G15;
       c2G14: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G15: // global
           I64[Sp - 8] = block_c2G0L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G19; else goto c2G0M;
       u2G19: // global
           call _c2G0L(R1) args: 0, res: 0, upd: 0;
       c2G0M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$cnegate_info" {
     GHC.Word.$fNumWord32_$cnegate_info:
         const GHC.Word.$fNumWord32_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2G0L() //  [R1]
         { []
         }
     {offset
       c2G0L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G18; else goto c2G17;
       c2G18: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G17: // global
           _s2DNW::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DNW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G0L_info" {
     block_c2G0L_info:
         const _c2G0L;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.856728727 UTC

[section ""data" . GHC.Word.$fNumWord32_$c*_closure" {
     GHC.Word.$fNumWord32_$c*_closure:
         const GHC.Word.$fNumWord32_$c*_info;
 },
 GHC.Word.$fNumWord32_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G1u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G1J; else goto c2G1K;
       c2G1J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G1K: // global
           I64[Sp - 16] = block_c2G1r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G1Q; else goto c2G1s;
       u2G1Q: // global
           call _c2G1r(R1) args: 0, res: 0, upd: 0;
       c2G1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c*_info" {
     GHC.Word.$fNumWord32_$c*_info:
         const GHC.Word.$fNumWord32_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G1r() //  [R1]
         { []
         }
     {offset
       c2G1r: // global
           I64[Sp] = block_c2G1x_info;
           _s2DO0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DO0::I64;
           if (R1 & 7 != 0) goto u2G1P; else goto c2G1y;
       u2G1P: // global
           call _c2G1x(R1) args: 0, res: 0, upd: 0;
       c2G1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G1r_info" {
     block_c2G1r_info:
         const _c2G1r;
         const 1;
         const 30;
 },
 _c2G1x() //  [R1]
         { []
         }
     {offset
       c2G1x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G1O; else goto c2G1N;
       c2G1O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G1N: // global
           _s2DO4::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DO4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G1x_info" {
     block_c2G1x_info:
         const _c2G1x;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.864882106 UTC

[section ""data" . GHC.Word.$fNumWord32_$c-_closure" {
     GHC.Word.$fNumWord32_$c-_closure:
         const GHC.Word.$fNumWord32_$c-_info;
 },
 GHC.Word.$fNumWord32_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G2x; else goto c2G2y;
       c2G2x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G2y: // global
           I64[Sp - 16] = block_c2G2f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G2E; else goto c2G2g;
       u2G2E: // global
           call _c2G2f(R1) args: 0, res: 0, upd: 0;
       c2G2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c-_info" {
     GHC.Word.$fNumWord32_$c-_info:
         const GHC.Word.$fNumWord32_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G2f() //  [R1]
         { []
         }
     {offset
       c2G2f: // global
           I64[Sp] = block_c2G2l_info;
           _s2DO8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DO8::I64;
           if (R1 & 7 != 0) goto u2G2D; else goto c2G2m;
       u2G2D: // global
           call _c2G2l(R1) args: 0, res: 0, upd: 0;
       c2G2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G2f_info" {
     block_c2G2f_info:
         const _c2G2f;
         const 1;
         const 30;
 },
 _c2G2l() //  [R1]
         { []
         }
     {offset
       c2G2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G2C; else goto c2G2B;
       c2G2C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G2B: // global
           _s2DOc::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G2l_info" {
     block_c2G2l_info:
         const _c2G2l;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.873186296 UTC

[section ""data" . GHC.Word.$fNumWord32_$c+_closure" {
     GHC.Word.$fNumWord32_$c+_closure:
         const GHC.Word.$fNumWord32_$c+_info;
 },
 GHC.Word.$fNumWord32_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G36: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G3l; else goto c2G3m;
       c2G3l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G3m: // global
           I64[Sp - 16] = block_c2G33_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G3s; else goto c2G34;
       u2G3s: // global
           call _c2G33(R1) args: 0, res: 0, upd: 0;
       c2G34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$c+_info" {
     GHC.Word.$fNumWord32_$c+_info:
         const GHC.Word.$fNumWord32_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G33() //  [R1]
         { []
         }
     {offset
       c2G33: // global
           I64[Sp] = block_c2G39_info;
           _s2DOg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOg::I64;
           if (R1 & 7 != 0) goto u2G3r; else goto c2G3a;
       u2G3r: // global
           call _c2G39(R1) args: 0, res: 0, upd: 0;
       c2G3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G33_info" {
     block_c2G33_info:
         const _c2G33;
         const 1;
         const 30;
 },
 _c2G39() //  [R1]
         { []
         }
     {offset
       c2G39: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G3q; else goto c2G3p;
       c2G3q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G3p: // global
           _s2DOk::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G39_info" {
     block_c2G39_info:
         const _c2G39;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.880621353 UTC

[section ""data" . GHC.Word.$ctoInteger2_closure" {
     GHC.Word.$ctoInteger2_closure:
         const GHC.Word.$ctoInteger2_info;
 },
 GHC.Word.$ctoInteger2_entry() //  [R2]
         { []
         }
     {offset
       c2G3U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G3V; else goto c2G3W;
       c2G3V: // global
           R2 = R2;
           R1 = GHC.Word.$ctoInteger2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G3W: // global
           I64[Sp - 8] = block_c2G3R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G41; else goto c2G3S;
       u2G41: // global
           call _c2G3R(R1) args: 0, res: 0, upd: 0;
       c2G3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$ctoInteger2_info" {
     GHC.Word.$ctoInteger2_info:
         const GHC.Word.$ctoInteger2_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2G3R() //  [R1]
         { []
         }
     {offset
       c2G3R: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G3R_info" {
     block_c2G3R_info:
         const _c2G3R;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.886483408 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cpopCount_closure" {
     GHC.Word.$fBitsWord32_$cpopCount_closure:
         const GHC.Word.$fBitsWord32_$cpopCount_info;
 },
 GHC.Word.$fBitsWord32_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2G4j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2G4u; else goto c2G4v;
       c2G4u: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2G4v: // global
           I64[Sp - 8] = block_c2G4g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G4z; else goto c2G4h;
       u2G4z: // global
           call _c2G4g(R1) args: 0, res: 0, upd: 0;
       c2G4h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cpopCount_info" {
     GHC.Word.$fBitsWord32_$cpopCount_info:
         const GHC.Word.$fBitsWord32_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2G4g() //  [R1]
         { []
         }
     {offset
       c2G4g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G4y; else goto c2G4x;
       c2G4y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G4x: // global
           (_c2G4m::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2G4m::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G4g_info" {
     block_c2G4g_info:
         const _c2G4g;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.892527536 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G4T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G55; else goto c2G56;
       c2G55: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G56: // global
           I64[Sp - 16] = block_c2G4Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G5c; else goto c2G4R;
       u2G5c: // global
           call _c2G4Q(R1) args: 0, res: 0, upd: 0;
       c2G4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord32_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G4Q() //  [R1]
         { []
         }
     {offset
       c2G4Q: // global
           I64[Sp] = block_c2G4W_info;
           _s2DOx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOx::I64;
           if (R1 & 7 != 0) goto u2G5b; else goto c2G4X;
       u2G5b: // global
           call _c2G4W(R1) args: 0, res: 0, upd: 0;
       c2G4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G4Q_info" {
     block_c2G4Q_info:
         const _c2G4Q;
         const 1;
         const 30;
 },
 _c2G4W() //  [R1]
         { []
         }
     {offset
       c2G4W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G5a; else goto c2G59;
       c2G5a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G59: // global
           _s2DOA::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G4W_info" {
     block_c2G4W_info:
         const _c2G4W;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.900379428 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftR_closure" {
     GHC.Word.$fBitsWord32_$cshiftR_closure:
         const GHC.Word.$fBitsWord32_$cshiftR_info;
 },
 GHC.Word.$fBitsWord32_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G5G; else goto c2G5H;
       c2G5G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G5H: // global
           I64[Sp - 16] = block_c2G5z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G61; else goto c2G5A;
       u2G61: // global
           call _c2G5z(R1) args: 0, res: 0, upd: 0;
       c2G5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshiftR_info" {
     GHC.Word.$fBitsWord32_$cshiftR_info:
         const GHC.Word.$fBitsWord32_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G5z() //  [R1]
         { []
         }
     {offset
       c2G5z: // global
           I64[Sp] = block_c2G5F_info;
           _s2DOE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOE::I64;
           if (R1 & 7 != 0) goto u2G60; else goto c2G5J;
       u2G60: // global
           call _c2G5F(R1) args: 0, res: 0, upd: 0;
       c2G5J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G5z_info" {
     block_c2G5z_info:
         const _c2G5z;
         const 1;
         const 30;
 },
 _c2G5F() //  [R1]
         { []
         }
     {offset
       c2G5F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G5P; else goto c2G5O;
       c2G5P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G5O: // global
           _s2DOG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DOG::I64, 64)) goto c2G5Y; else goto c2G5Z;
       c2G5Y: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DOG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2G5Z: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G5F_info" {
     block_c2G5F_info:
         const _c2G5F;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.909287262 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord32_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G6s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G6H; else goto c2G6I;
       c2G6H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G6I: // global
           I64[Sp - 16] = block_c2G6p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G6O; else goto c2G6q;
       u2G6O: // global
           call _c2G6p(R1) args: 0, res: 0, upd: 0;
       c2G6q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord32_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G6p() //  [R1]
         { []
         }
     {offset
       c2G6p: // global
           I64[Sp] = block_c2G6v_info;
           _s2DOM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOM::I64;
           if (R1 & 7 != 0) goto u2G6N; else goto c2G6w;
       u2G6N: // global
           call _c2G6v(R1) args: 0, res: 0, upd: 0;
       c2G6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G6p_info" {
     block_c2G6p_info:
         const _c2G6p;
         const 1;
         const 30;
 },
 _c2G6v() //  [R1]
         { []
         }
     {offset
       c2G6v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G6M; else goto c2G6L;
       c2G6M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G6L: // global
           _s2DOQ::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DOQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G6v_info" {
     block_c2G6v_info:
         const _c2G6v;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.917114313 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshiftL_closure" {
     GHC.Word.$fBitsWord32_$cshiftL_closure:
         const GHC.Word.$fBitsWord32_$cshiftL_info;
 },
 GHC.Word.$fBitsWord32_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G7e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G7i; else goto c2G7j;
       c2G7i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G7j: // global
           I64[Sp - 16] = block_c2G7b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G7G; else goto c2G7c;
       u2G7G: // global
           call _c2G7b(R1) args: 0, res: 0, upd: 0;
       c2G7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshiftL_info" {
     GHC.Word.$fBitsWord32_$cshiftL_info:
         const GHC.Word.$fBitsWord32_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G7b() //  [R1]
         { []
         }
     {offset
       c2G7b: // global
           I64[Sp] = block_c2G7h_info;
           _s2DOU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DOU::I64;
           if (R1 & 7 != 0) goto u2G7F; else goto c2G7l;
       u2G7F: // global
           call _c2G7h(R1) args: 0, res: 0, upd: 0;
       c2G7l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G7b_info" {
     block_c2G7b_info:
         const _c2G7b;
         const 1;
         const 30;
 },
 _c2G7h() //  [R1]
         { []
         }
     {offset
       c2G7h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2G7r; else goto c2G7q;
       c2G7r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2G7q: // global
           _s2DOW::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DOW::I64, 64)) goto c2G7D; else goto c2G7E;
       c2G7D: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] << _s2DOW::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2G7E: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G7h_info" {
     block_c2G7h_info:
         const _c2G7h;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.924395509 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cisSigned_closure" {
     GHC.Word.$fBitsWord32_$cisSigned_closure:
         const GHC.Word.$fBitsWord32_$cisSigned_info;
 },
 GHC.Word.$fBitsWord32_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2G85: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cisSigned_info" {
     GHC.Word.$fBitsWord32_$cisSigned_info:
         const GHC.Word.$fBitsWord32_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.929164004 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotate_closure" {
     GHC.Word.$fBitsWord32_$crotate_closure:
         const GHC.Word.$fBitsWord32_$crotate_info;
 },
 GHC.Word.$fBitsWord32_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G8l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2G8p; else goto c2G8q;
       c2G8p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G8q: // global
           I64[Sp - 16] = block_c2G8i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2G9d; else goto c2G8j;
       u2G9d: // global
           call _c2G8i(R1) args: 0, res: 0, upd: 0;
       c2G8j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotate_info" {
     GHC.Word.$fBitsWord32_$crotate_info:
         const GHC.Word.$fBitsWord32_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G8i() //  [R1]
         { []
         }
     {offset
       c2G8i: // global
           I64[Sp - 8] = block_c2G8o_info;
           _s2DP3::P64 = R1;
           _s2DP4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DP4::I64;
           P64[Sp + 8] = _s2DP3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2G9c; else goto c2G8s;
       u2G9c: // global
           call _c2G8o(R1) args: 0, res: 0, upd: 0;
       c2G8s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G8i_info" {
     block_c2G8i_info:
         const _c2G8i;
         const 1;
         const 30;
 },
 _c2G8o() //  [R1]
         { []
         }
     {offset
       c2G8o: // global
           _s2DP9::I64 = I64[R1 + 7] & 31;
           if (_s2DP9::I64 != 0) goto u2G9a; else goto c2G96;
       u2G9a: // global
           I64[Sp + 16] = _s2DP9::I64;
           Sp = Sp + 8;
           call _c2G8H() args: 0, res: 0, upd: 0;
       c2G96: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G8o_info" {
     block_c2G8o_info:
         const _c2G8o;
         const 66;
         const 30;
 },
 _c2G8H() //  []
         { []
         }
     {offset
       c2G8H: // global
           Hp = Hp + 16;
           _s2DP9::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2G93; else goto c2G92;
       c2G93: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2G8G_info;
           R1 = _s2DP9::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2G92: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2DP4::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2DP4::I64 << _s2DP9::I64) | (_s2DP4::I64 >> 32 - _s2DP9::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2G8G() //  [R1]
         { []
         }
     {offset
       c2G8G: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2G8H() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2G8G_info" {
     block_c2G8G_info:
         const _c2G8G;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.940028537 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cshift_closure" {
     GHC.Word.$fBitsWord32_$cshift_closure:
         const GHC.Word.$fBitsWord32_$cshift_info;
 },
 GHC.Word.$fBitsWord32_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2G9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2G9X; else goto c2G9Y;
       c2G9X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2G9Y: // global
           I64[Sp - 16] = block_c2G9Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GaF; else goto c2G9R;
       u2GaF: // global
           call _c2G9Q(R1) args: 0, res: 0, upd: 0;
       c2G9R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cshift_info" {
     GHC.Word.$fBitsWord32_$cshift_info:
         const GHC.Word.$fBitsWord32_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2G9Q() //  [R1]
         { []
         }
     {offset
       c2G9Q: // global
           I64[Sp] = block_c2G9W_info;
           _s2DPi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPi::I64;
           if (R1 & 7 != 0) goto u2GaE; else goto c2Ga0;
       u2GaE: // global
           call _c2G9W(R1) args: 0, res: 0, upd: 0;
       c2Ga0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G9Q_info" {
     block_c2G9Q_info:
         const _c2G9Q;
         const 1;
         const 30;
 },
 _c2G9W() //  [R1]
         { []
         }
     {offset
       c2G9W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ga6; else goto c2Ga5;
       c2Ga6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ga5: // global
           _s2DPi::I64 = I64[Sp + 8];
           _s2DPk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DPk::I64, 0)) goto c2Gao; else goto c2GaD;
       c2Gao: // global
           _s2DPm::I64 = -_s2DPk::I64;
           if (%MO_S_Ge_W64(_s2DPm::I64, 64)) goto c2GaC; else goto c2Gal;
       c2Gal: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPi::I64 >> _s2DPm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GaD: // global
           if (%MO_S_Ge_W64(_s2DPk::I64, 64)) goto c2GaC; else goto c2GaB;
       c2GaC: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GaB: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2DPi::I64 << _s2DPk::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2G9W_info" {
     block_c2G9W_info:
         const _c2G9W;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.948901792 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cxor_closure" {
     GHC.Word.$fBitsWord32_$cxor_closure:
         const GHC.Word.$fBitsWord32_$cxor_info;
 },
 GHC.Word.$fBitsWord32_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gbm; else goto c2Gbn;
       c2Gbm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gbn: // global
           I64[Sp - 16] = block_c2Gb7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gbt; else goto c2Gb8;
       u2Gbt: // global
           call _c2Gb7(R1) args: 0, res: 0, upd: 0;
       c2Gb8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cxor_info" {
     GHC.Word.$fBitsWord32_$cxor_info:
         const GHC.Word.$fBitsWord32_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gb7() //  [R1]
         { []
         }
     {offset
       c2Gb7: // global
           I64[Sp] = block_c2Gbd_info;
           _s2DPv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPv::I64;
           if (R1 & 7 != 0) goto u2Gbs; else goto c2Gbe;
       u2Gbs: // global
           call _c2Gbd(R1) args: 0, res: 0, upd: 0;
       c2Gbe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gb7_info" {
     block_c2Gb7_info:
         const _c2Gb7;
         const 1;
         const 30;
 },
 _c2Gbd() //  [R1]
         { []
         }
     {offset
       c2Gbd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gbr; else goto c2Gbq;
       c2Gbr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gbq: // global
           _s2DPy::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPy::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gbd_info" {
     block_c2Gbd_info:
         const _c2Gbd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.956871094 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.|._closure" {
     GHC.Word.$fBitsWord32_$c.|._closure:
         const GHC.Word.$fBitsWord32_$c.|._info;
 },
 GHC.Word.$fBitsWord32_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2GbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gc6; else goto c2Gc7;
       c2Gc6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gc7: // global
           I64[Sp - 16] = block_c2GbR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gcd; else goto c2GbS;
       u2Gcd: // global
           call _c2GbR(R1) args: 0, res: 0, upd: 0;
       c2GbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$c.|._info" {
     GHC.Word.$fBitsWord32_$c.|._info:
         const GHC.Word.$fBitsWord32_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GbR() //  [R1]
         { []
         }
     {offset
       c2GbR: // global
           I64[Sp] = block_c2GbX_info;
           _s2DPC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPC::I64;
           if (R1 & 7 != 0) goto u2Gcc; else goto c2GbY;
       u2Gcc: // global
           call _c2GbX(R1) args: 0, res: 0, upd: 0;
       c2GbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GbR_info" {
     block_c2GbR_info:
         const _c2GbR;
         const 1;
         const 30;
 },
 _c2GbX() //  [R1]
         { []
         }
     {offset
       c2GbX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gcb; else goto c2Gca;
       c2Gcb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gca: // global
           _s2DPF::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GbX_info" {
     block_c2GbX_info:
         const _c2GbX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.964551715 UTC

[section ""data" . GHC.Word.$fBitsWord32_$c.&._closure" {
     GHC.Word.$fBitsWord32_$c.&._closure:
         const GHC.Word.$fBitsWord32_$c.&._info;
 },
 GHC.Word.$fBitsWord32_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2GcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GcQ; else goto c2GcR;
       c2GcQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GcR: // global
           I64[Sp - 16] = block_c2GcB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GcX; else goto c2GcC;
       u2GcX: // global
           call _c2GcB(R1) args: 0, res: 0, upd: 0;
       c2GcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$c.&._info" {
     GHC.Word.$fBitsWord32_$c.&._info:
         const GHC.Word.$fBitsWord32_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GcB() //  [R1]
         { []
         }
     {offset
       c2GcB: // global
           I64[Sp] = block_c2GcH_info;
           _s2DPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DPJ::I64;
           if (R1 & 7 != 0) goto u2GcW; else goto c2GcI;
       u2GcW: // global
           call _c2GcH(R1) args: 0, res: 0, upd: 0;
       c2GcI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GcB_info" {
     block_c2GcB_info:
         const _c2GcB;
         const 1;
         const 30;
 },
 _c2GcH() //  [R1]
         { []
         }
     {offset
       c2GcH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GcV; else goto c2GcU;
       c2GcV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GcU: // global
           _s2DPM::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GcH_info" {
     block_c2GcH_info:
         const _c2GcH;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.972242902 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2Gdo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gdz; else goto c2GdA;
       c2Gdz: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GdA: // global
           I64[Sp - 8] = block_c2Gdl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GdE; else goto c2Gdm;
       u2GdE: // global
           call _c2Gdl(R1) args: 0, res: 0, upd: 0;
       c2Gdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Gdl() //  [R1]
         { []
         }
     {offset
       c2Gdl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GdD; else goto c2GdC;
       c2GdD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GdC: // global
           (_c2Gdr::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Gdr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gdl_info" {
     block_c2Gdl_info:
         const _c2Gdl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.978117347 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2Ge0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Geb; else goto c2Gec;
       c2Geb: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gec: // global
           I64[Sp - 8] = block_c2GdX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Geg; else goto c2GdY;
       u2Geg: // global
           call _c2GdX(R1) args: 0, res: 0, upd: 0;
       c2GdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GdX() //  [R1]
         { []
         }
     {offset
       c2GdX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gef; else goto c2Gee;
       c2Gef: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gee: // global
           (_c2Ge3::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Ge3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GdX_info" {
     block_c2GdX_info:
         const _c2GdX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.98403856 UTC

[section ""data" . GHC.Word.$fBitsWord3_closure" {
     GHC.Word.$fBitsWord3_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.98599577 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord32_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2GeA: // global
           R1 = GHC.Word.$fBitsWord3_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord32_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.989833774 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cpopCount_closure" {
     GHC.Word.$fBitsWord64_$cpopCount_closure:
         const GHC.Word.$fBitsWord64_$cpopCount_info;
 },
 GHC.Word.$fBitsWord64_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c2GeP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gf0; else goto c2Gf1;
       c2Gf0: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gf1: // global
           I64[Sp - 8] = block_c2GeM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gf5; else goto c2GeN;
       u2Gf5: // global
           call _c2GeM(R1) args: 0, res: 0, upd: 0;
       c2GeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cpopCount_info" {
     GHC.Word.$fBitsWord64_$cpopCount_info:
         const GHC.Word.$fBitsWord64_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GeM() //  [R1]
         { []
         }
     {offset
       c2GeM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gf4; else goto c2Gf3;
       c2Gf4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gf3: // global
           (_c2GeS::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2GeS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GeM_info" {
     block_c2GeM_info:
         const _c2GeM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:23.995943658 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftR_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gfp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GfB; else goto c2GfC;
       c2GfB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GfC: // global
           I64[Sp - 16] = block_c2Gfm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GfI; else goto c2Gfn;
       u2GfI: // global
           call _c2Gfm(R1) args: 0, res: 0, upd: 0;
       c2Gfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cunsafeShiftR_info" {
     GHC.Word.$fBitsWord64_$cunsafeShiftR_info:
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gfm() //  [R1]
         { []
         }
     {offset
       c2Gfm: // global
           I64[Sp] = block_c2Gfs_info;
           _s2DQ6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQ6::I64;
           if (R1 & 7 != 0) goto u2GfH; else goto c2Gft;
       u2GfH: // global
           call _c2Gfs(R1) args: 0, res: 0, upd: 0;
       c2Gft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gfm_info" {
     block_c2Gfm_info:
         const _c2Gfm;
         const 1;
         const 30;
 },
 _c2Gfs() //  [R1]
         { []
         }
     {offset
       c2Gfs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GfG; else goto c2GfF;
       c2GfG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GfF: // global
           _s2DQ9::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQ9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gfs_info" {
     block_c2Gfs_info:
         const _c2Gfs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.003961714 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftR_closure" {
     GHC.Word.$fBitsWord64_$cshiftR_closure:
         const GHC.Word.$fBitsWord64_$cshiftR_info;
 },
 GHC.Word.$fBitsWord64_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gg8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ggc; else goto c2Ggd;
       c2Ggc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ggd: // global
           I64[Sp - 16] = block_c2Gg5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ggx; else goto c2Gg6;
       u2Ggx: // global
           call _c2Gg5(R1) args: 0, res: 0, upd: 0;
       c2Gg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshiftR_info" {
     GHC.Word.$fBitsWord64_$cshiftR_info:
         const GHC.Word.$fBitsWord64_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gg5() //  [R1]
         { []
         }
     {offset
       c2Gg5: // global
           I64[Sp] = block_c2Ggb_info;
           _s2DQd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQd::I64;
           if (R1 & 7 != 0) goto u2Ggw; else goto c2Ggf;
       u2Ggw: // global
           call _c2Ggb(R1) args: 0, res: 0, upd: 0;
       c2Ggf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gg5_info" {
     block_c2Gg5_info:
         const _c2Gg5;
         const 1;
         const 30;
 },
 _c2Ggb() //  [R1]
         { []
         }
     {offset
       c2Ggb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ggl; else goto c2Ggk;
       c2Ggl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ggk: // global
           _s2DQf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQf::I64, 64)) goto c2Ggu; else goto c2Ggv;
       c2Ggu: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s2DQf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Ggv: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ggb_info" {
     block_c2Ggb_info:
         const _c2Ggb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.012240677 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cunsafeShiftL_closure" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_closure:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_info;
 },
 GHC.Word.$fBitsWord64_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GgY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gha; else goto c2Ghb;
       c2Gha: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ghb: // global
           I64[Sp - 16] = block_c2GgV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Ghh; else goto c2GgW;
       u2Ghh: // global
           call _c2GgV(R1) args: 0, res: 0, upd: 0;
       c2GgW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cunsafeShiftL_info" {
     GHC.Word.$fBitsWord64_$cunsafeShiftL_info:
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GgV() //  [R1]
         { []
         }
     {offset
       c2GgV: // global
           I64[Sp] = block_c2Gh1_info;
           _s2DQl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQl::I64;
           if (R1 & 7 != 0) goto u2Ghg; else goto c2Gh2;
       u2Ghg: // global
           call _c2Gh1(R1) args: 0, res: 0, upd: 0;
       c2Gh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GgV_info" {
     block_c2GgV_info:
         const _c2GgV;
         const 1;
         const 30;
 },
 _c2Gh1() //  [R1]
         { []
         }
     {offset
       c2Gh1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Ghf; else goto c2Ghe;
       c2Ghf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ghe: // global
           _s2DQo::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gh1_info" {
     block_c2Gh1_info:
         const _c2Gh1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.020581716 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshiftL_closure" {
     GHC.Word.$fBitsWord64_$cshiftL_closure:
         const GHC.Word.$fBitsWord64_$cshiftL_info;
 },
 GHC.Word.$fBitsWord64_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GhH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GhL; else goto c2GhM;
       c2GhL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GhM: // global
           I64[Sp - 16] = block_c2GhE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gi6; else goto c2GhF;
       u2Gi6: // global
           call _c2GhE(R1) args: 0, res: 0, upd: 0;
       c2GhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshiftL_info" {
     GHC.Word.$fBitsWord64_$cshiftL_info:
         const GHC.Word.$fBitsWord64_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GhE() //  [R1]
         { []
         }
     {offset
       c2GhE: // global
           I64[Sp] = block_c2GhK_info;
           _s2DQs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQs::I64;
           if (R1 & 7 != 0) goto u2Gi5; else goto c2GhO;
       u2Gi5: // global
           call _c2GhK(R1) args: 0, res: 0, upd: 0;
       c2GhO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GhE_info" {
     block_c2GhE_info:
         const _c2GhE;
         const 1;
         const 30;
 },
 _c2GhK() //  [R1]
         { []
         }
     {offset
       c2GhK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GhU; else goto c2GhT;
       c2GhU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GhT: // global
           _s2DQu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQu::I64, 64)) goto c2Gi3; else goto c2Gi4;
       c2Gi3: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s2DQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gi4: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GhK_info" {
     block_c2GhK_info:
         const _c2GhK;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.027674161 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cisSigned_closure" {
     GHC.Word.$fBitsWord64_$cisSigned_closure:
         const GHC.Word.$fBitsWord64_$cisSigned_info;
 },
 GHC.Word.$fBitsWord64_$cisSigned_entry() //  []
         { []
         }
     {offset
       c2Giu: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cisSigned_info" {
     GHC.Word.$fBitsWord64_$cisSigned_info:
         const GHC.Word.$fBitsWord64_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.03242306 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotate_closure" {
     GHC.Word.$fBitsWord64_$crotate_closure:
         const GHC.Word.$fBitsWord64_$crotate_info;
 },
 GHC.Word.$fBitsWord64_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GiK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GiO; else goto c2GiP;
       c2GiO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GiP: // global
           I64[Sp - 16] = block_c2GiH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gjz; else goto c2GiI;
       u2Gjz: // global
           call _c2GiH(R1) args: 0, res: 0, upd: 0;
       c2GiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotate_info" {
     GHC.Word.$fBitsWord64_$crotate_info:
         const GHC.Word.$fBitsWord64_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GiH() //  [R1]
         { []
         }
     {offset
       c2GiH: // global
           I64[Sp - 8] = block_c2GiN_info;
           _s2DQA::P64 = R1;
           _s2DQB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DQB::I64;
           P64[Sp + 8] = _s2DQA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gjy; else goto c2GiR;
       u2Gjy: // global
           call _c2GiN(R1) args: 0, res: 0, upd: 0;
       c2GiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GiH_info" {
     block_c2GiH_info:
         const _c2GiH;
         const 1;
         const 30;
 },
 _c2GiN() //  [R1]
         { []
         }
     {offset
       c2GiN: // global
           _s2DQG::I64 = I64[R1 + 7] & 63;
           if (_s2DQG::I64 != 0) goto u2Gjw; else goto c2Gjs;
       u2Gjw: // global
           I64[Sp + 16] = _s2DQG::I64;
           Sp = Sp + 8;
           call _c2Gj6() args: 0, res: 0, upd: 0;
       c2Gjs: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GiN_info" {
     block_c2GiN_info:
         const _c2GiN;
         const 66;
         const 30;
 },
 _c2Gj6() //  []
         { []
         }
     {offset
       c2Gj6: // global
           Hp = Hp + 16;
           _s2DQG::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2Gjp; else goto c2Gjo;
       c2Gjp: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Gj5_info;
           R1 = _s2DQG::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2Gjo: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2DQB::I64 = I64[Sp];
           I64[Hp] = (_s2DQB::I64 << _s2DQG::I64) | (_s2DQB::I64 >> 64 - _s2DQG::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gj5() //  [R1]
         { []
         }
     {offset
       c2Gj5: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Gj6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2Gj5_info" {
     block_c2Gj5_info:
         const _c2Gj5;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.043915296 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cshift_closure" {
     GHC.Word.$fBitsWord64_$cshift_closure:
         const GHC.Word.$fBitsWord64_$cshift_info;
 },
 GHC.Word.$fBitsWord64_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gki; else goto c2Gkj;
       c2Gki: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gkj: // global
           I64[Sp - 16] = block_c2Gkb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GkX; else goto c2Gkc;
       u2GkX: // global
           call _c2Gkb(R1) args: 0, res: 0, upd: 0;
       c2Gkc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cshift_info" {
     GHC.Word.$fBitsWord64_$cshift_info:
         const GHC.Word.$fBitsWord64_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gkb() //  [R1]
         { []
         }
     {offset
       c2Gkb: // global
           I64[Sp] = block_c2Gkh_info;
           _s2DQO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DQO::I64;
           if (R1 & 7 != 0) goto u2GkW; else goto c2Gkl;
       u2GkW: // global
           call _c2Gkh(R1) args: 0, res: 0, upd: 0;
       c2Gkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gkb_info" {
     block_c2Gkb_info:
         const _c2Gkb;
         const 1;
         const 30;
 },
 _c2Gkh() //  [R1]
         { []
         }
     {offset
       c2Gkh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gkr; else goto c2Gkq;
       c2Gkr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gkq: // global
           _s2DQO::I64 = I64[Sp + 8];
           _s2DQQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DQQ::I64, 0)) goto c2GkJ; else goto c2GkV;
       c2GkJ: // global
           _s2DQS::I64 = -_s2DQQ::I64;
           if (%MO_S_Ge_W64(_s2DQS::I64, 64)) goto c2GkU; else goto c2GkG;
       c2GkG: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQO::I64 >> _s2DQS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GkV: // global
           if (%MO_S_Ge_W64(_s2DQQ::I64, 64)) goto c2GkU; else goto c2GkT;
       c2GkU: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GkT: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DQO::I64 << _s2DQQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gkh_info" {
     block_c2Gkh_info:
         const _c2Gkh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.052196448 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cxor_closure" {
     GHC.Word.$fBitsWord64_$cxor_closure:
         const GHC.Word.$fBitsWord64_$cxor_info;
 },
 GHC.Word.$fBitsWord64_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Glr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GlD; else goto c2GlE;
       c2GlD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GlE: // global
           I64[Sp - 16] = block_c2Glo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GlK; else goto c2Glp;
       u2GlK: // global
           call _c2Glo(R1) args: 0, res: 0, upd: 0;
       c2Glp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cxor_info" {
     GHC.Word.$fBitsWord64_$cxor_info:
         const GHC.Word.$fBitsWord64_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Glo() //  [R1]
         { []
         }
     {offset
       c2Glo: // global
           I64[Sp] = block_c2Glu_info;
           _s2DR0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DR0::I64;
           if (R1 & 7 != 0) goto u2GlJ; else goto c2Glv;
       u2GlJ: // global
           call _c2Glu(R1) args: 0, res: 0, upd: 0;
       c2Glv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Glo_info" {
     block_c2Glo_info:
         const _c2Glo;
         const 1;
         const 30;
 },
 _c2Glu() //  [R1]
         { []
         }
     {offset
       c2Glu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GlI; else goto c2GlH;
       c2GlI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GlH: // global
           _s2DR3::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DR3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Glu_info" {
     block_c2Glu_info:
         const _c2Glu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.060414933 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.|._closure" {
     GHC.Word.$fBitsWord64_$c.|._closure:
         const GHC.Word.$fBitsWord64_$c.|._info;
 },
 GHC.Word.$fBitsWord64_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gmn; else goto c2Gmo;
       c2Gmn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gmo: // global
           I64[Sp - 16] = block_c2Gm8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gmu; else goto c2Gm9;
       u2Gmu: // global
           call _c2Gm8(R1) args: 0, res: 0, upd: 0;
       c2Gm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$c.|._info" {
     GHC.Word.$fBitsWord64_$c.|._info:
         const GHC.Word.$fBitsWord64_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gm8() //  [R1]
         { []
         }
     {offset
       c2Gm8: // global
           I64[Sp] = block_c2Gme_info;
           _s2DR7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DR7::I64;
           if (R1 & 7 != 0) goto u2Gmt; else goto c2Gmf;
       u2Gmt: // global
           call _c2Gme(R1) args: 0, res: 0, upd: 0;
       c2Gmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gm8_info" {
     block_c2Gm8_info:
         const _c2Gm8;
         const 1;
         const 30;
 },
 _c2Gme() //  [R1]
         { []
         }
     {offset
       c2Gme: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gms; else goto c2Gmr;
       c2Gms: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gmr: // global
           _s2DRa::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DRa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gme_info" {
     block_c2Gme_info:
         const _c2Gme;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.068353892 UTC

[section ""data" . GHC.Word.$fBitsWord64_$c.&._closure" {
     GHC.Word.$fBitsWord64_$c.&._closure:
         const GHC.Word.$fBitsWord64_$c.&._info;
 },
 GHC.Word.$fBitsWord64_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c2GmV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gn7; else goto c2Gn8;
       c2Gn7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gn8: // global
           I64[Sp - 16] = block_c2GmS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gne; else goto c2GmT;
       u2Gne: // global
           call _c2GmS(R1) args: 0, res: 0, upd: 0;
       c2GmT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$c.&._info" {
     GHC.Word.$fBitsWord64_$c.&._info:
         const GHC.Word.$fBitsWord64_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GmS() //  [R1]
         { []
         }
     {offset
       c2GmS: // global
           I64[Sp] = block_c2GmY_info;
           _s2DRe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRe::I64;
           if (R1 & 7 != 0) goto u2Gnd; else goto c2GmZ;
       u2Gnd: // global
           call _c2GmY(R1) args: 0, res: 0, upd: 0;
       c2GmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GmS_info" {
     block_c2GmS_info:
         const _c2GmS;
         const 1;
         const 30;
 },
 _c2GmY() //  [R1]
         { []
         }
     {offset
       c2GmY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gnc; else goto c2Gnb;
       c2Gnc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gnb: // global
           _s2DRh::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2DRh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GmY_info" {
     block_c2GmY_info:
         const _c2GmY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.075685226 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2GnF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GnQ; else goto c2GnR;
       c2GnQ: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GnR: // global
           I64[Sp - 8] = block_c2GnC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GnV; else goto c2GnD;
       u2GnV: // global
           call _c2GnC(R1) args: 0, res: 0, upd: 0;
       c2GnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info" {
     GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_info:
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GnC() //  [R1]
         { []
         }
     {offset
       c2GnC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GnU; else goto c2GnT;
       c2GnU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GnT: // global
           (_c2GnI::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2GnI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GnC_info" {
     block_c2GnC_info:
         const _c2GnC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.081707242 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info;
 },
 GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c2Goh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gos; else goto c2Got;
       c2Gos: // global
           R2 = R2;
           R1 = GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Got: // global
           I64[Sp - 8] = block_c2Goe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gox; else goto c2Gof;
       u2Gox: // global
           call _c2Goe(R1) args: 0, res: 0, upd: 0;
       c2Gof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info" {
     GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_info:
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Goe() //  [R1]
         { []
         }
     {offset
       c2Goe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gow; else goto c2Gov;
       c2Gow: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gov: // global
           (_c2Gok::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c2Gok::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Goe_info" {
     block_c2Goe_info:
         const _c2Goe;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.086668466 UTC

[section ""data" . GHC.Word.$fBitsWord5_closure" {
     GHC.Word.$fBitsWord5_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.088590166 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cfiniteBitSize_closure" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_closure:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_info;
 },
 GHC.Word.$fBitsWord64_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c2GoR: // global
           R1 = GHC.Word.$fBitsWord5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cfiniteBitSize_info" {
     GHC.Word.$fBitsWord64_$cfiniteBitSize_info:
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.092566062 UTC

[section ""data" . GHC.Word.eqWord8_closure" {
     GHC.Word.eqWord8_closure:
         const GHC.Word.eqWord8_info;
 },
 GHC.Word.eqWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Gp6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gpa; else goto c2Gpb;
       c2Gpa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gpb: // global
           I64[Sp - 16] = block_c2Gp3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gpk; else goto c2Gp4;
       u2Gpk: // global
           call _c2Gp3(R1) args: 0, res: 0, upd: 0;
       c2Gp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord8_info" {
     GHC.Word.eqWord8_info:
         const GHC.Word.eqWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Gp3() //  [R1]
         { []
         }
     {offset
       c2Gp3: // global
           I64[Sp] = block_c2Gp9_info;
           _s2DRw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRw::I64;
           if (R1 & 7 != 0) goto u2Gpj; else goto c2Gpd;
       u2Gpj: // global
           call _c2Gp9(R1) args: 0, res: 0, upd: 0;
       c2Gpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gp3_info" {
     block_c2Gp3_info:
         const _c2Gp3;
         const 1;
         const 30;
 },
 _c2Gp9() //  [R1]
         { []
         }
     {offset
       c2Gp9: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gp9_info" {
     block_c2Gp9_info:
         const _c2Gp9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.099686422 UTC

[section ""data" . GHC.Word.$fEqWord8_closure" {
     GHC.Word.$fEqWord8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord8_closure+2;
         const GHC.Word.neWord8_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.101413027 UTC

[section ""data" . GHC.Word.$fNumWord4_closure" {
     GHC.Word.$fNumWord4_closure:
         const GHC.Word.W8#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.103994254 UTC

[section ""data" . GHC.Word.$fNumWord8_$csignum_closure" {
     GHC.Word.$fNumWord8_$csignum_closure:
         const GHC.Word.$fNumWord8_$csignum_info;
 },
 GHC.Word.$fNumWord8_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2GpO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GpP; else goto c2GpQ;
       c2GpP: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GpQ: // global
           I64[Sp - 8] = block_c2GpL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GpY; else goto c2GpM;
       u2GpY: // global
           call _c2GpL(R1) args: 0, res: 0, upd: 0;
       c2GpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord8_$csignum_info" {
     GHC.Word.$fNumWord8_$csignum_info:
         const GHC.Word.$fNumWord8_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GpL() //  [R1]
         { []
         }
     {offset
       c2GpL: // global
           if (I64[R1 + 7] == 0) goto c2GpX; else goto c2GpW;
       c2GpX: // global
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GpW: // global
           R1 = GHC.Word.$fNumWord4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GpL_info" {
     block_c2GpL_info:
         const _c2GpL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.108994328 UTC

[section ""data" . GHC.Word.$fNumWord8_closure" {
     GHC.Word.$fNumWord8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord8_$c+_closure+2;
         const GHC.Word.$fNumWord8_$c-_closure+2;
         const GHC.Word.$fNumWord8_$c*_closure+2;
         const GHC.Word.$fNumWord8_$cnegate_closure+1;
         const GHC.Word.$fNumWord8_$cabs_closure+1;
         const GHC.Word.$fNumWord8_$csignum_closure+1;
         const GHC.Word.$fNumWord8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.112094293 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplement_closure" {
     GHC.Word.$fBitsWord8_$ccomplement_closure:
         const GHC.Word.$fBitsWord8_$ccomplement_info;
 },
 GHC.Word.$fBitsWord8_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2Gqj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gqq; else goto c2Gqr;
       c2Gqq: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gqr: // global
           I64[Sp - 8] = block_c2Gqg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gqv; else goto c2Gqh;
       u2Gqv: // global
           call _c2Gqg(R1) args: 0, res: 0, upd: 0;
       c2Gqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ccomplement_info" {
     GHC.Word.$fBitsWord8_$ccomplement_info:
         const GHC.Word.$fBitsWord8_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Gqg() //  [R1]
         { []
         }
     {offset
       c2Gqg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gqu; else goto c2Gqt;
       c2Gqu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gqt: // global
           _s2DRH::I64 = I64[R1 + 7] ^ 255;
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DRH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gqg_info" {
     block_c2Gqg_info:
         const _c2Gqg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.117054044 UTC

[section ""data" . GHC.Word.$fBitsWord10_closure" {
     GHC.Word.$fBitsWord10_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord9_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.119283353 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2GqO: // global
           R1 = GHC.Word.$fBitsWord10_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord8_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.123527404 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cbit_closure" {
     GHC.Word.$fBitsWord8_$cbit_closure:
         const GHC.Word.$fBitsWord8_$cbit_info;
 },
 GHC.Word.$fBitsWord8_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2Gr3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Gr4; else goto c2Gr5;
       c2Gr4: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Gr5: // global
           I64[Sp - 8] = block_c2Gr0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gro; else goto c2Gr1;
       u2Gro: // global
           call _c2Gr0(R1) args: 0, res: 0, upd: 0;
       c2Gr1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cbit_info" {
     GHC.Word.$fBitsWord8_$cbit_info:
         const GHC.Word.$fBitsWord8_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Gr0() //  [R1]
         { []
         }
     {offset
       c2Gr0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gra; else goto c2Gr9;
       c2Gra: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gr9: // global
           _s2DRL::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DRL::I64, 64)) goto c2Grm; else goto c2Grn;
       c2Grm: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DRL::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Grn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord8_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gr0_info" {
     block_c2Gr0_info:
         const _c2Gr0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.130889645 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ctestBit_closure" {
     GHC.Word.$fBitsWord8_$ctestBit_closure:
         const GHC.Word.$fBitsWord8_$ctestBit_info;
 },
 GHC.Word.$fBitsWord8_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GrQ; else goto c2GrR;
       c2GrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GrR: // global
           I64[Sp - 16] = block_c2GrJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gsq; else goto c2GrK;
       u2Gsq: // global
           call _c2GrJ(R1) args: 0, res: 0, upd: 0;
       c2GrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ctestBit_info" {
     GHC.Word.$fBitsWord8_$ctestBit_info:
         const GHC.Word.$fBitsWord8_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GrJ() //  [R1]
         { []
         }
     {offset
       c2GrJ: // global
           I64[Sp] = block_c2GrP_info;
           _s2DRS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DRS::I64;
           if (R1 & 7 != 0) goto u2Gsp; else goto c2GrT;
       u2Gsp: // global
           call _c2GrP(R1) args: 0, res: 0, upd: 0;
       c2GrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GrJ_info" {
     block_c2GrJ_info:
         const _c2GrJ;
         const 1;
         const 30;
 },
 _c2GrP() //  [R1]
         { []
         }
     {offset
       c2GrP: // global
           _s2DRU::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DRU::I64, 64)) goto c2Gso; else goto c2Gsn;
       c2Gsn: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DRU::I64)) == 0) goto c2Gso; else goto c2Gsc;
       c2Gso: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gsc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GrP_info" {
     block_c2GrP_info:
         const _c2GrP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.139664225 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateR_closure" {
     GHC.Word.$fBitsWord8_$crotateR_closure:
         const GHC.Word.$fBitsWord8_$crotateR_info;
 },
 GHC.Word.$fBitsWord8_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GsW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Gt0; else goto c2Gt1;
       c2Gt0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gt1: // global
           I64[Sp - 16] = block_c2GsT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GtR; else goto c2GsU;
       u2GtR: // global
           call _c2GsT(R1) args: 0, res: 0, upd: 0;
       c2GsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotateR_info" {
     GHC.Word.$fBitsWord8_$crotateR_info:
         const GHC.Word.$fBitsWord8_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GsT() //  [R1]
         { []
         }
     {offset
       c2GsT: // global
           I64[Sp - 8] = block_c2GsZ_info;
           _s2DS1::P64 = R1;
           _s2DS2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DS2::I64;
           P64[Sp + 8] = _s2DS1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GtQ; else goto c2Gt3;
       u2GtQ: // global
           call _c2GsZ(R1) args: 0, res: 0, upd: 0;
       c2Gt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GsT_info" {
     block_c2GsT_info:
         const _c2GsT;
         const 1;
         const 30;
 },
 _c2GsZ() //  [R1]
         { []
         }
     {offset
       c2GsZ: // global
           _s2DS8::I64 = -I64[R1 + 7] & 7;
           if (_s2DS8::I64 != 0) goto u2GtO; else goto c2GtK;
       u2GtO: // global
           I64[Sp + 16] = _s2DS8::I64;
           Sp = Sp + 8;
           call _c2Gtl() args: 0, res: 0, upd: 0;
       c2GtK: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GsZ_info" {
     block_c2GsZ_info:
         const _c2GsZ;
         const 66;
         const 30;
 },
 _c2Gtl() //  []
         { []
         }
     {offset
       c2Gtl: // global
           Hp = Hp + 16;
           _s2DS8::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2GtH; else goto c2GtG;
       c2GtH: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Gtk_info;
           R1 = _s2DS8::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2GtG: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           _s2DS2::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8((_s2DS2::I64 << _s2DS8::I64) | (_s2DS2::I64 >> 8 - _s2DS8::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Gtk() //  [R1]
         { []
         }
     {offset
       c2Gtk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Gtl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2Gtk_info" {
     block_c2Gtk_info:
         const _c2Gtk;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.148914354 UTC

[section ""data" . GHC.Word.$fBitsWord8_$crotateL_closure" {
     GHC.Word.$fBitsWord8_$crotateL_closure:
         const GHC.Word.$fBitsWord8_$crotateL_info;
 },
 GHC.Word.$fBitsWord8_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Guu: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord8_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$crotateL_info" {
     GHC.Word.$fBitsWord8_$crotateL_info:
         const GHC.Word.$fBitsWord8_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.153741123 UTC

[section ""data" . GHC.Word.$fBitsWord8_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord8_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord8_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord8_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GuI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GuM; else goto c2GuN;
       c2GuM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GuN: // global
           I64[Sp - 16] = block_c2GuF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gvd; else goto c2GuG;
       u2Gvd: // global
           call _c2GuF(R1) args: 0, res: 0, upd: 0;
       c2GuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$ccomplementBit_info" {
     GHC.Word.$fBitsWord8_$ccomplementBit_info:
         const GHC.Word.$fBitsWord8_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GuF() //  [R1]
         { []
         }
     {offset
       c2GuF: // global
           I64[Sp - 8] = block_c2GuL_info;
           _s2DSg::P64 = R1;
           _s2DSh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DSh::I64;
           P64[Sp + 8] = _s2DSg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gvc; else goto c2GuP;
       u2Gvc: // global
           call _c2GuL(R1) args: 0, res: 0, upd: 0;
       c2GuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GuF_info" {
     block_c2GuF_info:
         const _c2GuF;
         const 1;
         const 30;
 },
 _c2GuL() //  [R1]
         { []
         }
     {offset
       c2GuL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GuV; else goto c2GuU;
       c2GuV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GuU: // global
           _s2DSj::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSj::I64, 64)) goto c2Gva; else goto c2Gvb;
       c2Gva: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSj::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gvb: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GuL_info" {
     block_c2GuL_info:
         const _c2GuL;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.162170612 UTC

[section ""data" . GHC.Word.$fBitsWord8_$cclearBit_closure" {
     GHC.Word.$fBitsWord8_$cclearBit_closure:
         const GHC.Word.$fBitsWord8_$cclearBit_info;
 },
 GHC.Word.$fBitsWord8_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GvN; else goto c2GvO;
       c2GvN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GvO: // global
           I64[Sp - 16] = block_c2GvG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gwm; else goto c2GvH;
       u2Gwm: // global
           call _c2GvG(R1) args: 0, res: 0, upd: 0;
       c2GvH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$cclearBit_info" {
     GHC.Word.$fBitsWord8_$cclearBit_info:
         const GHC.Word.$fBitsWord8_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GvG() //  [R1]
         { []
         }
     {offset
       c2GvG: // global
           I64[Sp] = block_c2GvM_info;
           _s2DSr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSr::I64;
           if (R1 & 7 != 0) goto u2Gwl; else goto c2GvQ;
       u2Gwl: // global
           call _c2GvM(R1) args: 0, res: 0, upd: 0;
       c2GvQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GvG_info" {
     block_c2GvG_info:
         const _c2GvG;
         const 1;
         const 30;
 },
 _c2GvM() //  [R1]
         { []
         }
     {offset
       c2GvM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GvW; else goto c2GvV;
       c2GvW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GvV: // global
           _s2DSr::I64 = I64[Sp + 8];
           _s2DSt::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSt::I64, 64)) goto c2Gwe; else goto c2Gwk;
       c2Gwe: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DSr::I64 & %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSt::I64)) ^ 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gwk: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DSr::I64 & 255;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GvM_info" {
     block_c2GvM_info:
         const _c2GvM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.171056858 UTC

[section ""data" . GHC.Word.$fBitsWord8_$csetBit_closure" {
     GHC.Word.$fBitsWord8_$csetBit_closure:
         const GHC.Word.$fBitsWord8_$csetBit_info;
 },
 GHC.Word.$fBitsWord8_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GwV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GwZ; else goto c2Gx0;
       c2GwZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gx0: // global
           I64[Sp - 16] = block_c2GwS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gxq; else goto c2GwT;
       u2Gxq: // global
           call _c2GwS(R1) args: 0, res: 0, upd: 0;
       c2GwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord8_$csetBit_info" {
     GHC.Word.$fBitsWord8_$csetBit_info:
         const GHC.Word.$fBitsWord8_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GwS() //  [R1]
         { []
         }
     {offset
       c2GwS: // global
           I64[Sp - 8] = block_c2GwY_info;
           _s2DSC::P64 = R1;
           _s2DSD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DSD::I64;
           P64[Sp + 8] = _s2DSC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Gxp; else goto c2Gx2;
       u2Gxp: // global
           call _c2GwY(R1) args: 0, res: 0, upd: 0;
       c2Gx2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GwS_info" {
     block_c2GwS_info:
         const _c2GwS;
         const 1;
         const 30;
 },
 _c2GwY() //  [R1]
         { []
         }
     {offset
       c2GwY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gx8; else goto c2Gx7;
       c2Gx8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gx7: // global
           _s2DSF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DSF::I64, 64)) goto c2Gxn; else goto c2Gxo;
       c2Gxn: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(1 << _s2DSF::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gxo: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GwY_info" {
     block_c2GwY_info:
         const _c2GwY;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.178408919 UTC

[section ""data" . GHC.Word.$fBitsWord8_closure" {
     GHC.Word.$fBitsWord8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fBitsWord8_$c.&._closure+2;
         const GHC.Word.$fBitsWord8_$c.|._closure+2;
         const GHC.Word.$fBitsWord8_$cxor_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord8_$cshift_closure+2;
         const GHC.Word.$fBitsWord8_$crotate_closure+2;
         const GHC.Word.$fBitsWord8_$cminBound_closure+1;
         const GHC.Word.$fBitsWord8_$cbit_closure+1;
         const GHC.Word.$fBitsWord8_$csetBit_closure+2;
         const GHC.Word.$fBitsWord8_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord8_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord8_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord8_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord8_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord8_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord8_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord8_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord8_$crotateL_closure+2;
         const GHC.Word.$fBitsWord8_$crotateR_closure+2;
         const GHC.Word.$fBitsWord8_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.180414375 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord8_closure" {
     GHC.Word.$fFiniteBitsWord8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord8_closure+1;
         const GHC.Word.$fBitsWord8_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.183963066 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquot_closure" {
     GHC.Word.$fIntegralWord8_$cquot_closure:
         const GHC.Word.$fIntegralWord8_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GxY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Gy2; else goto c2Gy3;
       c2Gy2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Gy3: // global
           I64[Sp - 16] = block_c2GxV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gym; else goto c2GxW;
       u2Gym: // global
           call _c2GxV(R1) args: 0, res: 0, upd: 0;
       c2GxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cquot_info" {
     GHC.Word.$fIntegralWord8_$cquot_info:
         const GHC.Word.$fIntegralWord8_$cquot_entry;
         const 0;
         const 2251804108652558;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2GxV() //  [R1]
         { []
         }
     {offset
       c2GxV: // global
           I64[Sp] = block_c2Gy1_info;
           _s2DSN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSN::I64;
           if (R1 & 7 != 0) goto u2Gyl; else goto c2Gy5;
       u2Gyl: // global
           call _c2Gy1(R1) args: 0, res: 0, upd: 0;
       c2Gy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GxV_info" {
     block_c2GxV_info:
         const _c2GxV;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2Gy1() //  [R1]
         { []
         }
     {offset
       c2Gy1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Gyb; else goto c2Gya;
       c2Gyb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Gya: // global
           _s2DSQ::I64 = I64[R1 + 7];
           if (_s2DSQ::I64 != 0) goto c2Gyj; else goto c2Gyk;
       c2Gyj: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DSQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gyk: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gy1_info" {
     block_c2Gy1_info:
         const _c2Gy1;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.192182889 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$crem_closure" {
     GHC.Word.$fIntegralWord8_$crem_closure:
         const GHC.Word.$fIntegralWord8_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GyM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GyQ; else goto c2GyR;
       c2GyQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GyR: // global
           I64[Sp - 16] = block_c2GyJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Gza; else goto c2GyK;
       u2Gza: // global
           call _c2GyJ(R1) args: 0, res: 0, upd: 0;
       c2GyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$crem_info" {
     GHC.Word.$fIntegralWord8_$crem_info:
         const GHC.Word.$fIntegralWord8_$crem_entry;
         const 0;
         const 4503603922337806;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2GyJ() //  [R1]
         { []
         }
     {offset
       c2GyJ: // global
           I64[Sp] = block_c2GyP_info;
           _s2DSV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DSV::I64;
           if (R1 & 7 != 0) goto u2Gz9; else goto c2GyT;
       u2Gz9: // global
           call _c2GyP(R1) args: 0, res: 0, upd: 0;
       c2GyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GyJ_info" {
     block_c2GyJ_info:
         const _c2GyJ;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2GyP() //  [R1]
         { []
         }
     {offset
       c2GyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GyZ; else goto c2GyY;
       c2GyZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GyY: // global
           _s2DSY::I64 = I64[R1 + 7];
           if (_s2DSY::I64 != 0) goto c2Gz7; else goto c2Gz8;
       c2Gz7: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DSY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Gz8: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GyP_info" {
     block_c2GyP_info:
         const _c2GyP;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.200619558 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cquotRem_closure" {
     GHC.Word.$fIntegralWord8_$cquotRem_closure:
         const GHC.Word.$fIntegralWord8_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord8_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GzE; else goto c2GzF;
       c2GzE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GzF: // global
           I64[Sp - 16] = block_c2Gzx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GzX; else goto c2Gzy;
       u2GzX: // global
           call _c2Gzx(R1) args: 0, res: 0, upd: 0;
       c2Gzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cquotRem_info" {
     GHC.Word.$fIntegralWord8_$cquotRem_info:
         const GHC.Word.$fIntegralWord8_$cquotRem_entry;
         const 0;
         const 9007203549708302;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2Gzx() //  [R1]
         { []
         }
     {offset
       c2Gzx: // global
           I64[Sp] = block_c2GzD_info;
           _s2DT3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DT3::I64;
           if (R1 & 7 != 0) goto u2GzW; else goto c2GzH;
       u2GzW: // global
           call _c2GzD(R1) args: 0, res: 0, upd: 0;
       c2GzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Gzx_info" {
     block_c2Gzx_info:
         const _c2Gzx;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2GzD() //  [R1]
         { []
         }
     {offset
       c2GzD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2GzN; else goto c2GzM;
       c2GzN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GzM: // global
           _s2DT6::I64 = I64[R1 + 7];
           if (_s2DT6::I64 != 0) goto c2GzU; else goto c2GzV;
       c2GzU: // global
           (_s2DT8::I64, _s2DT9::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DT6::I64);
           I64[Hp - 48] = GHC.Word.W8#_con_info;
           I64[Hp - 40] = _s2DT9::I64;
           I64[Hp - 32] = GHC.Word.W8#_con_info;
           I64[Hp - 24] = _s2DT8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GzV: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GzD_info" {
     block_c2GzD_info:
         const _c2GzD;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.210827808 UTC

[section ""data" . GHC.Word.$fIntegralWord8_$cdivMod_closure" {
     GHC.Word.$fIntegralWord8_$cdivMod_closure:
         const GHC.Word.$fIntegralWord8_$cdivMod_info;
         const 0;
 },
 sat_s2DTm_entry() //  [R1]
         { []
         }
     {offset
       c2GAF: // global
           _s2DTm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2GAI; else goto c2GAJ;
       c2GAJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GAL; else goto c2GAK;
       c2GAL: // global
           HpAlloc = 16;
           goto c2GAI;
       c2GAI: // global
           R1 = _s2DTm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2GAK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DTm::P64;
           _s2DTl::I64 = I64[_s2DTm::P64 + 16] % I64[_s2DTm::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DTl::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DTm_info" {
     sat_s2DTm_info:
         const sat_s2DTm_entry;
         const 8589934592;
         const 20;
 },
 sat_s2DTk_entry() //  [R1]
         { []
         }
     {offset
       c2GAS: // global
           _s2DTk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2GAV; else goto c2GAW;
       c2GAW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GAY; else goto c2GAX;
       c2GAY: // global
           HpAlloc = 16;
           goto c2GAV;
       c2GAV: // global
           R1 = _s2DTk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2GAX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DTk::P64;
           _s2DTj::I64 = I64[_s2DTk::P64 + 16] / I64[_s2DTk::P64 + 24];
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s2DTj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DTk_info" {
     sat_s2DTk_info:
         const sat_s2DTk_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord8_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GB0; else goto c2GB1;
       c2GB0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GB1: // global
           I64[Sp - 16] = block_c2GAn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GBb; else goto c2GAo;
       u2GBb: // global
           call _c2GAn(R1) args: 0, res: 0, upd: 0;
       c2GAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord8_$cdivMod_info" {
     GHC.Word.$fIntegralWord8_$cdivMod_info:
         const GHC.Word.$fIntegralWord8_$cdivMod_entry;
         const 0;
         const 18014402804449294;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2GAn() //  [R1]
         { []
         }
     {offset
       c2GAn: // global
           I64[Sp] = block_c2GAs_info;
           _s2DTf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTf::I64;
           if (R1 & 7 != 0) goto u2GBa; else goto c2GAt;
       u2GBa: // global
           call _c2GAs(R1) args: 0, res: 0, upd: 0;
       c2GAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GAn_info" {
     block_c2GAn_info:
         const _c2GAn;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2GAs() //  [R1]
         { []
         }
     {offset
       c2GAs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2GB5; else goto c2GB4;
       c2GB5: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GB4: // global
           _s2DTi::I64 = I64[R1 + 7];
           if (_s2DTi::I64 != 0) goto c2GB8; else goto c2GB9;
       c2GB8: // global
           I64[Hp - 80] = sat_s2DTm_info;
           _s2DTf::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DTf::I64;
           I64[Hp - 56] = _s2DTi::I64;
           I64[Hp - 48] = sat_s2DTk_info;
           I64[Hp - 32] = _s2DTf::I64;
           I64[Hp - 24] = _s2DTi::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GB9: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GAs_info" {
     block_c2GAs_info:
         const _c2GAs;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.223001059 UTC

[section ""data" . GHC.Word.gtWord8_closure" {
     GHC.Word.gtWord8_closure:
         const GHC.Word.gtWord8_info;
 },
 GHC.Word.gtWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GBS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GBW; else goto c2GBX;
       c2GBW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GBX: // global
           I64[Sp - 16] = block_c2GBP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GC6; else goto c2GBQ;
       u2GC6: // global
           call _c2GBP(R1) args: 0, res: 0, upd: 0;
       c2GBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord8_info" {
     GHC.Word.gtWord8_info:
         const GHC.Word.gtWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GBP() //  [R1]
         { []
         }
     {offset
       c2GBP: // global
           I64[Sp] = block_c2GBV_info;
           _s2DTq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTq::I64;
           if (R1 & 7 != 0) goto u2GC5; else goto c2GBZ;
       u2GC5: // global
           call _c2GBV(R1) args: 0, res: 0, upd: 0;
       c2GBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GBP_info" {
     block_c2GBP_info:
         const _c2GBP;
         const 1;
         const 30;
 },
 _c2GBV() //  [R1]
         { []
         }
     {offset
       c2GBV: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GBV_info" {
     block_c2GBV_info:
         const _c2GBV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.230565391 UTC

[section ""data" . GHC.Word.geWord8_closure" {
     GHC.Word.geWord8_closure:
         const GHC.Word.geWord8_info;
 },
 GHC.Word.geWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GCy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GCC; else goto c2GCD;
       c2GCC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GCD: // global
           I64[Sp - 16] = block_c2GCv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GCM; else goto c2GCw;
       u2GCM: // global
           call _c2GCv(R1) args: 0, res: 0, upd: 0;
       c2GCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord8_info" {
     GHC.Word.geWord8_info:
         const GHC.Word.geWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GCv() //  [R1]
         { []
         }
     {offset
       c2GCv: // global
           I64[Sp] = block_c2GCB_info;
           _s2DTx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTx::I64;
           if (R1 & 7 != 0) goto u2GCL; else goto c2GCF;
       u2GCL: // global
           call _c2GCB(R1) args: 0, res: 0, upd: 0;
       c2GCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GCv_info" {
     block_c2GCv_info:
         const _c2GCv;
         const 1;
         const 30;
 },
 _c2GCB() //  [R1]
         { []
         }
     {offset
       c2GCB: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GCB_info" {
     block_c2GCB_info:
         const _c2GCB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.237931934 UTC

[section ""data" . GHC.Word.ltWord8_closure" {
     GHC.Word.ltWord8_closure:
         const GHC.Word.ltWord8_info;
 },
 GHC.Word.ltWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GDe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GDi; else goto c2GDj;
       c2GDi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GDj: // global
           I64[Sp - 16] = block_c2GDb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GDs; else goto c2GDc;
       u2GDs: // global
           call _c2GDb(R1) args: 0, res: 0, upd: 0;
       c2GDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord8_info" {
     GHC.Word.ltWord8_info:
         const GHC.Word.ltWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GDb() //  [R1]
         { []
         }
     {offset
       c2GDb: // global
           I64[Sp] = block_c2GDh_info;
           _s2DTE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTE::I64;
           if (R1 & 7 != 0) goto u2GDr; else goto c2GDl;
       u2GDr: // global
           call _c2GDh(R1) args: 0, res: 0, upd: 0;
       c2GDl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GDb_info" {
     block_c2GDb_info:
         const _c2GDb;
         const 1;
         const 30;
 },
 _c2GDh() //  [R1]
         { []
         }
     {offset
       c2GDh: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GDh_info" {
     block_c2GDh_info:
         const _c2GDh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.246463694 UTC

[section ""data" . GHC.Word.leWord8_closure" {
     GHC.Word.leWord8_closure:
         const GHC.Word.leWord8_info;
 },
 GHC.Word.leWord8_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GDU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GDY; else goto c2GDZ;
       c2GDY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GDZ: // global
           I64[Sp - 16] = block_c2GDR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GE8; else goto c2GDS;
       u2GE8: // global
           call _c2GDR(R1) args: 0, res: 0, upd: 0;
       c2GDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord8_info" {
     GHC.Word.leWord8_info:
         const GHC.Word.leWord8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GDR() //  [R1]
         { []
         }
     {offset
       c2GDR: // global
           I64[Sp] = block_c2GDX_info;
           _s2DTL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTL::I64;
           if (R1 & 7 != 0) goto u2GE7; else goto c2GE1;
       u2GE7: // global
           call _c2GDX(R1) args: 0, res: 0, upd: 0;
       c2GE1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GDR_info" {
     block_c2GDR_info:
         const _c2GDR;
         const 1;
         const 30;
 },
 _c2GDX() //  [R1]
         { []
         }
     {offset
       c2GDX: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GDX_info" {
     block_c2GDX_info:
         const _c2GDX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.254190232 UTC

[section ""data" . GHC.Word.$fOrdWord8_$ccompare_closure" {
     GHC.Word.$fOrdWord8_$ccompare_closure:
         const GHC.Word.$fOrdWord8_$ccompare_info;
 },
 GHC.Word.$fOrdWord8_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GEA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GEE; else goto c2GEF;
       c2GEE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GEF: // global
           I64[Sp - 16] = block_c2GEx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GEY; else goto c2GEy;
       u2GEY: // global
           call _c2GEx(R1) args: 0, res: 0, upd: 0;
       c2GEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$ccompare_info" {
     GHC.Word.$fOrdWord8_$ccompare_info:
         const GHC.Word.$fOrdWord8_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GEx() //  [R1]
         { []
         }
     {offset
       c2GEx: // global
           I64[Sp] = block_c2GED_info;
           _s2DTS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DTS::I64;
           if (R1 & 7 != 0) goto u2GEX; else goto c2GEH;
       u2GEX: // global
           call _c2GED(R1) args: 0, res: 0, upd: 0;
       c2GEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GEx_info" {
     block_c2GEx_info:
         const _c2GEx;
         const 1;
         const 30;
 },
 _c2GED() //  [R1]
         { []
         }
     {offset
       c2GED: // global
           _s2DTS::I64 = I64[Sp + 8];
           _s2DTU::I64 = I64[R1 + 7];
           if (_s2DTS::I64 == _s2DTU::I64) goto c2GEW; else goto c2GEV;
       c2GEW: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GEV: // global
           if (_s2DTS::I64 > _s2DTU::I64) goto c2GES; else goto c2GET;
       c2GES: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GET: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GED_info" {
     block_c2GED_info:
         const _c2GED;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.261941642 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmax_closure" {
     GHC.Word.$fOrdWord8_$cmax_closure:
         const GHC.Word.$fOrdWord8_$cmax_info;
 },
 GHC.Word.$fOrdWord8_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GFr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GFv; else goto c2GFw;
       c2GFv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GFw: // global
           I64[Sp - 16] = block_c2GFo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GFJ; else goto c2GFp;
       u2GFJ: // global
           call _c2GFo(R1) args: 0, res: 0, upd: 0;
       c2GFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$cmax_info" {
     GHC.Word.$fOrdWord8_$cmax_info:
         const GHC.Word.$fOrdWord8_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GFo() //  [R1]
         { []
         }
     {offset
       c2GFo: // global
           I64[Sp - 8] = block_c2GFu_info;
           _s2DTZ::P64 = R1;
           _s2DU0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DU0::I64;
           P64[Sp + 8] = _s2DTZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GFI; else goto c2GFy;
       u2GFI: // global
           call _c2GFu(R1) args: 0, res: 0, upd: 0;
       c2GFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GFo_info" {
     block_c2GFo_info:
         const _c2GFo;
         const 1;
         const 30;
 },
 _c2GFu() //  [R1]
         { []
         }
     {offset
       c2GFu: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2GFG; else goto c2GFH;
       c2GFG: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GFH: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GFu_info" {
     block_c2GFu_info:
         const _c2GFu;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.269892305 UTC

[section ""data" . GHC.Word.$fOrdWord8_$cmin_closure" {
     GHC.Word.$fOrdWord8_$cmin_closure:
         const GHC.Word.$fOrdWord8_$cmin_info;
 },
 GHC.Word.$fOrdWord8_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GGb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GGf; else goto c2GGg;
       c2GGf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GGg: // global
           I64[Sp - 16] = block_c2GG8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GGt; else goto c2GG9;
       u2GGt: // global
           call _c2GG8(R1) args: 0, res: 0, upd: 0;
       c2GG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord8_$cmin_info" {
     GHC.Word.$fOrdWord8_$cmin_info:
         const GHC.Word.$fOrdWord8_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GG8() //  [R1]
         { []
         }
     {offset
       c2GG8: // global
           I64[Sp - 8] = block_c2GGe_info;
           _s2DU6::P64 = R1;
           _s2DU7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DU7::I64;
           P64[Sp + 8] = _s2DU6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GGs; else goto c2GGi;
       u2GGs: // global
           call _c2GGe(R1) args: 0, res: 0, upd: 0;
       c2GGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GG8_info" {
     block_c2GG8_info:
         const _c2GG8;
         const 1;
         const 30;
 },
 _c2GGe() //  [R1]
         { []
         }
     {offset
       c2GGe: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2GGq; else goto c2GGr;
       c2GGq: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GGr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GGe_info" {
     block_c2GGe_info:
         const _c2GGe;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.276386078 UTC

[section ""data" . GHC.Word.$fOrdWord8_closure" {
     GHC.Word.$fOrdWord8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord8_closure+1;
         const GHC.Word.$fOrdWord8_$ccompare_closure+2;
         const GHC.Word.ltWord8_closure+2;
         const GHC.Word.leWord8_closure+2;
         const GHC.Word.gtWord8_closure+2;
         const GHC.Word.geWord8_closure+2;
         const GHC.Word.$fOrdWord8_$cmax_closure+2;
         const GHC.Word.$fOrdWord8_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.280066951 UTC

[section ""data" . GHC.Word.$fIxWord8_$cinRange_closure" {
     GHC.Word.$fIxWord8_$cinRange_closure:
         const GHC.Word.$fIxWord8_$cinRange_info;
 },
 GHC.Word.$fIxWord8_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GGW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GH5; else goto c2GH6;
       c2GH5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GH6: // global
           I64[Sp - 16] = block_c2GGT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GHt; else goto c2GGU;
       u2GHt: // global
           call _c2GGT(R1) args: 0, res: 0, upd: 0;
       c2GGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cinRange_info" {
     GHC.Word.$fIxWord8_$cinRange_info:
         const GHC.Word.$fIxWord8_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GGT() //  [R1]
         { []
         }
     {offset
       c2GGT: // global
           I64[Sp - 8] = block_c2GGZ_info;
           _s2DUf::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DUf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GHs; else goto c2GH0;
       u2GHs: // global
           call _c2GGZ(R1) args: 0, res: 0, upd: 0;
       c2GH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GGT_info" {
     block_c2GGT_info:
         const _c2GGT;
         const 1;
         const 30;
 },
 _c2GGZ() //  [R1]
         { []
         }
     {offset
       c2GGZ: // global
           I64[Sp] = block_c2GH4_info;
           _s2DUh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DUh::I64;
           if (R1 & 7 != 0) goto u2GHu; else goto c2GH9;
       u2GHu: // global
           call _c2GH4(R1) args: 0, res: 0, upd: 0;
       c2GH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GGZ_info" {
     block_c2GGZ_info:
         const _c2GGZ;
         const 2;
         const 30;
 },
 _c2GH4() //  [R1]
         { []
         }
     {offset
       c2GH4: // global
           _s2DUj::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DUj::I64) goto c2GHh; else goto c2GHl;
       c2GHh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GHl: // global
           _s2DUf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2GHk_info;
           R1 = _s2DUf::P64;
           I64[Sp + 16] = _s2DUj::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2GHv; else goto c2GHm;
       u2GHv: // global
           call _c2GHk(R1) args: 0, res: 0, upd: 0;
       c2GHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GH4_info" {
     block_c2GH4_info:
         const _c2GH4;
         const 130;
         const 30;
 },
 _c2GHk() //  [R1]
         { []
         }
     {offset
       c2GHk: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GHk_info" {
     block_c2GHk_info:
         const _c2GHk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.291961813 UTC

[section ""data" . GHC.Word.$fRealWord8_$ctoRational_closure" {
     GHC.Word.$fRealWord8_$ctoRational_closure:
         const GHC.Word.$fRealWord8_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord8_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2GI9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GIq; else goto c2GIr;
       c2GIq: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GIr: // global
           I64[Sp - 8] = block_c2GI6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GIy; else goto c2GI7;
       u2GIy: // global
           call _c2GI6(R1) args: 0, res: 0, upd: 0;
       c2GI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord8_$ctoRational_info" {
     GHC.Word.$fRealWord8_$ctoRational_info:
         const GHC.Word.$fRealWord8_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S2Ecg_srt+728;
 },
 _c2GI6() //  [R1]
         { []
         }
     {offset
       c2GI6: // global
           I64[Sp] = block_c2GIf_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GI6_info" {
     block_c2GI6_info:
         const _c2GI6;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2GIf() //  [R1]
         { []
         }
     {offset
       c2GIf: // global
           I64[Sp] = block_c2GIj_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GIf_info" {
     block_c2GIf_info:
         const _c2GIf;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2GIj() //  [R1]
         { []
         }
     {offset
       c2GIj: // global
           I64[Sp] = block_c2GIn_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GIj_info" {
     block_c2GIj_info:
         const _c2GIj;
         const 0;
         const 12884901918;
         const S2Ecg_srt+736;
 },
 _c2GIn() //  [R1, R2]
         { []
         }
     {offset
       c2GIn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2GIx; else goto c2GIw;
       c2GIx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2GIw: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GIn_info" {
     block_c2GIn_info:
         const _c2GIn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.301495608 UTC

[section ""data" . GHC.Word.$fRealWord8_closure" {
     GHC.Word.$fRealWord8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord8_closure+1;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fRealWord8_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.303288111 UTC

[section ""data" . GHC.Word.$fIntegralWord8_closure" {
     GHC.Word.$fIntegralWord8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord8_closure+1;
         const GHC.Word.$fEnumWord8_closure+1;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquot_closure+2;
         const GHC.Word.$fIntegralWord8_$crem_closure+2;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.306885977 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord8_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord8_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord8_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GJt; else goto c2GJu;
       c2GJt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GJu: // global
           I64[Sp - 16] = block_c2GJ3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GJB; else goto c2GJ4;
       u2GJB: // global
           call _c2GJ3(R1) args: 0, res: 0, upd: 0;
       c2GJ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cunsafeIndex_info" {
     GHC.Word.$fIxWord8_$cunsafeIndex_info:
         const GHC.Word.$fIxWord8_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GJ3() //  [R1]
         { []
         }
     {offset
       c2GJ3: // global
           I64[Sp] = block_c2GJ9_info;
           _s2DUA::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2DUA::P64;
           if (R1 & 7 != 0) goto u2GJA; else goto c2GJa;
       u2GJA: // global
           call _c2GJ9(R1) args: 0, res: 0, upd: 0;
       c2GJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GJ3_info" {
     block_c2GJ3_info:
         const _c2GJ3;
         const 1;
         const 30;
 },
 _c2GJ9() //  [R1]
         { []
         }
     {offset
       c2GJ9: // global
           I64[Sp] = block_c2GJe_info;
           _s2DUD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DUD::I64;
           if (R1 & 7 != 0) goto u2GJC; else goto c2GJf;
       u2GJC: // global
           call _c2GJe(R1) args: 0, res: 0, upd: 0;
       c2GJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GJ9_info" {
     block_c2GJ9_info:
         const _c2GJ9;
         const 1;
         const 30;
 },
 _c2GJe() //  [R1]
         { []
         }
     {offset
       c2GJe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GJz; else goto c2GJy;
       c2GJz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GJy: // global
           _s2DUI::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DUI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GJe_info" {
     block_c2GJe_info:
         const _c2GJe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.316063073 UTC

[section ""data" . GHC.Word.$fIxWord8_$crange_closure" {
     GHC.Word.$fIxWord8_$crange_closure:
         const GHC.Word.$fIxWord8_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2GK9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GKa; else goto c2GKb;
       c2GKa: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GKb: // global
           I64[Sp - 8] = block_c2GK6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GKf; else goto c2GK7;
       u2GKf: // global
           call _c2GK6(R1) args: 0, res: 0, upd: 0;
       c2GK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$crange_info" {
     GHC.Word.$fIxWord8_$crange_info:
         const GHC.Word.$fIxWord8_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+760;
 },
 _c2GK6() //  [R1]
         { []
         }
     {offset
       c2GK6: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord8_$cenumFromTo_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GK6_info" {
     block_c2GK6_info:
         const _c2GK6;
         const 0;
         const 4294967326;
         const S2Ecg_srt+768;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.321464909 UTC

[section ""data" . GHC.Word.$fIxWord1_closure" {
     GHC.Word.$fIxWord1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.324844465 UTC

[section ""data" . GHC.Word.$fIxWord8_$crangeSize_closure" {
     GHC.Word.$fIxWord8_$crangeSize_closure:
         const GHC.Word.$fIxWord8_$crangeSize_info;
 },
 GHC.Word.$fIxWord8_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2GKy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GKH; else goto c2GKI;
       c2GKH: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GKI: // global
           I64[Sp - 8] = block_c2GKv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GLd; else goto c2GKw;
       u2GLd: // global
           call _c2GKv(R1) args: 0, res: 0, upd: 0;
       c2GKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$crangeSize_info" {
     GHC.Word.$fIxWord8_$crangeSize_info:
         const GHC.Word.$fIxWord8_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GKv() //  [R1]
         { []
         }
     {offset
       c2GKv: // global
           I64[Sp - 8] = block_c2GKB_info;
           _s2DUQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DUQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GLc; else goto c2GKC;
       u2GLc: // global
           call _c2GKB(R1) args: 0, res: 0, upd: 0;
       c2GKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GKv_info" {
     block_c2GKv_info:
         const _c2GKv;
         const 0;
         const 30;
 },
 _c2GKB() //  [R1]
         { []
         }
     {offset
       c2GKB: // global
           I64[Sp] = block_c2GKG_info;
           _s2DUS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DUS::I64;
           if (R1 & 7 != 0) goto u2GLe; else goto c2GKL;
       u2GLe: // global
           call _c2GKG(R1) args: 0, res: 0, upd: 0;
       c2GKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GKB_info" {
     block_c2GKB_info:
         const _c2GKB;
         const 1;
         const 30;
 },
 _c2GKG() //  [R1]
         { []
         }
     {offset
       c2GKG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GKR; else goto c2GKQ;
       c2GKR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GKQ: // global
           _s2DUS::I64 = I64[Sp + 8];
           _s2DUU::I64 = I64[R1 + 7];
           if (_s2DUS::I64 > _s2DUU::I64) goto c2GKV; else goto c2GLb;
       c2GKV: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GLb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DUU::I64 - _s2DUS::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GKG_info" {
     block_c2GKG_info:
         const _c2GKG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.334917756 UTC

[section ""data" . GHC.Word.$fIxWord8_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord8_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2GLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GMd; else goto c2GMe;
       c2GMd: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GMe: // global
           I64[Sp - 8] = block_c2GLK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GMl; else goto c2GLL;
       u2GMl: // global
           call _c2GLK(R1) args: 0, res: 0, upd: 0;
       c2GLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord8_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GLK() //  [R1]
         { []
         }
     {offset
       c2GLK: // global
           I64[Sp - 8] = block_c2GLQ_info;
           _s2DV2::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2DV2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GMk; else goto c2GLR;
       u2GMk: // global
           call _c2GLQ(R1) args: 0, res: 0, upd: 0;
       c2GLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GLK_info" {
     block_c2GLK_info:
         const _c2GLK;
         const 0;
         const 30;
 },
 _c2GLQ() //  [R1]
         { []
         }
     {offset
       c2GLQ: // global
           I64[Sp] = block_c2GLV_info;
           _s2DV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DV5::I64;
           if (R1 & 7 != 0) goto u2GMm; else goto c2GLW;
       u2GMm: // global
           call _c2GLV(R1) args: 0, res: 0, upd: 0;
       c2GLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GLQ_info" {
     block_c2GLQ_info:
         const _c2GLQ;
         const 1;
         const 30;
 },
 _c2GLV() //  [R1]
         { []
         }
     {offset
       c2GLV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GMj; else goto c2GMi;
       c2GMj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GMi: // global
           _s2DVb::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DVb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GLV_info" {
     block_c2GLV_info:
         const _c2GLV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.345641677 UTC

[section ""data" . GHC.Word.$fIxWord8_$cindex_closure" {
     GHC.Word.$fIxWord8_$cindex_closure:
         const GHC.Word.$fIxWord8_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord8_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GMU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GN3; else goto c2GN4;
       c2GN3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GN4: // global
           I64[Sp - 16] = block_c2GMR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GNJ; else goto c2GMS;
       u2GNJ: // global
           call _c2GMR(R1) args: 0, res: 0, upd: 0;
       c2GMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord8_$cindex_info" {
     GHC.Word.$fIxWord8_$cindex_info:
         const GHC.Word.$fIxWord8_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+776;
 },
 _c2GMR() //  [R1]
         { []
         }
     {offset
       c2GMR: // global
           I64[Sp - 8] = block_c2GMX_info;
           _s2DVg::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DVg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GNI; else goto c2GMY;
       u2GNI: // global
           call _c2GMX(R1) args: 0, res: 0, upd: 0;
       c2GMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GMR_info" {
     block_c2GMR_info:
         const _c2GMR;
         const 1;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2GMX() //  [R1]
         { []
         }
     {offset
       c2GMX: // global
           I64[Sp] = block_c2GN2_info;
           _s2DVi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DVi::I64;
           if (R1 & 7 != 0) goto u2GNK; else goto c2GN7;
       u2GNK: // global
           call _c2GN2(R1) args: 0, res: 0, upd: 0;
       c2GN7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GMX_info" {
     block_c2GMX_info:
         const _c2GMX;
         const 2;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2GN2() //  [R1]
         { []
         }
     {offset
       c2GN2: // global
           _s2DVk::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DVk::I64) goto c2GNf; else goto c2GNj;
       c2GNf: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GNj: // global
           I64[Sp] = block_c2GNi_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVk::I64;
           if (R1 & 7 != 0) goto u2GNL; else goto c2GNk;
       u2GNL: // global
           call _c2GNi(R1) args: 0, res: 0, upd: 0;
       c2GNk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GN2_info" {
     block_c2GN2_info:
         const _c2GN2;
         const 130;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2GNi() //  [R1]
         { []
         }
     {offset
       c2GNi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GNq; else goto c2GNp;
       c2GNq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GNp: // global
           _s2DVk::I64 = I64[Sp + 8];
           if (_s2DVk::I64 > I64[R1 + 7]) goto c2GNu; else goto c2GNH;
       c2GNu: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2GNH: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s2DVk::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GNi_info" {
     block_c2GNi_info:
         const _c2GNi;
         const 194;
         const 4294967326;
         const S2Ecg_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.356235422 UTC

[section ""data" . GHC.Word.$fIxWord8_closure" {
     GHC.Word.$fIxWord8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord8_closure+1;
         const GHC.Word.$fIxWord8_$crange_closure+1;
         const GHC.Word.$fIxWord8_$cindex_closure+2;
         const GHC.Word.$fIxWord8_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord8_$cinRange_closure+2;
         const GHC.Word.$fIxWord8_$crangeSize_closure+1;
         const GHC.Word.$fIxWord8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.359282734 UTC

[section ""data" . GHC.Word.eqWord16_closure" {
     GHC.Word.eqWord16_closure:
         const GHC.Word.eqWord16_info;
 },
 GHC.Word.eqWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GOq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GOu; else goto c2GOv;
       c2GOu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GOv: // global
           I64[Sp - 16] = block_c2GOn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GOE; else goto c2GOo;
       u2GOE: // global
           call _c2GOn(R1) args: 0, res: 0, upd: 0;
       c2GOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord16_info" {
     GHC.Word.eqWord16_info:
         const GHC.Word.eqWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GOn() //  [R1]
         { []
         }
     {offset
       c2GOn: // global
           I64[Sp] = block_c2GOt_info;
           _s2DVv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVv::I64;
           if (R1 & 7 != 0) goto u2GOD; else goto c2GOx;
       u2GOD: // global
           call _c2GOt(R1) args: 0, res: 0, upd: 0;
       c2GOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GOn_info" {
     block_c2GOn_info:
         const _c2GOn;
         const 1;
         const 30;
 },
 _c2GOt() //  [R1]
         { []
         }
     {offset
       c2GOt: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GOt_info" {
     block_c2GOt_info:
         const _c2GOt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.365631082 UTC

[section ""data" . GHC.Word.$fEqWord16_closure" {
     GHC.Word.$fEqWord16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord16_closure+2;
         const GHC.Word.neWord16_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.367309161 UTC

[section ""data" . GHC.Word.$fNumWord1_closure" {
     GHC.Word.$fNumWord1_closure:
         const GHC.Word.W16#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.37050312 UTC

[section ""data" . GHC.Word.$fNumWord16_$csignum_closure" {
     GHC.Word.$fNumWord16_$csignum_closure:
         const GHC.Word.$fNumWord16_$csignum_info;
 },
 GHC.Word.$fNumWord16_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2GP8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GP9; else goto c2GPa;
       c2GP9: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GPa: // global
           I64[Sp - 8] = block_c2GP5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GPi; else goto c2GP6;
       u2GPi: // global
           call _c2GP5(R1) args: 0, res: 0, upd: 0;
       c2GP6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord16_$csignum_info" {
     GHC.Word.$fNumWord16_$csignum_info:
         const GHC.Word.$fNumWord16_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GP5() //  [R1]
         { []
         }
     {offset
       c2GP5: // global
           if (I64[R1 + 7] == 0) goto c2GPh; else goto c2GPg;
       c2GPh: // global
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GPg: // global
           R1 = GHC.Word.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GP5_info" {
     block_c2GP5_info:
         const _c2GP5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.375439902 UTC

[section ""data" . GHC.Word.$fNumWord16_closure" {
     GHC.Word.$fNumWord16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord16_$c+_closure+2;
         const GHC.Word.$fNumWord16_$c-_closure+2;
         const GHC.Word.$fNumWord16_$c*_closure+2;
         const GHC.Word.$fNumWord16_$cnegate_closure+1;
         const GHC.Word.$fNumWord16_$cabs_closure+1;
         const GHC.Word.$fNumWord16_$csignum_closure+1;
         const GHC.Word.$fNumWord16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.378213811 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplement_closure" {
     GHC.Word.$fBitsWord16_$ccomplement_closure:
         const GHC.Word.$fBitsWord16_$ccomplement_info;
 },
 GHC.Word.$fBitsWord16_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2GPD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GPK; else goto c2GPL;
       c2GPK: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GPL: // global
           I64[Sp - 8] = block_c2GPA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GPP; else goto c2GPB;
       u2GPP: // global
           call _c2GPA(R1) args: 0, res: 0, upd: 0;
       c2GPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ccomplement_info" {
     GHC.Word.$fBitsWord16_$ccomplement_info:
         const GHC.Word.$fBitsWord16_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GPA() //  [R1]
         { []
         }
     {offset
       c2GPA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GPO; else goto c2GPN;
       c2GPO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GPN: // global
           _s2DVG::I64 = I64[R1 + 7] ^ 65535;
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DVG::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GPA_info" {
     block_c2GPA_info:
         const _c2GPA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.38334844 UTC

[section ""data" . GHC.Word.$fBitsWord2_closure" {
     GHC.Word.$fBitsWord2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.385522479 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2GQ8: // global
           R1 = GHC.Word.$fBitsWord2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord16_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.390374949 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cbit_closure" {
     GHC.Word.$fBitsWord16_$cbit_closure:
         const GHC.Word.$fBitsWord16_$cbit_info;
 },
 GHC.Word.$fBitsWord16_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2GQn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2GQo; else goto c2GQp;
       c2GQo: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2GQp: // global
           I64[Sp - 8] = block_c2GQk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GQI; else goto c2GQl;
       u2GQI: // global
           call _c2GQk(R1) args: 0, res: 0, upd: 0;
       c2GQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cbit_info" {
     GHC.Word.$fBitsWord16_$cbit_info:
         const GHC.Word.$fBitsWord16_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2GQk() //  [R1]
         { []
         }
     {offset
       c2GQk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GQu; else goto c2GQt;
       c2GQu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GQt: // global
           _s2DVK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DVK::I64, 64)) goto c2GQG; else goto c2GQH;
       c2GQG: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DVK::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GQH: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord16_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GQk_info" {
     block_c2GQk_info:
         const _c2GQk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.397712491 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ctestBit_closure" {
     GHC.Word.$fBitsWord16_$ctestBit_closure:
         const GHC.Word.$fBitsWord16_$ctestBit_info;
 },
 GHC.Word.$fBitsWord16_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GRa; else goto c2GRb;
       c2GRa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GRb: // global
           I64[Sp - 16] = block_c2GR3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GRK; else goto c2GR4;
       u2GRK: // global
           call _c2GR3(R1) args: 0, res: 0, upd: 0;
       c2GR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ctestBit_info" {
     GHC.Word.$fBitsWord16_$ctestBit_info:
         const GHC.Word.$fBitsWord16_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GR3() //  [R1]
         { []
         }
     {offset
       c2GR3: // global
           I64[Sp] = block_c2GR9_info;
           _s2DVR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DVR::I64;
           if (R1 & 7 != 0) goto u2GRJ; else goto c2GRd;
       u2GRJ: // global
           call _c2GR9(R1) args: 0, res: 0, upd: 0;
       c2GRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GR3_info" {
     block_c2GR3_info:
         const _c2GR3;
         const 1;
         const 30;
 },
 _c2GR9() //  [R1]
         { []
         }
     {offset
       c2GR9: // global
           _s2DVT::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DVT::I64, 64)) goto c2GRI; else goto c2GRH;
       c2GRH: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DVT::I64)) == 0) goto c2GRI; else goto c2GRw;
       c2GRI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GRw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GR9_info" {
     block_c2GR9_info:
         const _c2GR9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.406717526 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateR_closure" {
     GHC.Word.$fBitsWord16_$crotateR_closure:
         const GHC.Word.$fBitsWord16_$crotateR_info;
 },
 GHC.Word.$fBitsWord16_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GSg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GSk; else goto c2GSl;
       c2GSk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GSl: // global
           I64[Sp - 16] = block_c2GSd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GTb; else goto c2GSe;
       u2GTb: // global
           call _c2GSd(R1) args: 0, res: 0, upd: 0;
       c2GSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotateR_info" {
     GHC.Word.$fBitsWord16_$crotateR_info:
         const GHC.Word.$fBitsWord16_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GSd() //  [R1]
         { []
         }
     {offset
       c2GSd: // global
           I64[Sp - 8] = block_c2GSj_info;
           _s2DW0::P64 = R1;
           _s2DW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DW1::I64;
           P64[Sp + 8] = _s2DW0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GTa; else goto c2GSn;
       u2GTa: // global
           call _c2GSj(R1) args: 0, res: 0, upd: 0;
       c2GSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GSd_info" {
     block_c2GSd_info:
         const _c2GSd;
         const 1;
         const 30;
 },
 _c2GSj() //  [R1]
         { []
         }
     {offset
       c2GSj: // global
           _s2DW7::I64 = -I64[R1 + 7] & 15;
           if (_s2DW7::I64 != 0) goto u2GT8; else goto c2GT4;
       u2GT8: // global
           I64[Sp + 16] = _s2DW7::I64;
           Sp = Sp + 8;
           call _c2GSF() args: 0, res: 0, upd: 0;
       c2GT4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GSj_info" {
     block_c2GSj_info:
         const _c2GSj;
         const 66;
         const 30;
 },
 _c2GSF() //  []
         { []
         }
     {offset
       c2GSF: // global
           Hp = Hp + 16;
           _s2DW7::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2GT1; else goto c2GT0;
       c2GT1: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2GSE_info;
           R1 = _s2DW7::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2GT0: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           _s2DW1::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16((_s2DW1::I64 << _s2DW7::I64) | (_s2DW1::I64 >> 16 - _s2DW7::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2GSE() //  [R1]
         { []
         }
     {offset
       c2GSE: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2GSF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2GSE_info" {
     block_c2GSE_info:
         const _c2GSE;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.416386239 UTC

[section ""data" . GHC.Word.$fBitsWord16_$crotateL_closure" {
     GHC.Word.$fBitsWord16_$crotateL_closure:
         const GHC.Word.$fBitsWord16_$crotateL_info;
 },
 GHC.Word.$fBitsWord16_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GTO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord16_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$crotateL_info" {
     GHC.Word.$fBitsWord16_$crotateL_info:
         const GHC.Word.$fBitsWord16_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.421018834 UTC

[section ""data" . GHC.Word.$fBitsWord16_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord16_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord16_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord16_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GU2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GU6; else goto c2GU7;
       c2GU6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GU7: // global
           I64[Sp - 16] = block_c2GTZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GUx; else goto c2GU0;
       u2GUx: // global
           call _c2GTZ(R1) args: 0, res: 0, upd: 0;
       c2GU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$ccomplementBit_info" {
     GHC.Word.$fBitsWord16_$ccomplementBit_info:
         const GHC.Word.$fBitsWord16_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GTZ() //  [R1]
         { []
         }
     {offset
       c2GTZ: // global
           I64[Sp - 8] = block_c2GU5_info;
           _s2DWf::P64 = R1;
           _s2DWg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DWg::I64;
           P64[Sp + 8] = _s2DWf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GUw; else goto c2GU9;
       u2GUw: // global
           call _c2GU5(R1) args: 0, res: 0, upd: 0;
       c2GU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GTZ_info" {
     block_c2GTZ_info:
         const _c2GTZ;
         const 1;
         const 30;
 },
 _c2GU5() //  [R1]
         { []
         }
     {offset
       c2GU5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GUf; else goto c2GUe;
       c2GUf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GUe: // global
           _s2DWi::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWi::I64, 64)) goto c2GUu; else goto c2GUv;
       c2GUu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWi::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GUv: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GU5_info" {
     block_c2GU5_info:
         const _c2GU5;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.430207852 UTC

[section ""data" . GHC.Word.$fBitsWord16_$cclearBit_closure" {
     GHC.Word.$fBitsWord16_$cclearBit_closure:
         const GHC.Word.$fBitsWord16_$cclearBit_info;
 },
 GHC.Word.$fBitsWord16_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GV7; else goto c2GV8;
       c2GV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GV8: // global
           I64[Sp - 16] = block_c2GV0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GVG; else goto c2GV1;
       u2GVG: // global
           call _c2GV0(R1) args: 0, res: 0, upd: 0;
       c2GV1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$cclearBit_info" {
     GHC.Word.$fBitsWord16_$cclearBit_info:
         const GHC.Word.$fBitsWord16_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GV0() //  [R1]
         { []
         }
     {offset
       c2GV0: // global
           I64[Sp] = block_c2GV6_info;
           _s2DWq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWq::I64;
           if (R1 & 7 != 0) goto u2GVF; else goto c2GVa;
       u2GVF: // global
           call _c2GV6(R1) args: 0, res: 0, upd: 0;
       c2GVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GV0_info" {
     block_c2GV0_info:
         const _c2GV0;
         const 1;
         const 30;
 },
 _c2GV6() //  [R1]
         { []
         }
     {offset
       c2GV6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GVg; else goto c2GVf;
       c2GVg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GVf: // global
           _s2DWq::I64 = I64[Sp + 8];
           _s2DWs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWs::I64, 64)) goto c2GVy; else goto c2GVE;
       c2GVy: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DWq::I64 & %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWs::I64)) ^ 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GVE: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DWq::I64 & 65535;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GV6_info" {
     block_c2GV6_info:
         const _c2GV6;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.438685984 UTC

[section ""data" . GHC.Word.$fBitsWord16_$csetBit_closure" {
     GHC.Word.$fBitsWord16_$csetBit_closure:
         const GHC.Word.$fBitsWord16_$csetBit_info;
 },
 GHC.Word.$fBitsWord16_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GWf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2GWj; else goto c2GWk;
       c2GWj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GWk: // global
           I64[Sp - 16] = block_c2GWc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GWK; else goto c2GWd;
       u2GWK: // global
           call _c2GWc(R1) args: 0, res: 0, upd: 0;
       c2GWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord16_$csetBit_info" {
     GHC.Word.$fBitsWord16_$csetBit_info:
         const GHC.Word.$fBitsWord16_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2GWc() //  [R1]
         { []
         }
     {offset
       c2GWc: // global
           I64[Sp - 8] = block_c2GWi_info;
           _s2DWB::P64 = R1;
           _s2DWC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DWC::I64;
           P64[Sp + 8] = _s2DWB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2GWJ; else goto c2GWm;
       u2GWJ: // global
           call _c2GWi(R1) args: 0, res: 0, upd: 0;
       c2GWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GWc_info" {
     block_c2GWc_info:
         const _c2GWc;
         const 1;
         const 30;
 },
 _c2GWi() //  [R1]
         { []
         }
     {offset
       c2GWi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GWs; else goto c2GWr;
       c2GWs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GWr: // global
           _s2DWE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DWE::I64, 64)) goto c2GWH; else goto c2GWI;
       c2GWH: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(1 << _s2DWE::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GWI: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GWi_info" {
     block_c2GWi_info:
         const _c2GWi;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.445859614 UTC

[section ""data" . GHC.Word.$fBitsWord16_closure" {
     GHC.Word.$fBitsWord16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fBitsWord16_$c.&._closure+2;
         const GHC.Word.$fBitsWord16_$c.|._closure+2;
         const GHC.Word.$fBitsWord16_$cxor_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord16_$cshift_closure+2;
         const GHC.Word.$fBitsWord16_$crotate_closure+2;
         const GHC.Word.$fBitsWord16_$cminBound_closure+1;
         const GHC.Word.$fBitsWord16_$cbit_closure+1;
         const GHC.Word.$fBitsWord16_$csetBit_closure+2;
         const GHC.Word.$fBitsWord16_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord16_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord16_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord16_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord16_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord16_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord16_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord16_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord16_$crotateL_closure+2;
         const GHC.Word.$fBitsWord16_$crotateR_closure+2;
         const GHC.Word.$fBitsWord16_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.447859981 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord16_closure" {
     GHC.Word.$fFiniteBitsWord16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord16_closure+1;
         const GHC.Word.$fBitsWord16_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.451214528 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquot_closure" {
     GHC.Word.$fIntegralWord16_$cquot_closure:
         const GHC.Word.$fIntegralWord16_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GXm; else goto c2GXn;
       c2GXm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GXn: // global
           I64[Sp - 16] = block_c2GXf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GXG; else goto c2GXg;
       u2GXG: // global
           call _c2GXf(R1) args: 0, res: 0, upd: 0;
       c2GXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cquot_info" {
     GHC.Word.$fIntegralWord16_$cquot_info:
         const GHC.Word.$fIntegralWord16_$cquot_entry;
         const 0;
         const 9223372041149743118;
         const 8589934607;
         const S2Ecg_srt+544;
 },
 _c2GXf() //  [R1]
         { []
         }
     {offset
       c2GXf: // global
           I64[Sp] = block_c2GXl_info;
           _s2DWM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWM::I64;
           if (R1 & 7 != 0) goto u2GXF; else goto c2GXp;
       u2GXF: // global
           call _c2GXl(R1) args: 0, res: 0, upd: 0;
       c2GXp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GXf_info" {
     block_c2GXf_info:
         const _c2GXf;
         const 1;
         const 4294967326;
         const S2Ecg_srt+544;
 },
 _c2GXl() //  [R1]
         { []
         }
     {offset
       c2GXl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GXv; else goto c2GXu;
       c2GXv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GXu: // global
           _s2DWP::I64 = I64[R1 + 7];
           if (_s2DWP::I64 != 0) goto c2GXD; else goto c2GXE;
       c2GXD: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2DWP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GXE: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GXl_info" {
     block_c2GXl_info:
         const _c2GXl;
         const 65;
         const 4294967326;
         const S2Ecg_srt+544;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.459910083 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$crem_closure" {
     GHC.Word.$fIntegralWord16_$crem_closure:
         const GHC.Word.$fIntegralWord16_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GY6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GYa; else goto c2GYb;
       c2GYa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GYb: // global
           I64[Sp - 16] = block_c2GY3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GYu; else goto c2GY4;
       u2GYu: // global
           call _c2GY3(R1) args: 0, res: 0, upd: 0;
       c2GY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$crem_info" {
     GHC.Word.$fIntegralWord16_$crem_info:
         const GHC.Word.$fIntegralWord16_$crem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+800;
 },
 _c2GY3() //  [R1]
         { []
         }
     {offset
       c2GY3: // global
           I64[Sp] = block_c2GY9_info;
           _s2DWU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DWU::I64;
           if (R1 & 7 != 0) goto u2GYt; else goto c2GYd;
       u2GYt: // global
           call _c2GY9(R1) args: 0, res: 0, upd: 0;
       c2GYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GY3_info" {
     block_c2GY3_info:
         const _c2GY3;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2GY9() //  [R1]
         { []
         }
     {offset
       c2GY9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2GYj; else goto c2GYi;
       c2GYj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GYi: // global
           _s2DWX::I64 = I64[R1 + 7];
           if (_s2DWX::I64 != 0) goto c2GYr; else goto c2GYs;
       c2GYr: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2DWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GYs: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GY9_info" {
     block_c2GY9_info:
         const _c2GY9;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.468242166 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cquotRem_closure" {
     GHC.Word.$fIntegralWord16_$cquotRem_closure:
         const GHC.Word.$fIntegralWord16_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord16_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2GYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2GYY; else goto c2GYZ;
       c2GYY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2GYZ: // global
           I64[Sp - 16] = block_c2GYR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2GZh; else goto c2GYS;
       u2GZh: // global
           call _c2GYR(R1) args: 0, res: 0, upd: 0;
       c2GYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cquotRem_info" {
     GHC.Word.$fIntegralWord16_$cquotRem_info:
         const GHC.Word.$fIntegralWord16_$cquotRem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2GYR() //  [R1]
         { []
         }
     {offset
       c2GYR: // global
           I64[Sp] = block_c2GYX_info;
           _s2DX2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DX2::I64;
           if (R1 & 7 != 0) goto u2GZg; else goto c2GZ1;
       u2GZg: // global
           call _c2GYX(R1) args: 0, res: 0, upd: 0;
       c2GZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GYR_info" {
     block_c2GYR_info:
         const _c2GYR;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2GYX() //  [R1]
         { []
         }
     {offset
       c2GYX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2GZ7; else goto c2GZ6;
       c2GZ7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2GZ6: // global
           _s2DX5::I64 = I64[R1 + 7];
           if (_s2DX5::I64 != 0) goto c2GZe; else goto c2GZf;
       c2GZe: // global
           (_s2DX7::I64, _s2DX8::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2DX5::I64);
           I64[Hp - 48] = GHC.Word.W16#_con_info;
           I64[Hp - 40] = _s2DX8::I64;
           I64[Hp - 32] = GHC.Word.W16#_con_info;
           I64[Hp - 24] = _s2DX7::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2GZf: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GYX_info" {
     block_c2GYX_info:
         const _c2GYX;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.478808511 UTC

[section ""data" . GHC.Word.$fIntegralWord16_$cdivMod_closure" {
     GHC.Word.$fIntegralWord16_$cdivMod_closure:
         const GHC.Word.$fIntegralWord16_$cdivMod_info;
         const 0;
 },
 sat_s2DXl_entry() //  [R1]
         { []
         }
     {offset
       c2GZZ: // global
           _s2DXl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2H02; else goto c2H03;
       c2H03: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H05; else goto c2H04;
       c2H05: // global
           HpAlloc = 16;
           goto c2H02;
       c2H02: // global
           R1 = _s2DXl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2H04: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DXl::P64;
           _s2DXk::I64 = I64[_s2DXl::P64 + 16] % I64[_s2DXl::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DXk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DXl_info" {
     sat_s2DXl_info:
         const sat_s2DXl_entry;
         const 8589934592;
         const 20;
 },
 sat_s2DXj_entry() //  [R1]
         { []
         }
     {offset
       c2H0c: // global
           _s2DXj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2H0f; else goto c2H0g;
       c2H0g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H0i; else goto c2H0h;
       c2H0i: // global
           HpAlloc = 16;
           goto c2H0f;
       c2H0f: // global
           R1 = _s2DXj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2H0h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2DXj::P64;
           _s2DXi::I64 = I64[_s2DXj::P64 + 16] / I64[_s2DXj::P64 + 24];
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s2DXi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2DXj_info" {
     sat_s2DXj_info:
         const sat_s2DXj_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord16_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H0j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H0k; else goto c2H0l;
       c2H0k: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H0l: // global
           I64[Sp - 16] = block_c2GZH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H0v; else goto c2GZI;
       u2H0v: // global
           call _c2GZH(R1) args: 0, res: 0, upd: 0;
       c2GZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord16_$cdivMod_info" {
     GHC.Word.$fIntegralWord16_$cdivMod_info:
         const GHC.Word.$fIntegralWord16_$cdivMod_entry;
         const 0;
         const 21474836494;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2GZH() //  [R1]
         { []
         }
     {offset
       c2GZH: // global
           I64[Sp] = block_c2GZM_info;
           _s2DXe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXe::I64;
           if (R1 & 7 != 0) goto u2H0u; else goto c2GZN;
       u2H0u: // global
           call _c2GZM(R1) args: 0, res: 0, upd: 0;
       c2GZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GZH_info" {
     block_c2GZH_info:
         const _c2GZH;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2GZM() //  [R1]
         { []
         }
     {offset
       c2GZM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2H0p; else goto c2H0o;
       c2H0p: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2H0o: // global
           _s2DXh::I64 = I64[R1 + 7];
           if (_s2DXh::I64 != 0) goto c2H0s; else goto c2H0t;
       c2H0s: // global
           I64[Hp - 80] = sat_s2DXl_info;
           _s2DXe::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2DXe::I64;
           I64[Hp - 56] = _s2DXh::I64;
           I64[Hp - 48] = sat_s2DXj_info;
           I64[Hp - 32] = _s2DXe::I64;
           I64[Hp - 24] = _s2DXh::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H0t: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2GZM_info" {
     block_c2GZM_info:
         const _c2GZM;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.491097579 UTC

[section ""data" . GHC.Word.gtWord16_closure" {
     GHC.Word.gtWord16_closure:
         const GHC.Word.gtWord16_info;
 },
 GHC.Word.gtWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H1c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H1g; else goto c2H1h;
       c2H1g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H1h: // global
           I64[Sp - 16] = block_c2H19_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H1q; else goto c2H1a;
       u2H1q: // global
           call _c2H19(R1) args: 0, res: 0, upd: 0;
       c2H1a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord16_info" {
     GHC.Word.gtWord16_info:
         const GHC.Word.gtWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H19() //  [R1]
         { []
         }
     {offset
       c2H19: // global
           I64[Sp] = block_c2H1f_info;
           _s2DXp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXp::I64;
           if (R1 & 7 != 0) goto u2H1p; else goto c2H1j;
       u2H1p: // global
           call _c2H1f(R1) args: 0, res: 0, upd: 0;
       c2H1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H19_info" {
     block_c2H19_info:
         const _c2H19;
         const 1;
         const 30;
 },
 _c2H1f() //  [R1]
         { []
         }
     {offset
       c2H1f: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H1f_info" {
     block_c2H1f_info:
         const _c2H1f;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.498701866 UTC

[section ""data" . GHC.Word.geWord16_closure" {
     GHC.Word.geWord16_closure:
         const GHC.Word.geWord16_info;
 },
 GHC.Word.geWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H1S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H1W; else goto c2H1X;
       c2H1W: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H1X: // global
           I64[Sp - 16] = block_c2H1P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H26; else goto c2H1Q;
       u2H26: // global
           call _c2H1P(R1) args: 0, res: 0, upd: 0;
       c2H1Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord16_info" {
     GHC.Word.geWord16_info:
         const GHC.Word.geWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H1P() //  [R1]
         { []
         }
     {offset
       c2H1P: // global
           I64[Sp] = block_c2H1V_info;
           _s2DXw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXw::I64;
           if (R1 & 7 != 0) goto u2H25; else goto c2H1Z;
       u2H25: // global
           call _c2H1V(R1) args: 0, res: 0, upd: 0;
       c2H1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H1P_info" {
     block_c2H1P_info:
         const _c2H1P;
         const 1;
         const 30;
 },
 _c2H1V() //  [R1]
         { []
         }
     {offset
       c2H1V: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H1V_info" {
     block_c2H1V_info:
         const _c2H1V;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.506394146 UTC

[section ""data" . GHC.Word.ltWord16_closure" {
     GHC.Word.ltWord16_closure:
         const GHC.Word.ltWord16_info;
 },
 GHC.Word.ltWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H2y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H2C; else goto c2H2D;
       c2H2C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H2D: // global
           I64[Sp - 16] = block_c2H2v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H2M; else goto c2H2w;
       u2H2M: // global
           call _c2H2v(R1) args: 0, res: 0, upd: 0;
       c2H2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord16_info" {
     GHC.Word.ltWord16_info:
         const GHC.Word.ltWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H2v() //  [R1]
         { []
         }
     {offset
       c2H2v: // global
           I64[Sp] = block_c2H2B_info;
           _s2DXD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXD::I64;
           if (R1 & 7 != 0) goto u2H2L; else goto c2H2F;
       u2H2L: // global
           call _c2H2B(R1) args: 0, res: 0, upd: 0;
       c2H2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H2v_info" {
     block_c2H2v_info:
         const _c2H2v;
         const 1;
         const 30;
 },
 _c2H2B() //  [R1]
         { []
         }
     {offset
       c2H2B: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H2B_info" {
     block_c2H2B_info:
         const _c2H2B;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.514851398 UTC

[section ""data" . GHC.Word.leWord16_closure" {
     GHC.Word.leWord16_closure:
         const GHC.Word.leWord16_info;
 },
 GHC.Word.leWord16_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H3i; else goto c2H3j;
       c2H3i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H3j: // global
           I64[Sp - 16] = block_c2H3b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H3s; else goto c2H3c;
       u2H3s: // global
           call _c2H3b(R1) args: 0, res: 0, upd: 0;
       c2H3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord16_info" {
     GHC.Word.leWord16_info:
         const GHC.Word.leWord16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H3b() //  [R1]
         { []
         }
     {offset
       c2H3b: // global
           I64[Sp] = block_c2H3h_info;
           _s2DXK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXK::I64;
           if (R1 & 7 != 0) goto u2H3r; else goto c2H3l;
       u2H3r: // global
           call _c2H3h(R1) args: 0, res: 0, upd: 0;
       c2H3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H3b_info" {
     block_c2H3b_info:
         const _c2H3b;
         const 1;
         const 30;
 },
 _c2H3h() //  [R1]
         { []
         }
     {offset
       c2H3h: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H3h_info" {
     block_c2H3h_info:
         const _c2H3h;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.522511329 UTC

[section ""data" . GHC.Word.$fOrdWord16_$ccompare_closure" {
     GHC.Word.$fOrdWord16_$ccompare_closure:
         const GHC.Word.$fOrdWord16_$ccompare_info;
 },
 GHC.Word.$fOrdWord16_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H3U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H3Y; else goto c2H3Z;
       c2H3Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H3Z: // global
           I64[Sp - 16] = block_c2H3R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H4i; else goto c2H3S;
       u2H4i: // global
           call _c2H3R(R1) args: 0, res: 0, upd: 0;
       c2H3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$ccompare_info" {
     GHC.Word.$fOrdWord16_$ccompare_info:
         const GHC.Word.$fOrdWord16_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H3R() //  [R1]
         { []
         }
     {offset
       c2H3R: // global
           I64[Sp] = block_c2H3X_info;
           _s2DXR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DXR::I64;
           if (R1 & 7 != 0) goto u2H4h; else goto c2H41;
       u2H4h: // global
           call _c2H3X(R1) args: 0, res: 0, upd: 0;
       c2H41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H3R_info" {
     block_c2H3R_info:
         const _c2H3R;
         const 1;
         const 30;
 },
 _c2H3X() //  [R1]
         { []
         }
     {offset
       c2H3X: // global
           _s2DXR::I64 = I64[Sp + 8];
           _s2DXT::I64 = I64[R1 + 7];
           if (_s2DXR::I64 == _s2DXT::I64) goto c2H4g; else goto c2H4f;
       c2H4g: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H4f: // global
           if (_s2DXR::I64 > _s2DXT::I64) goto c2H4c; else goto c2H4d;
       c2H4c: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H4d: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H3X_info" {
     block_c2H3X_info:
         const _c2H3X;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.530707432 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmax_closure" {
     GHC.Word.$fOrdWord16_$cmax_closure:
         const GHC.Word.$fOrdWord16_$cmax_info;
 },
 GHC.Word.$fOrdWord16_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H4L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H4P; else goto c2H4Q;
       c2H4P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H4Q: // global
           I64[Sp - 16] = block_c2H4I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H53; else goto c2H4J;
       u2H53: // global
           call _c2H4I(R1) args: 0, res: 0, upd: 0;
       c2H4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$cmax_info" {
     GHC.Word.$fOrdWord16_$cmax_info:
         const GHC.Word.$fOrdWord16_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H4I() //  [R1]
         { []
         }
     {offset
       c2H4I: // global
           I64[Sp - 8] = block_c2H4O_info;
           _s2DXY::P64 = R1;
           _s2DXZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DXZ::I64;
           P64[Sp + 8] = _s2DXY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H52; else goto c2H4S;
       u2H52: // global
           call _c2H4O(R1) args: 0, res: 0, upd: 0;
       c2H4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H4I_info" {
     block_c2H4I_info:
         const _c2H4I;
         const 1;
         const 30;
 },
 _c2H4O() //  [R1]
         { []
         }
     {offset
       c2H4O: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2H50; else goto c2H51;
       c2H50: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2H51: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H4O_info" {
     block_c2H4O_info:
         const _c2H4O;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.538908115 UTC

[section ""data" . GHC.Word.$fOrdWord16_$cmin_closure" {
     GHC.Word.$fOrdWord16_$cmin_closure:
         const GHC.Word.$fOrdWord16_$cmin_info;
 },
 GHC.Word.$fOrdWord16_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H5v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H5z; else goto c2H5A;
       c2H5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H5A: // global
           I64[Sp - 16] = block_c2H5s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H5N; else goto c2H5t;
       u2H5N: // global
           call _c2H5s(R1) args: 0, res: 0, upd: 0;
       c2H5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord16_$cmin_info" {
     GHC.Word.$fOrdWord16_$cmin_info:
         const GHC.Word.$fOrdWord16_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H5s() //  [R1]
         { []
         }
     {offset
       c2H5s: // global
           I64[Sp - 8] = block_c2H5y_info;
           _s2DY5::P64 = R1;
           _s2DY6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2DY6::I64;
           P64[Sp + 8] = _s2DY5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H5M; else goto c2H5C;
       u2H5M: // global
           call _c2H5y(R1) args: 0, res: 0, upd: 0;
       c2H5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H5s_info" {
     block_c2H5s_info:
         const _c2H5s;
         const 1;
         const 30;
 },
 _c2H5y() //  [R1]
         { []
         }
     {offset
       c2H5y: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2H5K; else goto c2H5L;
       c2H5K: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2H5L: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H5y_info" {
     block_c2H5y_info:
         const _c2H5y;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.545466475 UTC

[section ""data" . GHC.Word.$fOrdWord16_closure" {
     GHC.Word.$fOrdWord16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord16_closure+1;
         const GHC.Word.$fOrdWord16_$ccompare_closure+2;
         const GHC.Word.ltWord16_closure+2;
         const GHC.Word.leWord16_closure+2;
         const GHC.Word.gtWord16_closure+2;
         const GHC.Word.geWord16_closure+2;
         const GHC.Word.$fOrdWord16_$cmax_closure+2;
         const GHC.Word.$fOrdWord16_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.549704809 UTC

[section ""data" . GHC.Word.$fIxWord16_$cinRange_closure" {
     GHC.Word.$fIxWord16_$cinRange_closure:
         const GHC.Word.$fIxWord16_$cinRange_info;
 },
 GHC.Word.$fIxWord16_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H6g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2H6p; else goto c2H6q;
       c2H6p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H6q: // global
           I64[Sp - 16] = block_c2H6d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H6N; else goto c2H6e;
       u2H6N: // global
           call _c2H6d(R1) args: 0, res: 0, upd: 0;
       c2H6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cinRange_info" {
     GHC.Word.$fIxWord16_$cinRange_info:
         const GHC.Word.$fIxWord16_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H6d() //  [R1]
         { []
         }
     {offset
       c2H6d: // global
           I64[Sp - 8] = block_c2H6j_info;
           _s2DYe::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DYe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H6M; else goto c2H6k;
       u2H6M: // global
           call _c2H6j(R1) args: 0, res: 0, upd: 0;
       c2H6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H6d_info" {
     block_c2H6d_info:
         const _c2H6d;
         const 1;
         const 30;
 },
 _c2H6j() //  [R1]
         { []
         }
     {offset
       c2H6j: // global
           I64[Sp] = block_c2H6o_info;
           _s2DYg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DYg::I64;
           if (R1 & 7 != 0) goto u2H6O; else goto c2H6t;
       u2H6O: // global
           call _c2H6o(R1) args: 0, res: 0, upd: 0;
       c2H6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H6j_info" {
     block_c2H6j_info:
         const _c2H6j;
         const 2;
         const 30;
 },
 _c2H6o() //  [R1]
         { []
         }
     {offset
       c2H6o: // global
           _s2DYi::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DYi::I64) goto c2H6B; else goto c2H6F;
       c2H6B: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2H6F: // global
           _s2DYe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2H6E_info;
           R1 = _s2DYe::P64;
           I64[Sp + 16] = _s2DYi::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2H6P; else goto c2H6G;
       u2H6P: // global
           call _c2H6E(R1) args: 0, res: 0, upd: 0;
       c2H6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H6o_info" {
     block_c2H6o_info:
         const _c2H6o;
         const 130;
         const 30;
 },
 _c2H6E() //  [R1]
         { []
         }
     {offset
       c2H6E: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H6E_info" {
     block_c2H6E_info:
         const _c2H6E;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.560736591 UTC

[section ""data" . GHC.Word.$fRealWord16_$ctoRational_closure" {
     GHC.Word.$fRealWord16_$ctoRational_closure:
         const GHC.Word.$fRealWord16_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord16_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2H7t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2H7K; else goto c2H7L;
       c2H7K: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2H7L: // global
           I64[Sp - 8] = block_c2H7q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H7S; else goto c2H7r;
       u2H7S: // global
           call _c2H7q(R1) args: 0, res: 0, upd: 0;
       c2H7r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord16_$ctoRational_info" {
     GHC.Word.$fRealWord16_$ctoRational_info:
         const GHC.Word.$fRealWord16_$ctoRational_entry;
         const 0;
         const 17622250815502;
         const 4294967301;
         const S2Ecg_srt+736;
 },
 _c2H7q() //  [R1]
         { []
         }
     {offset
       c2H7q: // global
           I64[Sp] = block_c2H7z_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H7q_info" {
     block_c2H7q_info:
         const _c2H7q;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2H7z() //  [R1]
         { []
         }
     {offset
       c2H7z: // global
           I64[Sp] = block_c2H7D_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H7z_info" {
     block_c2H7z_info:
         const _c2H7z;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2H7D() //  [R1]
         { []
         }
     {offset
       c2H7D: // global
           I64[Sp] = block_c2H7H_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H7D_info" {
     block_c2H7D_info:
         const _c2H7D;
         const 0;
         const 12884901918;
         const S2Ecg_srt+736;
 },
 _c2H7H() //  [R1, R2]
         { []
         }
     {offset
       c2H7H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2H7R; else goto c2H7Q;
       c2H7R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2H7Q: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H7H_info" {
     block_c2H7H_info:
         const _c2H7H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.570413088 UTC

[section ""data" . GHC.Word.$fRealWord16_closure" {
     GHC.Word.$fRealWord16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord16_closure+1;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fRealWord16_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.572154185 UTC

[section ""data" . GHC.Word.$fIntegralWord16_closure" {
     GHC.Word.$fIntegralWord16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord16_closure+1;
         const GHC.Word.$fEnumWord16_closure+1;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquot_closure+2;
         const GHC.Word.$fIntegralWord16_$crem_closure+2;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger1_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.575617074 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord16_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord16_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord16_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2H8q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2H8N; else goto c2H8O;
       c2H8N: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2H8O: // global
           I64[Sp - 16] = block_c2H8n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2H8V; else goto c2H8o;
       u2H8V: // global
           call _c2H8n(R1) args: 0, res: 0, upd: 0;
       c2H8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cunsafeIndex_info" {
     GHC.Word.$fIxWord16_$cunsafeIndex_info:
         const GHC.Word.$fIxWord16_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2H8n() //  [R1]
         { []
         }
     {offset
       c2H8n: // global
           I64[Sp] = block_c2H8t_info;
           _s2DYz::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2DYz::P64;
           if (R1 & 7 != 0) goto u2H8U; else goto c2H8u;
       u2H8U: // global
           call _c2H8t(R1) args: 0, res: 0, upd: 0;
       c2H8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H8n_info" {
     block_c2H8n_info:
         const _c2H8n;
         const 1;
         const 30;
 },
 _c2H8t() //  [R1]
         { []
         }
     {offset
       c2H8t: // global
           I64[Sp] = block_c2H8y_info;
           _s2DYC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DYC::I64;
           if (R1 & 7 != 0) goto u2H8W; else goto c2H8z;
       u2H8W: // global
           call _c2H8y(R1) args: 0, res: 0, upd: 0;
       c2H8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H8t_info" {
     block_c2H8t_info:
         const _c2H8t;
         const 1;
         const 30;
 },
 _c2H8y() //  [R1]
         { []
         }
     {offset
       c2H8y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2H8T; else goto c2H8S;
       c2H8T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2H8S: // global
           _s2DYH::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DYH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H8y_info" {
     block_c2H8y_info:
         const _c2H8y;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.585665657 UTC

[section ""data" . GHC.Word.$fIxWord16_$crange_closure" {
     GHC.Word.$fIxWord16_$crange_closure:
         const GHC.Word.$fIxWord16_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2H9t: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2H9u; else goto c2H9v;
       c2H9u: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2H9v: // global
           I64[Sp - 8] = block_c2H9q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2H9z; else goto c2H9r;
       u2H9z: // global
           call _c2H9q(R1) args: 0, res: 0, upd: 0;
       c2H9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$crange_info" {
     GHC.Word.$fIxWord16_$crange_info:
         const GHC.Word.$fIxWord16_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+840;
 },
 _c2H9q() //  [R1]
         { []
         }
     {offset
       c2H9q: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord16_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H9q_info" {
     block_c2H9q_info:
         const _c2H9q;
         const 0;
         const 4294967326;
         const S2Ecg_srt+848;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.592039296 UTC

[section ""data" . GHC.Word.$fIxWord16_$crangeSize_closure" {
     GHC.Word.$fIxWord16_$crangeSize_closure:
         const GHC.Word.$fIxWord16_$crangeSize_info;
 },
 GHC.Word.$fIxWord16_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2H9R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ha0; else goto c2Ha1;
       c2Ha0: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Ha1: // global
           I64[Sp - 8] = block_c2H9O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Haw; else goto c2H9P;
       u2Haw: // global
           call _c2H9O(R1) args: 0, res: 0, upd: 0;
       c2H9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$crangeSize_info" {
     GHC.Word.$fIxWord16_$crangeSize_info:
         const GHC.Word.$fIxWord16_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2H9O() //  [R1]
         { []
         }
     {offset
       c2H9O: // global
           I64[Sp - 8] = block_c2H9U_info;
           _s2DYP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DYP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hav; else goto c2H9V;
       u2Hav: // global
           call _c2H9U(R1) args: 0, res: 0, upd: 0;
       c2H9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H9O_info" {
     block_c2H9O_info:
         const _c2H9O;
         const 0;
         const 30;
 },
 _c2H9U() //  [R1]
         { []
         }
     {offset
       c2H9U: // global
           I64[Sp] = block_c2H9Z_info;
           _s2DYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DYR::I64;
           if (R1 & 7 != 0) goto u2Hax; else goto c2Ha4;
       u2Hax: // global
           call _c2H9Z(R1) args: 0, res: 0, upd: 0;
       c2Ha4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H9U_info" {
     block_c2H9U_info:
         const _c2H9U;
         const 1;
         const 30;
 },
 _c2H9Z() //  [R1]
         { []
         }
     {offset
       c2H9Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Haa; else goto c2Ha9;
       c2Haa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Ha9: // global
           _s2DYR::I64 = I64[Sp + 8];
           _s2DYT::I64 = I64[R1 + 7];
           if (_s2DYR::I64 > _s2DYT::I64) goto c2Hae; else goto c2Hau;
       c2Hae: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hau: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DYT::I64 - _s2DYR::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2H9Z_info" {
     block_c2H9Z_info:
         const _c2H9Z;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.602182392 UTC

[section ""data" . GHC.Word.$fIxWord16_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord16_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2Hb6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hbw; else goto c2Hbx;
       c2Hbw: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hbx: // global
           I64[Sp - 8] = block_c2Hb3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HbE; else goto c2Hb4;
       u2HbE: // global
           call _c2Hb3(R1) args: 0, res: 0, upd: 0;
       c2Hb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord16_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Hb3() //  [R1]
         { []
         }
     {offset
       c2Hb3: // global
           I64[Sp - 8] = block_c2Hb9_info;
           _s2DZ1::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2DZ1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HbD; else goto c2Hba;
       u2HbD: // global
           call _c2Hb9(R1) args: 0, res: 0, upd: 0;
       c2Hba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hb3_info" {
     block_c2Hb3_info:
         const _c2Hb3;
         const 0;
         const 30;
 },
 _c2Hb9() //  [R1]
         { []
         }
     {offset
       c2Hb9: // global
           I64[Sp] = block_c2Hbe_info;
           _s2DZ4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZ4::I64;
           if (R1 & 7 != 0) goto u2HbF; else goto c2Hbf;
       u2HbF: // global
           call _c2Hbe(R1) args: 0, res: 0, upd: 0;
       c2Hbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hb9_info" {
     block_c2Hb9_info:
         const _c2Hb9;
         const 1;
         const 30;
 },
 _c2Hbe() //  [R1]
         { []
         }
     {offset
       c2Hbe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HbC; else goto c2HbB;
       c2HbC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HbB: // global
           _s2DZa::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2DZa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hbe_info" {
     block_c2Hbe_info:
         const _c2Hbe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.612972141 UTC

[section ""data" . GHC.Word.$fIxWord16_$cindex_closure" {
     GHC.Word.$fIxWord16_$cindex_closure:
         const GHC.Word.$fIxWord16_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord16_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hcd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hcm; else goto c2Hcn;
       c2Hcm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hcn: // global
           I64[Sp - 16] = block_c2Hca_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hd2; else goto c2Hcb;
       u2Hd2: // global
           call _c2Hca(R1) args: 0, res: 0, upd: 0;
       c2Hcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord16_$cindex_info" {
     GHC.Word.$fIxWord16_$cindex_info:
         const GHC.Word.$fIxWord16_$cindex_entry;
         const 0;
         const 4402341478414;
         const 8589934607;
         const S2Ecg_srt+776;
 },
 _c2Hca() //  [R1]
         { []
         }
     {offset
       c2Hca: // global
           I64[Sp - 8] = block_c2Hcg_info;
           _s2DZf::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2DZf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hd1; else goto c2Hch;
       u2Hd1: // global
           call _c2Hcg(R1) args: 0, res: 0, upd: 0;
       c2Hch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hca_info" {
     block_c2Hca_info:
         const _c2Hca;
         const 1;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2Hcg() //  [R1]
         { []
         }
     {offset
       c2Hcg: // global
           I64[Sp] = block_c2Hcl_info;
           _s2DZh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2DZh::I64;
           if (R1 & 7 != 0) goto u2Hd3; else goto c2Hcq;
       u2Hd3: // global
           call _c2Hcl(R1) args: 0, res: 0, upd: 0;
       c2Hcq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hcg_info" {
     block_c2Hcg_info:
         const _c2Hcg;
         const 2;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2Hcl() //  [R1]
         { []
         }
     {offset
       c2Hcl: // global
           _s2DZj::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2DZj::I64) goto c2Hcy; else goto c2HcC;
       c2Hcy: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HcC: // global
           I64[Sp] = block_c2HcB_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZj::I64;
           if (R1 & 7 != 0) goto u2Hd4; else goto c2HcD;
       u2Hd4: // global
           call _c2HcB(R1) args: 0, res: 0, upd: 0;
       c2HcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hcl_info" {
     block_c2Hcl_info:
         const _c2Hcl;
         const 130;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HcB() //  [R1]
         { []
         }
     {offset
       c2HcB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HcJ; else goto c2HcI;
       c2HcJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HcI: // global
           _s2DZj::I64 = I64[Sp + 8];
           if (_s2DZj::I64 > I64[R1 + 7]) goto c2HcN; else goto c2Hd0;
       c2HcN: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2Hd0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_s2DZj::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HcB_info" {
     block_c2HcB_info:
         const _c2HcB;
         const 194;
         const 4294967326;
         const S2Ecg_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.623936768 UTC

[section ""data" . GHC.Word.$fIxWord16_closure" {
     GHC.Word.$fIxWord16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord16_closure+1;
         const GHC.Word.$fIxWord16_$crange_closure+1;
         const GHC.Word.$fIxWord16_$cindex_closure+2;
         const GHC.Word.$fIxWord16_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord16_$cinRange_closure+2;
         const GHC.Word.$fIxWord16_$crangeSize_closure+1;
         const GHC.Word.$fIxWord16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.626792657 UTC

[section ""data" . GHC.Word.byteSwap16_closure" {
     GHC.Word.byteSwap16_closure:
         const GHC.Word.byteSwap16_info;
 },
 GHC.Word.byteSwap16_entry() //  [R2]
         { []
         }
     {offset
       c2HdJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HdU; else goto c2HdV;
       c2HdU: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap16_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HdV: // global
           I64[Sp - 8] = block_c2HdG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HdZ; else goto c2HdH;
       u2HdZ: // global
           call _c2HdG(R1) args: 0, res: 0, upd: 0;
       c2HdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap16_info" {
     GHC.Word.byteSwap16_info:
         const GHC.Word.byteSwap16_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HdG() //  [R1]
         { []
         }
     {offset
       c2HdG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HdY; else goto c2HdX;
       c2HdY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HdX: // global
           (_c2HdM::I64) = call MO_BSwap W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(_c2HdM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HdG_info" {
     block_c2HdG_info:
         const _c2HdG;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.633089935 UTC

[section ""data" . GHC.Word.eqWord32_closure" {
     GHC.Word.eqWord32_closure:
         const GHC.Word.eqWord32_info;
 },
 GHC.Word.eqWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hel: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hep; else goto c2Heq;
       c2Hep: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.eqWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Heq: // global
           I64[Sp - 16] = block_c2Hei_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hez; else goto c2Hej;
       u2Hez: // global
           call _c2Hei(R1) args: 0, res: 0, upd: 0;
       c2Hej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.eqWord32_info" {
     GHC.Word.eqWord32_info:
         const GHC.Word.eqWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hei() //  [R1]
         { []
         }
     {offset
       c2Hei: // global
           I64[Sp] = block_c2Heo_info;
           _s2DZz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZz::I64;
           if (R1 & 7 != 0) goto u2Hey; else goto c2Hes;
       u2Hey: // global
           call _c2Heo(R1) args: 0, res: 0, upd: 0;
       c2Hes: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hei_info" {
     block_c2Hei_info:
         const _c2Hei;
         const 1;
         const 30;
 },
 _c2Heo() //  [R1]
         { []
         }
     {offset
       c2Heo: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Heo_info" {
     block_c2Heo_info:
         const _c2Heo;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.640102345 UTC

[section ""data" . GHC.Word.$fEqWord32_closure" {
     GHC.Word.$fEqWord32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Word.eqWord32_closure+2;
         const GHC.Word.neWord32_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.641848406 UTC

[section ""data" . GHC.Word.$fNumWord2_closure" {
     GHC.Word.$fNumWord2_closure:
         const GHC.Word.W32#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.644447621 UTC

[section ""data" . GHC.Word.$fNumWord32_$csignum_closure" {
     GHC.Word.$fNumWord32_$csignum_closure:
         const GHC.Word.$fNumWord32_$csignum_info;
 },
 GHC.Word.$fNumWord32_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c2Hf3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hf4; else goto c2Hf5;
       c2Hf4: // global
           R2 = R2;
           R1 = GHC.Word.$fNumWord32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hf5: // global
           I64[Sp - 8] = block_c2Hf0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hfd; else goto c2Hf1;
       u2Hfd: // global
           call _c2Hf0(R1) args: 0, res: 0, upd: 0;
       c2Hf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fNumWord32_$csignum_info" {
     GHC.Word.$fNumWord32_$csignum_info:
         const GHC.Word.$fNumWord32_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Hf0() //  [R1]
         { []
         }
     {offset
       c2Hf0: // global
           if (I64[R1 + 7] == 0) goto c2Hfc; else goto c2Hfb;
       c2Hfc: // global
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hfb: // global
           R1 = GHC.Word.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hf0_info" {
     block_c2Hf0_info:
         const _c2Hf0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.649472933 UTC

[section ""data" . GHC.Word.$fNumWord32_closure" {
     GHC.Word.$fNumWord32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Word.$fNumWord32_$c+_closure+2;
         const GHC.Word.$fNumWord32_$c-_closure+2;
         const GHC.Word.$fNumWord32_$c*_closure+2;
         const GHC.Word.$fNumWord32_$cnegate_closure+1;
         const GHC.Word.$fNumWord32_$cabs_closure+1;
         const GHC.Word.$fNumWord32_$csignum_closure+1;
         const GHC.Word.$fNumWord32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.652264141 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplement_closure" {
     GHC.Word.$fBitsWord32_$ccomplement_closure:
         const GHC.Word.$fBitsWord32_$ccomplement_info;
 },
 GHC.Word.$fBitsWord32_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2Hfy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HfF; else goto c2HfG;
       c2HfF: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HfG: // global
           I64[Sp - 8] = block_c2Hfv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HfK; else goto c2Hfw;
       u2HfK: // global
           call _c2Hfv(R1) args: 0, res: 0, upd: 0;
       c2Hfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ccomplement_info" {
     GHC.Word.$fBitsWord32_$ccomplement_info:
         const GHC.Word.$fBitsWord32_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Hfv() //  [R1]
         { []
         }
     {offset
       c2Hfv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HfJ; else goto c2HfI;
       c2HfJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HfI: // global
           _s2DZK::I64 = I64[R1 + 7] ^ 4294967295;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2DZK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hfv_info" {
     block_c2Hfv_info:
         const _c2Hfv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.658196973 UTC

[section ""data" . GHC.Word.$fBitsWord4_closure" {
     GHC.Word.$fBitsWord4_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord3_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.660306803 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2Hg4: // global
           R1 = GHC.Word.$fBitsWord4_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord32_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.664443046 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cbit_closure" {
     GHC.Word.$fBitsWord32_$cbit_closure:
         const GHC.Word.$fBitsWord32_$cbit_info;
 },
 GHC.Word.$fBitsWord32_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2Hgj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hgk; else goto c2Hgl;
       c2Hgk: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hgl: // global
           I64[Sp - 8] = block_c2Hgg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HgE; else goto c2Hgh;
       u2HgE: // global
           call _c2Hgg(R1) args: 0, res: 0, upd: 0;
       c2Hgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cbit_info" {
     GHC.Word.$fBitsWord32_$cbit_info:
         const GHC.Word.$fBitsWord32_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2Hgg() //  [R1]
         { []
         }
     {offset
       c2Hgg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hgq; else goto c2Hgp;
       c2Hgq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hgp: // global
           _s2DZO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2DZO::I64, 64)) goto c2HgC; else goto c2HgD;
       c2HgC: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2DZO::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HgD: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord32_$cminBound_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hgg_info" {
     block_c2Hgg_info:
         const _c2Hgg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.670941228 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ctestBit_closure" {
     GHC.Word.$fBitsWord32_$ctestBit_closure:
         const GHC.Word.$fBitsWord32_$ctestBit_info;
 },
 GHC.Word.$fBitsWord32_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hh1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hh5; else goto c2Hh6;
       c2Hh5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hh6: // global
           I64[Sp - 16] = block_c2HgY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HhF; else goto c2HgZ;
       u2HhF: // global
           call _c2HgY(R1) args: 0, res: 0, upd: 0;
       c2HgZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ctestBit_info" {
     GHC.Word.$fBitsWord32_$ctestBit_info:
         const GHC.Word.$fBitsWord32_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HgY() //  [R1]
         { []
         }
     {offset
       c2HgY: // global
           I64[Sp] = block_c2Hh4_info;
           _s2DZV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2DZV::I64;
           if (R1 & 7 != 0) goto u2HhE; else goto c2Hh8;
       u2HhE: // global
           call _c2Hh4(R1) args: 0, res: 0, upd: 0;
       c2Hh8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HgY_info" {
     block_c2HgY_info:
         const _c2HgY;
         const 1;
         const 30;
 },
 _c2Hh4() //  [R1]
         { []
         }
     {offset
       c2Hh4: // global
           _s2DZX::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2DZX::I64, 64)) goto c2HhD; else goto c2HhC;
       c2HhC: // global
           if (I64[Sp + 8] & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2DZX::I64)) == 0) goto c2HhD; else goto c2Hhr;
       c2HhD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hhr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hh4_info" {
     block_c2Hh4_info:
         const _c2Hh4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.679885491 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateR_closure" {
     GHC.Word.$fBitsWord32_$crotateR_closure:
         const GHC.Word.$fBitsWord32_$crotateR_info;
 },
 GHC.Word.$fBitsWord32_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hia: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hie; else goto c2Hif;
       c2Hie: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hif: // global
           I64[Sp - 16] = block_c2Hi7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hj5; else goto c2Hi8;
       u2Hj5: // global
           call _c2Hi7(R1) args: 0, res: 0, upd: 0;
       c2Hi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotateR_info" {
     GHC.Word.$fBitsWord32_$crotateR_info:
         const GHC.Word.$fBitsWord32_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hi7() //  [R1]
         { []
         }
     {offset
       c2Hi7: // global
           I64[Sp - 8] = block_c2Hid_info;
           _s2E04::P64 = R1;
           _s2E05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E05::I64;
           P64[Sp + 8] = _s2E04::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hj4; else goto c2Hih;
       u2Hj4: // global
           call _c2Hid(R1) args: 0, res: 0, upd: 0;
       c2Hih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hi7_info" {
     block_c2Hi7_info:
         const _c2Hi7;
         const 1;
         const 30;
 },
 _c2Hid() //  [R1]
         { []
         }
     {offset
       c2Hid: // global
           _s2E0b::I64 = -I64[R1 + 7] & 31;
           if (_s2E0b::I64 != 0) goto u2Hj2; else goto c2HiY;
       u2Hj2: // global
           I64[Sp + 16] = _s2E0b::I64;
           Sp = Sp + 8;
           call _c2Hiz() args: 0, res: 0, upd: 0;
       c2HiY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hid_info" {
     block_c2Hid_info:
         const _c2Hid;
         const 66;
         const 30;
 },
 _c2Hiz() //  []
         { []
         }
     {offset
       c2Hiz: // global
           Hp = Hp + 16;
           _s2E0b::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2HiV; else goto c2HiU;
       c2HiV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2Hiy_info;
           R1 = _s2E0b::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2HiU: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           _s2E05::I64 = I64[Sp];
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_s2E05::I64 << _s2E0b::I64) | (_s2E05::I64 >> 32 - _s2E0b::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2Hiy() //  [R1]
         { []
         }
     {offset
       c2Hiy: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2Hiz() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2Hiy_info" {
     block_c2Hiy_info:
         const _c2Hiy;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.69079441 UTC

[section ""data" . GHC.Word.$fBitsWord32_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord32_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord32_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord32_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HjL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HjP; else goto c2HjQ;
       c2HjP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HjQ: // global
           I64[Sp - 16] = block_c2HjI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hkg; else goto c2HjJ;
       u2Hkg: // global
           call _c2HjI(R1) args: 0, res: 0, upd: 0;
       c2HjJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$ccomplementBit_info" {
     GHC.Word.$fBitsWord32_$ccomplementBit_info:
         const GHC.Word.$fBitsWord32_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HjI() //  [R1]
         { []
         }
     {offset
       c2HjI: // global
           I64[Sp - 8] = block_c2HjO_info;
           _s2E0j::P64 = R1;
           _s2E0k::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E0k::I64;
           P64[Sp + 8] = _s2E0j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hkf; else goto c2HjS;
       u2Hkf: // global
           call _c2HjO(R1) args: 0, res: 0, upd: 0;
       c2HjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HjI_info" {
     block_c2HjI_info:
         const _c2HjI;
         const 1;
         const 30;
 },
 _c2HjO() //  [R1]
         { []
         }
     {offset
       c2HjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HjY; else goto c2HjX;
       c2HjY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HjX: // global
           _s2E0m::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0m::I64, 64)) goto c2Hkd; else goto c2Hke;
       c2Hkd: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0m::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hke: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HjO_info" {
     block_c2HjO_info:
         const _c2HjO;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.69981899 UTC

[section ""data" . GHC.Word.$fBitsWord32_$cclearBit_closure" {
     GHC.Word.$fBitsWord32_$cclearBit_closure:
         const GHC.Word.$fBitsWord32_$cclearBit_info;
 },
 GHC.Word.$fBitsWord32_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HkL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HkP; else goto c2HkQ;
       c2HkP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HkQ: // global
           I64[Sp - 16] = block_c2HkI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hlo; else goto c2HkJ;
       u2Hlo: // global
           call _c2HkI(R1) args: 0, res: 0, upd: 0;
       c2HkJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$cclearBit_info" {
     GHC.Word.$fBitsWord32_$cclearBit_info:
         const GHC.Word.$fBitsWord32_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HkI() //  [R1]
         { []
         }
     {offset
       c2HkI: // global
           I64[Sp] = block_c2HkO_info;
           _s2E0u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0u::I64;
           if (R1 & 7 != 0) goto u2Hln; else goto c2HkS;
       u2Hln: // global
           call _c2HkO(R1) args: 0, res: 0, upd: 0;
       c2HkS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HkI_info" {
     block_c2HkI_info:
         const _c2HkI;
         const 1;
         const 30;
 },
 _c2HkO() //  [R1]
         { []
         }
     {offset
       c2HkO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HkY; else goto c2HkX;
       c2HkY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HkX: // global
           _s2E0u::I64 = I64[Sp + 8];
           _s2E0w::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0w::I64, 64)) goto c2Hlg; else goto c2Hlm;
       c2Hlg: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E0u::I64 & %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0w::I64)) ^ 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hlm: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E0u::I64 & 4294967295;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HkO_info" {
     block_c2HkO_info:
         const _c2HkO;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.708509301 UTC

[section ""data" . GHC.Word.$fBitsWord32_$csetBit_closure" {
     GHC.Word.$fBitsWord32_$csetBit_closure:
         const GHC.Word.$fBitsWord32_$csetBit_info;
 },
 GHC.Word.$fBitsWord32_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HlY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hm2; else goto c2Hm3;
       c2Hm2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hm3: // global
           I64[Sp - 16] = block_c2HlV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hmt; else goto c2HlW;
       u2Hmt: // global
           call _c2HlV(R1) args: 0, res: 0, upd: 0;
       c2HlW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$csetBit_info" {
     GHC.Word.$fBitsWord32_$csetBit_info:
         const GHC.Word.$fBitsWord32_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HlV() //  [R1]
         { []
         }
     {offset
       c2HlV: // global
           I64[Sp - 8] = block_c2Hm1_info;
           _s2E0F::P64 = R1;
           _s2E0G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E0G::I64;
           P64[Sp + 8] = _s2E0F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hms; else goto c2Hm5;
       u2Hms: // global
           call _c2Hm1(R1) args: 0, res: 0, upd: 0;
       c2Hm5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HlV_info" {
     block_c2HlV_info:
         const _c2HlV;
         const 1;
         const 30;
 },
 _c2Hm1() //  [R1]
         { []
         }
     {offset
       c2Hm1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hmb; else goto c2Hma;
       c2Hmb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hma: // global
           _s2E0I::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E0I::I64, 64)) goto c2Hmq; else goto c2Hmr;
       c2Hmq: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(1 << _s2E0I::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hmr: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hm1_info" {
     block_c2Hm1_info:
         const _c2Hm1;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.715845492 UTC

[section ""data" . GHC.Word.$fBitsWord32_$crotateL_closure" {
     GHC.Word.$fBitsWord32_$crotateL_closure:
         const GHC.Word.$fBitsWord32_$crotateL_info;
 },
 GHC.Word.$fBitsWord32_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HmV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord32_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord32_$crotateL_info" {
     GHC.Word.$fBitsWord32_$crotateL_info:
         const GHC.Word.$fBitsWord32_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.719115061 UTC

[section ""data" . GHC.Word.$fBitsWord32_closure" {
     GHC.Word.$fBitsWord32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fBitsWord32_$c.&._closure+2;
         const GHC.Word.$fBitsWord32_$c.|._closure+2;
         const GHC.Word.$fBitsWord32_$cxor_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord32_$cshift_closure+2;
         const GHC.Word.$fBitsWord32_$crotate_closure+2;
         const GHC.Word.$fBitsWord32_$cminBound_closure+1;
         const GHC.Word.$fBitsWord32_$cbit_closure+1;
         const GHC.Word.$fBitsWord32_$csetBit_closure+2;
         const GHC.Word.$fBitsWord32_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord32_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord32_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord32_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord32_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord32_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord32_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord32_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord32_$crotateL_closure+2;
         const GHC.Word.$fBitsWord32_$crotateR_closure+2;
         const GHC.Word.$fBitsWord32_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.721147754 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord32_closure" {
     GHC.Word.$fFiniteBitsWord32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord32_closure+1;
         const GHC.Word.$fBitsWord32_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.724438863 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquot_closure" {
     GHC.Word.$fIntegralWord32_$cquot_closure:
         const GHC.Word.$fIntegralWord32_$cquot_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hnb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hnf; else goto c2Hng;
       c2Hnf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hng: // global
           I64[Sp - 16] = block_c2Hn8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hnz; else goto c2Hn9;
       u2Hnz: // global
           call _c2Hn8(R1) args: 0, res: 0, upd: 0;
       c2Hn9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cquot_info" {
     GHC.Word.$fIntegralWord32_$cquot_info:
         const GHC.Word.$fIntegralWord32_$cquot_entry;
         const 0;
         const 554050781198;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2Hn8() //  [R1]
         { []
         }
     {offset
       c2Hn8: // global
           I64[Sp] = block_c2Hne_info;
           _s2E0Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0Q::I64;
           if (R1 & 7 != 0) goto u2Hny; else goto c2Hni;
       u2Hny: // global
           call _c2Hne(R1) args: 0, res: 0, upd: 0;
       c2Hni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hn8_info" {
     block_c2Hn8_info:
         const _c2Hn8;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2Hne() //  [R1]
         { []
         }
     {offset
       c2Hne: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hno; else goto c2Hnn;
       c2Hno: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hnn: // global
           _s2E0T::I64 = I64[R1 + 7];
           if (_s2E0T::I64 != 0) goto c2Hnw; else goto c2Hnx;
       c2Hnw: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] / _s2E0T::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hnx: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hne_info" {
     block_c2Hne_info:
         const _c2Hne;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.73329868 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$crem_closure" {
     GHC.Word.$fIntegralWord32_$crem_closure:
         const GHC.Word.$fIntegralWord32_$crem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HnZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Ho3; else goto c2Ho4;
       c2Ho3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Ho4: // global
           I64[Sp - 16] = block_c2HnW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hon; else goto c2HnX;
       u2Hon: // global
           call _c2HnW(R1) args: 0, res: 0, upd: 0;
       c2HnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$crem_info" {
     GHC.Word.$fIntegralWord32_$crem_info:
         const GHC.Word.$fIntegralWord32_$crem_entry;
         const 0;
         const 1103806595086;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2HnW() //  [R1]
         { []
         }
     {offset
       c2HnW: // global
           I64[Sp] = block_c2Ho2_info;
           _s2E0Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E0Y::I64;
           if (R1 & 7 != 0) goto u2Hom; else goto c2Ho6;
       u2Hom: // global
           call _c2Ho2(R1) args: 0, res: 0, upd: 0;
       c2Ho6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HnW_info" {
     block_c2HnW_info:
         const _c2HnW;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2Ho2() //  [R1]
         { []
         }
     {offset
       c2Ho2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hoc; else goto c2Hob;
       c2Hoc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hob: // global
           _s2E11::I64 = I64[R1 + 7];
           if (_s2E11::I64 != 0) goto c2Hok; else goto c2Hol;
       c2Hok: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = I64[Sp + 8] % _s2E11::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hol: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ho2_info" {
     block_c2Ho2_info:
         const _c2Ho2;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.742698601 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cquotRem_closure" {
     GHC.Word.$fIntegralWord32_$cquotRem_closure:
         const GHC.Word.$fIntegralWord32_$cquotRem_info;
         const 0;
 },
 GHC.Word.$fIntegralWord32_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HoR; else goto c2HoS;
       c2HoR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HoS: // global
           I64[Sp - 16] = block_c2HoK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hpa; else goto c2HoL;
       u2Hpa: // global
           call _c2HoK(R1) args: 0, res: 0, upd: 0;
       c2HoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cquotRem_info" {
     GHC.Word.$fIntegralWord32_$cquotRem_info:
         const GHC.Word.$fIntegralWord32_$cquotRem_entry;
         const 0;
         const 2203318222862;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2HoK() //  [R1]
         { []
         }
     {offset
       c2HoK: // global
           I64[Sp] = block_c2HoQ_info;
           _s2E16::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E16::I64;
           if (R1 & 7 != 0) goto u2Hp9; else goto c2HoU;
       u2Hp9: // global
           call _c2HoQ(R1) args: 0, res: 0, upd: 0;
       c2HoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HoK_info" {
     block_c2HoK_info:
         const _c2HoK;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2HoQ() //  [R1]
         { []
         }
     {offset
       c2HoQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c2Hp0; else goto c2HoZ;
       c2Hp0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HoZ: // global
           _s2E19::I64 = I64[R1 + 7];
           if (_s2E19::I64 != 0) goto c2Hp7; else goto c2Hp8;
       c2Hp7: // global
           (_s2E1b::I64, _s2E1c::I64) = call MO_U_QuotRem W64(I64[Sp + 8], _s2E19::I64);
           I64[Hp - 48] = GHC.Word.W32#_con_info;
           I64[Hp - 40] = _s2E1c::I64;
           I64[Hp - 32] = GHC.Word.W32#_con_info;
           I64[Hp - 24] = _s2E1b::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hp8: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HoQ_info" {
     block_c2HoQ_info:
         const _c2HoQ;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.752207077 UTC

[section ""data" . GHC.Word.$fIntegralWord32_$cdivMod_closure" {
     GHC.Word.$fIntegralWord32_$cdivMod_closure:
         const GHC.Word.$fIntegralWord32_$cdivMod_info;
         const 0;
 },
 sat_s2E1p_entry() //  [R1]
         { []
         }
     {offset
       c2HpS: // global
           _s2E1p::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2HpV; else goto c2HpW;
       c2HpW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HpY; else goto c2HpX;
       c2HpY: // global
           HpAlloc = 16;
           goto c2HpV;
       c2HpV: // global
           R1 = _s2E1p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2HpX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2E1p::P64;
           _s2E1o::I64 = I64[_s2E1p::P64 + 16] % I64[_s2E1p::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E1o::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2E1p_info" {
     sat_s2E1p_info:
         const sat_s2E1p_entry;
         const 8589934592;
         const 20;
 },
 sat_s2E1n_entry() //  [R1]
         { []
         }
     {offset
       c2Hq5: // global
           _s2E1n::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hq8; else goto c2Hq9;
       c2Hq9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2Hqb; else goto c2Hqa;
       c2Hqb: // global
           HpAlloc = 16;
           goto c2Hq8;
       c2Hq8: // global
           R1 = _s2E1n::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c2Hqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s2E1n::P64;
           _s2E1m::I64 = I64[_s2E1n::P64 + 16] / I64[_s2E1n::P64 + 24];
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s2E1m::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s2E1n_info" {
     sat_s2E1n_info:
         const sat_s2E1n_entry;
         const 8589934592;
         const 20;
 },
 GHC.Word.$fIntegralWord32_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hqc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hqd; else goto c2Hqe;
       c2Hqd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIntegralWord32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hqe: // global
           I64[Sp - 16] = block_c2HpA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hqo; else goto c2HpB;
       u2Hqo: // global
           call _c2HpA(R1) args: 0, res: 0, upd: 0;
       c2HpB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIntegralWord32_$cdivMod_info" {
     GHC.Word.$fIntegralWord32_$cdivMod_info:
         const GHC.Word.$fIntegralWord32_$cdivMod_entry;
         const 0;
         const 4402341478414;
         const 8589934607;
         const S2Ecg_srt+808;
 },
 _c2HpA() //  [R1]
         { []
         }
     {offset
       c2HpA: // global
           I64[Sp] = block_c2HpF_info;
           _s2E1i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1i::I64;
           if (R1 & 7 != 0) goto u2Hqn; else goto c2HpG;
       u2Hqn: // global
           call _c2HpF(R1) args: 0, res: 0, upd: 0;
       c2HpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HpA_info" {
     block_c2HpA_info:
         const _c2HpA;
         const 1;
         const 4294967326;
         const S2Ecg_srt+808;
 },
 _c2HpF() //  [R1]
         { []
         }
     {offset
       c2HpF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c2Hqi; else goto c2Hqh;
       c2Hqi: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2Hqh: // global
           _s2E1l::I64 = I64[R1 + 7];
           if (_s2E1l::I64 != 0) goto c2Hql; else goto c2Hqm;
       c2Hql: // global
           I64[Hp - 80] = sat_s2E1p_info;
           _s2E1i::I64 = I64[Sp + 8];
           I64[Hp - 64] = _s2E1i::I64;
           I64[Hp - 56] = _s2E1l::I64;
           I64[Hp - 48] = sat_s2E1n_info;
           I64[Hp - 32] = _s2E1i::I64;
           I64[Hp - 24] = _s2E1l::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hqm: // global
           Hp = Hp - 88;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HpF_info" {
     block_c2HpF_info:
         const _c2HpF;
         const 65;
         const 4294967326;
         const S2Ecg_srt+808;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.764195645 UTC

[section ""data" . GHC.Word.gtWord32_closure" {
     GHC.Word.gtWord32_closure:
         const GHC.Word.gtWord32_info;
 },
 GHC.Word.gtWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hr5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hr9; else goto c2Hra;
       c2Hr9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.gtWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hra: // global
           I64[Sp - 16] = block_c2Hr2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hrj; else goto c2Hr3;
       u2Hrj: // global
           call _c2Hr2(R1) args: 0, res: 0, upd: 0;
       c2Hr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.gtWord32_info" {
     GHC.Word.gtWord32_info:
         const GHC.Word.gtWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hr2() //  [R1]
         { []
         }
     {offset
       c2Hr2: // global
           I64[Sp] = block_c2Hr8_info;
           _s2E1t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1t::I64;
           if (R1 & 7 != 0) goto u2Hri; else goto c2Hrc;
       u2Hri: // global
           call _c2Hr8(R1) args: 0, res: 0, upd: 0;
       c2Hrc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hr2_info" {
     block_c2Hr2_info:
         const _c2Hr2;
         const 1;
         const 30;
 },
 _c2Hr8() //  [R1]
         { []
         }
     {offset
       c2Hr8: // global
           R1 = I64[((I64[Sp + 8] > I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hr8_info" {
     block_c2Hr8_info:
         const _c2Hr8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.771789308 UTC

[section ""data" . GHC.Word.geWord32_closure" {
     GHC.Word.geWord32_closure:
         const GHC.Word.geWord32_info;
 },
 GHC.Word.geWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HrL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HrP; else goto c2HrQ;
       c2HrP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.geWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HrQ: // global
           I64[Sp - 16] = block_c2HrI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HrZ; else goto c2HrJ;
       u2HrZ: // global
           call _c2HrI(R1) args: 0, res: 0, upd: 0;
       c2HrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.geWord32_info" {
     GHC.Word.geWord32_info:
         const GHC.Word.geWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HrI() //  [R1]
         { []
         }
     {offset
       c2HrI: // global
           I64[Sp] = block_c2HrO_info;
           _s2E1A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1A::I64;
           if (R1 & 7 != 0) goto u2HrY; else goto c2HrS;
       u2HrY: // global
           call _c2HrO(R1) args: 0, res: 0, upd: 0;
       c2HrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HrI_info" {
     block_c2HrI_info:
         const _c2HrI;
         const 1;
         const 30;
 },
 _c2HrO() //  [R1]
         { []
         }
     {offset
       c2HrO: // global
           R1 = I64[((I64[Sp + 8] >= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HrO_info" {
     block_c2HrO_info:
         const _c2HrO;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.780055331 UTC

[section ""data" . GHC.Word.ltWord32_closure" {
     GHC.Word.ltWord32_closure:
         const GHC.Word.ltWord32_info;
 },
 GHC.Word.ltWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hsr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Hsv; else goto c2Hsw;
       c2Hsv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.ltWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hsw: // global
           I64[Sp - 16] = block_c2Hso_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HsF; else goto c2Hsp;
       u2HsF: // global
           call _c2Hso(R1) args: 0, res: 0, upd: 0;
       c2Hsp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.ltWord32_info" {
     GHC.Word.ltWord32_info:
         const GHC.Word.ltWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hso() //  [R1]
         { []
         }
     {offset
       c2Hso: // global
           I64[Sp] = block_c2Hsu_info;
           _s2E1H::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1H::I64;
           if (R1 & 7 != 0) goto u2HsE; else goto c2Hsy;
       u2HsE: // global
           call _c2Hsu(R1) args: 0, res: 0, upd: 0;
       c2Hsy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hso_info" {
     block_c2Hso_info:
         const _c2Hso;
         const 1;
         const 30;
 },
 _c2Hsu() //  [R1]
         { []
         }
     {offset
       c2Hsu: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hsu_info" {
     block_c2Hsu_info:
         const _c2Hsu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.787992872 UTC

[section ""data" . GHC.Word.leWord32_closure" {
     GHC.Word.leWord32_closure:
         const GHC.Word.leWord32_info;
 },
 GHC.Word.leWord32_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Ht7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2Htb; else goto c2Htc;
       c2Htb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.leWord32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Htc: // global
           I64[Sp - 16] = block_c2Ht4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Htl; else goto c2Ht5;
       u2Htl: // global
           call _c2Ht4(R1) args: 0, res: 0, upd: 0;
       c2Ht5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.leWord32_info" {
     GHC.Word.leWord32_info:
         const GHC.Word.leWord32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Ht4() //  [R1]
         { []
         }
     {offset
       c2Ht4: // global
           I64[Sp] = block_c2Hta_info;
           _s2E1O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1O::I64;
           if (R1 & 7 != 0) goto u2Htk; else goto c2Hte;
       u2Htk: // global
           call _c2Hta(R1) args: 0, res: 0, upd: 0;
       c2Hte: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Ht4_info" {
     block_c2Ht4_info:
         const _c2Ht4;
         const 1;
         const 30;
 },
 _c2Hta() //  [R1]
         { []
         }
     {offset
       c2Hta: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hta_info" {
     block_c2Hta_info:
         const _c2Hta;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.795988238 UTC

[section ""data" . GHC.Word.$fOrdWord32_$ccompare_closure" {
     GHC.Word.$fOrdWord32_$ccompare_closure:
         const GHC.Word.$fOrdWord32_$ccompare_info;
 },
 GHC.Word.$fOrdWord32_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HtN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HtR; else goto c2HtS;
       c2HtR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HtS: // global
           I64[Sp - 16] = block_c2HtK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2Hub; else goto c2HtL;
       u2Hub: // global
           call _c2HtK(R1) args: 0, res: 0, upd: 0;
       c2HtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$ccompare_info" {
     GHC.Word.$fOrdWord32_$ccompare_info:
         const GHC.Word.$fOrdWord32_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HtK() //  [R1]
         { []
         }
     {offset
       c2HtK: // global
           I64[Sp] = block_c2HtQ_info;
           _s2E1V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E1V::I64;
           if (R1 & 7 != 0) goto u2Hua; else goto c2HtU;
       u2Hua: // global
           call _c2HtQ(R1) args: 0, res: 0, upd: 0;
       c2HtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HtK_info" {
     block_c2HtK_info:
         const _c2HtK;
         const 1;
         const 30;
 },
 _c2HtQ() //  [R1]
         { []
         }
     {offset
       c2HtQ: // global
           _s2E1V::I64 = I64[Sp + 8];
           _s2E1X::I64 = I64[R1 + 7];
           if (_s2E1V::I64 == _s2E1X::I64) goto c2Hu9; else goto c2Hu8;
       c2Hu9: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hu8: // global
           if (_s2E1V::I64 > _s2E1X::I64) goto c2Hu5; else goto c2Hu6;
       c2Hu5: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hu6: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HtQ_info" {
     block_c2HtQ_info:
         const _c2HtQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.804590894 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmax_closure" {
     GHC.Word.$fOrdWord32_$cmax_closure:
         const GHC.Word.$fOrdWord32_$cmax_info;
 },
 GHC.Word.$fOrdWord32_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HuE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HuI; else goto c2HuJ;
       c2HuI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HuJ: // global
           I64[Sp - 16] = block_c2HuB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HuW; else goto c2HuC;
       u2HuW: // global
           call _c2HuB(R1) args: 0, res: 0, upd: 0;
       c2HuC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$cmax_info" {
     GHC.Word.$fOrdWord32_$cmax_info:
         const GHC.Word.$fOrdWord32_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HuB() //  [R1]
         { []
         }
     {offset
       c2HuB: // global
           I64[Sp - 8] = block_c2HuH_info;
           _s2E22::P64 = R1;
           _s2E23::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E23::I64;
           P64[Sp + 8] = _s2E22::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HuV; else goto c2HuL;
       u2HuV: // global
           call _c2HuH(R1) args: 0, res: 0, upd: 0;
       c2HuL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HuB_info" {
     block_c2HuB_info:
         const _c2HuB;
         const 1;
         const 30;
 },
 _c2HuH() //  [R1]
         { []
         }
     {offset
       c2HuH: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2HuT; else goto c2HuU;
       c2HuT: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HuU: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HuH_info" {
     block_c2HuH_info:
         const _c2HuH;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.812637428 UTC

[section ""data" . GHC.Word.$fOrdWord32_$cmin_closure" {
     GHC.Word.$fOrdWord32_$cmin_closure:
         const GHC.Word.$fOrdWord32_$cmin_info;
 },
 GHC.Word.$fOrdWord32_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hvo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hvs; else goto c2Hvt;
       c2Hvs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fOrdWord32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hvt: // global
           I64[Sp - 16] = block_c2Hvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HvG; else goto c2Hvm;
       u2HvG: // global
           call _c2Hvl(R1) args: 0, res: 0, upd: 0;
       c2Hvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fOrdWord32_$cmin_info" {
     GHC.Word.$fOrdWord32_$cmin_info:
         const GHC.Word.$fOrdWord32_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hvl() //  [R1]
         { []
         }
     {offset
       c2Hvl: // global
           I64[Sp - 8] = block_c2Hvr_info;
           _s2E29::P64 = R1;
           _s2E2a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E2a::I64;
           P64[Sp + 8] = _s2E29::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HvF; else goto c2Hvv;
       u2HvF: // global
           call _c2Hvr(R1) args: 0, res: 0, upd: 0;
       c2Hvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hvl_info" {
     block_c2Hvl_info:
         const _c2Hvl;
         const 1;
         const 30;
 },
 _c2Hvr() //  [R1]
         { []
         }
     {offset
       c2Hvr: // global
           if (I64[Sp + 8] > I64[R1 + 7]) goto c2HvD; else goto c2HvE;
       c2HvD: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HvE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hvr_info" {
     block_c2Hvr_info:
         const _c2Hvr;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.820403691 UTC

[section ""data" . GHC.Word.$fOrdWord32_closure" {
     GHC.Word.$fOrdWord32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Word.$fEqWord32_closure+1;
         const GHC.Word.$fOrdWord32_$ccompare_closure+2;
         const GHC.Word.ltWord32_closure+2;
         const GHC.Word.leWord32_closure+2;
         const GHC.Word.gtWord32_closure+2;
         const GHC.Word.geWord32_closure+2;
         const GHC.Word.$fOrdWord32_$cmax_closure+2;
         const GHC.Word.$fOrdWord32_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.824074415 UTC

[section ""data" . GHC.Word.$fIxWord32_$cinRange_closure" {
     GHC.Word.$fIxWord32_$cinRange_closure:
         const GHC.Word.$fIxWord32_$cinRange_info;
 },
 GHC.Word.$fIxWord32_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hw9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2Hwi; else goto c2Hwj;
       c2Hwi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2Hwj: // global
           I64[Sp - 16] = block_c2Hw6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HwG; else goto c2Hw7;
       u2HwG: // global
           call _c2Hw6(R1) args: 0, res: 0, upd: 0;
       c2Hw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cinRange_info" {
     GHC.Word.$fIxWord32_$cinRange_info:
         const GHC.Word.$fIxWord32_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hw6() //  [R1]
         { []
         }
     {offset
       c2Hw6: // global
           I64[Sp - 8] = block_c2Hwc_info;
           _s2E2i::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HwF; else goto c2Hwd;
       u2HwF: // global
           call _c2Hwc(R1) args: 0, res: 0, upd: 0;
       c2Hwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hw6_info" {
     block_c2Hw6_info:
         const _c2Hw6;
         const 1;
         const 30;
 },
 _c2Hwc() //  [R1]
         { []
         }
     {offset
       c2Hwc: // global
           I64[Sp] = block_c2Hwh_info;
           _s2E2k::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E2k::I64;
           if (R1 & 7 != 0) goto u2HwH; else goto c2Hwm;
       u2HwH: // global
           call _c2Hwh(R1) args: 0, res: 0, upd: 0;
       c2Hwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hwc_info" {
     block_c2Hwc_info:
         const _c2Hwc;
         const 2;
         const 30;
 },
 _c2Hwh() //  [R1]
         { []
         }
     {offset
       c2Hwh: // global
           _s2E2m::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E2m::I64) goto c2Hwu; else goto c2Hwy;
       c2Hwu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2Hwy: // global
           _s2E2i::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2Hwx_info;
           R1 = _s2E2i::P64;
           I64[Sp + 16] = _s2E2m::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2HwI; else goto c2Hwz;
       u2HwI: // global
           call _c2Hwx(R1) args: 0, res: 0, upd: 0;
       c2Hwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hwh_info" {
     block_c2Hwh_info:
         const _c2Hwh;
         const 130;
         const 30;
 },
 _c2Hwx() //  [R1]
         { []
         }
     {offset
       c2Hwx: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hwx_info" {
     block_c2Hwx_info:
         const _c2Hwx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.835269351 UTC

[section ""data" . GHC.Word.$fRealWord32_$ctoRational_closure" {
     GHC.Word.$fRealWord32_$ctoRational_closure:
         const GHC.Word.$fRealWord32_$ctoRational_info;
         const 0;
 },
 GHC.Word.$fRealWord32_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c2Hxm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HxD; else goto c2HxE;
       c2HxD: // global
           R2 = R2;
           R1 = GHC.Word.$fRealWord32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HxE: // global
           I64[Sp - 8] = block_c2Hxj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HxL; else goto c2Hxk;
       u2HxL: // global
           call _c2Hxj(R1) args: 0, res: 0, upd: 0;
       c2Hxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fRealWord32_$ctoRational_info" {
     GHC.Word.$fRealWord32_$ctoRational_info:
         const GHC.Word.$fRealWord32_$ctoRational_entry;
         const 0;
         const 4503629692141582;
         const 4294967301;
         const S2Ecg_srt+736;
 },
 _c2Hxj() //  [R1]
         { []
         }
     {offset
       c2Hxj: // global
           I64[Sp] = block_c2Hxs_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hxj_info" {
     block_c2Hxj_info:
         const _c2Hxj;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2Hxs() //  [R1]
         { []
         }
     {offset
       c2Hxs: // global
           I64[Sp] = block_c2Hxw_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hxs_info" {
     block_c2Hxs_info:
         const _c2Hxs;
         const 0;
         const 30064771102;
         const S2Ecg_srt+736;
 },
 _c2Hxw() //  [R1]
         { []
         }
     {offset
       c2Hxw: // global
           I64[Sp] = block_c2HxA_info;
           R3 = GHC.Word.$fRealWord1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hxw_info" {
     block_c2Hxw_info:
         const _c2Hxw;
         const 0;
         const 12884901918;
         const S2Ecg_srt+736;
 },
 _c2HxA() //  [R1, R2]
         { []
         }
     {offset
       c2HxA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c2HxK; else goto c2HxJ;
       c2HxK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c2HxJ: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HxA_info" {
     block_c2HxA_info:
         const _c2HxA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.844523224 UTC

[section ""data" . GHC.Word.$fRealWord32_closure" {
     GHC.Word.$fRealWord32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Word.$fNumWord32_closure+1;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fRealWord32_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.84635381 UTC

[section ""data" . GHC.Word.$fIntegralWord32_closure" {
     GHC.Word.$fIntegralWord32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Word.$fRealWord32_closure+1;
         const GHC.Word.$fEnumWord32_closure+1;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquot_closure+2;
         const GHC.Word.$fIntegralWord32_$crem_closure+2;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure+2;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure+2;
         const GHC.Word.$ctoInteger2_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.850332722 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord32_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord32_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord32_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2Hyj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HyG; else goto c2HyH;
       c2HyG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HyH: // global
           I64[Sp - 16] = block_c2Hyg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HyO; else goto c2Hyh;
       u2HyO: // global
           call _c2Hyg(R1) args: 0, res: 0, upd: 0;
       c2Hyh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cunsafeIndex_info" {
     GHC.Word.$fIxWord32_$cunsafeIndex_info:
         const GHC.Word.$fIxWord32_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2Hyg() //  [R1]
         { []
         }
     {offset
       c2Hyg: // global
           I64[Sp] = block_c2Hym_info;
           _s2E2D::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2E2D::P64;
           if (R1 & 7 != 0) goto u2HyN; else goto c2Hyn;
       u2HyN: // global
           call _c2Hym(R1) args: 0, res: 0, upd: 0;
       c2Hyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hyg_info" {
     block_c2Hyg_info:
         const _c2Hyg;
         const 1;
         const 30;
 },
 _c2Hym() //  [R1]
         { []
         }
     {offset
       c2Hym: // global
           I64[Sp] = block_c2Hyr_info;
           _s2E2G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E2G::I64;
           if (R1 & 7 != 0) goto u2HyP; else goto c2Hys;
       u2HyP: // global
           call _c2Hyr(R1) args: 0, res: 0, upd: 0;
       c2Hys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hym_info" {
     block_c2Hym_info:
         const _c2Hym;
         const 1;
         const 30;
 },
 _c2Hyr() //  [R1]
         { []
         }
     {offset
       c2Hyr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HyM; else goto c2HyL;
       c2HyM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HyL: // global
           _s2E2L::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E2L::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hyr_info" {
     block_c2Hyr_info:
         const _c2Hyr;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.859651457 UTC

[section ""data" . GHC.Word.$fIxWord32_$crange_closure" {
     GHC.Word.$fIxWord32_$crange_closure:
         const GHC.Word.$fIxWord32_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2Hzm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2Hzn; else goto c2Hzo;
       c2Hzn: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2Hzo: // global
           I64[Sp - 8] = block_c2Hzj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2Hzs; else goto c2Hzk;
       u2Hzs: // global
           call _c2Hzj(R1) args: 0, res: 0, upd: 0;
       c2Hzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$crange_info" {
     GHC.Word.$fIxWord32_$crange_info:
         const GHC.Word.$fIxWord32_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+904;
 },
 _c2Hzj() //  [R1]
         { []
         }
     {offset
       c2Hzj: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord32_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2Hzj_info" {
     block_c2Hzj_info:
         const _c2Hzj;
         const 0;
         const 4294967326;
         const S2Ecg_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.866569898 UTC

[section ""data" . GHC.Word.$fIxWord32_$crangeSize_closure" {
     GHC.Word.$fIxWord32_$crangeSize_closure:
         const GHC.Word.$fIxWord32_$crangeSize_info;
 },
 GHC.Word.$fIxWord32_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2HzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HzT; else goto c2HzU;
       c2HzT: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HzU: // global
           I64[Sp - 8] = block_c2HzH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HAp; else goto c2HzI;
       u2HAp: // global
           call _c2HzH(R1) args: 0, res: 0, upd: 0;
       c2HzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$crangeSize_info" {
     GHC.Word.$fIxWord32_$crangeSize_info:
         const GHC.Word.$fIxWord32_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HzH() //  [R1]
         { []
         }
     {offset
       c2HzH: // global
           I64[Sp - 8] = block_c2HzN_info;
           _s2E2T::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E2T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HAo; else goto c2HzO;
       u2HAo: // global
           call _c2HzN(R1) args: 0, res: 0, upd: 0;
       c2HzO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HzH_info" {
     block_c2HzH_info:
         const _c2HzH;
         const 0;
         const 30;
 },
 _c2HzN() //  [R1]
         { []
         }
     {offset
       c2HzN: // global
           I64[Sp] = block_c2HzS_info;
           _s2E2V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E2V::I64;
           if (R1 & 7 != 0) goto u2HAq; else goto c2HzX;
       u2HAq: // global
           call _c2HzS(R1) args: 0, res: 0, upd: 0;
       c2HzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HzN_info" {
     block_c2HzN_info:
         const _c2HzN;
         const 1;
         const 30;
 },
 _c2HzS() //  [R1]
         { []
         }
     {offset
       c2HzS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HA3; else goto c2HA2;
       c2HA3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HA2: // global
           _s2E2V::I64 = I64[Sp + 8];
           _s2E2X::I64 = I64[R1 + 7];
           if (_s2E2V::I64 > _s2E2X::I64) goto c2HA7; else goto c2HAn;
       c2HA7: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HAn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2E2X::I64 - _s2E2V::I64)) + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HzS_info" {
     block_c2HzS_info:
         const _c2HzS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.876777758 UTC

[section ""data" . GHC.Word.$fIxWord32_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord32_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2HAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HBp; else goto c2HBq;
       c2HBp: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HBq: // global
           I64[Sp - 8] = block_c2HAW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HBx; else goto c2HAX;
       u2HBx: // global
           call _c2HAW(R1) args: 0, res: 0, upd: 0;
       c2HAX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord32_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HAW() //  [R1]
         { []
         }
     {offset
       c2HAW: // global
           I64[Sp - 8] = block_c2HB2_info;
           _s2E35::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2E35::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HBw; else goto c2HB3;
       u2HBw: // global
           call _c2HB2(R1) args: 0, res: 0, upd: 0;
       c2HB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HAW_info" {
     block_c2HAW_info:
         const _c2HAW;
         const 0;
         const 30;
 },
 _c2HB2() //  [R1]
         { []
         }
     {offset
       c2HB2: // global
           I64[Sp] = block_c2HB7_info;
           _s2E38::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E38::I64;
           if (R1 & 7 != 0) goto u2HBy; else goto c2HB8;
       u2HBy: // global
           call _c2HB7(R1) args: 0, res: 0, upd: 0;
       c2HB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HB2_info" {
     block_c2HB2_info:
         const _c2HB2;
         const 1;
         const 30;
 },
 _c2HB7() //  [R1]
         { []
         }
     {offset
       c2HB7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HBv; else goto c2HBu;
       c2HBv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HBu: // global
           _s2E3e::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7])) + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E3e::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HB7_info" {
     block_c2HB7_info:
         const _c2HB7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.887192348 UTC

[section ""data" . GHC.Word.$fIxWord32_$cindex_closure" {
     GHC.Word.$fIxWord32_$cindex_closure:
         const GHC.Word.$fIxWord32_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord32_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HC6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HCf; else goto c2HCg;
       c2HCf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HCg: // global
           I64[Sp - 16] = block_c2HC3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HCV; else goto c2HC4;
       u2HCV: // global
           call _c2HC3(R1) args: 0, res: 0, upd: 0;
       c2HC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord32_$cindex_info" {
     GHC.Word.$fIxWord32_$cindex_info:
         const GHC.Word.$fIxWord32_$cindex_entry;
         const 0;
         const 1125904201809934;
         const 8589934607;
         const S2Ecg_srt+776;
 },
 _c2HC3() //  [R1]
         { []
         }
     {offset
       c2HC3: // global
           I64[Sp - 8] = block_c2HC9_info;
           _s2E3j::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E3j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HCU; else goto c2HCa;
       u2HCU: // global
           call _c2HC9(R1) args: 0, res: 0, upd: 0;
       c2HCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HC3_info" {
     block_c2HC3_info:
         const _c2HC3;
         const 1;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HC9() //  [R1]
         { []
         }
     {offset
       c2HC9: // global
           I64[Sp] = block_c2HCe_info;
           _s2E3l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E3l::I64;
           if (R1 & 7 != 0) goto u2HCW; else goto c2HCj;
       u2HCW: // global
           call _c2HCe(R1) args: 0, res: 0, upd: 0;
       c2HCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HC9_info" {
     block_c2HC9_info:
         const _c2HC9;
         const 2;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HCe() //  [R1]
         { []
         }
     {offset
       c2HCe: // global
           _s2E3n::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E3n::I64) goto c2HCr; else goto c2HCv;
       c2HCr: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HCv: // global
           I64[Sp] = block_c2HCu_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E3n::I64;
           if (R1 & 7 != 0) goto u2HCX; else goto c2HCw;
       u2HCX: // global
           call _c2HCu(R1) args: 0, res: 0, upd: 0;
       c2HCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HCe_info" {
     block_c2HCe_info:
         const _c2HCe;
         const 130;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HCu() //  [R1]
         { []
         }
     {offset
       c2HCu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HCC; else goto c2HCB;
       c2HCC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HCB: // global
           _s2E3n::I64 = I64[Sp + 8];
           if (_s2E3n::I64 > I64[R1 + 7]) goto c2HCG; else goto c2HCT;
       c2HCG: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HCT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s2E3n::I64 - I64[Sp + 16]));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HCu_info" {
     block_c2HCu_info:
         const _c2HCu;
         const 194;
         const 4294967326;
         const S2Ecg_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.898175301 UTC

[section ""data" . GHC.Word.$fIxWord32_closure" {
     GHC.Word.$fIxWord32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord32_closure+1;
         const GHC.Word.$fIxWord32_$crange_closure+1;
         const GHC.Word.$fIxWord32_$cindex_closure+2;
         const GHC.Word.$fIxWord32_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord32_$cinRange_closure+2;
         const GHC.Word.$fIxWord32_$crangeSize_closure+1;
         const GHC.Word.$fIxWord32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.901021596 UTC

[section ""data" . GHC.Word.byteSwap32_closure" {
     GHC.Word.byteSwap32_closure:
         const GHC.Word.byteSwap32_info;
 },
 GHC.Word.byteSwap32_entry() //  [R2]
         { []
         }
     {offset
       c2HDC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HDN; else goto c2HDO;
       c2HDN: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap32_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HDO: // global
           I64[Sp - 8] = block_c2HDz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HDS; else goto c2HDA;
       u2HDS: // global
           call _c2HDz(R1) args: 0, res: 0, upd: 0;
       c2HDA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap32_info" {
     GHC.Word.byteSwap32_info:
         const GHC.Word.byteSwap32_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HDz() //  [R1]
         { []
         }
     {offset
       c2HDz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HDR; else goto c2HDQ;
       c2HDR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HDQ: // global
           (_c2HDF::I64) = call MO_BSwap W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_c2HDF::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HDz_info" {
     block_c2HDz_info:
         const _c2HDz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.906996859 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplement_closure" {
     GHC.Word.$fBitsWord64_$ccomplement_closure:
         const GHC.Word.$fBitsWord64_$ccomplement_info;
 },
 GHC.Word.$fBitsWord64_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c2HEd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HEk; else goto c2HEl;
       c2HEk: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HEl: // global
           I64[Sp - 8] = block_c2HEa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HEp; else goto c2HEb;
       u2HEp: // global
           call _c2HEa(R1) args: 0, res: 0, upd: 0;
       c2HEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ccomplement_info" {
     GHC.Word.$fBitsWord64_$ccomplement_info:
         const GHC.Word.$fBitsWord64_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HEa() //  [R1]
         { []
         }
     {offset
       c2HEa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HEo; else goto c2HEn;
       c2HEo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HEn: // global
           _s2E3D::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E3D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HEa_info" {
     block_c2HEa_info:
         const _c2HEa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.911965813 UTC

[section ""data" . GHC.Word.$fBitsWord6_closure" {
     GHC.Word.$fBitsWord6_closure:
         const GHC.Base.Just_con_info;
         const GHC.Word.$fBitsWord5_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.915136266 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_info;
 },
 GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c2HEI: // global
           R1 = GHC.Word.$fBitsWord6_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cbitSizeMaybe_info" {
     GHC.Word.$fBitsWord64_$cbitSizeMaybe_info:
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.919415105 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cbit_closure" {
     GHC.Word.$fBitsWord64_$cbit_closure:
         const GHC.Word.$fBitsWord64_$cbit_info;
 },
 GHC.Word.$fBitsWord64_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c2HEX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HEY; else goto c2HEZ;
       c2HEY: // global
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HEZ: // global
           I64[Sp - 8] = block_c2HEU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HFf; else goto c2HEV;
       u2HFf: // global
           call _c2HEU(R1) args: 0, res: 0, upd: 0;
       c2HEV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cbit_info" {
     GHC.Word.$fBitsWord64_$cbit_info:
         const GHC.Word.$fBitsWord64_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HEU() //  [R1]
         { []
         }
     {offset
       c2HEU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HF4; else goto c2HF3;
       c2HF4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HF3: // global
           _s2E3H::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E3H::I64, 64)) goto c2HFd; else goto c2HFe;
       c2HFd: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = 1 << _s2E3H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HFe: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fBitsWord7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HEU_info" {
     block_c2HEU_info:
         const _c2HEU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.925982932 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ctestBit_closure" {
     GHC.Word.$fBitsWord64_$ctestBit_closure:
         const GHC.Word.$fBitsWord64_$ctestBit_info;
 },
 GHC.Word.$fBitsWord64_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HFB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HFF; else goto c2HFG;
       c2HFF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HFG: // global
           I64[Sp - 16] = block_c2HFy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HGc; else goto c2HFz;
       u2HGc: // global
           call _c2HFy(R1) args: 0, res: 0, upd: 0;
       c2HFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ctestBit_info" {
     GHC.Word.$fBitsWord64_$ctestBit_info:
         const GHC.Word.$fBitsWord64_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HFy() //  [R1]
         { []
         }
     {offset
       c2HFy: // global
           I64[Sp] = block_c2HFE_info;
           _s2E3N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E3N::I64;
           if (R1 & 7 != 0) goto u2HGb; else goto c2HFI;
       u2HGb: // global
           call _c2HFE(R1) args: 0, res: 0, upd: 0;
       c2HFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HFy_info" {
     block_c2HFy_info:
         const _c2HFy;
         const 1;
         const 30;
 },
 _c2HFE() //  [R1]
         { []
         }
     {offset
       c2HFE: // global
           _s2E3P::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s2E3P::I64, 64)) goto c2HGa; else goto c2HG9;
       c2HG9: // global
           if (I64[Sp + 8] & (1 << _s2E3P::I64) == 0) goto c2HGa; else goto c2HFY;
       c2HGa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HFY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HFE_info" {
     block_c2HFE_info:
         const _c2HFE;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.93529743 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateR_closure" {
     GHC.Word.$fBitsWord64_$crotateR_closure:
         const GHC.Word.$fBitsWord64_$crotateR_info;
 },
 GHC.Word.$fBitsWord64_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HGG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HGK; else goto c2HGL;
       c2HGK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HGL: // global
           I64[Sp - 16] = block_c2HGD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HHy; else goto c2HGE;
       u2HHy: // global
           call _c2HGD(R1) args: 0, res: 0, upd: 0;
       c2HGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotateR_info" {
     GHC.Word.$fBitsWord64_$crotateR_info:
         const GHC.Word.$fBitsWord64_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HGD() //  [R1]
         { []
         }
     {offset
       c2HGD: // global
           I64[Sp - 8] = block_c2HGJ_info;
           _s2E3V::P64 = R1;
           _s2E3W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E3W::I64;
           P64[Sp + 8] = _s2E3V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HHx; else goto c2HGN;
       u2HHx: // global
           call _c2HGJ(R1) args: 0, res: 0, upd: 0;
       c2HGN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HGD_info" {
     block_c2HGD_info:
         const _c2HGD;
         const 1;
         const 30;
 },
 _c2HGJ() //  [R1]
         { []
         }
     {offset
       c2HGJ: // global
           _s2E42::I64 = -I64[R1 + 7] & 63;
           if (_s2E42::I64 != 0) goto u2HHv; else goto c2HHr;
       u2HHv: // global
           I64[Sp + 16] = _s2E42::I64;
           Sp = Sp + 8;
           call _c2HH5() args: 0, res: 0, upd: 0;
       c2HHr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HGJ_info" {
     block_c2HGJ_info:
         const _c2HGJ;
         const 66;
         const 30;
 },
 _c2HH5() //  []
         { []
         }
     {offset
       c2HH5: // global
           Hp = Hp + 16;
           _s2E42::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c2HHo; else goto c2HHn;
       c2HHo: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c2HH4_info;
           R1 = _s2E42::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c2HHn: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           _s2E3W::I64 = I64[Sp];
           I64[Hp] = (_s2E3W::I64 << _s2E42::I64) | (_s2E3W::I64 >> 64 - _s2E42::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2HH4() //  [R1]
         { []
         }
     {offset
       c2HH4: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c2HH5() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c2HH4_info" {
     block_c2HH4_info:
         const _c2HH4;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.945957152 UTC

[section ""data" . GHC.Word.$fBitsWord64_$ccomplementBit_closure" {
     GHC.Word.$fBitsWord64_$ccomplementBit_closure:
         const GHC.Word.$fBitsWord64_$ccomplementBit_info;
 },
 GHC.Word.$fBitsWord64_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HId: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HIh; else goto c2HIi;
       c2HIh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HIi: // global
           I64[Sp - 16] = block_c2HIa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HIF; else goto c2HIb;
       u2HIF: // global
           call _c2HIa(R1) args: 0, res: 0, upd: 0;
       c2HIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$ccomplementBit_info" {
     GHC.Word.$fBitsWord64_$ccomplementBit_info:
         const GHC.Word.$fBitsWord64_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HIa() //  [R1]
         { []
         }
     {offset
       c2HIa: // global
           I64[Sp - 8] = block_c2HIg_info;
           _s2E49::P64 = R1;
           _s2E4a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E4a::I64;
           P64[Sp + 8] = _s2E49::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HIE; else goto c2HIk;
       u2HIE: // global
           call _c2HIg(R1) args: 0, res: 0, upd: 0;
       c2HIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HIa_info" {
     block_c2HIa_info:
         const _c2HIa;
         const 1;
         const 30;
 },
 _c2HIg() //  [R1]
         { []
         }
     {offset
       c2HIg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HIq; else goto c2HIp;
       c2HIq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HIp: // global
           _s2E4c::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4c::I64, 64)) goto c2HIC; else goto c2HID;
       c2HIC: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s2E4c::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HID: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HIg_info" {
     block_c2HIg_info:
         const _c2HIg;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.954822211 UTC

[section ""data" . GHC.Word.$fBitsWord64_$cclearBit_closure" {
     GHC.Word.$fBitsWord64_$cclearBit_closure:
         const GHC.Word.$fBitsWord64_$cclearBit_info;
 },
 GHC.Word.$fBitsWord64_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HJd; else goto c2HJe;
       c2HJd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HJe: // global
           I64[Sp - 16] = block_c2HJ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HJJ; else goto c2HJ7;
       u2HJJ: // global
           call _c2HJ6(R1) args: 0, res: 0, upd: 0;
       c2HJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$cclearBit_info" {
     GHC.Word.$fBitsWord64_$cclearBit_info:
         const GHC.Word.$fBitsWord64_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HJ6() //  [R1]
         { []
         }
     {offset
       c2HJ6: // global
           I64[Sp] = block_c2HJc_info;
           _s2E4j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E4j::I64;
           if (R1 & 7 != 0) goto u2HJI; else goto c2HJg;
       u2HJI: // global
           call _c2HJc(R1) args: 0, res: 0, upd: 0;
       c2HJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HJ6_info" {
     block_c2HJ6_info:
         const _c2HJ6;
         const 1;
         const 30;
 },
 _c2HJc() //  [R1]
         { []
         }
     {offset
       c2HJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HJm; else goto c2HJl;
       c2HJm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HJl: // global
           _s2E4j::I64 = I64[Sp + 8];
           _s2E4l::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4l::I64, 64)) goto c2HJB; else goto c2HJH;
       c2HJB: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E4j::I64 & (1 << _s2E4l::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HJH: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s2E4j::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HJc_info" {
     block_c2HJc_info:
         const _c2HJc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.963182189 UTC

[section ""data" . GHC.Word.$fBitsWord64_$csetBit_closure" {
     GHC.Word.$fBitsWord64_$csetBit_closure:
         const GHC.Word.$fBitsWord64_$csetBit_info;
 },
 GHC.Word.$fBitsWord64_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HKh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HKl; else goto c2HKm;
       c2HKl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fBitsWord64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HKm: // global
           I64[Sp - 16] = block_c2HKe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HKJ; else goto c2HKf;
       u2HKJ: // global
           call _c2HKe(R1) args: 0, res: 0, upd: 0;
       c2HKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$csetBit_info" {
     GHC.Word.$fBitsWord64_$csetBit_info:
         const GHC.Word.$fBitsWord64_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HKe() //  [R1]
         { []
         }
     {offset
       c2HKe: // global
           I64[Sp - 8] = block_c2HKk_info;
           _s2E4t::P64 = R1;
           _s2E4u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s2E4u::I64;
           P64[Sp + 8] = _s2E4t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HKI; else goto c2HKo;
       u2HKI: // global
           call _c2HKk(R1) args: 0, res: 0, upd: 0;
       c2HKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HKe_info" {
     block_c2HKe_info:
         const _c2HKe;
         const 1;
         const 30;
 },
 _c2HKk() //  [R1]
         { []
         }
     {offset
       c2HKk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HKu; else goto c2HKt;
       c2HKu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HKt: // global
           _s2E4w::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s2E4w::I64, 64)) goto c2HKG; else goto c2HKH;
       c2HKG: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s2E4w::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HKH: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HKk_info" {
     block_c2HKk_info:
         const _c2HKk;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.971488201 UTC

[section ""data" . GHC.Word.$fBitsWord64_$crotateL_closure" {
     GHC.Word.$fBitsWord64_$crotateL_closure:
         const GHC.Word.$fBitsWord64_$crotateL_info;
 },
 GHC.Word.$fBitsWord64_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HLa: // global
           R3 = R3;
           R2 = R2;
           call GHC.Word.$fBitsWord64_$crotate_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fBitsWord64_$crotateL_info" {
     GHC.Word.$fBitsWord64_$crotateL_info:
         const GHC.Word.$fBitsWord64_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.974643303 UTC

[section ""data" . GHC.Word.$fBitsWord64_closure" {
     GHC.Word.$fBitsWord64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Word.$fEqWord64_closure+1;
         const GHC.Word.$fBitsWord64_$c.&._closure+2;
         const GHC.Word.$fBitsWord64_$c.|._closure+2;
         const GHC.Word.$fBitsWord64_$cxor_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplement_closure+1;
         const GHC.Word.$fBitsWord64_$cshift_closure+2;
         const GHC.Word.$fBitsWord64_$crotate_closure+2;
         const GHC.Word.$fBitsWord7_closure+1;
         const GHC.Word.$fBitsWord64_$cbit_closure+1;
         const GHC.Word.$fBitsWord64_$csetBit_closure+2;
         const GHC.Word.$fBitsWord64_$cclearBit_closure+2;
         const GHC.Word.$fBitsWord64_$ccomplementBit_closure+2;
         const GHC.Word.$fBitsWord64_$ctestBit_closure+2;
         const GHC.Word.$fBitsWord64_$cbitSizeMaybe_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fBitsWord64_$cisSigned_closure+1;
         const GHC.Word.$fBitsWord64_$cshiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftL_closure+2;
         const GHC.Word.$fBitsWord64_$cshiftR_closure+2;
         const GHC.Word.$fBitsWord64_$cunsafeShiftR_closure+2;
         const GHC.Word.$fBitsWord64_$crotateL_closure+2;
         const GHC.Word.$fBitsWord64_$crotateR_closure+2;
         const GHC.Word.$fBitsWord64_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.976604003 UTC

[section ""data" . GHC.Word.$fFiniteBitsWord64_closure" {
     GHC.Word.$fFiniteBitsWord64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Word.$fBitsWord64_closure+1;
         const GHC.Word.$fBitsWord64_$cfiniteBitSize_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros_closure+1;
         const GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.980355531 UTC

[section ""data" . GHC.Word.$fIxWord64_$cinRange_closure" {
     GHC.Word.$fIxWord64_$cinRange_closure:
         const GHC.Word.$fIxWord64_$cinRange_info;
 },
 GHC.Word.$fIxWord64_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HLq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HLz; else goto c2HLA;
       c2HLz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HLA: // global
           I64[Sp - 16] = block_c2HLn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HLX; else goto c2HLo;
       u2HLX: // global
           call _c2HLn(R1) args: 0, res: 0, upd: 0;
       c2HLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cinRange_info" {
     GHC.Word.$fIxWord64_$cinRange_info:
         const GHC.Word.$fIxWord64_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HLn() //  [R1]
         { []
         }
     {offset
       c2HLn: // global
           I64[Sp - 8] = block_c2HLt_info;
           _s2E4E::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E4E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HLW; else goto c2HLu;
       u2HLW: // global
           call _c2HLt(R1) args: 0, res: 0, upd: 0;
       c2HLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HLn_info" {
     block_c2HLn_info:
         const _c2HLn;
         const 1;
         const 30;
 },
 _c2HLt() //  [R1]
         { []
         }
     {offset
       c2HLt: // global
           I64[Sp] = block_c2HLy_info;
           _s2E4G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E4G::I64;
           if (R1 & 7 != 0) goto u2HLY; else goto c2HLD;
       u2HLY: // global
           call _c2HLy(R1) args: 0, res: 0, upd: 0;
       c2HLD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HLt_info" {
     block_c2HLt_info:
         const _c2HLt;
         const 2;
         const 30;
 },
 _c2HLy() //  [R1]
         { []
         }
     {offset
       c2HLy: // global
           _s2E4I::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E4I::I64) goto c2HLL; else goto c2HLP;
       c2HLL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HLP: // global
           _s2E4E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c2HLO_info;
           R1 = _s2E4E::P64;
           I64[Sp + 16] = _s2E4I::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u2HLZ; else goto c2HLQ;
       u2HLZ: // global
           call _c2HLO(R1) args: 0, res: 0, upd: 0;
       c2HLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HLy_info" {
     block_c2HLy_info:
         const _c2HLy;
         const 130;
         const 30;
 },
 _c2HLO() //  [R1]
         { []
         }
     {offset
       c2HLO: // global
           R1 = I64[((I64[Sp + 8] <= I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HLO_info" {
     block_c2HLO_info:
         const _c2HLO;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.990957466 UTC

[section ""data" . GHC.Word.$fIxWord64_$crange_closure" {
     GHC.Word.$fIxWord64_$crange_closure:
         const GHC.Word.$fIxWord64_$crange_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$crange_entry() //  [R2]
         { []
         }
     {offset
       c2HMD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HME; else goto c2HMF;
       c2HME: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HMF: // global
           I64[Sp - 8] = block_c2HMA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HMJ; else goto c2HMB;
       u2HMJ: // global
           call _c2HMA(R1) args: 0, res: 0, upd: 0;
       c2HMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$crange_info" {
     GHC.Word.$fIxWord64_$crange_info:
         const GHC.Word.$fIxWord64_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S2Ecg_srt+928;
 },
 _c2HMA() //  [R1]
         { []
         }
     {offset
       c2HMA: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Word.$fEnumWord64_$cenumFromTo_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HMA_info" {
     block_c2HMA_info:
         const _c2HMA;
         const 0;
         const 4294967326;
         const S2Ecg_srt+928;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:24.996996831 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeIndex_closure" {
     GHC.Word.$fIxWord64_$cunsafeIndex_closure:
         const GHC.Word.$fIxWord64_$cunsafeIndex_info;
 },
 GHC.Word.$fIxWord64_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HNl; else goto c2HNm;
       c2HNl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HNm: // global
           I64[Sp - 16] = block_c2HMY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HNt; else goto c2HMZ;
       u2HNt: // global
           call _c2HMY(R1) args: 0, res: 0, upd: 0;
       c2HMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cunsafeIndex_info" {
     GHC.Word.$fIxWord64_$cunsafeIndex_info:
         const GHC.Word.$fIxWord64_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c2HMY() //  [R1]
         { []
         }
     {offset
       c2HMY: // global
           I64[Sp] = block_c2HN4_info;
           _s2E4U::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s2E4U::P64;
           if (R1 & 7 != 0) goto u2HNs; else goto c2HN5;
       u2HNs: // global
           call _c2HN4(R1) args: 0, res: 0, upd: 0;
       c2HN5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HMY_info" {
     block_c2HMY_info:
         const _c2HMY;
         const 1;
         const 30;
 },
 _c2HN4() //  [R1]
         { []
         }
     {offset
       c2HN4: // global
           I64[Sp] = block_c2HN9_info;
           _s2E4X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E4X::I64;
           if (R1 & 7 != 0) goto u2HNu; else goto c2HNa;
       u2HNu: // global
           call _c2HN9(R1) args: 0, res: 0, upd: 0;
       c2HNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HN4_info" {
     block_c2HN4_info:
         const _c2HN4;
         const 1;
         const 30;
 },
 _c2HN9() //  [R1]
         { []
         }
     {offset
       c2HN9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HNr; else goto c2HNq;
       c2HNr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HNq: // global
           _s2E51::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E51::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HN9_info" {
     block_c2HN9_info:
         const _c2HN9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.006968161 UTC

[section ""data" . GHC.Word.$fIxWord64_$crangeSize_closure" {
     GHC.Word.$fIxWord64_$crangeSize_closure:
         const GHC.Word.$fIxWord64_$crangeSize_info;
 },
 GHC.Word.$fIxWord64_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2HO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HO9; else goto c2HOa;
       c2HO9: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HOa: // global
           I64[Sp - 8] = block_c2HNX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HOC; else goto c2HNY;
       u2HOC: // global
           call _c2HNX(R1) args: 0, res: 0, upd: 0;
       c2HNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$crangeSize_info" {
     GHC.Word.$fIxWord64_$crangeSize_info:
         const GHC.Word.$fIxWord64_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HNX() //  [R1]
         { []
         }
     {offset
       c2HNX: // global
           I64[Sp - 8] = block_c2HO3_info;
           _s2E55::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E55::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HOB; else goto c2HO4;
       u2HOB: // global
           call _c2HO3(R1) args: 0, res: 0, upd: 0;
       c2HO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HNX_info" {
     block_c2HNX_info:
         const _c2HNX;
         const 0;
         const 30;
 },
 _c2HO3() //  [R1]
         { []
         }
     {offset
       c2HO3: // global
           I64[Sp] = block_c2HO8_info;
           _s2E57::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E57::I64;
           if (R1 & 7 != 0) goto u2HOD; else goto c2HOd;
       u2HOD: // global
           call _c2HO8(R1) args: 0, res: 0, upd: 0;
       c2HOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HO3_info" {
     block_c2HO3_info:
         const _c2HO3;
         const 1;
         const 30;
 },
 _c2HO8() //  [R1]
         { []
         }
     {offset
       c2HO8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HOj; else goto c2HOi;
       c2HOj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HOi: // global
           _s2E57::I64 = I64[Sp + 8];
           _s2E59::I64 = I64[R1 + 7];
           if (_s2E57::I64 > _s2E59::I64) goto c2HOn; else goto c2HOA;
       c2HOn: // global
           Hp = Hp - 16;
           R1 = GHC.Word.$fIxWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2HOA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E59::I64 - _s2E57::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HO8_info" {
     block_c2HO8_info:
         const _c2HO8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.016486122 UTC

[section ""data" . GHC.Word.$fIxWord64_$cunsafeRangeSize_closure" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_closure:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_info;
 },
 GHC.Word.$fIxWord64_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c2HPb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c2HPy; else goto c2HPz;
       c2HPy: // global
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HPz: // global
           I64[Sp - 8] = block_c2HP8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HPG; else goto c2HP9;
       u2HPG: // global
           call _c2HP8(R1) args: 0, res: 0, upd: 0;
       c2HP9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cunsafeRangeSize_info" {
     GHC.Word.$fIxWord64_$cunsafeRangeSize_info:
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HP8() //  [R1]
         { []
         }
     {offset
       c2HP8: // global
           I64[Sp - 8] = block_c2HPe_info;
           _s2E5g::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s2E5g::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HPF; else goto c2HPf;
       u2HPF: // global
           call _c2HPe(R1) args: 0, res: 0, upd: 0;
       c2HPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HP8_info" {
     block_c2HP8_info:
         const _c2HP8;
         const 0;
         const 30;
 },
 _c2HPe() //  [R1]
         { []
         }
     {offset
       c2HPe: // global
           I64[Sp] = block_c2HPj_info;
           _s2E5j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E5j::I64;
           if (R1 & 7 != 0) goto u2HPH; else goto c2HPk;
       u2HPH: // global
           call _c2HPj(R1) args: 0, res: 0, upd: 0;
       c2HPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HPe_info" {
     block_c2HPe_info:
         const _c2HPe;
         const 1;
         const 30;
 },
 _c2HPj() //  [R1]
         { []
         }
     {offset
       c2HPj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HPE; else goto c2HPD;
       c2HPE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HPD: // global
           _s2E5o::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E5o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HPj_info" {
     block_c2HPj_info:
         const _c2HPj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.026759364 UTC

[section ""data" . GHC.Word.$fIxWord64_$cindex_closure" {
     GHC.Word.$fIxWord64_$cindex_closure:
         const GHC.Word.$fIxWord64_$cindex_info;
         const 0;
 },
 GHC.Word.$fIxWord64_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HQe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2HQn; else goto c2HQo;
       c2HQn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Word.$fIxWord64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2HQo: // global
           I64[Sp - 16] = block_c2HQb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2HR0; else goto c2HQc;
       u2HR0: // global
           call _c2HQb(R1) args: 0, res: 0, upd: 0;
       c2HQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.$fIxWord64_$cindex_info" {
     GHC.Word.$fIxWord64_$cindex_info:
         const GHC.Word.$fIxWord64_$cindex_entry;
         const 0;
         const 9007203549708302;
         const 8589934607;
         const S2Ecg_srt+776;
 },
 _c2HQb() //  [R1]
         { []
         }
     {offset
       c2HQb: // global
           I64[Sp - 8] = block_c2HQh_info;
           _s2E5t::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s2E5t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HQZ; else goto c2HQi;
       u2HQZ: // global
           call _c2HQh(R1) args: 0, res: 0, upd: 0;
       c2HQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HQb_info" {
     block_c2HQb_info:
         const _c2HQb;
         const 1;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HQh() //  [R1]
         { []
         }
     {offset
       c2HQh: // global
           I64[Sp] = block_c2HQm_info;
           _s2E5v::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s2E5v::I64;
           if (R1 & 7 != 0) goto u2HR1; else goto c2HQr;
       u2HR1: // global
           call _c2HQm(R1) args: 0, res: 0, upd: 0;
       c2HQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HQh_info" {
     block_c2HQh_info:
         const _c2HQh;
         const 2;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HQm() //  [R1]
         { []
         }
     {offset
       c2HQm: // global
           _s2E5x::I64 = I64[R1 + 7];
           if (I64[Sp + 16] > _s2E5x::I64) goto c2HQz; else goto c2HQD;
       c2HQz: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HQD: // global
           I64[Sp] = block_c2HQC_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s2E5x::I64;
           if (R1 & 7 != 0) goto u2HR2; else goto c2HQE;
       u2HR2: // global
           call _c2HQC(R1) args: 0, res: 0, upd: 0;
       c2HQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HQm_info" {
     block_c2HQm_info:
         const _c2HQm;
         const 130;
         const 4294967326;
         const S2Ecg_srt+776;
 },
 _c2HQC() //  [R1]
         { []
         }
     {offset
       c2HQC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HQK; else goto c2HQJ;
       c2HQK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HQJ: // global
           _s2E5x::I64 = I64[Sp + 8];
           if (_s2E5x::I64 > I64[R1 + 7]) goto c2HQO; else goto c2HQY;
       c2HQO: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c2HQY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s2E5x::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HQC_info" {
     block_c2HQC_info:
         const _c2HQC;
         const 194;
         const 4294967326;
         const S2Ecg_srt+776;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.036847458 UTC

[section ""data" . GHC.Word.$fIxWord64_closure" {
     GHC.Word.$fIxWord64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Word.$fOrdWord64_closure+1;
         const GHC.Word.$fIxWord64_$crange_closure+1;
         const GHC.Word.$fIxWord64_$cindex_closure+2;
         const GHC.Word.$fIxWord64_$cunsafeIndex_closure+2;
         const GHC.Word.$fIxWord64_$cinRange_closure+2;
         const GHC.Word.$fIxWord64_$crangeSize_closure+1;
         const GHC.Word.$fIxWord64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.039242691 UTC

[section ""data" . GHC.Word.uncheckedShiftL64#_closure" {
     GHC.Word.uncheckedShiftL64#_closure:
         const GHC.Word.uncheckedShiftL64#_info;
 },
 GHC.Word.uncheckedShiftL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HRE: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.uncheckedShiftL64#_info" {
     GHC.Word.uncheckedShiftL64#_info:
         const GHC.Word.uncheckedShiftL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.043283655 UTC

[section ""data" . GHC.Word.uncheckedShiftRL64#_closure" {
     GHC.Word.uncheckedShiftRL64#_closure:
         const GHC.Word.uncheckedShiftRL64#_info;
 },
 GHC.Word.uncheckedShiftRL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c2HRS: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.uncheckedShiftRL64#_info" {
     GHC.Word.uncheckedShiftRL64#_info:
         const GHC.Word.uncheckedShiftRL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.047160428 UTC

[section ""data" . GHC.Word.byteSwap64_closure" {
     GHC.Word.byteSwap64_closure:
         const GHC.Word.byteSwap64_info;
 },
 GHC.Word.byteSwap64_entry() //  [R2]
         { []
         }
     {offset
       c2HS8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2HSg; else goto c2HSh;
       c2HSg: // global
           R2 = R2;
           R1 = GHC.Word.byteSwap64_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HSh: // global
           I64[Sp - 8] = block_c2HS5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2HSl; else goto c2HS6;
       u2HSl: // global
           call _c2HS5(R1) args: 0, res: 0, upd: 0;
       c2HS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.byteSwap64_info" {
     GHC.Word.byteSwap64_info:
         const GHC.Word.byteSwap64_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c2HS5() //  [R1]
         { []
         }
     {offset
       c2HS5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HSk; else goto c2HSj;
       c2HSk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2HSj: // global
           (_c2HSb::I64) = call MO_BSwap W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _c2HSb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c2HS5_info" {
     block_c2HS5_info:
         const _c2HS5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.05205775 UTC

[section ""cstring" . GHC.Word.$trModule4_bytes" {
     GHC.Word.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.054032365 UTC

[section ""data" . GHC.Word.$trModule3_closure" {
     GHC.Word.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.055581997 UTC

[section ""cstring" . GHC.Word.$trModule2_bytes" {
     GHC.Word.$trModule2_bytes:
         I8[] [71,72,67,46,87,111,114,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.057190805 UTC

[section ""data" . GHC.Word.$trModule1_closure" {
     GHC.Word.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.058959242 UTC

[section ""data" . GHC.Word.$trModule_closure" {
     GHC.Word.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Word.$trModule3_closure+1;
         const GHC.Word.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.060677949 UTC

[section ""data" . $krep_r2uFN_closure" {
     $krep_r2uFN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWord#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.062338061 UTC

[section ""data" . GHC.Word.$tcWord7_closure" {
     GHC.Word.$tcWord7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord9_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.063946462 UTC

[section ""data" . GHC.Word.$tcWord8_closure" {
     GHC.Word.$tcWord8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord7_closure+1;
         const GHC.Types.krep$*_closure;
         const 2052113150978616866;
         const 10393726928463219846;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.065704555 UTC

[section ""data" . $krep1_r2uFO_closure" {
     $krep1_r2uFO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.0678652 UTC

[section ""data" . GHC.Word.$tc'W8#1_closure" {
     GHC.Word.$tc'W8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep1_r2uFO_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.069879164 UTC

[section ""cstring" . GHC.Word.$tc'W8#3_bytes" {
     GHC.Word.$tc'W8#3_bytes:
         I8[] [39,87,56,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.071543896 UTC

[section ""data" . GHC.Word.$tc'W8#2_closure" {
     GHC.Word.$tc'W8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W8#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.073217846 UTC

[section ""data" . GHC.Word.$tc'W8#_closure" {
     GHC.Word.$tc'W8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W8#2_closure+1;
         const GHC.Word.$tc'W8#1_closure+4;
         const 12964227823649101302;
         const 11115249754126507208;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.074964224 UTC

[section ""data" . GHC.Word.$tcWord1_closure" {
     GHC.Word.$tcWord1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.076597198 UTC

[section ""data" . GHC.Word.$tcWord16_closure" {
     GHC.Word.$tcWord16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1884349046328127494;
         const 12602100146125136909;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.07840003 UTC

[section ""data" . $krep2_r2uFP_closure" {
     $krep2_r2uFP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.080050731 UTC

[section ""data" . GHC.Word.$tc'W16#1_closure" {
     GHC.Word.$tc'W16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep2_r2uFP_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.081961731 UTC

[section ""cstring" . GHC.Word.$tc'W16#3_bytes" {
     GHC.Word.$tc'W16#3_bytes:
         I8[] [39,87,49,54,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.083553682 UTC

[section ""data" . GHC.Word.$tc'W16#2_closure" {
     GHC.Word.$tc'W16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W16#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.08521696 UTC

[section ""data" . GHC.Word.$tc'W16#_closure" {
     GHC.Word.$tc'W16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W16#2_closure+1;
         const GHC.Word.$tc'W16#1_closure+4;
         const 13828125037659739325;
         const 16689402625363715300;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.086964229 UTC

[section ""data" . GHC.Word.$tcWord3_closure" {
     GHC.Word.$tcWord3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.088662781 UTC

[section ""data" . GHC.Word.$tcWord32_closure" {
     GHC.Word.$tcWord32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord3_closure+1;
         const GHC.Types.krep$*_closure;
         const 3293767376230595825;
         const 2424786049275339072;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.090449414 UTC

[section ""data" . $krep3_r2uFQ_closure" {
     $krep3_r2uFQ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.092482302 UTC

[section ""data" . GHC.Word.$tc'W32#1_closure" {
     GHC.Word.$tc'W32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep3_r2uFQ_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.094880054 UTC

[section ""cstring" . GHC.Word.$tc'W32#3_bytes" {
     GHC.Word.$tc'W32#3_bytes:
         I8[] [39,87,51,50,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.096440144 UTC

[section ""data" . GHC.Word.$tc'W32#2_closure" {
     GHC.Word.$tc'W32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W32#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.098198811 UTC

[section ""data" . GHC.Word.$tc'W32#_closure" {
     GHC.Word.$tc'W32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W32#2_closure+1;
         const GHC.Word.$tc'W32#1_closure+4;
         const 15609358257729636621;
         const 4567728021977807739;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.099987806 UTC

[section ""data" . GHC.Word.$tcWord5_closure" {
     GHC.Word.$tcWord5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tcWord6_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.101760349 UTC

[section ""data" . GHC.Word.$tcWord64_closure" {
     GHC.Word.$tcWord64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tcWord5_closure+1;
         const GHC.Types.krep$*_closure;
         const 3342358330123258062;
         const 10610880953247303810;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.103508247 UTC

[section ""data" . $krep4_r2uFR_closure" {
     $krep4_r2uFR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.105233636 UTC

[section ""data" . GHC.Word.$tc'W64#1_closure" {
     GHC.Word.$tc'W64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r2uFN_closure+1;
         const $krep4_r2uFR_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.106906285 UTC

[section ""cstring" . GHC.Word.$tc'W64#3_bytes" {
     GHC.Word.$tc'W64#3_bytes:
         I8[] [39,87,54,52,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.108532982 UTC

[section ""data" . GHC.Word.$tc'W64#2_closure" {
     GHC.Word.$tc'W64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Word.$tc'W64#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.110275228 UTC

[section ""data" . GHC.Word.$tc'W64#_closure" {
     GHC.Word.$tc'W64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Word.$trModule_closure+1;
         const GHC.Word.$tc'W64#2_closure+1;
         const GHC.Word.$tc'W64#1_closure+4;
         const 3390197976568817661;
         const 1176743391454549598;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.112608581 UTC

[section ""data" . GHC.Word.W8#_closure" {
     GHC.Word.W8#_closure:
         const GHC.Word.W8#_info;
 },
 GHC.Word.W8#_entry() //  [R2]
         { []
         }
     {offset
       c2HTb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTf; else goto c2HTe;
       c2HTf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTe: // global
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W8#_info" {
     GHC.Word.W8#_info:
         const GHC.Word.W8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.116384351 UTC

[section ""data" . GHC.Word.W16#_closure" {
     GHC.Word.W16#_closure:
         const GHC.Word.W16#_info;
 },
 GHC.Word.W16#_entry() //  [R2]
         { []
         }
     {offset
       c2HTr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTv; else goto c2HTu;
       c2HTv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTu: // global
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W16#_info" {
     GHC.Word.W16#_info:
         const GHC.Word.W16#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.121355026 UTC

[section ""data" . GHC.Word.W32#_closure" {
     GHC.Word.W32#_closure:
         const GHC.Word.W32#_info;
 },
 GHC.Word.W32#_entry() //  [R2]
         { []
         }
     {offset
       c2HTH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HTL; else goto c2HTK;
       c2HTL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HTK: // global
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W32#_info" {
     GHC.Word.W32#_info:
         const GHC.Word.W32#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.125503283 UTC

[section ""data" . GHC.Word.W64#_closure" {
     GHC.Word.W64#_closure:
         const GHC.Word.W64#_info;
 },
 GHC.Word.W64#_entry() //  [R2]
         { []
         }
     {offset
       c2HTX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2HU1; else goto c2HU0;
       c2HU1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Word.W64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2HU0: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W64#_info" {
     GHC.Word.W64#_info:
         const GHC.Word.W64#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.128919102 UTC

[section ""cstring" . i2HU9_str" {
     i2HU9_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,56,35]
 },
 GHC.Word.W8#_con_entry() //  [R1]
         { []
         }
     {offset
       c2HU8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W8#_con_info" {
     GHC.Word.W8#_con_info:
         const GHC.Word.W8#_con_entry;
         const 4294967296;
         const 3;
         const i2HU9_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.132810548 UTC

[section ""cstring" . i2HUg_str" {
     i2HUg_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,49,54,35]
 },
 GHC.Word.W16#_con_entry() //  [R1]
         { []
         }
     {offset
       c2HUf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W16#_con_info" {
     GHC.Word.W16#_con_info:
         const GHC.Word.W16#_con_entry;
         const 4294967296;
         const 3;
         const i2HUg_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.135914204 UTC

[section ""cstring" . i2HUn_str" {
     i2HUn_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,51,50,35]
 },
 GHC.Word.W32#_con_entry() //  [R1]
         { []
         }
     {offset
       c2HUm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W32#_con_info" {
     GHC.Word.W32#_con_info:
         const GHC.Word.W32#_con_entry;
         const 4294967296;
         const 3;
         const i2HUn_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.139065369 UTC

[section ""cstring" . i2HUu_str" {
     i2HUu_str:
         I8[] [98,97,115,101,58,71,72,67,46,87,111,114,100,46,87,54,52,35]
 },
 GHC.Word.W64#_con_entry() //  [R1]
         { []
         }
     {offset
       c2HUt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Word.W64#_con_info" {
     GHC.Word.W64#_con_info:
         const GHC.Word.W64#_con_entry;
         const 4294967296;
         const 3;
         const i2HUu_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:57:25.142734618 UTC

[section ""relreadonly" . S2Ecg_srt" {
     S2Ecg_srt:
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Word.$fShowWord3_closure;
         const GHC.Word.$w$cshow_closure;
         const GHC.Word.$fShowWord64_$cshow_closure;
         const GHC.Word.$fShowWord64_$cshowsPrec_closure;
         const GHC.Enum.fromEnumError_closure;
         const GHC.Word.$fShowWord64_closure;
         const lvl_r2uFF_closure;
         const sat_s2DyV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Word.$w$ctoRational_closure;
         const GHC.Word.$fRealWord64_$ctoRational_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord8_$cpred_closure;
         const GHC.Word.$fEnumWord10_closure;
         const GHC.Word.$fEnumWord8_$csucc_closure;
         const GHC.Word.$fEnumWord11_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl2_r2uFH_closure;
         const GHC.Word.$wlvl3_closure;
         const GHC.Word.$fEnumWord8_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum2_closure;
         const GHC.Word.$w$cenumFromThenTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo2_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Word.$wgo2_closure;
         const GHC.Word.$fEnumWord8_go_closure;
         const GHC.Word.$fEnumWord8_$cenumFrom_closure;
         const GHC.Word.$fEnumWord8_closure;
         const GHC.Word.$fEnumWord16_$cpred_closure;
         const GHC.Word.$fEnumWord1_closure;
         const GHC.Word.$fEnumWord16_$csucc_closure;
         const GHC.Word.$fEnumWord2_closure;
         const lvl4_r2uFJ_closure;
         const GHC.Word.$wlvl_closure;
         const GHC.Word.$fEnumWord16_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum_closure;
         const GHC.Word.$w$cenumFromThenTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$wgo_closure;
         const GHC.Word.$fEnumWord16_go_closure;
         const GHC.Word.$fEnumWord16_$cenumFrom_closure;
         const GHC.Word.$fEnumWord16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Word.$fEnumWord32_$cpred_closure;
         const GHC.Word.$fEnumWord3_closure;
         const GHC.Word.$fEnumWord32_$csucc_closure;
         const GHC.Word.$fEnumWord4_closure;
         const lvl6_r2uFL_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Word.$wlvl1_closure;
         const GHC.Word.$fEnumWord32_$ctoEnum_closure;
         const GHC.Word.$w$ctoEnum1_closure;
         const GHC.Word.$w$cenumFromThenTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromThenTo_closure;
         const GHC.Word.$w$cenumFromTo1_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$wgo1_closure;
         const GHC.Word.$fEnumWord32_go_closure;
         const GHC.Word.$fEnumWord32_$cenumFrom_closure;
         const GHC.Word.$fEnumWord32_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord64_$cdivMod_closure;
         const GHC.Word.$fIntegralWord64_$cquotRem_closure;
         const GHC.Word.$fIntegralWord64_$cmod_closure;
         const GHC.Word.$fIntegralWord64_$cdiv_closure;
         const GHC.Word.$fEnumWord64_$cpred_closure;
         const GHC.Word.$fEnumWord7_closure;
         const GHC.Word.$fEnumWord64_$csucc_closure;
         const GHC.Word.$fEnumWord9_closure;
         const GHC.Word.$fEnumWord6_closure;
         const GHC.Word.$wlvl2_closure;
         const GHC.Word.$fEnumWord64_$ctoEnum_closure;
         const GHC.Word.$fEnumWord64_$cfromEnum_closure;
         const GHC.Word.$fEnumWord5_closure;
         const GHC.Real.integralEnumFromThenTo_closure;
         const GHC.Word.$fIntegralWord64_closure;
         const GHC.Real.integralEnumFromTo_closure;
         const GHC.Real.integralEnumFrom_closure;
         const GHC.Real.integralEnumFromThen_closure;
         const GHC.Word.$fIntegralWord8_$cquot_closure;
         const GHC.Word.$fIntegralWord8_$crem_closure;
         const GHC.Word.$fIntegralWord8_$cquotRem_closure;
         const GHC.Word.$fIntegralWord8_$cdivMod_closure;
         const GHC.Word.$fRealWord8_$ctoRational_closure;
         const GHC.Word.$fRealWord1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Word.$fIxWord8_$crange_closure;
         const GHC.Word.$fEnumWord8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Word.$fIxWord8_$cindex_closure;
         const GHC.Word.$fIntegralWord16_$cquot_closure;
         const GHC.Word.$fIntegralWord16_$crem_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Word.$fIntegralWord16_$cquotRem_closure;
         const GHC.Word.$fIntegralWord16_$cdivMod_closure;
         const GHC.Word.$fRealWord16_$ctoRational_closure;
         const GHC.Word.$fIxWord16_$crange_closure;
         const GHC.Word.$fEnumWord16_$cenumFromTo_closure;
         const GHC.Word.$fIxWord16_$cindex_closure;
         const GHC.Word.$fIntegralWord32_$cquot_closure;
         const GHC.Word.$fIntegralWord32_$crem_closure;
         const GHC.Word.$fIntegralWord32_$cquotRem_closure;
         const GHC.Word.$fIntegralWord32_$cdivMod_closure;
         const GHC.Word.$fRealWord32_$ctoRational_closure;
         const GHC.Word.$fIxWord32_$crange_closure;
         const GHC.Word.$fEnumWord32_$cenumFromTo_closure;
         const GHC.Word.$fIxWord32_$cindex_closure;
         const GHC.Word.$fEnumWord64_$cenumFromTo_closure;
         const GHC.Word.$fIxWord64_$crange_closure;
         const GHC.Word.$fIxWord64_$cindex_closure;
 }]

