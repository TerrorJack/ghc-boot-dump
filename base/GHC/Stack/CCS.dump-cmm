
==================== Output Cmm ====================
2018-03-16 16:05:04.251422018 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:04.252293082 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS1_closure" {
     GHC.Stack.CCS.getCurrentCCS1_closure:
         const GHC.Stack.CCS.getCurrentCCS1_info;
 },
 GHC.Stack.CCS.getCurrentCCS1_entry() //  [R2]
         { info_tbl: [(ca1kq,
                       label: GHC.Stack.CCS.getCurrentCCS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1kq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1ku; else goto ca1kt;
       ca1ku: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCurrentCCS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1kt: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = CCCS;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.253291736 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS_closure" {
     GHC.Stack.CCS.getCurrentCCS_closure:
         const GHC.Stack.CCS.getCurrentCCS_info;
 },
 GHC.Stack.CCS.getCurrentCCS_entry() //  [R2]
         { info_tbl: [(ca1kz,
                       label: GHC.Stack.CCS.getCurrentCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1kz: // global
           R2 = R2;
           call GHC.Stack.CCS.getCurrentCCS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.254156136 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf1_closure" {
     GHC.Stack.CCS.getCCSOf1_closure:
         const GHC.Stack.CCS.getCCSOf1_info;
 },
 GHC.Stack.CCS.getCCSOf1_entry() //  [R2]
         { info_tbl: [(ca1kH,
                       label: GHC.Stack.CCS.getCCSOf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1kH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1kL; else goto ca1kK;
       ca1kL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCCSOf1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1kK: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = 0;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.255139498 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf_closure" {
     GHC.Stack.CCS.getCCSOf_closure:
         const GHC.Stack.CCS.getCCSOf_info;
 },
 GHC.Stack.CCS.getCCSOf_entry() //  [R2]
         { info_tbl: [(ca1kQ,
                       label: GHC.Stack.CCS.getCCSOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1kQ: // global
           R2 = R2;
           call GHC.Stack.CCS.getCCSOf1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.255973495 UTC

[section ""data" . GHC.Stack.CCS.clearCCS_closure" {
     GHC.Stack.CCS.clearCCS_closure:
         const GHC.Stack.CCS.clearCCS_info;
 },
 GHC.Stack.CCS.clearCCS_entry() //  [R2]
         { info_tbl: [(ca1kX,
                       label: GHC.Stack.CCS.clearCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1kX: // global
           R1 = R2;
           call stg_clearCCS#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.256713292 UTC

[section ""cstring" . f_ra1i8_bytes" {
     f_ra1i8_bytes:
         I8[] [10,32,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.257497363 UTC

[section ""data" . f1_ra1i9_closure" {
     f1_ra1i9_closure:
         const f1_ra1i9_info;
         const 0;
         const 0;
         const 0;
 },
 f1_ra1i9_entry() //  [R1]
         { info_tbl: [(ca1l6,
                       label: f1_ra1i9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1l6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1l7; else goto ca1l8;
       ca1l7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1l8: // global
           (_ca1l3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1l3::I64 == 0) goto ca1l5; else goto ca1l4;
       ca1l5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1l4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1l3::I64;
           R2 = f_ra1i8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.258430804 UTC

[section ""cstring" . GHC.Stack.CCS.renderStack1_bytes" {
     GHC.Stack.CCS.renderStack1_bytes:
         I8[] [67,97,108,108,83,116,97,99,107,32,40,102,114,111,109,32,45,112,114,111,102,41,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.259636067 UTC

[section ""data" . GHC.Stack.CCS.renderStack_go_closure" {
     GHC.Stack.CCS.renderStack_go_closure:
         const GHC.Stack.CCS.renderStack_go_info;
         const 0;
 },
 sat_sa1iy_entry() //  [R1]
         { info_tbl: [(ca1lr,
                       label: sat_sa1iy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1lr: // global
           R2 = P64[R1 + 16];
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa1iz_entry() //  [R1]
         { info_tbl: [(ca1lu,
                       label: sat_sa1iz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1lu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1ly; else goto ca1lx;
       ca1ly: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1lx: // global
           _sa1iw::P64 = P64[R1 + 16];
           _sa1ix::P64 = P64[R1 + 24];
           I64[Hp - 16] = sat_sa1iy_info;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 16;
           R2 = _sa1iw::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stack.CCS.renderStack_go_entry() //  [R2]
         { info_tbl: [(ca1lD,
                       label: GHC.Stack.CCS.renderStack_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1lD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1lE; else goto ca1lF;
       ca1lE: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1lF: // global
           I64[Sp - 8] = block_ca1ld_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1lL; else goto ca1le;
       ua1lL: // global
           call _ca1ld(R1) args: 0, res: 0, upd: 0;
       ca1le: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1ld() //  [R1]
         { info_tbl: [(ca1ld,
                       label: block_ca1ld_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1ld: // global
           if (R1 & 7 == 1) goto ca1lA; else goto ca1lB;
       ca1lA: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1lB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca1lK; else goto ca1lJ;
       ca1lK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1lJ: // global
           _sa1iw::P64 = P64[R1 + 6];
           _sa1ix::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sa1iz_info;
           P64[Hp - 8] = _sa1iw::P64;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 24;
           R2 = f1_ra1i9_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.262309513 UTC

[section ""data" . GHC.Stack.CCS.renderStack_closure" {
     GHC.Stack.CCS.renderStack_closure:
         const GHC.Stack.CCS.renderStack_info;
         const 0;
 },
 sat_sa1iC_entry() //  [R1]
         { info_tbl: [(ca1lX,
                       label: sat_sa1iC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1lX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca1lY; else goto ca1lZ;
       ca1lY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1lZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca1lV_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca1lV() //  [R1]
         { info_tbl: [(ca1lV,
                       label: block_ca1lV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1lV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.renderStack_entry() //  [R2]
         { info_tbl: [(ca1m3,
                       label: GHC.Stack.CCS.renderStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1m3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1m7; else goto ca1m6;
       ca1m7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1m6: // global
           I64[Hp - 16] = sat_sa1iC_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.263470774 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule4_bytes" {
     GHC.Stack.CCS.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.264038908 UTC

[section ""data" . GHC.Stack.CCS.$trModule3_closure" {
     GHC.Stack.CCS.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.264597904 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule2_bytes" {
     GHC.Stack.CCS.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107,46,67,67,83]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.265150584 UTC

[section ""data" . GHC.Stack.CCS.$trModule1_closure" {
     GHC.Stack.CCS.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.265694843 UTC

[section ""data" . GHC.Stack.CCS.$trModule_closure" {
     GHC.Stack.CCS.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.CCS.$trModule3_closure+1;
         const GHC.Stack.CCS.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.266263547 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentreStack2_bytes" {
     GHC.Stack.CCS.$tcCostCentreStack2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.266795755 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack1_closure" {
     GHC.Stack.CCS.$tcCostCentreStack1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentreStack2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.26733441 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack_closure" {
     GHC.Stack.CCS.$tcCostCentreStack_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentreStack1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4388269014118491027;
         const 5682182778281832541;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.267923746 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentre2_bytes" {
     GHC.Stack.CCS.$tcCostCentre2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.268470302 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre1_closure" {
     GHC.Stack.CCS.$tcCostCentre1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentre2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.269071854 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre_closure" {
     GHC.Stack.CCS.$tcCostCentre_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentre1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10996116669986307392;
         const 5747049382639019202;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.27003211 UTC

[section ""data" . GHC.Stack.CCS.ccsCC1_closure" {
     GHC.Stack.CCS.ccsCC1_closure:
         const GHC.Stack.CCS.ccsCC1_info;
 },
 GHC.Stack.CCS.ccsCC1_entry() //  [R2]
         { info_tbl: [(ca1mf,
                       label: GHC.Stack.CCS.ccsCC1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1mm; else goto ca1mn;
       ca1mm: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsCC1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1mn: // global
           I64[Sp - 8] = block_ca1mc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1mr; else goto ca1md;
       ua1mr: // global
           call _ca1mc(R1) args: 0, res: 0, upd: 0;
       ca1md: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1mc() //  [R1]
         { info_tbl: [(ca1mc,
                       label: block_ca1mc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1mq; else goto ca1mp;
       ca1mq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1mp: // global
           _sa1iK::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.271228484 UTC

[section ""data" . GHC.Stack.CCS.ccsCC_closure" {
     GHC.Stack.CCS.ccsCC_closure:
         const GHC.Stack.CCS.ccsCC_info;
 },
 GHC.Stack.CCS.ccsCC_entry() //  [R2]
         { info_tbl: [(ca1mw,
                       label: GHC.Stack.CCS.ccsCC_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mw: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsCC1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.272193206 UTC

[section ""data" . GHC.Stack.CCS.ccsParent1_closure" {
     GHC.Stack.CCS.ccsParent1_closure:
         const GHC.Stack.CCS.ccsParent1_info;
 },
 GHC.Stack.CCS.ccsParent1_entry() //  [R2]
         { info_tbl: [(ca1mG,
                       label: GHC.Stack.CCS.ccsParent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1mN; else goto ca1mO;
       ca1mN: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsParent1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1mO: // global
           I64[Sp - 8] = block_ca1mD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1mS; else goto ca1mE;
       ua1mS: // global
           call _ca1mD(R1) args: 0, res: 0, upd: 0;
       ca1mE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1mD() //  [R1]
         { info_tbl: [(ca1mD,
                       label: block_ca1mD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1mR; else goto ca1mQ;
       ca1mR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1mQ: // global
           _sa1iT::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iT::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.273592317 UTC

[section ""data" . GHC.Stack.CCS.ccsParent_closure" {
     GHC.Stack.CCS.ccsParent_closure:
         const GHC.Stack.CCS.ccsParent_info;
 },
 GHC.Stack.CCS.ccsParent_entry() //  [R2]
         { info_tbl: [(ca1mX,
                       label: GHC.Stack.CCS.ccsParent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1mX: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsParent1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.274542867 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan1_closure" {
     GHC.Stack.CCS.ccSrcSpan1_closure:
         const GHC.Stack.CCS.ccSrcSpan1_info;
 },
 GHC.Stack.CCS.ccSrcSpan1_entry() //  [R2]
         { info_tbl: [(ca1n7,
                       label: GHC.Stack.CCS.ccSrcSpan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1n7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1ne; else goto ca1nf;
       ca1ne: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccSrcSpan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1nf: // global
           I64[Sp - 8] = block_ca1n4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1nj; else goto ca1n5;
       ua1nj: // global
           call _ca1n4(R1) args: 0, res: 0, upd: 0;
       ca1n5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1n4() //  [R1]
         { info_tbl: [(ca1n4,
                       label: block_ca1n4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1n4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1ni; else goto ca1nh;
       ca1ni: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1nh: // global
           _sa1j2::I64 = I64[I64[R1 + 7] + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1j2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.275736199 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan_closure" {
     GHC.Stack.CCS.ccSrcSpan_closure:
         const GHC.Stack.CCS.ccSrcSpan_info;
 },
 GHC.Stack.CCS.ccSrcSpan_entry() //  [R2]
         { info_tbl: [(ca1no,
                       label: GHC.Stack.CCS.ccSrcSpan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1no: // global
           R2 = R2;
           call GHC.Stack.CCS.ccSrcSpan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.276726724 UTC

[section ""data" . GHC.Stack.CCS.ccModule1_closure" {
     GHC.Stack.CCS.ccModule1_closure:
         const GHC.Stack.CCS.ccModule1_info;
 },
 GHC.Stack.CCS.ccModule1_entry() //  [R2]
         { info_tbl: [(ca1ny,
                       label: GHC.Stack.CCS.ccModule1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1ny: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1nF; else goto ca1nG;
       ca1nF: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccModule1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1nG: // global
           I64[Sp - 8] = block_ca1nv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1nK; else goto ca1nw;
       ua1nK: // global
           call _ca1nv(R1) args: 0, res: 0, upd: 0;
       ca1nw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1nv() //  [R1]
         { info_tbl: [(ca1nv,
                       label: block_ca1nv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1nv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1nJ; else goto ca1nI;
       ca1nJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1nI: // global
           _sa1jb::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.277959501 UTC

[section ""data" . GHC.Stack.CCS.ccModule_closure" {
     GHC.Stack.CCS.ccModule_closure:
         const GHC.Stack.CCS.ccModule_info;
 },
 GHC.Stack.CCS.ccModule_entry() //  [R2]
         { info_tbl: [(ca1nP,
                       label: GHC.Stack.CCS.ccModule_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1nP: // global
           R2 = R2;
           call GHC.Stack.CCS.ccModule1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.278915396 UTC

[section ""data" . GHC.Stack.CCS.ccLabel1_closure" {
     GHC.Stack.CCS.ccLabel1_closure:
         const GHC.Stack.CCS.ccLabel1_info;
 },
 GHC.Stack.CCS.ccLabel1_entry() //  [R2]
         { info_tbl: [(ca1nZ,
                       label: GHC.Stack.CCS.ccLabel1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1nZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1o6; else goto ca1o7;
       ca1o6: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccLabel1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1o7: // global
           I64[Sp - 8] = block_ca1nW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1ob; else goto ca1nX;
       ua1ob: // global
           call _ca1nW(R1) args: 0, res: 0, upd: 0;
       ca1nX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1nW() //  [R1]
         { info_tbl: [(ca1nW,
                       label: block_ca1nW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1nW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1oa; else goto ca1o9;
       ca1oa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1o9: // global
           _sa1jk::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.280108522 UTC

[section ""data" . GHC.Stack.CCS.ccLabel_closure" {
     GHC.Stack.CCS.ccLabel_closure:
         const GHC.Stack.CCS.ccLabel_info;
 },
 GHC.Stack.CCS.ccLabel_entry() //  [R2]
         { info_tbl: [(ca1og,
                       label: GHC.Stack.CCS.ccLabel_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1og: // global
           R2 = R2;
           call GHC.Stack.CCS.ccLabel1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.280811949 UTC

[section ""cstring" . lvl_ra1ia_bytes" {
     lvl_ra1ia_bytes:
         I8[] [77,65,73,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.281635393 UTC

[section ""data" . lvl1_ra1ib_closure" {
     lvl1_ra1ib_closure:
         const lvl1_ra1ib_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra1ib_entry() //  [R1]
         { info_tbl: [(ca1op,
                       label: lvl1_ra1ib_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1op: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1oq; else goto ca1or;
       ca1oq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1or: // global
           (_ca1om::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1om::I64 == 0) goto ca1oo; else goto ca1on;
       ca1oo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1on: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1om::I64;
           R2 = lvl_ra1ia_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.282597552 UTC

[section ""cstring" . lvl2_ra1ic_bytes" {
     lvl2_ra1ic_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.283173473 UTC

[section ""data" . lvl3_ra1id_closure" {
     lvl3_ra1id_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.283749113 UTC

[section ""data" . lvl4_ra1ie_closure" {
     lvl4_ra1ie_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.284322428 UTC

[section ""data" . lvl5_ra1if_closure" {
     lvl5_ra1if_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.285051526 UTC

[section ""data" . lvl6_ra1ig_closure" {
     lvl6_ra1ig_closure:
         const lvl6_ra1ig_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra1ig_entry() //  [R1]
         { info_tbl: [(ca1oy,
                       label: lvl6_ra1ig_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1oy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1oz; else goto ca1oA;
       ca1oz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1oA: // global
           (_ca1ov::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1ov::I64 == 0) goto ca1ox; else goto ca1ow;
       ca1ox: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1ow: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1ov::I64;
           R2 = lvl2_ra1ic_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.288599696 UTC

[section ""data" . GHC.Stack.CCS.$wgo_closure" {
     GHC.Stack.CCS.$wgo_closure:
         const GHC.Stack.CCS.$wgo_info;
         const 0;
 },
 sat_sa1jU_entry() //  [R1]
         { info_tbl: [(ca1pl,
                       label: sat_sa1jU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1pm; else goto ca1pn;
       ca1pm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1pn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl6_ra1ig_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jX_entry() //  [R1]
         { info_tbl: [(ca1pq,
                       label: sat_sa1jX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pq: // global
           _sa1jX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1pr; else goto ca1ps;
       ca1ps: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca1pu; else goto ca1pt;
       ca1pu: // global
           HpAlloc = 72;
           goto ca1pr;
       ca1pr: // global
           R1 = _sa1jX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1pt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jX::P64;
           _sa1jA::P64 = P64[_sa1jX::P64 + 16];
           _sa1jO::P64 = P64[_sa1jX::P64 + 24];
           I64[Hp - 64] = sat_sa1jU_info;
           P64[Hp - 48] = _sa1jO::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl3_ra1id_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl4_ra1ie_closure+1;
           P64[Hp] = Hp - 38;
           R3 = Hp - 14;
           R2 = _sa1jA::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jZ_entry() //  [R1]
         { info_tbl: [(ca1pw,
                       label: sat_sa1jZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pw: // global
           _sa1jZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1px; else goto ca1py;
       ca1py: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca1pA; else goto ca1pz;
       ca1pA: // global
           HpAlloc = 56;
           goto ca1px;
       ca1px: // global
           R1 = _sa1jZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1pz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jZ::P64;
           _sa1jA::P64 = P64[_sa1jZ::P64 + 16];
           _sa1jH::P64 = P64[_sa1jZ::P64 + 24];
           _sa1jO::P64 = P64[_sa1jZ::P64 + 32];
           I64[Hp - 48] = sat_sa1jX_info;
           P64[Hp - 32] = _sa1jA::P64;
           P64[Hp - 24] = _sa1jO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl5_ra1if_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sa1jH::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.$wgo_entry() //  [R2, R3]
         { info_tbl: [(ca1pE,
                       label: GHC.Stack.CCS.$wgo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca1pF; else goto ua1qb;
       ca1pF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua1qb: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca1oC() args: 0, res: 0, upd: 0;
     }
 },
 _ca1oC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1oC: // global
           _sa1jm::I64 = I64[Sp];
           if (_sa1jm::I64 == 0) goto ua1qc; else goto ca1pC;
       ua1qc: // global
           Sp = Sp + 8;
           call _ca1pD() args: 0, res: 0, upd: 0;
       ca1pC: // global
           _sa1jt::I64 = I64[_sa1jm::I64 + 8];
           _sa1jx::I64 = I64[_sa1jt::I64 + 8];
           I64[Sp - 16] = block_ca1oO_info;
           R3 = _sa1jx::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           I64[Sp - 8] = _sa1jt::I64;
           Sp = Sp - 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1oO() //  [R1]
         { info_tbl: [(ca1oO,
                       label: block_ca1oO_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1oO: // global
           _sa1jE::I64 = I64[I64[Sp + 8] + 16];
           I64[Sp - 8] = block_ca1oT_info;
           R3 = _sa1jE::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1oT() //  [R1]
         { info_tbl: [(ca1oT,
                       label: block_ca1oT_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1oT: // global
           _sa1jL::I64 = I64[I64[Sp + 16] + 24];
           I64[Sp] = block_ca1oY_info;
           R3 = _sa1jL::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 16] = R1;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1oY() //  [R1]
         { info_tbl: [(ca1oY,
                       label: block_ca1oY_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1oY: // global
           _sa1jS::I64 = I64[I64[Sp + 24] + 16];
           I64[Sp - 8] = block_ca1pK_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = _sa1jS::I64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1pK() //  [R1]
         { info_tbl: [(ca1pK,
                       label: block_ca1pK_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pK: // global
           if (R1 & 7 == 1) goto ua1qi; else goto ca1pY;
       ua1qi: // global
           call _ca1p6() args: 0, res: 0, upd: 0;
       ca1pY: // global
           I64[Sp] = block_ca1pW_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1pW() //  [R1]
         { info_tbl: [(ca1pW,
                       label: block_ca1pW_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pW: // global
           if (R1 & 7 == 1) goto ua1qj; else goto ua1qd;
       ua1qj: // global
           call _ca1p6() args: 0, res: 0, upd: 0;
       ua1qd: // global
           Sp = Sp + 40;
           call _ca1pD() args: 0, res: 0, upd: 0;
     }
 },
 _ca1p6() //  []
         { info_tbl: [(ca1p6,
                       label: block_ca1p6_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1p6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ca1pN; else goto ca1pM;
       ca1pN: // global
           HpAlloc = 64;
           I64[Sp] = block_ca1p6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca1pM: // global
           I64[Hp - 56] = sat_sa1jZ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 32] = I64[Sp + 8];
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 32;
           call _ca1oC() args: 0, res: 0, upd: 0;
     }
 },
 _ca1pD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1pD: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.292149203 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings2_closure" {
     GHC.Stack.CCS.ccsToStrings2_closure:
         const GHC.Stack.CCS.ccsToStrings2_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings2_entry() //  [R2, R3]
         { info_tbl: [(ca1qs,
                       label: GHC.Stack.CCS.ccsToStrings2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1qt; else goto ca1qu;
       ca1qt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca1qu: // global
           I64[Sp - 16] = block_ca1qp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua1qy; else goto ca1qq;
       ua1qy: // global
           call _ca1qp(R1) args: 0, res: 0, upd: 0;
       ca1qq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1qp() //  [R1]
         { info_tbl: [(ca1qp,
                       label: block_ca1qp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qp: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.29337575 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings1_closure" {
     GHC.Stack.CCS.ccsToStrings1_closure:
         const GHC.Stack.CCS.ccsToStrings1_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings1_entry() //  [R2]
         { info_tbl: [(ca1qG,
                       label: GHC.Stack.CCS.ccsToStrings1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1qH; else goto ca1qI;
       ca1qH: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1qI: // global
           I64[Sp - 8] = block_ca1qD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1qM; else goto ca1qE;
       ua1qM: // global
           call _ca1qD(R1) args: 0, res: 0, upd: 0;
       ca1qE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1qD() //  [R1]
         { info_tbl: [(ca1qD,
                       label: block_ca1qD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qD: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.294417061 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings_closure" {
     GHC.Stack.CCS.ccsToStrings_closure:
         const GHC.Stack.CCS.ccsToStrings_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings_entry() //  [R2]
         { info_tbl: [(ca1qR,
                       label: GHC.Stack.CCS.ccsToStrings_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qR: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsToStrings1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.295252312 UTC

[section ""data" . GHC.Stack.CCS.whoCreated1_closure" {
     GHC.Stack.CCS.whoCreated1_closure:
         const GHC.Stack.CCS.whoCreated1_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated1_entry() //  []
         { info_tbl: [(ca1qY,
                       label: GHC.Stack.CCS.whoCreated1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1qY: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = 0;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.296062627 UTC

[section ""data" . GHC.Stack.CCS.whoCreated_closure" {
     GHC.Stack.CCS.whoCreated_closure:
         const GHC.Stack.CCS.whoCreated_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated_entry() //  [R2]
         { info_tbl: [(ca1r5,
                       label: GHC.Stack.CCS.whoCreated_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1r5: // global
           R2 = R2;
           call GHC.Stack.CCS.whoCreated1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.296912307 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack1_closure" {
     GHC.Stack.CCS.currentCallStack1_closure:
         const GHC.Stack.CCS.currentCallStack1_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack1_entry() //  []
         { info_tbl: [(ca1rc,
                       label: GHC.Stack.CCS.currentCallStack1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rc: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.29806742 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack_closure" {
     GHC.Stack.CCS.currentCallStack_closure:
         const GHC.Stack.CCS.currentCallStack_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack_entry() //  []
         { info_tbl: [(ca1rj,
                       label: GHC.Stack.CCS.currentCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rj: // global
           call GHC.Stack.CCS.currentCallStack1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.298762815 UTC

[section ""relreadonly" . Sa1lM_srt" {
     Sa1lM_srt:
         const GHC.Stack.CCS.renderStack_go_closure;
         const f1_ra1i9_closure;
         const GHC.Stack.CCS.renderStack_closure;
         const lvl6_ra1ig_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const lvl1_ra1ib_closure;
         const GHC.Stack.CCS.ccsToStrings2_closure;
         const GHC.Stack.CCS.ccsToStrings1_closure;
         const GHC.Stack.CCS.whoCreated1_closure;
         const GHC.Stack.CCS.currentCallStack1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.299393683 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:04.300086515 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS1_closure" {
     GHC.Stack.CCS.getCurrentCCS1_closure:
         const GHC.Stack.CCS.getCurrentCCS1_info;
 },
 GHC.Stack.CCS.getCurrentCCS1_entry() //  [R2]
         { info_tbl: [(ca1rr,
                       label: GHC.Stack.CCS.getCurrentCCS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1rv; else goto ca1ru;
       ca1rv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCurrentCCS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1ru: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = CCCS;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.30104014 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS_closure" {
     GHC.Stack.CCS.getCurrentCCS_closure:
         const GHC.Stack.CCS.getCurrentCCS_info;
 },
 GHC.Stack.CCS.getCurrentCCS_entry() //  [R2]
         { info_tbl: [(ca1rA,
                       label: GHC.Stack.CCS.getCurrentCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rA: // global
           R2 = R2;
           call GHC.Stack.CCS.getCurrentCCS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.301932584 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf1_closure" {
     GHC.Stack.CCS.getCCSOf1_closure:
         const GHC.Stack.CCS.getCCSOf1_info;
 },
 GHC.Stack.CCS.getCCSOf1_entry() //  [R2]
         { info_tbl: [(ca1rI,
                       label: GHC.Stack.CCS.getCCSOf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1rM; else goto ca1rL;
       ca1rM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCCSOf1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1rL: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = 0;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.302830639 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf_closure" {
     GHC.Stack.CCS.getCCSOf_closure:
         const GHC.Stack.CCS.getCCSOf_info;
 },
 GHC.Stack.CCS.getCCSOf_entry() //  [R2]
         { info_tbl: [(ca1rR,
                       label: GHC.Stack.CCS.getCCSOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rR: // global
           R2 = R2;
           call GHC.Stack.CCS.getCCSOf1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.303641273 UTC

[section ""data" . GHC.Stack.CCS.clearCCS_closure" {
     GHC.Stack.CCS.clearCCS_closure:
         const GHC.Stack.CCS.clearCCS_info;
 },
 GHC.Stack.CCS.clearCCS_entry() //  [R2]
         { info_tbl: [(ca1rY,
                       label: GHC.Stack.CCS.clearCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1rY: // global
           R1 = R2;
           call stg_clearCCS#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.304346962 UTC

[section ""cstring" . f_ra1i8_bytes" {
     f_ra1i8_bytes:
         I8[] [10,32,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.305083994 UTC

[section ""data" . f1_ra1i9_closure" {
     f1_ra1i9_closure:
         const f1_ra1i9_info;
         const 0;
         const 0;
         const 0;
 },
 f1_ra1i9_entry() //  [R1]
         { info_tbl: [(ca1s7,
                       label: f1_ra1i9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1s7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1s8; else goto ca1s9;
       ca1s8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1s9: // global
           (_ca1s4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1s4::I64 == 0) goto ca1s6; else goto ca1s5;
       ca1s6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1s5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1s4::I64;
           R2 = f_ra1i8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.3059854 UTC

[section ""cstring" . GHC.Stack.CCS.renderStack1_bytes" {
     GHC.Stack.CCS.renderStack1_bytes:
         I8[] [67,97,108,108,83,116,97,99,107,32,40,102,114,111,109,32,45,112,114,111,102,41,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.307090125 UTC

[section ""data" . GHC.Stack.CCS.renderStack_go_closure" {
     GHC.Stack.CCS.renderStack_go_closure:
         const GHC.Stack.CCS.renderStack_go_info;
         const 0;
 },
 sat_sa1iy_entry() //  [R1]
         { info_tbl: [(ca1ss,
                       label: sat_sa1iy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1ss: // global
           R2 = P64[R1 + 16];
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa1iz_entry() //  [R1]
         { info_tbl: [(ca1sv,
                       label: sat_sa1iz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1sv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1sz; else goto ca1sy;
       ca1sz: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1sy: // global
           _sa1iw::P64 = P64[R1 + 16];
           _sa1ix::P64 = P64[R1 + 24];
           I64[Hp - 16] = sat_sa1iy_info;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 16;
           R2 = _sa1iw::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stack.CCS.renderStack_go_entry() //  [R2]
         { info_tbl: [(ca1sE,
                       label: GHC.Stack.CCS.renderStack_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1sE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1sF; else goto ca1sG;
       ca1sF: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1sG: // global
           I64[Sp - 8] = block_ca1se_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1sM; else goto ca1sf;
       ua1sM: // global
           call _ca1se(R1) args: 0, res: 0, upd: 0;
       ca1sf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1se() //  [R1]
         { info_tbl: [(ca1se,
                       label: block_ca1se_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1se: // global
           if (R1 & 7 == 1) goto ca1sB; else goto ca1sC;
       ca1sB: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1sC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca1sL; else goto ca1sK;
       ca1sL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1sK: // global
           _sa1iw::P64 = P64[R1 + 6];
           _sa1ix::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sa1iz_info;
           P64[Hp - 8] = _sa1iw::P64;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 24;
           R2 = f1_ra1i9_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.30903837 UTC

[section ""data" . GHC.Stack.CCS.renderStack_closure" {
     GHC.Stack.CCS.renderStack_closure:
         const GHC.Stack.CCS.renderStack_info;
         const 0;
 },
 sat_sa1iC_entry() //  [R1]
         { info_tbl: [(ca1sX,
                       label: sat_sa1iC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1sX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca1sY; else goto ca1sZ;
       ca1sY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1sZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca1sV_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca1sV() //  [R1]
         { info_tbl: [(ca1sV,
                       label: block_ca1sV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1sV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.renderStack_entry() //  [R2]
         { info_tbl: [(ca1t3,
                       label: GHC.Stack.CCS.renderStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1t3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1t7; else goto ca1t6;
       ca1t7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1t6: // global
           I64[Hp - 16] = sat_sa1iC_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.310448209 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule4_bytes" {
     GHC.Stack.CCS.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.310989142 UTC

[section ""data" . GHC.Stack.CCS.$trModule3_closure" {
     GHC.Stack.CCS.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.311568798 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule2_bytes" {
     GHC.Stack.CCS.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107,46,67,67,83]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.312159899 UTC

[section ""data" . GHC.Stack.CCS.$trModule1_closure" {
     GHC.Stack.CCS.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.312752964 UTC

[section ""data" . GHC.Stack.CCS.$trModule_closure" {
     GHC.Stack.CCS.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.CCS.$trModule3_closure+1;
         const GHC.Stack.CCS.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.313379242 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentreStack2_bytes" {
     GHC.Stack.CCS.$tcCostCentreStack2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.314802931 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack1_closure" {
     GHC.Stack.CCS.$tcCostCentreStack1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentreStack2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.315419995 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack_closure" {
     GHC.Stack.CCS.$tcCostCentreStack_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentreStack1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4388269014118491027;
         const 5682182778281832541;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.316003494 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentre2_bytes" {
     GHC.Stack.CCS.$tcCostCentre2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.316549737 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre1_closure" {
     GHC.Stack.CCS.$tcCostCentre1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentre2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.317091992 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre_closure" {
     GHC.Stack.CCS.$tcCostCentre_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentre1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10996116669986307392;
         const 5747049382639019202;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.318292238 UTC

[section ""data" . GHC.Stack.CCS.ccsCC1_closure" {
     GHC.Stack.CCS.ccsCC1_closure:
         const GHC.Stack.CCS.ccsCC1_info;
 },
 GHC.Stack.CCS.ccsCC1_entry() //  [R2]
         { info_tbl: [(ca1tf,
                       label: GHC.Stack.CCS.ccsCC1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1tm; else goto ca1tn;
       ca1tm: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsCC1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1tn: // global
           I64[Sp - 8] = block_ca1tc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1tr; else goto ca1td;
       ua1tr: // global
           call _ca1tc(R1) args: 0, res: 0, upd: 0;
       ca1td: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1tc() //  [R1]
         { info_tbl: [(ca1tc,
                       label: block_ca1tc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1tq; else goto ca1tp;
       ca1tq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1tp: // global
           _sa1iK::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.319457292 UTC

[section ""data" . GHC.Stack.CCS.ccsCC_closure" {
     GHC.Stack.CCS.ccsCC_closure:
         const GHC.Stack.CCS.ccsCC_info;
 },
 GHC.Stack.CCS.ccsCC_entry() //  [R2]
         { info_tbl: [(ca1tw,
                       label: GHC.Stack.CCS.ccsCC_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tw: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsCC1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.320392624 UTC

[section ""data" . GHC.Stack.CCS.ccsParent1_closure" {
     GHC.Stack.CCS.ccsParent1_closure:
         const GHC.Stack.CCS.ccsParent1_info;
 },
 GHC.Stack.CCS.ccsParent1_entry() //  [R2]
         { info_tbl: [(ca1tG,
                       label: GHC.Stack.CCS.ccsParent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1tN; else goto ca1tO;
       ca1tN: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsParent1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1tO: // global
           I64[Sp - 8] = block_ca1tD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1tS; else goto ca1tE;
       ua1tS: // global
           call _ca1tD(R1) args: 0, res: 0, upd: 0;
       ca1tE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1tD() //  [R1]
         { info_tbl: [(ca1tD,
                       label: block_ca1tD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1tR; else goto ca1tQ;
       ca1tR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1tQ: // global
           _sa1iT::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iT::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.321572181 UTC

[section ""data" . GHC.Stack.CCS.ccsParent_closure" {
     GHC.Stack.CCS.ccsParent_closure:
         const GHC.Stack.CCS.ccsParent_info;
 },
 GHC.Stack.CCS.ccsParent_entry() //  [R2]
         { info_tbl: [(ca1tX,
                       label: GHC.Stack.CCS.ccsParent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1tX: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsParent1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.322516621 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan1_closure" {
     GHC.Stack.CCS.ccSrcSpan1_closure:
         const GHC.Stack.CCS.ccSrcSpan1_info;
 },
 GHC.Stack.CCS.ccSrcSpan1_entry() //  [R2]
         { info_tbl: [(ca1u7,
                       label: GHC.Stack.CCS.ccSrcSpan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1u7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1ue; else goto ca1uf;
       ca1ue: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccSrcSpan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1uf: // global
           I64[Sp - 8] = block_ca1u4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1uj; else goto ca1u5;
       ua1uj: // global
           call _ca1u4(R1) args: 0, res: 0, upd: 0;
       ca1u5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1u4() //  [R1]
         { info_tbl: [(ca1u4,
                       label: block_ca1u4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1u4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1ui; else goto ca1uh;
       ca1ui: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1uh: // global
           _sa1j2::I64 = I64[I64[R1 + 7] + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1j2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.323751823 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan_closure" {
     GHC.Stack.CCS.ccSrcSpan_closure:
         const GHC.Stack.CCS.ccSrcSpan_info;
 },
 GHC.Stack.CCS.ccSrcSpan_entry() //  [R2]
         { info_tbl: [(ca1uo,
                       label: GHC.Stack.CCS.ccSrcSpan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uo: // global
           R2 = R2;
           call GHC.Stack.CCS.ccSrcSpan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.324724299 UTC

[section ""data" . GHC.Stack.CCS.ccModule1_closure" {
     GHC.Stack.CCS.ccModule1_closure:
         const GHC.Stack.CCS.ccModule1_info;
 },
 GHC.Stack.CCS.ccModule1_entry() //  [R2]
         { info_tbl: [(ca1uy,
                       label: GHC.Stack.CCS.ccModule1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1uF; else goto ca1uG;
       ca1uF: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccModule1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1uG: // global
           I64[Sp - 8] = block_ca1uv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1uK; else goto ca1uw;
       ua1uK: // global
           call _ca1uv(R1) args: 0, res: 0, upd: 0;
       ca1uw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1uv() //  [R1]
         { info_tbl: [(ca1uv,
                       label: block_ca1uv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1uJ; else goto ca1uI;
       ca1uJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1uI: // global
           _sa1jb::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.325936158 UTC

[section ""data" . GHC.Stack.CCS.ccModule_closure" {
     GHC.Stack.CCS.ccModule_closure:
         const GHC.Stack.CCS.ccModule_info;
 },
 GHC.Stack.CCS.ccModule_entry() //  [R2]
         { info_tbl: [(ca1uP,
                       label: GHC.Stack.CCS.ccModule_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uP: // global
           R2 = R2;
           call GHC.Stack.CCS.ccModule1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.326895682 UTC

[section ""data" . GHC.Stack.CCS.ccLabel1_closure" {
     GHC.Stack.CCS.ccLabel1_closure:
         const GHC.Stack.CCS.ccLabel1_info;
 },
 GHC.Stack.CCS.ccLabel1_entry() //  [R2]
         { info_tbl: [(ca1uZ,
                       label: GHC.Stack.CCS.ccLabel1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1v6; else goto ca1v7;
       ca1v6: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccLabel1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1v7: // global
           I64[Sp - 8] = block_ca1uW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1vb; else goto ca1uX;
       ua1vb: // global
           call _ca1uW(R1) args: 0, res: 0, upd: 0;
       ca1uX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1uW() //  [R1]
         { info_tbl: [(ca1uW,
                       label: block_ca1uW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1uW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1va; else goto ca1v9;
       ca1va: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1v9: // global
           _sa1jk::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.328096567 UTC

[section ""data" . GHC.Stack.CCS.ccLabel_closure" {
     GHC.Stack.CCS.ccLabel_closure:
         const GHC.Stack.CCS.ccLabel_info;
 },
 GHC.Stack.CCS.ccLabel_entry() //  [R2]
         { info_tbl: [(ca1vg,
                       label: GHC.Stack.CCS.ccLabel_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vg: // global
           R2 = R2;
           call GHC.Stack.CCS.ccLabel1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.328835117 UTC

[section ""cstring" . lvl_ra1ia_bytes" {
     lvl_ra1ia_bytes:
         I8[] [77,65,73,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.329853758 UTC

[section ""data" . lvl1_ra1ib_closure" {
     lvl1_ra1ib_closure:
         const lvl1_ra1ib_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra1ib_entry() //  [R1]
         { info_tbl: [(ca1vp,
                       label: lvl1_ra1ib_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1vq; else goto ca1vr;
       ca1vq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1vr: // global
           (_ca1vm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1vm::I64 == 0) goto ca1vo; else goto ca1vn;
       ca1vo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1vn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1vm::I64;
           R2 = lvl_ra1ia_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.330727661 UTC

[section ""cstring" . lvl2_ra1ic_bytes" {
     lvl2_ra1ic_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.331301008 UTC

[section ""data" . lvl3_ra1id_closure" {
     lvl3_ra1id_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.331869216 UTC

[section ""data" . lvl4_ra1ie_closure" {
     lvl4_ra1ie_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.332428395 UTC

[section ""data" . lvl5_ra1if_closure" {
     lvl5_ra1if_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.33315775 UTC

[section ""data" . lvl6_ra1ig_closure" {
     lvl6_ra1ig_closure:
         const lvl6_ra1ig_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra1ig_entry() //  [R1]
         { info_tbl: [(ca1vy,
                       label: lvl6_ra1ig_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1vz; else goto ca1vA;
       ca1vz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1vA: // global
           (_ca1vv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1vv::I64 == 0) goto ca1vx; else goto ca1vw;
       ca1vx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1vw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1vv::I64;
           R2 = lvl2_ra1ic_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.335546003 UTC

[section ""data" . GHC.Stack.CCS.$wgo_closure" {
     GHC.Stack.CCS.$wgo_closure:
         const GHC.Stack.CCS.$wgo_info;
         const 0;
 },
 sat_sa1jU_entry() //  [R1]
         { info_tbl: [(ca1wl,
                       label: sat_sa1jU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1wm; else goto ca1wn;
       ca1wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1wn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl6_ra1ig_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jX_entry() //  [R1]
         { info_tbl: [(ca1wq,
                       label: sat_sa1jX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wq: // global
           _sa1jX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1wr; else goto ca1ws;
       ca1ws: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca1wu; else goto ca1wt;
       ca1wu: // global
           HpAlloc = 72;
           goto ca1wr;
       ca1wr: // global
           R1 = _sa1jX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1wt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jX::P64;
           _sa1jA::P64 = P64[_sa1jX::P64 + 16];
           _sa1jO::P64 = P64[_sa1jX::P64 + 24];
           I64[Hp - 64] = sat_sa1jU_info;
           P64[Hp - 48] = _sa1jO::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl3_ra1id_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl4_ra1ie_closure+1;
           P64[Hp] = Hp - 38;
           R3 = Hp - 14;
           R2 = _sa1jA::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jZ_entry() //  [R1]
         { info_tbl: [(ca1ww,
                       label: sat_sa1jZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1ww: // global
           _sa1jZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1wx; else goto ca1wy;
       ca1wy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca1wA; else goto ca1wz;
       ca1wA: // global
           HpAlloc = 56;
           goto ca1wx;
       ca1wx: // global
           R1 = _sa1jZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1wz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jZ::P64;
           _sa1jA::P64 = P64[_sa1jZ::P64 + 16];
           _sa1jH::P64 = P64[_sa1jZ::P64 + 24];
           _sa1jO::P64 = P64[_sa1jZ::P64 + 32];
           I64[Hp - 48] = sat_sa1jX_info;
           P64[Hp - 32] = _sa1jA::P64;
           P64[Hp - 24] = _sa1jO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl5_ra1if_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sa1jH::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.$wgo_entry() //  [R2, R3]
         { info_tbl: [(ca1wE,
                       label: GHC.Stack.CCS.$wgo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wE: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca1wF; else goto ua1xb;
       ca1wF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua1xb: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca1vC() args: 0, res: 0, upd: 0;
     }
 },
 _ca1vC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vC: // global
           _sa1jm::I64 = I64[Sp];
           if (_sa1jm::I64 == 0) goto ua1xc; else goto ca1wC;
       ua1xc: // global
           Sp = Sp + 8;
           call _ca1wD() args: 0, res: 0, upd: 0;
       ca1wC: // global
           _sa1jt::I64 = I64[_sa1jm::I64 + 8];
           _sa1jx::I64 = I64[_sa1jt::I64 + 8];
           I64[Sp - 16] = block_ca1vO_info;
           R3 = _sa1jx::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           I64[Sp - 8] = _sa1jt::I64;
           Sp = Sp - 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1vO() //  [R1]
         { info_tbl: [(ca1vO,
                       label: block_ca1vO_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vO: // global
           _sa1jE::I64 = I64[I64[Sp + 8] + 16];
           I64[Sp - 8] = block_ca1vT_info;
           R3 = _sa1jE::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1vT() //  [R1]
         { info_tbl: [(ca1vT,
                       label: block_ca1vT_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vT: // global
           _sa1jL::I64 = I64[I64[Sp + 16] + 24];
           I64[Sp] = block_ca1vY_info;
           R3 = _sa1jL::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 16] = R1;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1vY() //  [R1]
         { info_tbl: [(ca1vY,
                       label: block_ca1vY_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1vY: // global
           _sa1jS::I64 = I64[I64[Sp + 24] + 16];
           I64[Sp - 8] = block_ca1wK_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = _sa1jS::I64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1wK() //  [R1]
         { info_tbl: [(ca1wK,
                       label: block_ca1wK_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wK: // global
           if (R1 & 7 == 1) goto ua1xi; else goto ca1wY;
       ua1xi: // global
           call _ca1w6() args: 0, res: 0, upd: 0;
       ca1wY: // global
           I64[Sp] = block_ca1wW_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1wW() //  [R1]
         { info_tbl: [(ca1wW,
                       label: block_ca1wW_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wW: // global
           if (R1 & 7 == 1) goto ua1xj; else goto ua1xd;
       ua1xj: // global
           call _ca1w6() args: 0, res: 0, upd: 0;
       ua1xd: // global
           Sp = Sp + 40;
           call _ca1wD() args: 0, res: 0, upd: 0;
     }
 },
 _ca1w6() //  []
         { info_tbl: [(ca1w6,
                       label: block_ca1w6_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1w6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ca1wN; else goto ca1wM;
       ca1wN: // global
           HpAlloc = 64;
           I64[Sp] = block_ca1w6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca1wM: // global
           I64[Hp - 56] = sat_sa1jZ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 32] = I64[Sp + 8];
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 32;
           call _ca1vC() args: 0, res: 0, upd: 0;
     }
 },
 _ca1wD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1wD: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.339418373 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings2_closure" {
     GHC.Stack.CCS.ccsToStrings2_closure:
         const GHC.Stack.CCS.ccsToStrings2_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings2_entry() //  [R2, R3]
         { info_tbl: [(ca1xs,
                       label: GHC.Stack.CCS.ccsToStrings2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1xt; else goto ca1xu;
       ca1xt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca1xu: // global
           I64[Sp - 16] = block_ca1xp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua1xy; else goto ca1xq;
       ua1xy: // global
           call _ca1xp(R1) args: 0, res: 0, upd: 0;
       ca1xq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1xp() //  [R1]
         { info_tbl: [(ca1xp,
                       label: block_ca1xp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xp: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.340703001 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings1_closure" {
     GHC.Stack.CCS.ccsToStrings1_closure:
         const GHC.Stack.CCS.ccsToStrings1_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings1_entry() //  [R2]
         { info_tbl: [(ca1xG,
                       label: GHC.Stack.CCS.ccsToStrings1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1xH; else goto ca1xI;
       ca1xH: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1xI: // global
           I64[Sp - 8] = block_ca1xD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1xM; else goto ca1xE;
       ua1xM: // global
           call _ca1xD(R1) args: 0, res: 0, upd: 0;
       ca1xE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1xD() //  [R1]
         { info_tbl: [(ca1xD,
                       label: block_ca1xD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xD: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.343071126 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings_closure" {
     GHC.Stack.CCS.ccsToStrings_closure:
         const GHC.Stack.CCS.ccsToStrings_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings_entry() //  [R2]
         { info_tbl: [(ca1xR,
                       label: GHC.Stack.CCS.ccsToStrings_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xR: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsToStrings1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.343887439 UTC

[section ""data" . GHC.Stack.CCS.whoCreated1_closure" {
     GHC.Stack.CCS.whoCreated1_closure:
         const GHC.Stack.CCS.whoCreated1_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated1_entry() //  []
         { info_tbl: [(ca1xY,
                       label: GHC.Stack.CCS.whoCreated1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1xY: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = 0;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.344688775 UTC

[section ""data" . GHC.Stack.CCS.whoCreated_closure" {
     GHC.Stack.CCS.whoCreated_closure:
         const GHC.Stack.CCS.whoCreated_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated_entry() //  [R2]
         { info_tbl: [(ca1y5,
                       label: GHC.Stack.CCS.whoCreated_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1y5: // global
           R2 = R2;
           call GHC.Stack.CCS.whoCreated1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.345511522 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack1_closure" {
     GHC.Stack.CCS.currentCallStack1_closure:
         const GHC.Stack.CCS.currentCallStack1_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack1_entry() //  []
         { info_tbl: [(ca1yc,
                       label: GHC.Stack.CCS.currentCallStack1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1yc: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.346308293 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack_closure" {
     GHC.Stack.CCS.currentCallStack_closure:
         const GHC.Stack.CCS.currentCallStack_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack_entry() //  []
         { info_tbl: [(ca1yj,
                       label: GHC.Stack.CCS.currentCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1yj: // global
           call GHC.Stack.CCS.currentCallStack1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.347009726 UTC

[section ""relreadonly" . Sa1lM_srt" {
     Sa1lM_srt:
         const GHC.Stack.CCS.renderStack_go_closure;
         const f1_ra1i9_closure;
         const GHC.Stack.CCS.renderStack_closure;
         const lvl6_ra1ig_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const lvl1_ra1ib_closure;
         const GHC.Stack.CCS.ccsToStrings2_closure;
         const GHC.Stack.CCS.ccsToStrings1_closure;
         const GHC.Stack.CCS.whoCreated1_closure;
         const GHC.Stack.CCS.currentCallStack1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.347819766 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:04.349107253 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS1_closure" {
     GHC.Stack.CCS.getCurrentCCS1_closure:
         const GHC.Stack.CCS.getCurrentCCS1_info;
 },
 GHC.Stack.CCS.getCurrentCCS1_entry() //  [R2]
         { info_tbl: [(ca1yr,
                       label: GHC.Stack.CCS.getCurrentCCS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1yr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1yv; else goto ca1yu;
       ca1yv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCurrentCCS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1yu: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = CCCS;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.353024449 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS_closure" {
     GHC.Stack.CCS.getCurrentCCS_closure:
         const GHC.Stack.CCS.getCurrentCCS_info;
 },
 GHC.Stack.CCS.getCurrentCCS_entry() //  [R2]
         { info_tbl: [(ca1yG,
                       label: GHC.Stack.CCS.getCurrentCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1yG: // global
           R2 = R2;
           call GHC.Stack.CCS.getCurrentCCS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.356638697 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf1_closure" {
     GHC.Stack.CCS.getCCSOf1_closure:
         const GHC.Stack.CCS.getCCSOf1_info;
 },
 GHC.Stack.CCS.getCCSOf1_entry() //  [R2]
         { info_tbl: [(ca1yS,
                       label: GHC.Stack.CCS.getCCSOf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1yS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1yW; else goto ca1yV;
       ca1yW: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCCSOf1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1yV: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = 0;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.360286872 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf_closure" {
     GHC.Stack.CCS.getCCSOf_closure:
         const GHC.Stack.CCS.getCCSOf_info;
 },
 GHC.Stack.CCS.getCCSOf_entry() //  [R2]
         { info_tbl: [(ca1z6,
                       label: GHC.Stack.CCS.getCCSOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1z6: // global
           R2 = R2;
           call GHC.Stack.CCS.getCCSOf1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.363644889 UTC

[section ""data" . GHC.Stack.CCS.clearCCS_closure" {
     GHC.Stack.CCS.clearCCS_closure:
         const GHC.Stack.CCS.clearCCS_info;
 },
 GHC.Stack.CCS.clearCCS_entry() //  [R2]
         { info_tbl: [(ca1zh,
                       label: GHC.Stack.CCS.clearCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1zh: // global
           R1 = R2;
           call stg_clearCCS#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.367279502 UTC

[section ""cstring" . f_ra1i8_bytes" {
     f_ra1i8_bytes:
         I8[] [10,32,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.369888241 UTC

[section ""data" . f1_ra1i9_closure" {
     f1_ra1i9_closure:
         const f1_ra1i9_info;
         const 0;
         const 0;
         const 0;
 },
 f1_ra1i9_entry() //  [R1]
         { info_tbl: [(ca1zv,
                       label: f1_ra1i9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1zv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1zw; else goto ca1zx;
       ca1zw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1zx: // global
           (_ca1zs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1zs::I64 == 0) goto ca1zu; else goto ca1zt;
       ca1zu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1zt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1zs::I64;
           R2 = f_ra1i8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.373767044 UTC

[section ""cstring" . GHC.Stack.CCS.renderStack1_bytes" {
     GHC.Stack.CCS.renderStack1_bytes:
         I8[] [67,97,108,108,83,116,97,99,107,32,40,102,114,111,109,32,45,112,114,111,102,41,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.376059603 UTC

[section ""data" . GHC.Stack.CCS.renderStack_go_closure" {
     GHC.Stack.CCS.renderStack_go_closure:
         const GHC.Stack.CCS.renderStack_go_info;
         const 0;
 },
 sat_sa1iy_entry() //  [R1]
         { info_tbl: [(ca1zY,
                       label: sat_sa1iy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1zY: // global
           R2 = P64[R1 + 16];
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa1iz_entry() //  [R1]
         { info_tbl: [(ca1A1,
                       label: sat_sa1iz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1A1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1A5; else goto ca1A4;
       ca1A5: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1A4: // global
           _sa1iw::P64 = P64[R1 + 16];
           _sa1ix::P64 = P64[R1 + 24];
           I64[Hp - 16] = sat_sa1iy_info;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 16;
           R2 = _sa1iw::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stack.CCS.renderStack_go_entry() //  [R2]
         { info_tbl: [(ca1Aa,
                       label: GHC.Stack.CCS.renderStack_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Aa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Ab; else goto ca1Ac;
       ca1Ab: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Ac: // global
           I64[Sp - 8] = block_ca1zK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Ai; else goto ca1zL;
       ua1Ai: // global
           call _ca1zK(R1) args: 0, res: 0, upd: 0;
       ca1zL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1zK() //  [R1]
         { info_tbl: [(ca1zK,
                       label: block_ca1zK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1zK: // global
           if (R1 & 7 == 1) goto ca1A7; else goto ca1A8;
       ca1A7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1A8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca1Ah; else goto ca1Ag;
       ca1Ah: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Ag: // global
           _sa1iw::P64 = P64[R1 + 6];
           _sa1ix::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sa1iz_info;
           P64[Hp - 8] = _sa1iw::P64;
           P64[Hp] = _sa1ix::P64;
           R3 = Hp - 24;
           R2 = f1_ra1i9_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.386246733 UTC

[section ""data" . GHC.Stack.CCS.renderStack_closure" {
     GHC.Stack.CCS.renderStack_closure:
         const GHC.Stack.CCS.renderStack_info;
         const 0;
 },
 sat_sa1iC_entry() //  [R1]
         { info_tbl: [(ca1AL,
                       label: sat_sa1iC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1AL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca1AM; else goto ca1AN;
       ca1AM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1AN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca1AJ_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca1AJ() //  [R1]
         { info_tbl: [(ca1AJ,
                       label: block_ca1AJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1AJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.renderStack_entry() //  [R2]
         { info_tbl: [(ca1AR,
                       label: GHC.Stack.CCS.renderStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1AR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1AV; else goto ca1AU;
       ca1AV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1AU: // global
           I64[Hp - 16] = sat_sa1iC_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.39386644 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule4_bytes" {
     GHC.Stack.CCS.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.39547477 UTC

[section ""data" . GHC.Stack.CCS.$trModule3_closure" {
     GHC.Stack.CCS.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.39713834 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule2_bytes" {
     GHC.Stack.CCS.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107,46,67,67,83]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.399316706 UTC

[section ""data" . GHC.Stack.CCS.$trModule1_closure" {
     GHC.Stack.CCS.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.400991493 UTC

[section ""data" . GHC.Stack.CCS.$trModule_closure" {
     GHC.Stack.CCS.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.CCS.$trModule3_closure+1;
         const GHC.Stack.CCS.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.402776198 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentreStack2_bytes" {
     GHC.Stack.CCS.$tcCostCentreStack2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.4044278 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack1_closure" {
     GHC.Stack.CCS.$tcCostCentreStack1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentreStack2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.406198225 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack_closure" {
     GHC.Stack.CCS.$tcCostCentreStack_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentreStack1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4388269014118491027;
         const 5682182778281832541;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.408080594 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentre2_bytes" {
     GHC.Stack.CCS.$tcCostCentre2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.410198246 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre1_closure" {
     GHC.Stack.CCS.$tcCostCentre1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentre2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.411965019 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre_closure" {
     GHC.Stack.CCS.$tcCostCentre_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentre1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10996116669986307392;
         const 5747049382639019202;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.414418224 UTC

[section ""data" . GHC.Stack.CCS.ccsCC1_closure" {
     GHC.Stack.CCS.ccsCC1_closure:
         const GHC.Stack.CCS.ccsCC1_info;
 },
 GHC.Stack.CCS.ccsCC1_entry() //  [R2]
         { info_tbl: [(ca1Bp,
                       label: GHC.Stack.CCS.ccsCC1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Bp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Bw; else goto ca1Bx;
       ca1Bw: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsCC1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Bx: // global
           I64[Sp - 8] = block_ca1Bm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1BB; else goto ca1Bn;
       ua1BB: // global
           call _ca1Bm(R1) args: 0, res: 0, upd: 0;
       ca1Bn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Bm() //  [R1]
         { info_tbl: [(ca1Bm,
                       label: block_ca1Bm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Bm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1BA; else goto ca1Bz;
       ca1BA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Bz: // global
           _sa1iK::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iK::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.420699889 UTC

[section ""data" . GHC.Stack.CCS.ccsCC_closure" {
     GHC.Stack.CCS.ccsCC_closure:
         const GHC.Stack.CCS.ccsCC_info;
 },
 GHC.Stack.CCS.ccsCC_entry() //  [R2]
         { info_tbl: [(ca1BR,
                       label: GHC.Stack.CCS.ccsCC_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1BR: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsCC1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.424630243 UTC

[section ""data" . GHC.Stack.CCS.ccsParent1_closure" {
     GHC.Stack.CCS.ccsParent1_closure:
         const GHC.Stack.CCS.ccsParent1_info;
 },
 GHC.Stack.CCS.ccsParent1_entry() //  [R2]
         { info_tbl: [(ca1C5,
                       label: GHC.Stack.CCS.ccsParent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1C5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Cc; else goto ca1Cd;
       ca1Cc: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsParent1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Cd: // global
           I64[Sp - 8] = block_ca1C2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Ch; else goto ca1C3;
       ua1Ch: // global
           call _ca1C2(R1) args: 0, res: 0, upd: 0;
       ca1C3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1C2() //  [R1]
         { info_tbl: [(ca1C2,
                       label: block_ca1C2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1C2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1Cg; else goto ca1Cf;
       ca1Cg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Cf: // global
           _sa1iT::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1iT::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.430357283 UTC

[section ""data" . GHC.Stack.CCS.ccsParent_closure" {
     GHC.Stack.CCS.ccsParent_closure:
         const GHC.Stack.CCS.ccsParent_info;
 },
 GHC.Stack.CCS.ccsParent_entry() //  [R2]
         { info_tbl: [(ca1Cx,
                       label: GHC.Stack.CCS.ccsParent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Cx: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsParent1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.434170177 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan1_closure" {
     GHC.Stack.CCS.ccSrcSpan1_closure:
         const GHC.Stack.CCS.ccSrcSpan1_info;
 },
 GHC.Stack.CCS.ccSrcSpan1_entry() //  [R2]
         { info_tbl: [(ca1CL,
                       label: GHC.Stack.CCS.ccSrcSpan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1CL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1CS; else goto ca1CT;
       ca1CS: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccSrcSpan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1CT: // global
           I64[Sp - 8] = block_ca1CI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1CX; else goto ca1CJ;
       ua1CX: // global
           call _ca1CI(R1) args: 0, res: 0, upd: 0;
       ca1CJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1CI() //  [R1]
         { info_tbl: [(ca1CI,
                       label: block_ca1CI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1CI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1CW; else goto ca1CV;
       ca1CW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1CV: // global
           _sa1j2::I64 = I64[I64[R1 + 7] + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1j2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.440073395 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan_closure" {
     GHC.Stack.CCS.ccSrcSpan_closure:
         const GHC.Stack.CCS.ccSrcSpan_info;
 },
 GHC.Stack.CCS.ccSrcSpan_entry() //  [R2]
         { info_tbl: [(ca1Dd,
                       label: GHC.Stack.CCS.ccSrcSpan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Dd: // global
           R2 = R2;
           call GHC.Stack.CCS.ccSrcSpan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.444112242 UTC

[section ""data" . GHC.Stack.CCS.ccModule1_closure" {
     GHC.Stack.CCS.ccModule1_closure:
         const GHC.Stack.CCS.ccModule1_info;
 },
 GHC.Stack.CCS.ccModule1_entry() //  [R2]
         { info_tbl: [(ca1Dr,
                       label: GHC.Stack.CCS.ccModule1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Dr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Dy; else goto ca1Dz;
       ca1Dy: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccModule1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Dz: // global
           I64[Sp - 8] = block_ca1Do_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1DD; else goto ca1Dp;
       ua1DD: // global
           call _ca1Do(R1) args: 0, res: 0, upd: 0;
       ca1Dp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Do() //  [R1]
         { info_tbl: [(ca1Do,
                       label: block_ca1Do_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Do: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1DC; else goto ca1DB;
       ca1DC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1DB: // global
           _sa1jb::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.449931638 UTC

[section ""data" . GHC.Stack.CCS.ccModule_closure" {
     GHC.Stack.CCS.ccModule_closure:
         const GHC.Stack.CCS.ccModule_info;
 },
 GHC.Stack.CCS.ccModule_entry() //  [R2]
         { info_tbl: [(ca1DT,
                       label: GHC.Stack.CCS.ccModule_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1DT: // global
           R2 = R2;
           call GHC.Stack.CCS.ccModule1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.453345961 UTC

[section ""data" . GHC.Stack.CCS.ccLabel1_closure" {
     GHC.Stack.CCS.ccLabel1_closure:
         const GHC.Stack.CCS.ccLabel1_info;
 },
 GHC.Stack.CCS.ccLabel1_entry() //  [R2]
         { info_tbl: [(ca1E7,
                       label: GHC.Stack.CCS.ccLabel1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1E7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Ee; else goto ca1Ef;
       ca1Ee: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccLabel1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Ef: // global
           I64[Sp - 8] = block_ca1E4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Ej; else goto ca1E5;
       ua1Ej: // global
           call _ca1E4(R1) args: 0, res: 0, upd: 0;
       ca1E5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1E4() //  [R1]
         { info_tbl: [(ca1E4,
                       label: block_ca1E4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1E4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1Ei; else goto ca1Eh;
       ca1Ei: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Eh: // global
           _sa1jk::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1jk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.459118746 UTC

[section ""data" . GHC.Stack.CCS.ccLabel_closure" {
     GHC.Stack.CCS.ccLabel_closure:
         const GHC.Stack.CCS.ccLabel_info;
 },
 GHC.Stack.CCS.ccLabel_entry() //  [R2]
         { info_tbl: [(ca1Ez,
                       label: GHC.Stack.CCS.ccLabel_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Ez: // global
           R2 = R2;
           call GHC.Stack.CCS.ccLabel1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.462277488 UTC

[section ""cstring" . lvl_ra1ia_bytes" {
     lvl_ra1ia_bytes:
         I8[] [77,65,73,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.464238273 UTC

[section ""data" . lvl1_ra1ib_closure" {
     lvl1_ra1ib_closure:
         const lvl1_ra1ib_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra1ib_entry() //  [R1]
         { info_tbl: [(ca1EN,
                       label: lvl1_ra1ib_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1EN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1EO; else goto ca1EP;
       ca1EO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1EP: // global
           (_ca1EK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1EK::I64 == 0) goto ca1EM; else goto ca1EL;
       ca1EM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1EL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1EK::I64;
           R2 = lvl_ra1ia_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.468545701 UTC

[section ""cstring" . lvl2_ra1ic_bytes" {
     lvl2_ra1ic_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.470487919 UTC

[section ""data" . lvl3_ra1id_closure" {
     lvl3_ra1id_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.47213325 UTC

[section ""data" . lvl4_ra1ie_closure" {
     lvl4_ra1ie_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.473723057 UTC

[section ""data" . lvl5_ra1if_closure" {
     lvl5_ra1if_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.475589994 UTC

[section ""data" . lvl6_ra1ig_closure" {
     lvl6_ra1ig_closure:
         const lvl6_ra1ig_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra1ig_entry() //  [R1]
         { info_tbl: [(ca1F7,
                       label: lvl6_ra1ig_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1F7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1F8; else goto ca1F9;
       ca1F8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1F9: // global
           (_ca1F4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1F4::I64 == 0) goto ca1F6; else goto ca1F5;
       ca1F6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1F5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1F4::I64;
           R2 = lvl2_ra1ic_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.480996124 UTC

[section ""data" . GHC.Stack.CCS.$wgo_closure" {
     GHC.Stack.CCS.$wgo_closure:
         const GHC.Stack.CCS.$wgo_info;
         const 0;
 },
 sat_sa1jU_entry() //  [R1]
         { info_tbl: [(ca1G1,
                       label: sat_sa1jU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1G1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1G2; else goto ca1G3;
       ca1G2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1G3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl6_ra1ig_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jX_entry() //  [R1]
         { info_tbl: [(ca1G6,
                       label: sat_sa1jX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1G6: // global
           _sa1jX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1G7; else goto ca1G8;
       ca1G8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca1Ga; else goto ca1G9;
       ca1Ga: // global
           HpAlloc = 72;
           goto ca1G7;
       ca1G7: // global
           R1 = _sa1jX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1G9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jX::P64;
           _sa1jA::P64 = P64[_sa1jX::P64 + 16];
           _sa1jO::P64 = P64[_sa1jX::P64 + 24];
           I64[Hp - 64] = sat_sa1jU_info;
           P64[Hp - 48] = _sa1jO::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl3_ra1id_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl4_ra1ie_closure+1;
           P64[Hp] = Hp - 38;
           R3 = Hp - 14;
           R2 = _sa1jA::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1jZ_entry() //  [R1]
         { info_tbl: [(ca1Gc,
                       label: sat_sa1jZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Gc: // global
           _sa1jZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1Gd; else goto ca1Ge;
       ca1Ge: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca1Gg; else goto ca1Gf;
       ca1Gg: // global
           HpAlloc = 56;
           goto ca1Gd;
       ca1Gd: // global
           R1 = _sa1jZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1Gf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1jZ::P64;
           _sa1jA::P64 = P64[_sa1jZ::P64 + 16];
           _sa1jH::P64 = P64[_sa1jZ::P64 + 24];
           _sa1jO::P64 = P64[_sa1jZ::P64 + 32];
           I64[Hp - 48] = sat_sa1jX_info;
           P64[Hp - 32] = _sa1jA::P64;
           P64[Hp - 24] = _sa1jO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl5_ra1if_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sa1jH::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.$wgo_entry() //  [R2, R3]
         { info_tbl: [(ca1Gk,
                       label: GHC.Stack.CCS.$wgo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Gk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca1Gl; else goto ua1GR;
       ca1Gl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua1GR: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca1Fi() args: 0, res: 0, upd: 0;
     }
 },
 _ca1Fi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Fi: // global
           _sa1jm::I64 = I64[Sp];
           if (_sa1jm::I64 == 0) goto ua1GS; else goto ca1Gi;
       ua1GS: // global
           Sp = Sp + 8;
           call _ca1Gj() args: 0, res: 0, upd: 0;
       ca1Gi: // global
           _sa1jt::I64 = I64[_sa1jm::I64 + 8];
           _sa1jx::I64 = I64[_sa1jt::I64 + 8];
           I64[Sp - 16] = block_ca1Fu_info;
           R3 = _sa1jx::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           I64[Sp - 8] = _sa1jt::I64;
           Sp = Sp - 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Fu() //  [R1]
         { info_tbl: [(ca1Fu,
                       label: block_ca1Fu_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Fu: // global
           _sa1jE::I64 = I64[I64[Sp + 8] + 16];
           I64[Sp - 8] = block_ca1Fz_info;
           R3 = _sa1jE::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Fz() //  [R1]
         { info_tbl: [(ca1Fz,
                       label: block_ca1Fz_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Fz: // global
           _sa1jL::I64 = I64[I64[Sp + 16] + 24];
           I64[Sp] = block_ca1FE_info;
           R3 = _sa1jL::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 16] = R1;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1FE() //  [R1]
         { info_tbl: [(ca1FE,
                       label: block_ca1FE_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1FE: // global
           _sa1jS::I64 = I64[I64[Sp + 24] + 16];
           I64[Sp - 8] = block_ca1Gq_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = _sa1jS::I64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Gq() //  [R1]
         { info_tbl: [(ca1Gq,
                       label: block_ca1Gq_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Gq: // global
           if (R1 & 7 == 1) goto ua1GY; else goto ca1GE;
       ua1GY: // global
           call _ca1FM() args: 0, res: 0, upd: 0;
       ca1GE: // global
           I64[Sp] = block_ca1GC_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1GC() //  [R1]
         { info_tbl: [(ca1GC,
                       label: block_ca1GC_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1GC: // global
           if (R1 & 7 == 1) goto ua1GZ; else goto ua1GT;
       ua1GZ: // global
           call _ca1FM() args: 0, res: 0, upd: 0;
       ua1GT: // global
           Sp = Sp + 40;
           call _ca1Gj() args: 0, res: 0, upd: 0;
     }
 },
 _ca1FM() //  []
         { info_tbl: [(ca1FM,
                       label: block_ca1FM_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1FM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ca1Gt; else goto ca1Gs;
       ca1Gt: // global
           HpAlloc = 64;
           I64[Sp] = block_ca1FM_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca1Gs: // global
           I64[Hp - 56] = sat_sa1jZ_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 32] = I64[Sp + 8];
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 32;
           call _ca1Fi() args: 0, res: 0, upd: 0;
     }
 },
 _ca1Gj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Gj: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.504950871 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings2_closure" {
     GHC.Stack.CCS.ccsToStrings2_closure:
         const GHC.Stack.CCS.ccsToStrings2_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings2_entry() //  [R2, R3]
         { info_tbl: [(ca1I3,
                       label: GHC.Stack.CCS.ccsToStrings2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1I3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1I4; else goto ca1I5;
       ca1I4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca1I5: // global
           I64[Sp - 16] = block_ca1I0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua1I9; else goto ca1I1;
       ua1I9: // global
           call _ca1I0(R1) args: 0, res: 0, upd: 0;
       ca1I1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1I0() //  [R1]
         { info_tbl: [(ca1I0,
                       label: block_ca1I0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1I0: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.510726299 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings1_closure" {
     GHC.Stack.CCS.ccsToStrings1_closure:
         const GHC.Stack.CCS.ccsToStrings1_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings1_entry() //  [R2]
         { info_tbl: [(ca1Iq,
                       label: GHC.Stack.CCS.ccsToStrings1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Iq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Ir; else goto ca1Is;
       ca1Ir: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Is: // global
           I64[Sp - 8] = block_ca1In_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Iw; else goto ca1Io;
       ua1Iw: // global
           call _ca1In(R1) args: 0, res: 0, upd: 0;
       ca1Io: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1In() //  [R1]
         { info_tbl: [(ca1In,
                       label: block_ca1In_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1In: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.516071783 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings_closure" {
     GHC.Stack.CCS.ccsToStrings_closure:
         const GHC.Stack.CCS.ccsToStrings_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings_entry() //  [R2]
         { info_tbl: [(ca1IK,
                       label: GHC.Stack.CCS.ccsToStrings_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1IK: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsToStrings1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.520342386 UTC

[section ""data" . GHC.Stack.CCS.whoCreated1_closure" {
     GHC.Stack.CCS.whoCreated1_closure:
         const GHC.Stack.CCS.whoCreated1_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated1_entry() //  []
         { info_tbl: [(ca1IV,
                       label: GHC.Stack.CCS.whoCreated1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1IV: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = 0;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.523729953 UTC

[section ""data" . GHC.Stack.CCS.whoCreated_closure" {
     GHC.Stack.CCS.whoCreated_closure:
         const GHC.Stack.CCS.whoCreated_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated_entry() //  [R2]
         { info_tbl: [(ca1J6,
                       label: GHC.Stack.CCS.whoCreated_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1J6: // global
           R2 = R2;
           call GHC.Stack.CCS.whoCreated1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.526907886 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack1_closure" {
     GHC.Stack.CCS.currentCallStack1_closure:
         const GHC.Stack.CCS.currentCallStack1_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack1_entry() //  []
         { info_tbl: [(ca1Jh,
                       label: GHC.Stack.CCS.currentCallStack1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Jh: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.530478374 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack_closure" {
     GHC.Stack.CCS.currentCallStack_closure:
         const GHC.Stack.CCS.currentCallStack_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack_entry() //  []
         { info_tbl: [(ca1Js,
                       label: GHC.Stack.CCS.currentCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Js: // global
           call GHC.Stack.CCS.currentCallStack1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.53362247 UTC

[section ""relreadonly" . Sa1lM_srt" {
     Sa1lM_srt:
         const GHC.Stack.CCS.renderStack_go_closure;
         const f1_ra1i9_closure;
         const GHC.Stack.CCS.renderStack_closure;
         const lvl6_ra1ig_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const lvl1_ra1ib_closure;
         const GHC.Stack.CCS.ccsToStrings2_closure;
         const GHC.Stack.CCS.ccsToStrings1_closure;
         const GHC.Stack.CCS.whoCreated1_closure;
         const GHC.Stack.CCS.currentCallStack1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.857905675 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:04.859330662 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS1_closure" {
     GHC.Stack.CCS.getCurrentCCS1_closure:
         const GHC.Stack.CCS.getCurrentCCS1_info;
 },
 GHC.Stack.CCS.getCurrentCCS1_entry() //  [R2]
         { info_tbl: [(ca1LI,
                       label: GHC.Stack.CCS.getCurrentCCS1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1LI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1LM; else goto ca1LL;
       ca1LM: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCurrentCCS1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1LL: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = CCCS;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.863305452 UTC

[section ""data" . GHC.Stack.CCS.getCurrentCCS_closure" {
     GHC.Stack.CCS.getCurrentCCS_closure:
         const GHC.Stack.CCS.getCurrentCCS_info;
 },
 GHC.Stack.CCS.getCurrentCCS_entry() //  [R2]
         { info_tbl: [(ca1LY,
                       label: GHC.Stack.CCS.getCurrentCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1LY: // global
           R2 = R2;
           call GHC.Stack.CCS.getCurrentCCS1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.866809528 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf1_closure" {
     GHC.Stack.CCS.getCCSOf1_closure:
         const GHC.Stack.CCS.getCCSOf1_info;
 },
 GHC.Stack.CCS.getCCSOf1_entry() //  [R2]
         { info_tbl: [(ca1Ma,
                       label: GHC.Stack.CCS.getCCSOf1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Ma: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1Me; else goto ca1Md;
       ca1Me: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Stack.CCS.getCCSOf1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Md: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = 0;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.870512081 UTC

[section ""data" . GHC.Stack.CCS.getCCSOf_closure" {
     GHC.Stack.CCS.getCCSOf_closure:
         const GHC.Stack.CCS.getCCSOf_info;
 },
 GHC.Stack.CCS.getCCSOf_entry() //  [R2]
         { info_tbl: [(ca1Mp,
                       label: GHC.Stack.CCS.getCCSOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Mp: // global
           R2 = R2;
           call GHC.Stack.CCS.getCCSOf1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.874026738 UTC

[section ""data" . GHC.Stack.CCS.clearCCS_closure" {
     GHC.Stack.CCS.clearCCS_closure:
         const GHC.Stack.CCS.clearCCS_info;
 },
 GHC.Stack.CCS.clearCCS_entry() //  [R2]
         { info_tbl: [(ca1MA,
                       label: GHC.Stack.CCS.clearCCS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1MA: // global
           R1 = R2;
           call stg_clearCCS#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.877030358 UTC

[section ""cstring" . f_ra1i8_bytes" {
     f_ra1i8_bytes:
         I8[] [10,32,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.878871536 UTC

[section ""data" . f1_ra1i9_closure" {
     f1_ra1i9_closure:
         const f1_ra1i9_info;
         const 0;
         const 0;
         const 0;
 },
 f1_ra1i9_entry() //  [R1]
         { info_tbl: [(ca1MO,
                       label: f1_ra1i9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1MO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1MP; else goto ca1MQ;
       ca1MP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1MQ: // global
           (_ca1ML::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1ML::I64 == 0) goto ca1MN; else goto ca1MM;
       ca1MN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1MM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1ML::I64;
           R2 = f_ra1i8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.883010025 UTC

[section ""cstring" . GHC.Stack.CCS.renderStack1_bytes" {
     GHC.Stack.CCS.renderStack1_bytes:
         I8[] [67,97,108,108,83,116,97,99,107,32,40,102,114,111,109,32,45,112,114,111,102,41,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.885608037 UTC

[section ""data" . GHC.Stack.CCS.renderStack_go_closure" {
     GHC.Stack.CCS.renderStack_go_closure:
         const GHC.Stack.CCS.renderStack_go_info;
         const 0;
 },
 sat_sa1JQ_entry() //  [R1]
         { info_tbl: [(ca1Ni,
                       label: sat_sa1JQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Ni: // global
           R2 = P64[R1 + 16];
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sa1JR_entry() //  [R1]
         { info_tbl: [(ca1Nl,
                       label: sat_sa1JR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Nl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1Np; else goto ca1No;
       ca1Np: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1No: // global
           _sa1JO::P64 = P64[R1 + 16];
           _sa1JP::P64 = P64[R1 + 24];
           I64[Hp - 16] = sat_sa1JQ_info;
           P64[Hp] = _sa1JP::P64;
           R3 = Hp - 16;
           R2 = _sa1JO::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stack.CCS.renderStack_go_entry() //  [R2]
         { info_tbl: [(ca1Nu,
                       label: GHC.Stack.CCS.renderStack_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Nu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Nv; else goto ca1Nw;
       ca1Nv: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Nw: // global
           I64[Sp - 8] = block_ca1N4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1NC; else goto ca1N5;
       ua1NC: // global
           call _ca1N4(R1) args: 0, res: 0, upd: 0;
       ca1N5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1N4() //  [R1]
         { info_tbl: [(ca1N4,
                       label: block_ca1N4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1N4: // global
           if (R1 & 7 == 1) goto ca1Nr; else goto ca1Ns;
       ca1Nr: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ca1Ns: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ca1NB; else goto ca1NA;
       ca1NB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1NA: // global
           _sa1JO::P64 = P64[R1 + 6];
           _sa1JP::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sa1JR_info;
           P64[Hp - 8] = _sa1JO::P64;
           P64[Hp] = _sa1JP::P64;
           R3 = Hp - 24;
           R2 = f1_ra1i9_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.895445664 UTC

[section ""data" . GHC.Stack.CCS.renderStack_closure" {
     GHC.Stack.CCS.renderStack_closure:
         const GHC.Stack.CCS.renderStack_info;
         const 0;
 },
 sat_sa1JU_entry() //  [R1]
         { info_tbl: [(ca1Oa,
                       label: sat_sa1JU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Oa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ca1Ob; else goto ca1Oc;
       ca1Ob: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1Oc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ca1O8_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ca1O8() //  [R1]
         { info_tbl: [(ca1O8,
                       label: block_ca1O8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1O8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.renderStack_entry() //  [R2]
         { info_tbl: [(ca1Og,
                       label: GHC.Stack.CCS.renderStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Og: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ca1Ok; else goto ca1Oj;
       ca1Ok: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stack.CCS.renderStack_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Oj: // global
           I64[Hp - 16] = sat_sa1JU_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.90283178 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule4_bytes" {
     GHC.Stack.CCS.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.904507718 UTC

[section ""data" . GHC.Stack.CCS.$trModule3_closure" {
     GHC.Stack.CCS.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.906462056 UTC

[section ""cstring" . GHC.Stack.CCS.$trModule2_bytes" {
     GHC.Stack.CCS.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,99,107,46,67,67,83]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.908069554 UTC

[section ""data" . GHC.Stack.CCS.$trModule1_closure" {
     GHC.Stack.CCS.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.909687931 UTC

[section ""data" . GHC.Stack.CCS.$trModule_closure" {
     GHC.Stack.CCS.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stack.CCS.$trModule3_closure+1;
         const GHC.Stack.CCS.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.911373834 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentreStack2_bytes" {
     GHC.Stack.CCS.$tcCostCentreStack2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101,83,116,97,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.913031494 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack1_closure" {
     GHC.Stack.CCS.$tcCostCentreStack1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentreStack2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.915114958 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentreStack_closure" {
     GHC.Stack.CCS.$tcCostCentreStack_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentreStack1_closure+1;
         const GHC.Types.krep$*_closure;
         const 4388269014118491027;
         const 5682182778281832541;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.91708053 UTC

[section ""cstring" . GHC.Stack.CCS.$tcCostCentre2_bytes" {
     GHC.Stack.CCS.$tcCostCentre2_bytes:
         I8[] [67,111,115,116,67,101,110,116,114,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.918705633 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre1_closure" {
     GHC.Stack.CCS.$tcCostCentre1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stack.CCS.$tcCostCentre2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.920304453 UTC

[section ""data" . GHC.Stack.CCS.$tcCostCentre_closure" {
     GHC.Stack.CCS.$tcCostCentre_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stack.CCS.$trModule_closure+1;
         const GHC.Stack.CCS.$tcCostCentre1_closure+1;
         const GHC.Types.krep$*_closure;
         const 10996116669986307392;
         const 5747049382639019202;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.922540636 UTC

[section ""data" . GHC.Stack.CCS.ccsCC1_closure" {
     GHC.Stack.CCS.ccsCC1_closure:
         const GHC.Stack.CCS.ccsCC1_info;
 },
 GHC.Stack.CCS.ccsCC1_entry() //  [R2]
         { info_tbl: [(ca1OS,
                       label: GHC.Stack.CCS.ccsCC1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1OS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1OZ; else goto ca1P0;
       ca1OZ: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsCC1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1P0: // global
           I64[Sp - 8] = block_ca1OP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1P4; else goto ca1OQ;
       ua1P4: // global
           call _ca1OP(R1) args: 0, res: 0, upd: 0;
       ca1OQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1OP() //  [R1]
         { info_tbl: [(ca1OP,
                       label: block_ca1OP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1OP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1P3; else goto ca1P2;
       ca1P3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1P2: // global
           _sa1K2::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1K2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.928362754 UTC

[section ""data" . GHC.Stack.CCS.ccsCC_closure" {
     GHC.Stack.CCS.ccsCC_closure:
         const GHC.Stack.CCS.ccsCC_info;
 },
 GHC.Stack.CCS.ccsCC_entry() //  [R2]
         { info_tbl: [(ca1Pm,
                       label: GHC.Stack.CCS.ccsCC_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Pm: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsCC1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.931775118 UTC

[section ""data" . GHC.Stack.CCS.ccsParent1_closure" {
     GHC.Stack.CCS.ccsParent1_closure:
         const GHC.Stack.CCS.ccsParent1_info;
 },
 GHC.Stack.CCS.ccsParent1_entry() //  [R2]
         { info_tbl: [(ca1PA,
                       label: GHC.Stack.CCS.ccsParent1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1PA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1PH; else goto ca1PI;
       ca1PH: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsParent1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1PI: // global
           I64[Sp - 8] = block_ca1Px_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1PM; else goto ca1Py;
       ua1PM: // global
           call _ca1Px(R1) args: 0, res: 0, upd: 0;
       ca1Py: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Px() //  [R1]
         { info_tbl: [(ca1Px,
                       label: block_ca1Px_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Px: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1PL; else goto ca1PK;
       ca1PL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1PK: // global
           _sa1Kb::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1Kb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.938281948 UTC

[section ""data" . GHC.Stack.CCS.ccsParent_closure" {
     GHC.Stack.CCS.ccsParent_closure:
         const GHC.Stack.CCS.ccsParent_info;
 },
 GHC.Stack.CCS.ccsParent_entry() //  [R2]
         { info_tbl: [(ca1Q4,
                       label: GHC.Stack.CCS.ccsParent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Q4: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsParent1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.941571564 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan1_closure" {
     GHC.Stack.CCS.ccSrcSpan1_closure:
         const GHC.Stack.CCS.ccSrcSpan1_info;
 },
 GHC.Stack.CCS.ccSrcSpan1_entry() //  [R2]
         { info_tbl: [(ca1Qi,
                       label: GHC.Stack.CCS.ccSrcSpan1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Qi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Qp; else goto ca1Qq;
       ca1Qp: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccSrcSpan1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Qq: // global
           I64[Sp - 8] = block_ca1Qf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Qu; else goto ca1Qg;
       ua1Qu: // global
           call _ca1Qf(R1) args: 0, res: 0, upd: 0;
       ca1Qg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Qf() //  [R1]
         { info_tbl: [(ca1Qf,
                       label: block_ca1Qf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Qf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1Qt; else goto ca1Qs;
       ca1Qt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Qs: // global
           _sa1Kk::I64 = I64[I64[R1 + 7] + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1Kk::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.947700432 UTC

[section ""data" . GHC.Stack.CCS.ccSrcSpan_closure" {
     GHC.Stack.CCS.ccSrcSpan_closure:
         const GHC.Stack.CCS.ccSrcSpan_info;
 },
 GHC.Stack.CCS.ccSrcSpan_entry() //  [R2]
         { info_tbl: [(ca1QM,
                       label: GHC.Stack.CCS.ccSrcSpan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1QM: // global
           R2 = R2;
           call GHC.Stack.CCS.ccSrcSpan1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.950976496 UTC

[section ""data" . GHC.Stack.CCS.ccModule1_closure" {
     GHC.Stack.CCS.ccModule1_closure:
         const GHC.Stack.CCS.ccModule1_info;
 },
 GHC.Stack.CCS.ccModule1_entry() //  [R2]
         { info_tbl: [(ca1R0,
                       label: GHC.Stack.CCS.ccModule1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1R0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1R7; else goto ca1R8;
       ca1R7: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccModule1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1R8: // global
           I64[Sp - 8] = block_ca1QX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Rc; else goto ca1QY;
       ua1Rc: // global
           call _ca1QX(R1) args: 0, res: 0, upd: 0;
       ca1QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1QX() //  [R1]
         { info_tbl: [(ca1QX,
                       label: block_ca1QX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1QX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1Rb; else goto ca1Ra;
       ca1Rb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1Ra: // global
           _sa1Kt::I64 = I64[I64[R1 + 7] + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1Kt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.956444053 UTC

[section ""data" . GHC.Stack.CCS.ccModule_closure" {
     GHC.Stack.CCS.ccModule_closure:
         const GHC.Stack.CCS.ccModule_info;
 },
 GHC.Stack.CCS.ccModule_entry() //  [R2]
         { info_tbl: [(ca1Ru,
                       label: GHC.Stack.CCS.ccModule_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Ru: // global
           R2 = R2;
           call GHC.Stack.CCS.ccModule1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.960452368 UTC

[section ""data" . GHC.Stack.CCS.ccLabel1_closure" {
     GHC.Stack.CCS.ccLabel1_closure:
         const GHC.Stack.CCS.ccLabel1_info;
 },
 GHC.Stack.CCS.ccLabel1_entry() //  [R2]
         { info_tbl: [(ca1RI,
                       label: GHC.Stack.CCS.ccLabel1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1RI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1RP; else goto ca1RQ;
       ca1RP: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccLabel1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1RQ: // global
           I64[Sp - 8] = block_ca1RF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1RU; else goto ca1RG;
       ua1RU: // global
           call _ca1RF(R1) args: 0, res: 0, upd: 0;
       ca1RG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1RF() //  [R1]
         { info_tbl: [(ca1RF,
                       label: block_ca1RF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1RF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ca1RT; else goto ca1RS;
       ca1RT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ca1RS: // global
           _sa1KC::I64 = I64[I64[R1 + 7] + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sa1KC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.965823735 UTC

[section ""data" . GHC.Stack.CCS.ccLabel_closure" {
     GHC.Stack.CCS.ccLabel_closure:
         const GHC.Stack.CCS.ccLabel_info;
 },
 GHC.Stack.CCS.ccLabel_entry() //  [R2]
         { info_tbl: [(ca1Sc,
                       label: GHC.Stack.CCS.ccLabel_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Sc: // global
           R2 = R2;
           call GHC.Stack.CCS.ccLabel1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.969024834 UTC

[section ""cstring" . lvl_ra1ia_bytes" {
     lvl_ra1ia_bytes:
         I8[] [77,65,73,78]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.971141616 UTC

[section ""data" . lvl1_ra1ib_closure" {
     lvl1_ra1ib_closure:
         const lvl1_ra1ib_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ra1ib_entry() //  [R1]
         { info_tbl: [(ca1Sq,
                       label: lvl1_ra1ib_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Sq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1Sr; else goto ca1Ss;
       ca1Sr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1Ss: // global
           (_ca1Sn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1Sn::I64 == 0) goto ca1Sp; else goto ca1So;
       ca1Sp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1So: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1Sn::I64;
           R2 = lvl_ra1ia_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.9749124 UTC

[section ""cstring" . lvl2_ra1ic_bytes" {
     lvl2_ra1ic_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.976487336 UTC

[section ""data" . lvl3_ra1id_closure" {
     lvl3_ra1id_closure:
         const GHC.Types.C#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.978114218 UTC

[section ""data" . lvl4_ra1ie_closure" {
     lvl4_ra1ie_closure:
         const GHC.Types.C#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.979952814 UTC

[section ""data" . lvl5_ra1if_closure" {
     lvl5_ra1if_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.982030691 UTC

[section ""data" . lvl6_ra1ig_closure" {
     lvl6_ra1ig_closure:
         const lvl6_ra1ig_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_ra1ig_entry() //  [R1]
         { info_tbl: [(ca1SL,
                       label: lvl6_ra1ig_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1SL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1SM; else goto ca1SN;
       ca1SM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1SN: // global
           (_ca1SI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ca1SI::I64 == 0) goto ca1SK; else goto ca1SJ;
       ca1SK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ca1SJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ca1SI::I64;
           R2 = lvl2_ra1ic_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:04.987112733 UTC

[section ""data" . GHC.Stack.CCS.$wgo_closure" {
     GHC.Stack.CCS.$wgo_closure:
         const GHC.Stack.CCS.$wgo_info;
         const 0;
 },
 sat_sa1Lc_entry() //  [R1]
         { info_tbl: [(ca1TG,
                       label: sat_sa1Lc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1TG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1TH; else goto ca1TI;
       ca1TH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1TI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = lvl6_ra1ig_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1Lf_entry() //  [R1]
         { info_tbl: [(ca1TL,
                       label: sat_sa1Lf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1TL: // global
           _sa1Lf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1TM; else goto ca1TN;
       ca1TN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ca1TP; else goto ca1TO;
       ca1TP: // global
           HpAlloc = 72;
           goto ca1TM;
       ca1TM: // global
           R1 = _sa1Lf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1TO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1Lf::P64;
           _sa1KS::P64 = P64[_sa1Lf::P64 + 16];
           _sa1L6::P64 = P64[_sa1Lf::P64 + 24];
           I64[Hp - 64] = sat_sa1Lc_info;
           P64[Hp - 48] = _sa1L6::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl3_ra1id_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl4_ra1ie_closure+1;
           P64[Hp] = Hp - 38;
           R3 = Hp - 14;
           R2 = _sa1KS::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sa1Lh_entry() //  [R1]
         { info_tbl: [(ca1TR,
                       label: sat_sa1Lh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1TR: // global
           _sa1Lh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ca1TS; else goto ca1TT;
       ca1TT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ca1TV; else goto ca1TU;
       ca1TV: // global
           HpAlloc = 56;
           goto ca1TS;
       ca1TS: // global
           R1 = _sa1Lh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ca1TU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sa1Lh::P64;
           _sa1KS::P64 = P64[_sa1Lh::P64 + 16];
           _sa1KZ::P64 = P64[_sa1Lh::P64 + 24];
           _sa1L6::P64 = P64[_sa1Lh::P64 + 32];
           I64[Hp - 48] = sat_sa1Lf_info;
           P64[Hp - 32] = _sa1KS::P64;
           P64[Hp - 24] = _sa1L6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl5_ra1if_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sa1KZ::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stack.CCS.$wgo_entry() //  [R2, R3]
         { info_tbl: [(ca1TZ,
                       label: GHC.Stack.CCS.$wgo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1TZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ca1U0; else goto ua1Uw;
       ca1U0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ua1Uw: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ca1SX() args: 0, res: 0, upd: 0;
     }
 },
 _ca1SX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1SX: // global
           _sa1KE::I64 = I64[Sp];
           if (_sa1KE::I64 == 0) goto ua1Ux; else goto ca1TX;
       ua1Ux: // global
           Sp = Sp + 8;
           call _ca1TY() args: 0, res: 0, upd: 0;
       ca1TX: // global
           _sa1KL::I64 = I64[_sa1KE::I64 + 8];
           _sa1KP::I64 = I64[_sa1KL::I64 + 8];
           I64[Sp - 16] = block_ca1T9_info;
           R3 = _sa1KP::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           I64[Sp - 8] = _sa1KL::I64;
           Sp = Sp - 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1T9() //  [R1]
         { info_tbl: [(ca1T9,
                       label: block_ca1T9_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1T9: // global
           _sa1KW::I64 = I64[I64[Sp + 8] + 16];
           I64[Sp - 8] = block_ca1Te_info;
           R3 = _sa1KW::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Te() //  [R1]
         { info_tbl: [(ca1Te,
                       label: block_ca1Te_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Te: // global
           _sa1L3::I64 = I64[I64[Sp + 16] + 24];
           I64[Sp] = block_ca1Tj_info;
           R3 = _sa1L3::I64;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp + 16] = R1;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Tj() //  [R1]
         { info_tbl: [(ca1Tj,
                       label: block_ca1Tj_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Tj: // global
           _sa1La::I64 = I64[I64[Sp + 24] + 16];
           I64[Sp - 8] = block_ca1U5_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           I64[Sp] = _sa1La::I64;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1U5() //  [R1]
         { info_tbl: [(ca1U5,
                       label: block_ca1U5_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1U5: // global
           if (R1 & 7 == 1) goto ua1UD; else goto ca1Uj;
       ua1UD: // global
           call _ca1Tr() args: 0, res: 0, upd: 0;
       ca1Uj: // global
           I64[Sp] = block_ca1Uh_info;
           R3 = lvl1_ra1ib_closure;
           R2 = P64[Sp + 16];
           call GHC.Base.eqString_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Uh() //  [R1]
         { info_tbl: [(ca1Uh,
                       label: block_ca1Uh_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Uh: // global
           if (R1 & 7 == 1) goto ua1UE; else goto ua1Uy;
       ua1UE: // global
           call _ca1Tr() args: 0, res: 0, upd: 0;
       ua1Uy: // global
           Sp = Sp + 40;
           call _ca1TY() args: 0, res: 0, upd: 0;
     }
 },
 _ca1Tr() //  []
         { info_tbl: [(ca1Tr,
                       label: block_ca1Tr_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Tr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ca1U8; else goto ca1U7;
       ca1U8: // global
           HpAlloc = 64;
           I64[Sp] = block_ca1Tr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ca1U7: // global
           I64[Hp - 56] = sat_sa1Lh_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 32] = I64[Sp + 8];
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 32;
           call _ca1SX() args: 0, res: 0, upd: 0;
     }
 },
 _ca1TY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1TY: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.009877126 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings2_closure" {
     GHC.Stack.CCS.ccsToStrings2_closure:
         const GHC.Stack.CCS.ccsToStrings2_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings2_entry() //  [R2, R3]
         { info_tbl: [(ca1W1,
                       label: GHC.Stack.CCS.ccsToStrings2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1W1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ca1W2; else goto ca1W3;
       ca1W2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ca1W3: // global
           I64[Sp - 16] = block_ca1VY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ua1W7; else goto ca1VZ;
       ua1W7: // global
           call _ca1VY(R1) args: 0, res: 0, upd: 0;
       ca1VZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1VY() //  [R1]
         { info_tbl: [(ca1VY,
                       label: block_ca1VY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1VY: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.015438386 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings1_closure" {
     GHC.Stack.CCS.ccsToStrings1_closure:
         const GHC.Stack.CCS.ccsToStrings1_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings1_entry() //  [R2]
         { info_tbl: [(ca1Wp,
                       label: GHC.Stack.CCS.ccsToStrings1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Wp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ca1Wq; else goto ca1Wr;
       ca1Wq: // global
           R2 = R2;
           R1 = GHC.Stack.CCS.ccsToStrings1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ca1Wr: // global
           I64[Sp - 8] = block_ca1Wm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ua1Wv; else goto ca1Wn;
       ua1Wv: // global
           call _ca1Wm(R1) args: 0, res: 0, upd: 0;
       ca1Wn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ca1Wm() //  [R1]
         { info_tbl: [(ca1Wm,
                       label: block_ca1Wm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Wm: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.020949961 UTC

[section ""data" . GHC.Stack.CCS.ccsToStrings_closure" {
     GHC.Stack.CCS.ccsToStrings_closure:
         const GHC.Stack.CCS.ccsToStrings_info;
         const 0;
 },
 GHC.Stack.CCS.ccsToStrings_entry() //  [R2]
         { info_tbl: [(ca1WL,
                       label: GHC.Stack.CCS.ccsToStrings_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1WL: // global
           R2 = R2;
           call GHC.Stack.CCS.ccsToStrings1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.024400637 UTC

[section ""data" . GHC.Stack.CCS.whoCreated1_closure" {
     GHC.Stack.CCS.whoCreated1_closure:
         const GHC.Stack.CCS.whoCreated1_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated1_entry() //  []
         { info_tbl: [(ca1WW,
                       label: GHC.Stack.CCS.whoCreated1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1WW: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = 0;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.027633335 UTC

[section ""data" . GHC.Stack.CCS.whoCreated_closure" {
     GHC.Stack.CCS.whoCreated_closure:
         const GHC.Stack.CCS.whoCreated_info;
         const 0;
 },
 GHC.Stack.CCS.whoCreated_entry() //  [R2]
         { info_tbl: [(ca1X8,
                       label: GHC.Stack.CCS.whoCreated_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1X8: // global
           R2 = R2;
           call GHC.Stack.CCS.whoCreated1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.031340693 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack1_closure" {
     GHC.Stack.CCS.currentCallStack1_closure:
         const GHC.Stack.CCS.currentCallStack1_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack1_entry() //  []
         { info_tbl: [(ca1Xj,
                       label: GHC.Stack.CCS.currentCallStack1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Xj: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.035021745 UTC

[section ""data" . GHC.Stack.CCS.currentCallStack_closure" {
     GHC.Stack.CCS.currentCallStack_closure:
         const GHC.Stack.CCS.currentCallStack_info;
         const 0;
 },
 GHC.Stack.CCS.currentCallStack_entry() //  []
         { info_tbl: [(ca1Xv,
                       label: GHC.Stack.CCS.currentCallStack_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ca1Xv: // global
           call GHC.Stack.CCS.currentCallStack1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:05.038035561 UTC

[section ""relreadonly" . Sa1ND_srt" {
     Sa1ND_srt:
         const GHC.Stack.CCS.renderStack_go_closure;
         const f1_ra1i9_closure;
         const GHC.Stack.CCS.renderStack_closure;
         const lvl6_ra1ig_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const lvl1_ra1ib_closure;
         const GHC.Stack.CCS.ccsToStrings2_closure;
         const GHC.Stack.CCS.ccsToStrings1_closure;
         const GHC.Stack.CCS.whoCreated1_closure;
         const GHC.Stack.CCS.currentCallStack1_closure;
 }]

