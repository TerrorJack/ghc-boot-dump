
==================== Output Cmm ====================
2018-03-16 16:02:47.222558203 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:47.223102194 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState6_bytes" {
     GHC.IO.$fShowMaskingState6_bytes:
         I8[] [85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.223952168 UTC

[section ""data" . GHC.IO.$fShowMaskingState5_closure" {
     GHC.IO.$fShowMaskingState5_closure:
         const GHC.IO.$fShowMaskingState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState5_entry() //  [R1]
         { info_tbl: [(c7E1R,
                       label: GHC.IO.$fShowMaskingState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E1R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E1S; else goto c7E1T;
       c7E1S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7E1T: // global
           (_c7E1O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7E1O::I64 == 0) goto c7E1Q; else goto c7E1P;
       c7E1Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7E1P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7E1O::I64;
           R2 = GHC.IO.$fShowMaskingState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.224868224 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState4_bytes" {
     GHC.IO.$fShowMaskingState4_bytes:
         I8[] [77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.22557564 UTC

[section ""data" . GHC.IO.$fShowMaskingState3_closure" {
     GHC.IO.$fShowMaskingState3_closure:
         const GHC.IO.$fShowMaskingState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState3_entry() //  [R1]
         { info_tbl: [(c7E20,
                       label: GHC.IO.$fShowMaskingState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E20: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E21; else goto c7E22;
       c7E21: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7E22: // global
           (_c7E1X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7E1X::I64 == 0) goto c7E1Z; else goto c7E1Y;
       c7E1Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7E1Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7E1X::I64;
           R2 = GHC.IO.$fShowMaskingState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.226417107 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState2_bytes" {
     GHC.IO.$fShowMaskingState2_bytes:
         I8[] [77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.227130619 UTC

[section ""data" . GHC.IO.$fShowMaskingState1_closure" {
     GHC.IO.$fShowMaskingState1_closure:
         const GHC.IO.$fShowMaskingState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState1_entry() //  [R1]
         { info_tbl: [(c7E29,
                       label: GHC.IO.$fShowMaskingState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E29: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E2a; else goto c7E2b;
       c7E2a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7E2b: // global
           (_c7E26::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7E26::I64 == 0) goto c7E28; else goto c7E27;
       c7E28: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7E27: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7E26::I64;
           R2 = GHC.IO.$fShowMaskingState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.228397072 UTC

[section ""data" . GHC.IO.$w$cshowsPrec_closure" {
     GHC.IO.$w$cshowsPrec_closure:
         const GHC.IO.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c7E2o,
                       label: GHC.IO.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E2o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E2p; else goto c7E2q;
       c7E2p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E2q: // global
           I64[Sp - 16] = block_c7E2g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7E2B; else goto c7E2h;
       u7E2B: // global
           call _c7E2g(R1) args: 0, res: 0, upd: 0;
       c7E2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E2g() //  [R1]
         { info_tbl: [(c7E2g,
                       label: block_c7E2g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E2g: // global
           _s7DXR::P64 = P64[Sp + 8];
           _c7E2n::P64 = R1 & 7;
           if (_c7E2n::P64 < 3) goto u7E2A; else goto c7E2m;
       u7E2A: // global
           if (_c7E2n::P64 < 2) goto c7E2k; else goto c7E2l;
       c7E2k: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7E2l: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7E2m: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.229770154 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowsPrec_closure" {
     GHC.IO.$fShowMaskingState_$cshowsPrec_closure:
         const GHC.IO.$fShowMaskingState_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c7E2H,
                       label: GHC.IO.$fShowMaskingState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E2H: // global
           _s7DXU::P64 = R3;
           R3 = R4;
           R2 = _s7DXU::P64;
           call GHC.IO.$w$cshowsPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.230762328 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshow_closure" {
     GHC.IO.$fShowMaskingState_$cshow_closure:
         const GHC.IO.$fShowMaskingState_$cshow_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshow_entry() //  [R2]
         { info_tbl: [(c7E2W,
                       label: GHC.IO.$fShowMaskingState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E2W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7E2X; else goto c7E2Y;
       c7E2X: // global
           R2 = R2;
           R1 = GHC.IO.$fShowMaskingState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E2Y: // global
           I64[Sp - 8] = block_c7E2O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7E39; else goto c7E2P;
       u7E39: // global
           call _c7E2O(R1) args: 0, res: 0, upd: 0;
       c7E2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E2O() //  [R1]
         { info_tbl: [(c7E2O,
                       label: block_c7E2O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E2O: // global
           _c7E2V::P64 = R1 & 7;
           if (_c7E2V::P64 < 3) goto u7E38; else goto c7E2U;
       u7E38: // global
           if (_c7E2V::P64 < 2) goto c7E2S; else goto c7E2T;
       c7E2S: // global
           R1 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7E2T: // global
           R1 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7E2U: // global
           R1 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.231974677 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowList_closure" {
     GHC.IO.$fShowMaskingState_$cshowList_closure:
         const GHC.IO.$fShowMaskingState_$cshowList_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c7E3e,
                       label: GHC.IO.$fShowMaskingState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E3e: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.232702741 UTC

[section ""data" . GHC.IO.$fShowMaskingState_closure" {
     GHC.IO.$fShowMaskingState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.$fShowMaskingState_$cshowsPrec_closure+3;
         const GHC.IO.$fShowMaskingState_$cshow_closure+1;
         const GHC.IO.$fShowMaskingState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.233943561 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c==_closure" {
     GHC.IO.$fEqMaskingState_$c==_closure:
         const GHC.IO.$fEqMaskingState_$c==_info;
 },
 GHC.IO.$fEqMaskingState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7E3t,
                       label: GHC.IO.$fEqMaskingState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E3u; else goto c7E3v;
       c7E3u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E3v: // global
           I64[Sp - 16] = block_c7E3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7E4s; else goto c7E3m;
       u7E4s: // global
           call _c7E3l(R1) args: 0, res: 0, upd: 0;
       c7E3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E3l() //  [R1]
         { info_tbl: [(c7E3l,
                       label: block_c7E3l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E3l: // global
           _s7DY1::P64 = P64[Sp + 8];
           _c7E3s::P64 = R1 & 7;
           if (_c7E3s::P64 < 3) goto u7E4i; else goto c7E3r;
       u7E4i: // global
           if (_c7E3s::P64 < 2) goto c7E3p; else goto c7E3q;
       c7E3p: // global
           I64[Sp + 8] = block_c7E3y_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E4p; else goto c7E3A;
       u7E4p: // global
           call _c7E3y(R1) args: 0, res: 0, upd: 0;
       c7E3A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7E3q: // global
           I64[Sp + 8] = block_c7E3N_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E4q; else goto c7E3P;
       u7E4q: // global
           call _c7E3N(R1) args: 0, res: 0, upd: 0;
       c7E3P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7E3r: // global
           I64[Sp + 8] = block_c7E42_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E4r; else goto c7E44;
       u7E4r: // global
           call _c7E42(R1) args: 0, res: 0, upd: 0;
       c7E44: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E3y() //  [R1]
         { info_tbl: [(c7E3y,
                       label: block_c7E3y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E3y: // global
           if (R1 & 7 == 1) goto u7E4j; else goto u7E4k;
       u7E4j: // global
           Sp = Sp + 8;
           call _c7E4e() args: 0, res: 0, upd: 0;
       u7E4k: // global
           Sp = Sp + 8;
           call _c7E4a() args: 0, res: 0, upd: 0;
     }
 },
 _c7E3N() //  [R1]
         { info_tbl: [(c7E3N,
                       label: block_c7E3N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E3N: // global
           if (R1 & 7 == 2) goto u7E4l; else goto u7E4m;
       u7E4l: // global
           Sp = Sp + 8;
           call _c7E4e() args: 0, res: 0, upd: 0;
       u7E4m: // global
           Sp = Sp + 8;
           call _c7E4a() args: 0, res: 0, upd: 0;
     }
 },
 _c7E42() //  [R1]
         { info_tbl: [(c7E42,
                       label: block_c7E42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E42: // global
           if (R1 & 7 == 3) goto u7E4n; else goto u7E4o;
       u7E4n: // global
           Sp = Sp + 8;
           call _c7E4e() args: 0, res: 0, upd: 0;
       u7E4o: // global
           Sp = Sp + 8;
           call _c7E4a() args: 0, res: 0, upd: 0;
     }
 },
 _c7E4e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E4e: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7E4a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E4a: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.2364246 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c/=_closure" {
     GHC.IO.$fEqMaskingState_$c/=_closure:
         const GHC.IO.$fEqMaskingState_$c/=_info;
 },
 GHC.IO.$fEqMaskingState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7E4L,
                       label: GHC.IO.$fEqMaskingState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E4M; else goto c7E4N;
       c7E4M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E4N: // global
           I64[Sp - 16] = block_c7E4D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7E5K; else goto c7E4E;
       u7E5K: // global
           call _c7E4D(R1) args: 0, res: 0, upd: 0;
       c7E4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E4D() //  [R1]
         { info_tbl: [(c7E4D,
                       label: block_c7E4D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E4D: // global
           _s7DY7::P64 = P64[Sp + 8];
           _c7E4K::P64 = R1 & 7;
           if (_c7E4K::P64 < 3) goto u7E5A; else goto c7E4J;
       u7E5A: // global
           if (_c7E4K::P64 < 2) goto c7E4H; else goto c7E4I;
       c7E4H: // global
           I64[Sp + 8] = block_c7E4Q_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E5H; else goto c7E4S;
       u7E5H: // global
           call _c7E4Q(R1) args: 0, res: 0, upd: 0;
       c7E4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7E4I: // global
           I64[Sp + 8] = block_c7E55_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E5I; else goto c7E57;
       u7E5I: // global
           call _c7E55(R1) args: 0, res: 0, upd: 0;
       c7E57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7E4J: // global
           I64[Sp + 8] = block_c7E5k_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7E5J; else goto c7E5m;
       u7E5J: // global
           call _c7E5k(R1) args: 0, res: 0, upd: 0;
       c7E5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E4Q() //  [R1]
         { info_tbl: [(c7E4Q,
                       label: block_c7E4Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E4Q: // global
           if (R1 & 7 == 1) goto u7E5B; else goto u7E5C;
       u7E5B: // global
           Sp = Sp + 8;
           call _c7E5w() args: 0, res: 0, upd: 0;
       u7E5C: // global
           Sp = Sp + 8;
           call _c7E5s() args: 0, res: 0, upd: 0;
     }
 },
 _c7E55() //  [R1]
         { info_tbl: [(c7E55,
                       label: block_c7E55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E55: // global
           if (R1 & 7 == 2) goto u7E5D; else goto u7E5E;
       u7E5D: // global
           Sp = Sp + 8;
           call _c7E5w() args: 0, res: 0, upd: 0;
       u7E5E: // global
           Sp = Sp + 8;
           call _c7E5s() args: 0, res: 0, upd: 0;
     }
 },
 _c7E5k() //  [R1]
         { info_tbl: [(c7E5k,
                       label: block_c7E5k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E5k: // global
           if (R1 & 7 == 3) goto u7E5F; else goto u7E5G;
       u7E5F: // global
           Sp = Sp + 8;
           call _c7E5w() args: 0, res: 0, upd: 0;
       u7E5G: // global
           Sp = Sp + 8;
           call _c7E5s() args: 0, res: 0, upd: 0;
     }
 },
 _c7E5w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E5w: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7E5s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E5s: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.238347994 UTC

[section ""data" . GHC.IO.$fEqMaskingState_closure" {
     GHC.IO.$fEqMaskingState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.$fEqMaskingState_$c==_closure+2;
         const GHC.IO.$fEqMaskingState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.239204123 UTC

[section ""data" . GHC.IO.liftIO_closure" {
     GHC.IO.liftIO_closure:
         const GHC.IO.liftIO_info;
 },
 GHC.IO.liftIO_entry() //  [R2]
         { info_tbl: [(c7E5Y,
                       label: GHC.IO.liftIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E5Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7E5Z; else goto c7E60;
       c7E5Z: // global
           R2 = R2;
           R1 = GHC.IO.liftIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E60: // global
           I64[Sp - 8] = block_c7E5V_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E5V() //  [R1]
         { info_tbl: [(c7E5V,
                       label: block_c7E5V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E5V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7E63; else goto c7E62;
       c7E63: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E62: // global
           I64[Hp - 8] = GHC.ST.STret_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.240662501 UTC

[section ""data" . GHC.IO.failIO1_closure" {
     GHC.IO.failIO1_closure:
         const GHC.IO.failIO1_info;
         const 0;
 },
 sat_s7DYj_entry() //  [R1]
         { info_tbl: [(c7E6g,
                       label: sat_s7DYj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E6h; else goto c7E6i;
       c7E6h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7E6i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           R1 = GHC.IO.Exception.userError_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7DYk_entry() //  [R1]
         { info_tbl: [(c7E6j,
                       label: sat_s7DYk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6j: // global
           _s7DYk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c7E6k; else goto c7E6l;
       c7E6l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7E6n; else goto c7E6m;
       c7E6n: // global
           HpAlloc = 24;
           goto c7E6k;
       c7E6k: // global
           R1 = _s7DYk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7E6m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7DYk::P64;
           _s7DYh::P64 = P64[_s7DYk::P64 + 16];
           I64[Hp - 16] = sat_s7DYj_info;
           P64[Hp] = _s7DYh::P64;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.failIO1_entry() //  [R2]
         { info_tbl: [(c7E6o,
                       label: GHC.IO.failIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7E6s; else goto c7E6r;
       c7E6s: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.failIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E6r: // global
           I64[Hp - 16] = sat_s7DYk_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.24220431 UTC

[section ""data" . GHC.IO.failIO_closure" {
     GHC.IO.failIO_closure:
         const GHC.IO.failIO_info;
         const 0;
 },
 GHC.IO.failIO_entry() //  [R2]
         { info_tbl: [(c7E6x,
                       label: GHC.IO.failIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6x: // global
           R2 = R2;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.243036242 UTC

[section ""data" . GHC.IO.stToIO1_closure" {
     GHC.IO.stToIO1_closure:
         const GHC.IO.stToIO1_info;
 },
 GHC.IO.stToIO1_entry() //  [R2]
         { info_tbl: [(c7E6E,
                       label: GHC.IO.stToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6E: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.243855029 UTC

[section ""data" . GHC.IO.stToIO_closure" {
     GHC.IO.stToIO_closure:
         const GHC.IO.stToIO_info;
 },
 GHC.IO.stToIO_entry() //  [R2]
         { info_tbl: [(c7E6L,
                       label: GHC.IO.stToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6L: // global
           R2 = R2;
           call GHC.IO.stToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.244680895 UTC

[section ""data" . GHC.IO.ioToST1_closure" {
     GHC.IO.ioToST1_closure:
         const GHC.IO.ioToST1_info;
 },
 GHC.IO.ioToST1_entry() //  [R2]
         { info_tbl: [(c7E6S,
                       label: GHC.IO.ioToST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6S: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.245472008 UTC

[section ""data" . GHC.IO.ioToST_closure" {
     GHC.IO.ioToST_closure:
         const GHC.IO.ioToST_info;
 },
 GHC.IO.ioToST_entry() //  [R2]
         { info_tbl: [(c7E6Z,
                       label: GHC.IO.ioToST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E6Z: // global
           R2 = R2;
           call GHC.IO.ioToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.24626063 UTC

[section ""data" . GHC.IO.unsafeIOToST1_closure" {
     GHC.IO.unsafeIOToST1_closure:
         const GHC.IO.unsafeIOToST1_info;
 },
 GHC.IO.unsafeIOToST1_entry() //  [R2]
         { info_tbl: [(c7E76,
                       label: GHC.IO.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E76: // global
           R1 = R2;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.247056782 UTC

[section ""data" . GHC.IO.unsafeIOToST_closure" {
     GHC.IO.unsafeIOToST_closure:
         const GHC.IO.unsafeIOToST_info;
 },
 GHC.IO.unsafeIOToST_entry() //  [R2]
         { info_tbl: [(c7E7d,
                       label: GHC.IO.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7d: // global
           R2 = R2;
           call GHC.IO.unsafeIOToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.247882845 UTC

[section ""data" . GHC.IO.unsafeSTToIO1_closure" {
     GHC.IO.unsafeSTToIO1_closure:
         const GHC.IO.unsafeSTToIO1_info;
 },
 GHC.IO.unsafeSTToIO1_entry() //  [R2]
         { info_tbl: [(c7E7k,
                       label: GHC.IO.unsafeSTToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7k: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.248707019 UTC

[section ""data" . GHC.IO.unsafeSTToIO_closure" {
     GHC.IO.unsafeSTToIO_closure:
         const GHC.IO.unsafeSTToIO_info;
 },
 GHC.IO.unsafeSTToIO_entry() //  [R2]
         { info_tbl: [(c7E7r,
                       label: GHC.IO.unsafeSTToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7r: // global
           R2 = R2;
           call GHC.IO.unsafeSTToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.250109671 UTC

[section ""data" . GHC.IO.catch1_closure" {
     GHC.IO.catch1_closure:
         const GHC.IO.catch1_info;
 },
 sat_s7DYw_entry() //  [R1]
         { info_tbl: [(c7E7M,
                       label: sat_s7DYw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7M: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYy_entry() //  [R1, R2]
         { info_tbl: [(c7E7T,
                       label: sat_s7DYy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7E7U; else goto c7E7V;
       c7E7U: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E7V: // global
           I64[Sp - 24] = block_c7E7D_info;
           _s7DYu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYu::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYu::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7E7D() //  [R1]
         { info_tbl: [(c7E7D,
                       label: block_c7E7D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E7D: // global
           if (R1 & 7 == 1) goto c7E7Q; else goto c7E7R;
       c7E7Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7E7Y; else goto c7E7X;
       c7E7Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E7X: // global
           I64[Hp - 8] = sat_s7DYw_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7E7R: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catch1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7E82,
                       label: GHC.IO.catch1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E82: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7E86; else goto c7E85;
       c7E86: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catch1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E85: // global
           I64[Hp - 16] = sat_s7DYy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.251779031 UTC

[section ""data" . GHC.IO.catch_closure" {
     GHC.IO.catch_closure:
         const GHC.IO.catch_info;
 },
 GHC.IO.catch_entry() //  [R2, R3, R4]
         { info_tbl: [(c7E8b,
                       label: GHC.IO.catch_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catch1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.253228583 UTC

[section ""data" . GHC.IO.catchException1_closure" {
     GHC.IO.catchException1_closure:
         const GHC.IO.catchException1_info;
 },
 sat_s7DYG_entry() //  [R1]
         { info_tbl: [(c7E8y,
                       label: sat_s7DYG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8y: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYI_entry() //  [R1, R2]
         { info_tbl: [(c7E8F,
                       label: sat_s7DYI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7E8G; else goto c7E8H;
       c7E8G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E8H: // global
           I64[Sp - 24] = block_c7E8p_info;
           _s7DYE::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYE::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYE::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7E8p() //  [R1]
         { info_tbl: [(c7E8p,
                       label: block_c7E8p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8p: // global
           if (R1 & 7 == 1) goto c7E8C; else goto c7E8D;
       c7E8C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7E8K; else goto c7E8J;
       c7E8K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E8J: // global
           I64[Hp - 8] = sat_s7DYG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7E8D: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchException1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7E8O,
                       label: GHC.IO.catchException1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7E8P; else goto c7E8Q;
       c7E8P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchException1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E8Q: // global
           I64[Sp - 24] = block_c7E8i_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E8i() //  [R1]
         { info_tbl: [(c7E8i,
                       label: block_c7E8i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8i: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7E8T; else goto c7E8S;
       c7E8T: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E8S: // global
           I64[Hp - 16] = sat_s7DYI_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = R1;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.255495987 UTC

[section ""data" . GHC.IO.catchException_closure" {
     GHC.IO.catchException_closure:
         const GHC.IO.catchException_info;
 },
 GHC.IO.catchException_entry() //  [R2, R3, R4]
         { info_tbl: [(c7E8Y,
                       label: GHC.IO.catchException_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E8Y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchException1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.256923331 UTC

[section ""data" . GHC.IO.mplusIO1_closure" {
     GHC.IO.mplusIO1_closure:
         const GHC.IO.mplusIO1_info;
         const 0;
 },
 sat_s7DYP_entry() //  [R1]
         { info_tbl: [(c7E9l,
                       label: sat_s7DYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9l: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYR_entry() //  [R1, R2]
         { info_tbl: [(c7E9s,
                       label: sat_s7DYR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7E9t; else goto c7E9u;
       c7E9t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7E9u: // global
           I64[Sp - 24] = block_c7E9c_info;
           _s7DYN::P64 = R2;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYN::P64;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = _s7DYN::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7E9c() //  [R1]
         { info_tbl: [(c7E9c,
                       label: block_c7E9c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9c: // global
           if (R1 & 7 == 1) goto c7E9p; else goto c7E9q;
       c7E9p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7E9x; else goto c7E9w;
       c7E9x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E9w: // global
           I64[Hp - 8] = sat_s7DYP_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7E9q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mplusIO1_entry() //  [R2, R3]
         { info_tbl: [(c7E9B,
                       label: GHC.IO.mplusIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7E9C; else goto c7E9D;
       c7E9C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.mplusIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7E9D: // global
           I64[Sp - 16] = block_c7E95_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E95() //  [R1]
         { info_tbl: [(c7E95,
                       label: block_c7E95_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E95: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7E9G; else goto c7E9F;
       c7E9G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7E9F: // global
           I64[Hp - 8] = sat_s7DYR_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.258970365 UTC

[section ""data" . GHC.IO.mplusIO_closure" {
     GHC.IO.mplusIO_closure:
         const GHC.IO.mplusIO_info;
         const 0;
 },
 GHC.IO.mplusIO_entry() //  [R2, R3]
         { info_tbl: [(c7E9L,
                       label: GHC.IO.mplusIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9L: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.mplusIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.26024384 UTC

[section ""data" . GHC.IO.catchAny1_closure" {
     GHC.IO.catchAny1_closure:
         const GHC.IO.catchAny1_info;
 },
 sat_s7DZ0_entry() //  [R1, R2]
         { info_tbl: [(c7Ea2,
                       label: sat_s7DZ0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ea2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ea3; else goto c7Ea4;
       c7Ea3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ea4: // global
           I64[Sp - 16] = block_c7E9Z_info;
           _s7DYT::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s7DYT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Ea8; else goto c7Ea0;
       u7Ea8: // global
           call _c7E9Z(R1) args: 0, res: 0, upd: 0;
       c7Ea0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E9Z() //  [R1]
         { info_tbl: [(c7E9Z,
                       label: block_c7E9Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9Z: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchAny1_entry() //  [R2, R3]
         { info_tbl: [(c7Ea9,
                       label: GHC.IO.catchAny1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ea9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eaa; else goto c7Eab;
       c7Eaa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Eab: // global
           I64[Sp - 16] = block_c7E9S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7E9S() //  [R1]
         { info_tbl: [(c7E9S,
                       label: block_c7E9S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7E9S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Eae; else goto c7Ead;
       c7Eae: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ead: // global
           I64[Hp - 8] = sat_s7DZ0_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.263511795 UTC

[section ""data" . GHC.IO.catchAny_closure" {
     GHC.IO.catchAny_closure:
         const GHC.IO.catchAny_info;
 },
 GHC.IO.catchAny_entry() //  [R2, R3]
         { info_tbl: [(c7Eaj,
                       label: GHC.IO.catchAny_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eaj: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchAny1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.264517119 UTC

[section ""data" . GHC.IO.throwIO1_closure" {
     GHC.IO.throwIO1_closure:
         const GHC.IO.throwIO1_info;
 },
 sat_s7DZ4_entry() //  [R1]
         { info_tbl: [(c7Eau,
                       label: sat_s7DZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eau: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Eav; else goto c7Eaw;
       c7Eav: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Eaw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.throwIO1_entry() //  [R2, R3]
         { info_tbl: [(c7Eax,
                       label: GHC.IO.throwIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eax: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7EaB; else goto c7EaA;
       c7EaB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.throwIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EaA: // global
           I64[Hp - 24] = sat_s7DZ4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.266021076 UTC

[section ""data" . GHC.IO.throwIO_closure" {
     GHC.IO.throwIO_closure:
         const GHC.IO.throwIO_info;
 },
 GHC.IO.throwIO_entry() //  [R2, R3]
         { info_tbl: [(c7EaG,
                       label: GHC.IO.throwIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EaG: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.267149181 UTC

[section ""data" . GHC.IO.onException1_closure" {
     GHC.IO.onException1_closure:
         const GHC.IO.onException1_info;
 },
 sat_s7DZe_entry() //  [R1, R2]
         { info_tbl: [(c7EaW,
                       label: sat_s7DZe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EaW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EaX; else goto c7EaY;
       c7EaX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EaY: // global
           I64[Sp - 16] = block_c7EaU_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EaU() //  []
         { info_tbl: [(c7EaU,
                       label: block_c7EaU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EaU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.onException1_entry() //  [R2, R3]
         { info_tbl: [(c7Eb0,
                       label: GHC.IO.onException1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eb0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eb1; else goto c7Eb2;
       c7Eb1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.onException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Eb2: // global
           I64[Sp - 16] = block_c7EaN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EaN() //  [R1]
         { info_tbl: [(c7EaN,
                       label: block_c7EaN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EaN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Eb5; else goto c7Eb4;
       c7Eb5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Eb4: // global
           I64[Hp - 8] = sat_s7DZe_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.268630776 UTC

[section ""data" . GHC.IO.onException_closure" {
     GHC.IO.onException_closure:
         const GHC.IO.onException_info;
 },
 GHC.IO.onException_entry() //  [R2, R3]
         { info_tbl: [(c7Eba,
                       label: GHC.IO.onException_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eba: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.onException1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.269452135 UTC

[section ""data" . GHC.IO.unsafeUnmask_closure" {
     GHC.IO.unsafeUnmask_closure:
         const GHC.IO.unsafeUnmask_info;
 },
 GHC.IO.unsafeUnmask_entry() //  [R2]
         { info_tbl: [(c7Ebh,
                       label: GHC.IO.unsafeUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ebh: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.270502502 UTC

[section ""data" . GHC.IO.getMaskingState1_closure" {
     GHC.IO.getMaskingState1_closure:
         const GHC.IO.getMaskingState1_info;
 },
 sat_s7DZk_entry() //  [R1]
         { info_tbl: [(c7Ebz,
                       label: sat_s7DZk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ebz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EbA; else goto c7EbB;
       c7EbA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EbB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s7DZj::I64 = I64[R1 + 16];
           if (_s7DZj::I64 != 0) goto u7EbC; else goto c7Ebx;
       u7EbC: // global
           if (_s7DZj::I64 != 1) goto c7Ebw; else goto c7Eby;
       c7Ebw: // global
           R1 = GHC.IO.MaskedInterruptible_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Eby: // global
           R1 = GHC.IO.MaskedUninterruptible_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7Ebx: // global
           R1 = GHC.IO.Unmasked_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.getMaskingState1_entry() //  []
         { info_tbl: [(c7EbD,
                       label: GHC.IO.getMaskingState1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EbD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7EbE; else goto c7EbF;
       c7EbE: // global
           R1 = GHC.IO.getMaskingState1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7EbF: // global
           I64[Sp - 8] = block_c7Ebo_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Ebo() //  [R1]
         { info_tbl: [(c7Ebo,
                       label: block_c7Ebo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ebo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EbI; else goto c7EbH;
       c7EbI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EbH: // global
           I64[Hp - 16] = sat_s7DZk_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.271917785 UTC

[section ""data" . GHC.IO.getMaskingState_closure" {
     GHC.IO.getMaskingState_closure:
         const GHC.IO.getMaskingState_info;
 },
 GHC.IO.getMaskingState_entry() //  []
         { info_tbl: [(c7EbN,
                       label: GHC.IO.getMaskingState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EbN: // global
           call GHC.IO.getMaskingState1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.272864306 UTC

[section ""data" . GHC.IO.interruptible1_closure" {
     GHC.IO.interruptible1_closure:
         const GHC.IO.interruptible1_info;
 },
 GHC.IO.interruptible1_entry() //  [R2]
         { info_tbl: [(c7Ec1,
                       label: GHC.IO.interruptible1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ec1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ec2; else goto c7Ec3;
       c7Ec2: // global
           R2 = R2;
           R1 = GHC.IO.interruptible1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ec3: // global
           I64[Sp - 16] = block_c7EbU_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EbU() //  [R1]
         { info_tbl: [(c7EbU,
                       label: block_c7EbU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EbU: // global
           _s7DZl::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Ec0; else goto u7Ec5;
       u7Ec5: // global
           if (R1 == 1) goto c7Ec0; else goto c7EbY;
       c7Ec0: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7EbY: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.273971725 UTC

[section ""data" . GHC.IO.interruptible_closure" {
     GHC.IO.interruptible_closure:
         const GHC.IO.interruptible_info;
 },
 GHC.IO.interruptible_entry() //  [R2]
         { info_tbl: [(c7Eca,
                       label: GHC.IO.interruptible_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eca: // global
           R2 = R2;
           call GHC.IO.interruptible1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.275241259 UTC

[section ""data" . GHC.IO.mask1_closure" {
     GHC.IO.mask1_closure:
         const GHC.IO.mask1_info;
 },
 sat_s7DZx_entry() //  [R2]
         { info_tbl: [(c7Ecq,
                       label: sat_s7DZx_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ecq: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZy_entry() //  [R2]
         { info_tbl: [(c7Ecz,
                       label: sat_s7DZy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ecz: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZA_entry() //  [R2]
         { info_tbl: [(c7EcI,
                       label: sat_s7DZA_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EcI: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mask1_entry() //  [R2]
         { info_tbl: [(c7EcP,
                       label: GHC.IO.mask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EcP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EcQ; else goto c7EcR;
       c7EcQ: // global
           R2 = R2;
           R1 = GHC.IO.mask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EcR: // global
           I64[Sp - 16] = block_c7Ech_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Ech() //  [R1]
         { info_tbl: [(c7Ech,
                       label: block_c7Ech_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ech: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EcU; else goto c7EcT;
       c7EcU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EcT: // global
           _s7DZr::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EcN; else goto u7EcY;
       c7EcN: // global
           I64[Hp - 8] = sat_s7DZy_info;
           I64[Sp + 8] = block_c7EcV_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7EcY: // global
           if (R1 == 1) goto c7EcO; else goto c7EcM;
       c7EcO: // global
           I64[Hp - 8] = sat_s7DZA_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7EcM: // global
           I64[Hp - 8] = sat_s7DZx_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EcV() //  [R1]
         { info_tbl: [(c7EcV,
                       label: block_c7EcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EcV: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.277005365 UTC

[section ""data" . GHC.IO.mask_closure" {
     GHC.IO.mask_closure:
         const GHC.IO.mask_info;
 },
 GHC.IO.mask_entry() //  [R2]
         { info_tbl: [(c7Ed3,
                       label: GHC.IO.mask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ed3: // global
           R2 = R2;
           call GHC.IO.mask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.277917819 UTC

[section ""data" . GHC.IO.mask_1_closure" {
     GHC.IO.mask_1_closure:
         const GHC.IO.mask_1_info;
 },
 GHC.IO.mask_1_entry() //  [R2]
         { info_tbl: [(c7Edg,
                       label: GHC.IO.mask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Edg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Edh; else goto c7Edi;
       c7Edh: // global
           R2 = R2;
           R1 = GHC.IO.mask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Edi: // global
           I64[Sp - 16] = block_c7Eda_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Eda() //  [R1]
         { info_tbl: [(c7Eda,
                       label: block_c7Eda_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eda: // global
           _s7DZB::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Edf; else goto c7Ede;
       c7Edf: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c7Ede: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.278980099 UTC

[section ""data" . GHC.IO.mask__closure" {
     GHC.IO.mask__closure:
         const GHC.IO.mask__info;
 },
 GHC.IO.mask__entry() //  [R2]
         { info_tbl: [(c7Edo,
                       label: GHC.IO.mask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Edo: // global
           R2 = R2;
           call GHC.IO.mask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.281715941 UTC

[section ""data" . GHC.IO.bracket1_closure" {
     GHC.IO.bracket1_closure:
         const GHC.IO.bracket1_info;
 },
 sat_s7DZZ_entry() //  [R1, R2]
         { info_tbl: [(c7EdI,
                       label: sat_s7DZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EdI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EdJ; else goto c7EdK;
       c7EdJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EdK: // global
           I64[Sp - 16] = block_c7EdG_info;
           _s7DZU::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7DZU::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EdG() //  []
         { info_tbl: [(c7EdG,
                       label: block_c7EdG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EdG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZT_entry() //  [R1]
         { info_tbl: [(c7EdS,
                       label: sat_s7DZT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EdS: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0h_entry() //  [R1, R2]
         { info_tbl: [(c7Eea,
                       label: sat_s7E0h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eeb; else goto c7Eec;
       c7Eeb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Eec: // global
           I64[Sp - 16] = block_c7Ee8_info;
           _s7E0c::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0c::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ee8() //  []
         { info_tbl: [(c7Ee8,
                       label: block_c7Ee8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ee8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0b_entry() //  [R1]
         { info_tbl: [(c7Eek,
                       label: sat_s7E0b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eek: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0o_entry() //  [R1]
         { info_tbl: [(c7Eer,
                       label: sat_s7E0o_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eer: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Ees; else goto c7Eet;
       c7Ees: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7Eet: // global
           I64[Sp - 24] = block_c7Ee1_info;
           _s7DZI::P64 = P64[R1 + 15];
           _s7DZJ::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s7DZI::P64;
           P64[Sp - 8] = _s7DZJ::P64;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ee1() //  [R1]
         { info_tbl: [(c7Ee1,
                       label: block_c7Ee1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ee1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Eew; else goto c7Eev;
       c7Eew: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Eev: // global
           I64[Hp - 64] = sat_s7E0h_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0b_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Een_info;
           R2 = Hp - 62;
           _s7E09::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E09::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Een() //  [R1]
         { info_tbl: [(c7Een,
                       label: block_c7Een_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Een: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Eep_info;
           R2 = P64[Sp + 16];
           _s7E0k::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0k::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eep() //  []
         { info_tbl: [(c7Eep,
                       label: block_c7Eep_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eep: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0z_entry() //  [R1, R2]
         { info_tbl: [(c7EeJ,
                       label: sat_s7E0z_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EeJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EeK; else goto c7EeL;
       c7EeK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EeL: // global
           I64[Sp - 16] = block_c7EeH_info;
           _s7E0u::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0u::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EeH() //  []
         { info_tbl: [(c7EeH,
                       label: block_c7EeH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EeH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0t_entry() //  [R1]
         { info_tbl: [(c7EeT,
                       label: sat_s7E0t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EeT: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.bracket1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ef0,
                       label: GHC.IO.bracket1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ef0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Ef1; else goto c7Ef2;
       c7Ef1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.bracket1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ef2: // global
           I64[Sp - 32] = block_c7Edv_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Edv() //  [R1]
         { info_tbl: [(c7Edv,
                       label: block_c7Edv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Edv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ef5; else goto c7Ef4;
       c7Ef5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ef4: // global
           _s7DZH::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EeY; else goto u7Efo;
       c7EeY: // global
           I64[Hp - 24] = sat_s7E0o_info;
           P64[Hp - 16] = _s7DZH::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7Efo: // global
           if (R1 == 1) goto c7EeZ; else goto c7EeX;
       c7EeZ: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7EeA_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c7EeX: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7Edz_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EeA() //  [R1]
         { info_tbl: [(c7EeA,
                       label: block_c7EeA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EeA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Efk; else goto c7Efj;
       c7Efk: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Efj: // global
           I64[Hp - 64] = sat_s7E0z_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0t_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Eff_info;
           R2 = Hp - 62;
           _s7E0r::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E0r::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eff() //  [R1]
         { info_tbl: [(c7Eff,
                       label: block_c7Eff_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eff: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Efh_info;
           R2 = P64[Sp + 16];
           _s7E0C::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0C::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Efh() //  []
         { info_tbl: [(c7Efh,
                       label: block_c7Efh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Efh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Edz() //  [R1]
         { info_tbl: [(c7Edz,
                       label: block_c7Edz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Edz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Efb; else goto c7Efa;
       c7Efb: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Efa: // global
           I64[Hp - 64] = sat_s7DZZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7DZT_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Ef6_info;
           R2 = Hp - 62;
           _s7DZR::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7DZR::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ef6() //  [R1]
         { info_tbl: [(c7Ef6,
                       label: block_c7Ef6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ef6: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Ef8_info;
           R2 = P64[Sp + 16];
           _s7E02::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E02::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ef8() //  []
         { info_tbl: [(c7Ef8,
                       label: block_c7Ef8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ef8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.286411767 UTC

[section ""data" . GHC.IO.bracket_closure" {
     GHC.IO.bracket_closure:
         const GHC.IO.bracket_info;
 },
 GHC.IO.bracket_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Eft,
                       label: GHC.IO.bracket_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eft: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.288670846 UTC

[section ""data" . GHC.IO.finally1_closure" {
     GHC.IO.finally1_closure:
         const GHC.IO.finally1_info;
 },
 sat_s7E0T_entry() //  [R1, R2]
         { info_tbl: [(c7EfL,
                       label: sat_s7E0T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EfL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EfM; else goto c7EfN;
       c7EfM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EfN: // global
           I64[Sp - 16] = block_c7EfJ_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EfJ() //  []
         { info_tbl: [(c7EfJ,
                       label: block_c7EfJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EfJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0N_entry() //  [R1]
         { info_tbl: [(c7EfU,
                       label: sat_s7E0N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EfU: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E17_entry() //  [R1, R2]
         { info_tbl: [(c7Ega,
                       label: sat_s7E17_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ega: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Egb; else goto c7Egc;
       c7Egb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Egc: // global
           I64[Sp - 16] = block_c7Eg8_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eg8() //  []
         { info_tbl: [(c7Eg8,
                       label: block_c7Eg8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eg8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E11_entry() //  [R1]
         { info_tbl: [(c7Egj,
                       label: sat_s7E11_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Egj: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1e_entry() //  [R1]
         { info_tbl: [(c7Egq,
                       label: sat_s7E1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Egq: // global
           _s7E1e::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Egr; else goto c7Egs;
       c7Egs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Egu; else goto c7Egt;
       c7Egu: // global
           HpAlloc = 32;
           goto c7Egr;
       c7Egr: // global
           R1 = _s7E1e::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7Egt: // global
           _s7E0G::P64 = P64[_s7E1e::P64 + 7];
           _s7E0H::P64 = P64[_s7E1e::P64 + 15];
           I64[Hp - 24] = sat_s7E17_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E11_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp - 16] = block_c7Egm_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           P64[Sp - 8] = _s7E0H::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Egm() //  [R1]
         { info_tbl: [(c7Egm,
                       label: block_c7Egm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Egm: // global
           I64[Sp] = block_c7Ego_info;
           _s7E1a::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1a::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ego() //  []
         { info_tbl: [(c7Ego,
                       label: block_c7Ego_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ego: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1l_entry() //  [R1, R2]
         { info_tbl: [(c7EgF,
                       label: sat_s7E1l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EgF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EgG; else goto c7EgH;
       c7EgG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EgH: // global
           I64[Sp - 16] = block_c7EgD_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EgD() //  []
         { info_tbl: [(c7EgD,
                       label: block_c7EgD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EgD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1f_entry() //  [R1]
         { info_tbl: [(c7EgO,
                       label: sat_s7E1f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EgO: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.finally1_entry() //  [R2, R3]
         { info_tbl: [(c7EgV,
                       label: GHC.IO.finally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EgV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EgW; else goto c7EgX;
       c7EgW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.finally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EgX: // global
           I64[Sp - 24] = block_c7EfA_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EfA() //  [R1]
         { info_tbl: [(c7EfA,
                       label: block_c7EfA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EfA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Eh0; else goto c7EgZ;
       c7Eh0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EgZ: // global
           _s7E0G::P64 = P64[Sp + 8];
           _s7E0H::P64 = P64[Sp + 16];
           if (R1 == 0) goto c7EgT; else goto u7Ehd;
       c7EgT: // global
           I64[Hp - 24] = sat_s7E1e_info;
           P64[Hp - 16] = _s7E0G::P64;
           P64[Hp - 8] = _s7E0H::P64;
           _c7EfY::P64 = Hp - 23;
           Hp = Hp - 8;
           R1 = _c7EfY::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7Ehd: // global
           if (R1 == 1) goto c7EgU; else goto c7EgS;
       c7EgU: // global
           I64[Hp - 24] = sat_s7E1l_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E1f_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7Eh7_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       c7EgS: // global
           I64[Hp - 24] = sat_s7E0T_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E0N_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7Eh1_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eh7() //  [R1]
         { info_tbl: [(c7Eh7,
                       label: block_c7Eh7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eh7: // global
           I64[Sp] = block_c7Eh9_info;
           _s7E1o::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1o::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eh9() //  []
         { info_tbl: [(c7Eh9,
                       label: block_c7Eh9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eh9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Eh1() //  [R1]
         { info_tbl: [(c7Eh1,
                       label: block_c7Eh1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eh1: // global
           I64[Sp] = block_c7Eh3_info;
           _s7E0W::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E0W::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eh3() //  []
         { info_tbl: [(c7Eh3,
                       label: block_c7Eh3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eh3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.29246826 UTC

[section ""data" . GHC.IO.finally_closure" {
     GHC.IO.finally_closure:
         const GHC.IO.finally_info;
 },
 GHC.IO.finally_entry() //  [R2, R3]
         { info_tbl: [(c7Ehi,
                       label: GHC.IO.finally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ehi: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.finally1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.294128779 UTC

[section ""data" . GHC.IO.uninterruptibleMask1_closure" {
     GHC.IO.uninterruptibleMask1_closure:
         const GHC.IO.uninterruptibleMask1_info;
 },
 sat_s7E1y_entry() //  [R2]
         { info_tbl: [(c7Ehy,
                       label: sat_s7E1y_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ehy: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1A_entry() //  [R2]
         { info_tbl: [(c7EhH,
                       label: sat_s7E1A_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EhH: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1C_entry() //  [R2]
         { info_tbl: [(c7EhQ,
                       label: sat_s7E1C_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EhQ: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.uninterruptibleMask1_entry() //  [R2]
         { info_tbl: [(c7EhX,
                       label: GHC.IO.uninterruptibleMask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EhX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EhY; else goto c7EhZ;
       c7EhY: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EhZ: // global
           I64[Sp - 16] = block_c7Ehp_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Ehp() //  [R1]
         { info_tbl: [(c7Ehp,
                       label: block_c7Ehp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ehp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Ei2; else goto c7Ei1;
       c7Ei2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ei1: // global
           _s7E1s::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EhV; else goto u7Ei9;
       c7EhV: // global
           I64[Hp - 8] = sat_s7E1A_info;
           I64[Sp + 8] = block_c7Ei6_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7Ei9: // global
           if (R1 == 1) goto c7EhW; else goto c7EhU;
       c7EhW: // global
           I64[Hp - 8] = sat_s7E1C_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7EhU: // global
           I64[Hp - 8] = sat_s7E1y_info;
           I64[Sp + 8] = block_c7Ei3_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ei6() //  [R1]
         { info_tbl: [(c7Ei6,
                       label: block_c7Ei6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ei6: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ei3() //  [R1]
         { info_tbl: [(c7Ei3,
                       label: block_c7Ei3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ei3: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.295955991 UTC

[section ""data" . GHC.IO.uninterruptibleMask_closure" {
     GHC.IO.uninterruptibleMask_closure:
         const GHC.IO.uninterruptibleMask_info;
 },
 GHC.IO.uninterruptibleMask_entry() //  [R2]
         { info_tbl: [(c7Eie,
                       label: GHC.IO.uninterruptibleMask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eie: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.296883789 UTC

[section ""data" . GHC.IO.uninterruptibleMask_1_closure" {
     GHC.IO.uninterruptibleMask_1_closure:
         const GHC.IO.uninterruptibleMask_1_info;
 },
 GHC.IO.uninterruptibleMask_1_entry() //  [R2]
         { info_tbl: [(c7Eir,
                       label: GHC.IO.uninterruptibleMask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eis; else goto c7Eit;
       c7Eis: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Eit: // global
           I64[Sp - 16] = block_c7Eil_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Eil() //  [R1]
         { info_tbl: [(c7Eil,
                       label: block_c7Eil_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eil: // global
           _s7E1D::P64 = P64[Sp + 8];
           if (R1 == 1) goto c7Eiq; else goto c7Eip;
       c7Eiq: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7Eip: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.297996531 UTC

[section ""data" . GHC.IO.uninterruptibleMask__closure" {
     GHC.IO.uninterruptibleMask__closure:
         const GHC.IO.uninterruptibleMask__info;
 },
 GHC.IO.uninterruptibleMask__entry() //  [R2]
         { info_tbl: [(c7Eiz,
                       label: GHC.IO.uninterruptibleMask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eiz: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.298790155 UTC

[section ""data" . GHC.IO.evaluate1_closure" {
     GHC.IO.evaluate1_closure:
         const GHC.IO.evaluate1_info;
 },
 GHC.IO.evaluate1_entry() //  [R2]
         { info_tbl: [(c7EiG,
                       label: GHC.IO.evaluate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiG: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.299599991 UTC

[section ""data" . GHC.IO.evaluate_closure" {
     GHC.IO.evaluate_closure:
         const GHC.IO.evaluate_info;
 },
 GHC.IO.evaluate_entry() //  [R2]
         { info_tbl: [(c7EiN,
                       label: GHC.IO.evaluate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiN: // global
           R2 = R2;
           call GHC.IO.evaluate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.300288536 UTC

[section ""cstring" . GHC.IO.$trModule4_bytes" {
     GHC.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.300821636 UTC

[section ""data" . GHC.IO.$trModule3_closure" {
     GHC.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.301417386 UTC

[section ""cstring" . GHC.IO.$trModule2_bytes" {
     GHC.IO.$trModule2_bytes:
         I8[] [71,72,67,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.301970653 UTC

[section ""data" . GHC.IO.$trModule1_closure" {
     GHC.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.302560255 UTC

[section ""data" . GHC.IO.$trModule_closure" {
     GHC.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.$trModule3_closure+1;
         const GHC.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.303161529 UTC

[section ""cstring" . GHC.IO.$tcMaskingState2_bytes" {
     GHC.IO.$tcMaskingState2_bytes:
         I8[] [77,97,115,107,105,110,103,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.303739163 UTC

[section ""data" . GHC.IO.$tcMaskingState1_closure" {
     GHC.IO.$tcMaskingState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tcMaskingState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.304315054 UTC

[section ""data" . GHC.IO.$tcMaskingState_closure" {
     GHC.IO.$tcMaskingState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tcMaskingState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1377527551354837803;
         const 7593236071496752895;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.304882728 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible1_closure" {
     GHC.IO.$tc'MaskedInterruptible1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.$tcMaskingState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.305555013 UTC

[section ""cstring" . GHC.IO.$tc'Unmasked2_bytes" {
     GHC.IO.$tc'Unmasked2_bytes:
         I8[] [39,85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.306109713 UTC

[section ""data" . GHC.IO.$tc'Unmasked1_closure" {
     GHC.IO.$tc'Unmasked1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'Unmasked2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.30666701 UTC

[section ""data" . GHC.IO.$tc'Unmasked_closure" {
     GHC.IO.$tc'Unmasked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'Unmasked1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 16923189221218057084;
         const 12178290748160137861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.307206388 UTC

[section ""cstring" . GHC.IO.$tc'MaskedInterruptible3_bytes" {
     GHC.IO.$tc'MaskedInterruptible3_bytes:
         I8[] [39,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.307738586 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible2_closure" {
     GHC.IO.$tc'MaskedInterruptible2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedInterruptible3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.308266322 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible_closure" {
     GHC.IO.$tc'MaskedInterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedInterruptible2_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 8247192854047081576;
         const 3389631131447074398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.308848413 UTC

[section ""cstring" . GHC.IO.$tc'MaskedUninterruptible2_bytes" {
     GHC.IO.$tc'MaskedUninterruptible2_bytes:
         I8[] [39,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.309413497 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible1_closure" {
     GHC.IO.$tc'MaskedUninterruptible1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedUninterruptible2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.309985545 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible_closure" {
     GHC.IO.$tc'MaskedUninterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedUninterruptible1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 10964471758180118067;
         const 9988357998868476725;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.312074237 UTC

[section ""data" . GHC.IO.Unmasked_closure" {
     GHC.IO.Unmasked_closure:
         const GHC.IO.Unmasked_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.312684492 UTC

[section ""data" . GHC.IO.MaskedInterruptible_closure" {
     GHC.IO.MaskedInterruptible_closure:
         const GHC.IO.MaskedInterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.313214381 UTC

[section ""data" . GHC.IO.MaskedUninterruptible_closure" {
     GHC.IO.MaskedUninterruptible_closure:
         const GHC.IO.MaskedUninterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.313799148 UTC

[section ""relreadonly" . GHC.IO.MaskingState_closure_tbl" {
     GHC.IO.MaskingState_closure_tbl:
         const GHC.IO.Unmasked_closure+1;
         const GHC.IO.MaskedInterruptible_closure+2;
         const GHC.IO.MaskedUninterruptible_closure+3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.314453029 UTC

[GHC.IO.Unmasked_con_entry() //  [R1]
         { info_tbl: [(c7EiQ,
                       label: GHC.IO.Unmasked_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,85,110,109,97,115,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.31517572 UTC

[GHC.IO.MaskedInterruptible_con_entry() //  [R1]
         { info_tbl: [(c7EiR,
                       label: GHC.IO.MaskedInterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiR: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.315852184 UTC

[GHC.IO.MaskedUninterruptible_con_entry() //  [R1]
         { info_tbl: [(c7EiS,
                       label: GHC.IO.MaskedUninterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiS: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.316512189 UTC

[section ""relreadonly" . S7E2C_srt" {
     S7E2C_srt:
         const GHC.IO.$w$cshowsPrec_closure;
         const GHC.IO.$fShowMaskingState1_closure;
         const GHC.IO.$fShowMaskingState3_closure;
         const GHC.IO.$fShowMaskingState5_closure;
         const GHC.IO.$fShowMaskingState_$cshow_closure;
         const GHC.IO.Exception.userError_closure;
         const GHC.IO.Exception.$fxExceptionIOException_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.mplusIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.317147701 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:47.317699124 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState6_bytes" {
     GHC.IO.$fShowMaskingState6_bytes:
         I8[] [85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.318468405 UTC

[section ""data" . GHC.IO.$fShowMaskingState5_closure" {
     GHC.IO.$fShowMaskingState5_closure:
         const GHC.IO.$fShowMaskingState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState5_entry() //  [R1]
         { info_tbl: [(c7EiZ,
                       label: GHC.IO.$fShowMaskingState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EiZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ej0; else goto c7Ej1;
       c7Ej0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ej1: // global
           (_c7EiW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7EiW::I64 == 0) goto c7EiY; else goto c7EiX;
       c7EiY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7EiX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7EiW::I64;
           R2 = GHC.IO.$fShowMaskingState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.319344442 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState4_bytes" {
     GHC.IO.$fShowMaskingState4_bytes:
         I8[] [77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.320084717 UTC

[section ""data" . GHC.IO.$fShowMaskingState3_closure" {
     GHC.IO.$fShowMaskingState3_closure:
         const GHC.IO.$fShowMaskingState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState3_entry() //  [R1]
         { info_tbl: [(c7Ej8,
                       label: GHC.IO.$fShowMaskingState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ej8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ej9; else goto c7Eja;
       c7Ej9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Eja: // global
           (_c7Ej5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Ej5::I64 == 0) goto c7Ej7; else goto c7Ej6;
       c7Ej7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Ej6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Ej5::I64;
           R2 = GHC.IO.$fShowMaskingState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.320954145 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState2_bytes" {
     GHC.IO.$fShowMaskingState2_bytes:
         I8[] [77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.321671687 UTC

[section ""data" . GHC.IO.$fShowMaskingState1_closure" {
     GHC.IO.$fShowMaskingState1_closure:
         const GHC.IO.$fShowMaskingState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState1_entry() //  [R1]
         { info_tbl: [(c7Ejh,
                       label: GHC.IO.$fShowMaskingState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ejh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eji; else goto c7Ejj;
       c7Eji: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ejj: // global
           (_c7Eje::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Eje::I64 == 0) goto c7Ejg; else goto c7Ejf;
       c7Ejg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Ejf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Eje::I64;
           R2 = GHC.IO.$fShowMaskingState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.322920081 UTC

[section ""data" . GHC.IO.$w$cshowsPrec_closure" {
     GHC.IO.$w$cshowsPrec_closure:
         const GHC.IO.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c7Ejw,
                       label: GHC.IO.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ejw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ejx; else goto c7Ejy;
       c7Ejx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ejy: // global
           I64[Sp - 16] = block_c7Ejo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EjJ; else goto c7Ejp;
       u7EjJ: // global
           call _c7Ejo(R1) args: 0, res: 0, upd: 0;
       c7Ejp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ejo() //  [R1]
         { info_tbl: [(c7Ejo,
                       label: block_c7Ejo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ejo: // global
           _s7DXR::P64 = P64[Sp + 8];
           _c7Ejv::P64 = R1 & 7;
           if (_c7Ejv::P64 < 3) goto u7EjI; else goto c7Eju;
       u7EjI: // global
           if (_c7Ejv::P64 < 2) goto c7Ejs; else goto c7Ejt;
       c7Ejs: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7Ejt: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7Eju: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.324235803 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowsPrec_closure" {
     GHC.IO.$fShowMaskingState_$cshowsPrec_closure:
         const GHC.IO.$fShowMaskingState_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c7EjO,
                       label: GHC.IO.$fShowMaskingState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EjO: // global
           _s7DXU::P64 = R3;
           R3 = R4;
           R2 = _s7DXU::P64;
           call GHC.IO.$w$cshowsPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.325221252 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshow_closure" {
     GHC.IO.$fShowMaskingState_$cshow_closure:
         const GHC.IO.$fShowMaskingState_$cshow_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshow_entry() //  [R2]
         { info_tbl: [(c7Ek3,
                       label: GHC.IO.$fShowMaskingState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ek3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Ek4; else goto c7Ek5;
       c7Ek4: // global
           R2 = R2;
           R1 = GHC.IO.$fShowMaskingState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ek5: // global
           I64[Sp - 8] = block_c7EjV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7Ekg; else goto c7EjW;
       u7Ekg: // global
           call _c7EjV(R1) args: 0, res: 0, upd: 0;
       c7EjW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EjV() //  [R1]
         { info_tbl: [(c7EjV,
                       label: block_c7EjV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EjV: // global
           _c7Ek2::P64 = R1 & 7;
           if (_c7Ek2::P64 < 3) goto u7Ekf; else goto c7Ek1;
       u7Ekf: // global
           if (_c7Ek2::P64 < 2) goto c7EjZ; else goto c7Ek0;
       c7EjZ: // global
           R1 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7Ek0: // global
           R1 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7Ek1: // global
           R1 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.3264277 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowList_closure" {
     GHC.IO.$fShowMaskingState_$cshowList_closure:
         const GHC.IO.$fShowMaskingState_$cshowList_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c7Ekl,
                       label: GHC.IO.$fShowMaskingState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ekl: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.327134366 UTC

[section ""data" . GHC.IO.$fShowMaskingState_closure" {
     GHC.IO.$fShowMaskingState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.$fShowMaskingState_$cshowsPrec_closure+3;
         const GHC.IO.$fShowMaskingState_$cshow_closure+1;
         const GHC.IO.$fShowMaskingState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.328340788 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c==_closure" {
     GHC.IO.$fEqMaskingState_$c==_closure:
         const GHC.IO.$fEqMaskingState_$c==_info;
 },
 GHC.IO.$fEqMaskingState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7EkA,
                       label: GHC.IO.$fEqMaskingState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EkA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EkB; else goto c7EkC;
       c7EkB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EkC: // global
           I64[Sp - 16] = block_c7Eks_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Elz; else goto c7Ekt;
       u7Elz: // global
           call _c7Eks(R1) args: 0, res: 0, upd: 0;
       c7Ekt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eks() //  [R1]
         { info_tbl: [(c7Eks,
                       label: block_c7Eks_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eks: // global
           _s7DY1::P64 = P64[Sp + 8];
           _c7Ekz::P64 = R1 & 7;
           if (_c7Ekz::P64 < 3) goto u7Elp; else goto c7Eky;
       u7Elp: // global
           if (_c7Ekz::P64 < 2) goto c7Ekw; else goto c7Ekx;
       c7Ekw: // global
           I64[Sp + 8] = block_c7EkF_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Elw; else goto c7EkH;
       u7Elw: // global
           call _c7EkF(R1) args: 0, res: 0, upd: 0;
       c7EkH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Ekx: // global
           I64[Sp + 8] = block_c7EkU_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Elx; else goto c7EkW;
       u7Elx: // global
           call _c7EkU(R1) args: 0, res: 0, upd: 0;
       c7EkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7Eky: // global
           I64[Sp + 8] = block_c7El9_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7Ely; else goto c7Elb;
       u7Ely: // global
           call _c7El9(R1) args: 0, res: 0, upd: 0;
       c7Elb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EkF() //  [R1]
         { info_tbl: [(c7EkF,
                       label: block_c7EkF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EkF: // global
           if (R1 & 7 == 1) goto u7Elq; else goto u7Elr;
       u7Elq: // global
           Sp = Sp + 8;
           call _c7Ell() args: 0, res: 0, upd: 0;
       u7Elr: // global
           Sp = Sp + 8;
           call _c7Elh() args: 0, res: 0, upd: 0;
     }
 },
 _c7EkU() //  [R1]
         { info_tbl: [(c7EkU,
                       label: block_c7EkU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EkU: // global
           if (R1 & 7 == 2) goto u7Els; else goto u7Elt;
       u7Els: // global
           Sp = Sp + 8;
           call _c7Ell() args: 0, res: 0, upd: 0;
       u7Elt: // global
           Sp = Sp + 8;
           call _c7Elh() args: 0, res: 0, upd: 0;
     }
 },
 _c7El9() //  [R1]
         { info_tbl: [(c7El9,
                       label: block_c7El9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7El9: // global
           if (R1 & 7 == 3) goto u7Elu; else goto u7Elv;
       u7Elu: // global
           Sp = Sp + 8;
           call _c7Ell() args: 0, res: 0, upd: 0;
       u7Elv: // global
           Sp = Sp + 8;
           call _c7Elh() args: 0, res: 0, upd: 0;
     }
 },
 _c7Ell() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ell: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Elh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Elh: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.331552224 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c/=_closure" {
     GHC.IO.$fEqMaskingState_$c/=_closure:
         const GHC.IO.$fEqMaskingState_$c/=_info;
 },
 GHC.IO.$fEqMaskingState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7ElS,
                       label: GHC.IO.$fEqMaskingState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ElS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ElT; else goto c7ElU;
       c7ElT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ElU: // global
           I64[Sp - 16] = block_c7ElK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EmR; else goto c7ElL;
       u7EmR: // global
           call _c7ElK(R1) args: 0, res: 0, upd: 0;
       c7ElL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ElK() //  [R1]
         { info_tbl: [(c7ElK,
                       label: block_c7ElK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ElK: // global
           _s7DY7::P64 = P64[Sp + 8];
           _c7ElR::P64 = R1 & 7;
           if (_c7ElR::P64 < 3) goto u7EmH; else goto c7ElQ;
       u7EmH: // global
           if (_c7ElR::P64 < 2) goto c7ElO; else goto c7ElP;
       c7ElO: // global
           I64[Sp + 8] = block_c7ElX_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EmO; else goto c7ElZ;
       u7EmO: // global
           call _c7ElX(R1) args: 0, res: 0, upd: 0;
       c7ElZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ElP: // global
           I64[Sp + 8] = block_c7Emc_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EmP; else goto c7Eme;
       u7EmP: // global
           call _c7Emc(R1) args: 0, res: 0, upd: 0;
       c7Eme: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ElQ: // global
           I64[Sp + 8] = block_c7Emr_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EmQ; else goto c7Emt;
       u7EmQ: // global
           call _c7Emr(R1) args: 0, res: 0, upd: 0;
       c7Emt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ElX() //  [R1]
         { info_tbl: [(c7ElX,
                       label: block_c7ElX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ElX: // global
           if (R1 & 7 == 1) goto u7EmI; else goto u7EmJ;
       u7EmI: // global
           Sp = Sp + 8;
           call _c7EmD() args: 0, res: 0, upd: 0;
       u7EmJ: // global
           Sp = Sp + 8;
           call _c7Emz() args: 0, res: 0, upd: 0;
     }
 },
 _c7Emc() //  [R1]
         { info_tbl: [(c7Emc,
                       label: block_c7Emc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Emc: // global
           if (R1 & 7 == 2) goto u7EmK; else goto u7EmL;
       u7EmK: // global
           Sp = Sp + 8;
           call _c7EmD() args: 0, res: 0, upd: 0;
       u7EmL: // global
           Sp = Sp + 8;
           call _c7Emz() args: 0, res: 0, upd: 0;
     }
 },
 _c7Emr() //  [R1]
         { info_tbl: [(c7Emr,
                       label: block_c7Emr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Emr: // global
           if (R1 & 7 == 3) goto u7EmM; else goto u7EmN;
       u7EmM: // global
           Sp = Sp + 8;
           call _c7EmD() args: 0, res: 0, upd: 0;
       u7EmN: // global
           Sp = Sp + 8;
           call _c7Emz() args: 0, res: 0, upd: 0;
     }
 },
 _c7EmD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EmD: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Emz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Emz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.333376361 UTC

[section ""data" . GHC.IO.$fEqMaskingState_closure" {
     GHC.IO.$fEqMaskingState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.$fEqMaskingState_$c==_closure+2;
         const GHC.IO.$fEqMaskingState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.334175983 UTC

[section ""data" . GHC.IO.liftIO_closure" {
     GHC.IO.liftIO_closure:
         const GHC.IO.liftIO_info;
 },
 GHC.IO.liftIO_entry() //  [R2]
         { info_tbl: [(c7En5,
                       label: GHC.IO.liftIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7En5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7En6; else goto c7En7;
       c7En6: // global
           R2 = R2;
           R1 = GHC.IO.liftIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7En7: // global
           I64[Sp - 8] = block_c7En2_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7En2() //  [R1]
         { info_tbl: [(c7En2,
                       label: block_c7En2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7En2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Ena; else goto c7En9;
       c7Ena: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7En9: // global
           I64[Hp - 8] = GHC.ST.STret_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.335620018 UTC

[section ""data" . GHC.IO.failIO1_closure" {
     GHC.IO.failIO1_closure:
         const GHC.IO.failIO1_info;
         const 0;
 },
 sat_s7DYj_entry() //  [R1]
         { info_tbl: [(c7Enn,
                       label: sat_s7DYj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Enn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Eno; else goto c7Enp;
       c7Eno: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Enp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           R1 = GHC.IO.Exception.userError_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7DYk_entry() //  [R1]
         { info_tbl: [(c7Enq,
                       label: sat_s7DYk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Enq: // global
           _s7DYk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c7Enr; else goto c7Ens;
       c7Ens: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Enu; else goto c7Ent;
       c7Enu: // global
           HpAlloc = 24;
           goto c7Enr;
       c7Enr: // global
           R1 = _s7DYk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ent: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7DYk::P64;
           _s7DYh::P64 = P64[_s7DYk::P64 + 16];
           I64[Hp - 16] = sat_s7DYj_info;
           P64[Hp] = _s7DYh::P64;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.failIO1_entry() //  [R2]
         { info_tbl: [(c7Env,
                       label: GHC.IO.failIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Env: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Enz; else goto c7Eny;
       c7Enz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.failIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Eny: // global
           I64[Hp - 16] = sat_s7DYk_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.337097051 UTC

[section ""data" . GHC.IO.failIO_closure" {
     GHC.IO.failIO_closure:
         const GHC.IO.failIO_info;
         const 0;
 },
 GHC.IO.failIO_entry() //  [R2]
         { info_tbl: [(c7EnE,
                       label: GHC.IO.failIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EnE: // global
           R2 = R2;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.337951551 UTC

[section ""data" . GHC.IO.stToIO1_closure" {
     GHC.IO.stToIO1_closure:
         const GHC.IO.stToIO1_info;
 },
 GHC.IO.stToIO1_entry() //  [R2]
         { info_tbl: [(c7EnL,
                       label: GHC.IO.stToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EnL: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.338739723 UTC

[section ""data" . GHC.IO.stToIO_closure" {
     GHC.IO.stToIO_closure:
         const GHC.IO.stToIO_info;
 },
 GHC.IO.stToIO_entry() //  [R2]
         { info_tbl: [(c7EnS,
                       label: GHC.IO.stToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EnS: // global
           R2 = R2;
           call GHC.IO.stToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.339533588 UTC

[section ""data" . GHC.IO.ioToST1_closure" {
     GHC.IO.ioToST1_closure:
         const GHC.IO.ioToST1_info;
 },
 GHC.IO.ioToST1_entry() //  [R2]
         { info_tbl: [(c7EnZ,
                       label: GHC.IO.ioToST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EnZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.340304875 UTC

[section ""data" . GHC.IO.ioToST_closure" {
     GHC.IO.ioToST_closure:
         const GHC.IO.ioToST_info;
 },
 GHC.IO.ioToST_entry() //  [R2]
         { info_tbl: [(c7Eo6,
                       label: GHC.IO.ioToST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eo6: // global
           R2 = R2;
           call GHC.IO.ioToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.341079221 UTC

[section ""data" . GHC.IO.unsafeIOToST1_closure" {
     GHC.IO.unsafeIOToST1_closure:
         const GHC.IO.unsafeIOToST1_info;
 },
 GHC.IO.unsafeIOToST1_entry() //  [R2]
         { info_tbl: [(c7Eod,
                       label: GHC.IO.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eod: // global
           R1 = R2;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.341882035 UTC

[section ""data" . GHC.IO.unsafeIOToST_closure" {
     GHC.IO.unsafeIOToST_closure:
         const GHC.IO.unsafeIOToST_info;
 },
 GHC.IO.unsafeIOToST_entry() //  [R2]
         { info_tbl: [(c7Eok,
                       label: GHC.IO.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eok: // global
           R2 = R2;
           call GHC.IO.unsafeIOToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.342666099 UTC

[section ""data" . GHC.IO.unsafeSTToIO1_closure" {
     GHC.IO.unsafeSTToIO1_closure:
         const GHC.IO.unsafeSTToIO1_info;
 },
 GHC.IO.unsafeSTToIO1_entry() //  [R2]
         { info_tbl: [(c7Eor,
                       label: GHC.IO.unsafeSTToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eor: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.343465141 UTC

[section ""data" . GHC.IO.unsafeSTToIO_closure" {
     GHC.IO.unsafeSTToIO_closure:
         const GHC.IO.unsafeSTToIO_info;
 },
 GHC.IO.unsafeSTToIO_entry() //  [R2]
         { info_tbl: [(c7Eoy,
                       label: GHC.IO.unsafeSTToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eoy: // global
           R2 = R2;
           call GHC.IO.unsafeSTToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.344759418 UTC

[section ""data" . GHC.IO.catch1_closure" {
     GHC.IO.catch1_closure:
         const GHC.IO.catch1_info;
 },
 sat_s7DYw_entry() //  [R1]
         { info_tbl: [(c7EoT,
                       label: sat_s7DYw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EoT: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYy_entry() //  [R1, R2]
         { info_tbl: [(c7Ep0,
                       label: sat_s7DYy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ep0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Ep1; else goto c7Ep2;
       c7Ep1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ep2: // global
           I64[Sp - 24] = block_c7EoK_info;
           _s7DYu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYu::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYu::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7EoK() //  [R1]
         { info_tbl: [(c7EoK,
                       label: block_c7EoK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EoK: // global
           if (R1 & 7 == 1) goto c7EoX; else goto c7EoY;
       c7EoX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Ep5; else goto c7Ep4;
       c7Ep5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ep4: // global
           I64[Hp - 8] = sat_s7DYw_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7EoY: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catch1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ep9,
                       label: GHC.IO.catch1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ep9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Epd; else goto c7Epc;
       c7Epd: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catch1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Epc: // global
           I64[Hp - 16] = sat_s7DYy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.346761218 UTC

[section ""data" . GHC.IO.catch_closure" {
     GHC.IO.catch_closure:
         const GHC.IO.catch_info;
 },
 GHC.IO.catch_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Epi,
                       label: GHC.IO.catch_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Epi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catch1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.348163693 UTC

[section ""data" . GHC.IO.catchException1_closure" {
     GHC.IO.catchException1_closure:
         const GHC.IO.catchException1_info;
 },
 sat_s7DYG_entry() //  [R1]
         { info_tbl: [(c7EpF,
                       label: sat_s7DYG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EpF: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYI_entry() //  [R1, R2]
         { info_tbl: [(c7EpM,
                       label: sat_s7DYI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EpM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7EpN; else goto c7EpO;
       c7EpN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EpO: // global
           I64[Sp - 24] = block_c7Epw_info;
           _s7DYE::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYE::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYE::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Epw() //  [R1]
         { info_tbl: [(c7Epw,
                       label: block_c7Epw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Epw: // global
           if (R1 & 7 == 1) goto c7EpJ; else goto c7EpK;
       c7EpJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EpR; else goto c7EpQ;
       c7EpR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EpQ: // global
           I64[Hp - 8] = sat_s7DYG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7EpK: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchException1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EpV,
                       label: GHC.IO.catchException1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EpV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EpW; else goto c7EpX;
       c7EpW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchException1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EpX: // global
           I64[Sp - 24] = block_c7Epp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Epp() //  [R1]
         { info_tbl: [(c7Epp,
                       label: block_c7Epp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Epp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Eq0; else goto c7EpZ;
       c7Eq0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EpZ: // global
           I64[Hp - 16] = sat_s7DYI_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = R1;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.350075239 UTC

[section ""data" . GHC.IO.catchException_closure" {
     GHC.IO.catchException_closure:
         const GHC.IO.catchException_info;
 },
 GHC.IO.catchException_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Eq5,
                       label: GHC.IO.catchException_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eq5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchException1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.351492762 UTC

[section ""data" . GHC.IO.mplusIO1_closure" {
     GHC.IO.mplusIO1_closure:
         const GHC.IO.mplusIO1_info;
         const 0;
 },
 sat_s7DYP_entry() //  [R1]
         { info_tbl: [(c7Eqs,
                       label: sat_s7DYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eqs: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYR_entry() //  [R1, R2]
         { info_tbl: [(c7Eqz,
                       label: sat_s7DYR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eqz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7EqA; else goto c7EqB;
       c7EqA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EqB: // global
           I64[Sp - 24] = block_c7Eqj_info;
           _s7DYN::P64 = R2;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYN::P64;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = _s7DYN::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Eqj() //  [R1]
         { info_tbl: [(c7Eqj,
                       label: block_c7Eqj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eqj: // global
           if (R1 & 7 == 1) goto c7Eqw; else goto c7Eqx;
       c7Eqw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EqE; else goto c7EqD;
       c7EqE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EqD: // global
           I64[Hp - 8] = sat_s7DYP_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Eqx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mplusIO1_entry() //  [R2, R3]
         { info_tbl: [(c7EqI,
                       label: GHC.IO.mplusIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EqI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EqJ; else goto c7EqK;
       c7EqJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.mplusIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EqK: // global
           I64[Sp - 16] = block_c7Eqc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eqc() //  [R1]
         { info_tbl: [(c7Eqc,
                       label: block_c7Eqc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eqc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EqN; else goto c7EqM;
       c7EqN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EqM: // global
           I64[Hp - 8] = sat_s7DYR_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.353362037 UTC

[section ""data" . GHC.IO.mplusIO_closure" {
     GHC.IO.mplusIO_closure:
         const GHC.IO.mplusIO_info;
         const 0;
 },
 GHC.IO.mplusIO_entry() //  [R2, R3]
         { info_tbl: [(c7EqS,
                       label: GHC.IO.mplusIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EqS: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.mplusIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.354574674 UTC

[section ""data" . GHC.IO.catchAny1_closure" {
     GHC.IO.catchAny1_closure:
         const GHC.IO.catchAny1_info;
 },
 sat_s7DZ0_entry() //  [R1, R2]
         { info_tbl: [(c7Er9,
                       label: sat_s7DZ0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Er9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Era; else goto c7Erb;
       c7Era: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Erb: // global
           I64[Sp - 16] = block_c7Er6_info;
           _s7DYT::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s7DYT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Erf; else goto c7Er7;
       u7Erf: // global
           call _c7Er6(R1) args: 0, res: 0, upd: 0;
       c7Er7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Er6() //  [R1]
         { info_tbl: [(c7Er6,
                       label: block_c7Er6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Er6: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchAny1_entry() //  [R2, R3]
         { info_tbl: [(c7Erg,
                       label: GHC.IO.catchAny1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Erg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Erh; else goto c7Eri;
       c7Erh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Eri: // global
           I64[Sp - 16] = block_c7EqZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EqZ() //  [R1]
         { info_tbl: [(c7EqZ,
                       label: block_c7EqZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EqZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Erl; else goto c7Erk;
       c7Erl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Erk: // global
           I64[Hp - 8] = sat_s7DZ0_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.356138317 UTC

[section ""data" . GHC.IO.catchAny_closure" {
     GHC.IO.catchAny_closure:
         const GHC.IO.catchAny_info;
 },
 GHC.IO.catchAny_entry() //  [R2, R3]
         { info_tbl: [(c7Erq,
                       label: GHC.IO.catchAny_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Erq: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchAny1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.357193832 UTC

[section ""data" . GHC.IO.throwIO1_closure" {
     GHC.IO.throwIO1_closure:
         const GHC.IO.throwIO1_info;
 },
 sat_s7DZ4_entry() //  [R1]
         { info_tbl: [(c7ErB,
                       label: sat_s7DZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ErB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ErC; else goto c7ErD;
       c7ErC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ErD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.throwIO1_entry() //  [R2, R3]
         { info_tbl: [(c7ErE,
                       label: GHC.IO.throwIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ErE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ErI; else goto c7ErH;
       c7ErI: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.throwIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ErH: // global
           I64[Hp - 24] = sat_s7DZ4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.359798503 UTC

[section ""data" . GHC.IO.throwIO_closure" {
     GHC.IO.throwIO_closure:
         const GHC.IO.throwIO_info;
 },
 GHC.IO.throwIO_entry() //  [R2, R3]
         { info_tbl: [(c7ErN,
                       label: GHC.IO.throwIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ErN: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.36095575 UTC

[section ""data" . GHC.IO.onException1_closure" {
     GHC.IO.onException1_closure:
         const GHC.IO.onException1_info;
 },
 sat_s7DZe_entry() //  [R1, R2]
         { info_tbl: [(c7Es3,
                       label: sat_s7DZe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Es3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Es4; else goto c7Es5;
       c7Es4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Es5: // global
           I64[Sp - 16] = block_c7Es1_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Es1() //  []
         { info_tbl: [(c7Es1,
                       label: block_c7Es1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Es1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.onException1_entry() //  [R2, R3]
         { info_tbl: [(c7Es7,
                       label: GHC.IO.onException1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Es7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Es8; else goto c7Es9;
       c7Es8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.onException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Es9: // global
           I64[Sp - 16] = block_c7ErU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ErU() //  [R1]
         { info_tbl: [(c7ErU,
                       label: block_c7ErU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ErU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Esc; else goto c7Esb;
       c7Esc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Esb: // global
           I64[Hp - 8] = sat_s7DZe_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.362712353 UTC

[section ""data" . GHC.IO.onException_closure" {
     GHC.IO.onException_closure:
         const GHC.IO.onException_info;
 },
 GHC.IO.onException_entry() //  [R2, R3]
         { info_tbl: [(c7Esh,
                       label: GHC.IO.onException_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Esh: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.onException1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.363541699 UTC

[section ""data" . GHC.IO.unsafeUnmask_closure" {
     GHC.IO.unsafeUnmask_closure:
         const GHC.IO.unsafeUnmask_info;
 },
 GHC.IO.unsafeUnmask_entry() //  [R2]
         { info_tbl: [(c7Eso,
                       label: GHC.IO.unsafeUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eso: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.364582209 UTC

[section ""data" . GHC.IO.getMaskingState1_closure" {
     GHC.IO.getMaskingState1_closure:
         const GHC.IO.getMaskingState1_info;
 },
 sat_s7DZk_entry() //  [R1]
         { info_tbl: [(c7EsG,
                       label: sat_s7DZk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EsG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EsH; else goto c7EsI;
       c7EsH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EsI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s7DZj::I64 = I64[R1 + 16];
           if (_s7DZj::I64 != 0) goto u7EsJ; else goto c7EsE;
       u7EsJ: // global
           if (_s7DZj::I64 != 1) goto c7EsD; else goto c7EsF;
       c7EsD: // global
           R1 = GHC.IO.MaskedInterruptible_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7EsF: // global
           R1 = GHC.IO.MaskedUninterruptible_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7EsE: // global
           R1 = GHC.IO.Unmasked_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.getMaskingState1_entry() //  []
         { info_tbl: [(c7EsK,
                       label: GHC.IO.getMaskingState1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EsK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7EsL; else goto c7EsM;
       c7EsL: // global
           R1 = GHC.IO.getMaskingState1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7EsM: // global
           I64[Sp - 8] = block_c7Esv_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Esv() //  [R1]
         { info_tbl: [(c7Esv,
                       label: block_c7Esv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Esv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EsP; else goto c7EsO;
       c7EsP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EsO: // global
           I64[Hp - 16] = sat_s7DZk_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.366032206 UTC

[section ""data" . GHC.IO.getMaskingState_closure" {
     GHC.IO.getMaskingState_closure:
         const GHC.IO.getMaskingState_info;
 },
 GHC.IO.getMaskingState_entry() //  []
         { info_tbl: [(c7EsU,
                       label: GHC.IO.getMaskingState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EsU: // global
           call GHC.IO.getMaskingState1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.366980497 UTC

[section ""data" . GHC.IO.interruptible1_closure" {
     GHC.IO.interruptible1_closure:
         const GHC.IO.interruptible1_info;
 },
 GHC.IO.interruptible1_entry() //  [R2]
         { info_tbl: [(c7Et8,
                       label: GHC.IO.interruptible1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Et8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Et9; else goto c7Eta;
       c7Et9: // global
           R2 = R2;
           R1 = GHC.IO.interruptible1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Eta: // global
           I64[Sp - 16] = block_c7Et1_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Et1() //  [R1]
         { info_tbl: [(c7Et1,
                       label: block_c7Et1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Et1: // global
           _s7DZl::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Et7; else goto u7Etc;
       u7Etc: // global
           if (R1 == 1) goto c7Et7; else goto c7Et5;
       c7Et7: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7Et5: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.368079088 UTC

[section ""data" . GHC.IO.interruptible_closure" {
     GHC.IO.interruptible_closure:
         const GHC.IO.interruptible_info;
 },
 GHC.IO.interruptible_entry() //  [R2]
         { info_tbl: [(c7Eth,
                       label: GHC.IO.interruptible_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eth: // global
           R2 = R2;
           call GHC.IO.interruptible1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.369371253 UTC

[section ""data" . GHC.IO.mask1_closure" {
     GHC.IO.mask1_closure:
         const GHC.IO.mask1_info;
 },
 sat_s7DZx_entry() //  [R2]
         { info_tbl: [(c7Etx,
                       label: sat_s7DZx_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Etx: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZy_entry() //  [R2]
         { info_tbl: [(c7EtG,
                       label: sat_s7DZy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EtG: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZA_entry() //  [R2]
         { info_tbl: [(c7EtP,
                       label: sat_s7DZA_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EtP: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mask1_entry() //  [R2]
         { info_tbl: [(c7EtW,
                       label: GHC.IO.mask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EtW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EtX; else goto c7EtY;
       c7EtX: // global
           R2 = R2;
           R1 = GHC.IO.mask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EtY: // global
           I64[Sp - 16] = block_c7Eto_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Eto() //  [R1]
         { info_tbl: [(c7Eto,
                       label: block_c7Eto_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eto: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Eu1; else goto c7Eu0;
       c7Eu1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Eu0: // global
           _s7DZr::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EtU; else goto u7Eu5;
       c7EtU: // global
           I64[Hp - 8] = sat_s7DZy_info;
           I64[Sp + 8] = block_c7Eu2_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7Eu5: // global
           if (R1 == 1) goto c7EtV; else goto c7EtT;
       c7EtV: // global
           I64[Hp - 8] = sat_s7DZA_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7EtT: // global
           I64[Hp - 8] = sat_s7DZx_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Eu2() //  [R1]
         { info_tbl: [(c7Eu2,
                       label: block_c7Eu2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eu2: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.371080448 UTC

[section ""data" . GHC.IO.mask_closure" {
     GHC.IO.mask_closure:
         const GHC.IO.mask_info;
 },
 GHC.IO.mask_entry() //  [R2]
         { info_tbl: [(c7Eua,
                       label: GHC.IO.mask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eua: // global
           R2 = R2;
           call GHC.IO.mask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.371954593 UTC

[section ""data" . GHC.IO.mask_1_closure" {
     GHC.IO.mask_1_closure:
         const GHC.IO.mask_1_info;
 },
 GHC.IO.mask_1_entry() //  [R2]
         { info_tbl: [(c7Eun,
                       label: GHC.IO.mask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eun: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Euo; else goto c7Eup;
       c7Euo: // global
           R2 = R2;
           R1 = GHC.IO.mask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Eup: // global
           I64[Sp - 16] = block_c7Euh_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Euh() //  [R1]
         { info_tbl: [(c7Euh,
                       label: block_c7Euh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Euh: // global
           _s7DZB::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Eum; else goto c7Eul;
       c7Eum: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c7Eul: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.373040829 UTC

[section ""data" . GHC.IO.mask__closure" {
     GHC.IO.mask__closure:
         const GHC.IO.mask__info;
 },
 GHC.IO.mask__entry() //  [R2]
         { info_tbl: [(c7Euv,
                       label: GHC.IO.mask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Euv: // global
           R2 = R2;
           call GHC.IO.mask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.375864789 UTC

[section ""data" . GHC.IO.bracket1_closure" {
     GHC.IO.bracket1_closure:
         const GHC.IO.bracket1_info;
 },
 sat_s7DZZ_entry() //  [R1, R2]
         { info_tbl: [(c7EuP,
                       label: sat_s7DZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EuQ; else goto c7EuR;
       c7EuQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EuR: // global
           I64[Sp - 16] = block_c7EuN_info;
           _s7DZU::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7DZU::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EuN() //  []
         { info_tbl: [(c7EuN,
                       label: block_c7EuN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EuN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZT_entry() //  [R1]
         { info_tbl: [(c7EuZ,
                       label: sat_s7DZT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EuZ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0h_entry() //  [R1, R2]
         { info_tbl: [(c7Evh,
                       label: sat_s7E0h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Evi; else goto c7Evj;
       c7Evi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Evj: // global
           I64[Sp - 16] = block_c7Evf_info;
           _s7E0c::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0c::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Evf() //  []
         { info_tbl: [(c7Evf,
                       label: block_c7Evf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0b_entry() //  [R1]
         { info_tbl: [(c7Evr,
                       label: sat_s7E0b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evr: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0o_entry() //  [R1]
         { info_tbl: [(c7Evy,
                       label: sat_s7E0o_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Evz; else goto c7EvA;
       c7Evz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7EvA: // global
           I64[Sp - 24] = block_c7Ev8_info;
           _s7DZI::P64 = P64[R1 + 15];
           _s7DZJ::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s7DZI::P64;
           P64[Sp - 8] = _s7DZJ::P64;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ev8() //  [R1]
         { info_tbl: [(c7Ev8,
                       label: block_c7Ev8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ev8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7EvD; else goto c7EvC;
       c7EvD: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EvC: // global
           I64[Hp - 64] = sat_s7E0h_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0b_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Evu_info;
           R2 = Hp - 62;
           _s7E09::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E09::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Evu() //  [R1]
         { info_tbl: [(c7Evu,
                       label: block_c7Evu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evu: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Evw_info;
           R2 = P64[Sp + 16];
           _s7E0k::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0k::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Evw() //  []
         { info_tbl: [(c7Evw,
                       label: block_c7Evw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Evw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0z_entry() //  [R1, R2]
         { info_tbl: [(c7EvQ,
                       label: sat_s7E0z_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EvQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EvR; else goto c7EvS;
       c7EvR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EvS: // global
           I64[Sp - 16] = block_c7EvO_info;
           _s7E0u::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0u::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EvO() //  []
         { info_tbl: [(c7EvO,
                       label: block_c7EvO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EvO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0t_entry() //  [R1]
         { info_tbl: [(c7Ew0,
                       label: sat_s7E0t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ew0: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.bracket1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ew7,
                       label: GHC.IO.bracket1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ew7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Ew8; else goto c7Ew9;
       c7Ew8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.bracket1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ew9: // global
           I64[Sp - 32] = block_c7EuC_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EuC() //  [R1]
         { info_tbl: [(c7EuC,
                       label: block_c7EuC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EuC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ewc; else goto c7Ewb;
       c7Ewc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ewb: // global
           _s7DZH::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Ew5; else goto u7Ewv;
       c7Ew5: // global
           I64[Hp - 24] = sat_s7E0o_info;
           P64[Hp - 16] = _s7DZH::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7Ewv: // global
           if (R1 == 1) goto c7Ew6; else goto c7Ew4;
       c7Ew6: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7EvH_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c7Ew4: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7EuG_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EvH() //  [R1]
         { info_tbl: [(c7EvH,
                       label: block_c7EvH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EvH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Ewr; else goto c7Ewq;
       c7Ewr: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ewq: // global
           I64[Hp - 64] = sat_s7E0z_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0t_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Ewm_info;
           R2 = Hp - 62;
           _s7E0r::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E0r::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ewm() //  [R1]
         { info_tbl: [(c7Ewm,
                       label: block_c7Ewm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ewm: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Ewo_info;
           R2 = P64[Sp + 16];
           _s7E0C::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0C::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ewo() //  []
         { info_tbl: [(c7Ewo,
                       label: block_c7Ewo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ewo: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EuG() //  [R1]
         { info_tbl: [(c7EuG,
                       label: block_c7EuG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EuG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Ewi; else goto c7Ewh;
       c7Ewi: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ewh: // global
           I64[Hp - 64] = sat_s7DZZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7DZT_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Ewd_info;
           R2 = Hp - 62;
           _s7DZR::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7DZR::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ewd() //  [R1]
         { info_tbl: [(c7Ewd,
                       label: block_c7Ewd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ewd: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Ewf_info;
           R2 = P64[Sp + 16];
           _s7E02::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E02::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ewf() //  []
         { info_tbl: [(c7Ewf,
                       label: block_c7Ewf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ewf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.380604248 UTC

[section ""data" . GHC.IO.bracket_closure" {
     GHC.IO.bracket_closure:
         const GHC.IO.bracket_info;
 },
 GHC.IO.bracket_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EwA,
                       label: GHC.IO.bracket_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EwA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.382825551 UTC

[section ""data" . GHC.IO.finally1_closure" {
     GHC.IO.finally1_closure:
         const GHC.IO.finally1_info;
 },
 sat_s7E0T_entry() //  [R1, R2]
         { info_tbl: [(c7EwS,
                       label: sat_s7E0T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EwS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EwT; else goto c7EwU;
       c7EwT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EwU: // global
           I64[Sp - 16] = block_c7EwQ_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EwQ() //  []
         { info_tbl: [(c7EwQ,
                       label: block_c7EwQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EwQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0N_entry() //  [R1]
         { info_tbl: [(c7Ex1,
                       label: sat_s7E0N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ex1: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E17_entry() //  [R1, R2]
         { info_tbl: [(c7Exh,
                       label: sat_s7E17_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Exh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Exi; else goto c7Exj;
       c7Exi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Exj: // global
           I64[Sp - 16] = block_c7Exf_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Exf() //  []
         { info_tbl: [(c7Exf,
                       label: block_c7Exf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Exf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E11_entry() //  [R1]
         { info_tbl: [(c7Exq,
                       label: sat_s7E11_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Exq: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1e_entry() //  [R1]
         { info_tbl: [(c7Exx,
                       label: sat_s7E1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Exx: // global
           _s7E1e::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Exy; else goto c7Exz;
       c7Exz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ExB; else goto c7ExA;
       c7ExB: // global
           HpAlloc = 32;
           goto c7Exy;
       c7Exy: // global
           R1 = _s7E1e::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7ExA: // global
           _s7E0G::P64 = P64[_s7E1e::P64 + 7];
           _s7E0H::P64 = P64[_s7E1e::P64 + 15];
           I64[Hp - 24] = sat_s7E17_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E11_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp - 16] = block_c7Ext_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           P64[Sp - 8] = _s7E0H::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ext() //  [R1]
         { info_tbl: [(c7Ext,
                       label: block_c7Ext_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ext: // global
           I64[Sp] = block_c7Exv_info;
           _s7E1a::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1a::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Exv() //  []
         { info_tbl: [(c7Exv,
                       label: block_c7Exv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Exv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1l_entry() //  [R1, R2]
         { info_tbl: [(c7ExM,
                       label: sat_s7E1l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ExM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ExN; else goto c7ExO;
       c7ExN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ExO: // global
           I64[Sp - 16] = block_c7ExK_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ExK() //  []
         { info_tbl: [(c7ExK,
                       label: block_c7ExK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ExK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1f_entry() //  [R1]
         { info_tbl: [(c7ExV,
                       label: sat_s7E1f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ExV: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.finally1_entry() //  [R2, R3]
         { info_tbl: [(c7Ey2,
                       label: GHC.IO.finally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ey2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Ey3; else goto c7Ey4;
       c7Ey3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.finally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ey4: // global
           I64[Sp - 24] = block_c7EwH_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EwH() //  [R1]
         { info_tbl: [(c7EwH,
                       label: block_c7EwH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EwH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ey7; else goto c7Ey6;
       c7Ey7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ey6: // global
           _s7E0G::P64 = P64[Sp + 8];
           _s7E0H::P64 = P64[Sp + 16];
           if (R1 == 0) goto c7Ey0; else goto u7Eyk;
       c7Ey0: // global
           I64[Hp - 24] = sat_s7E1e_info;
           P64[Hp - 16] = _s7E0G::P64;
           P64[Hp - 8] = _s7E0H::P64;
           _c7Ex5::P64 = Hp - 23;
           Hp = Hp - 8;
           R1 = _c7Ex5::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7Eyk: // global
           if (R1 == 1) goto c7Ey1; else goto c7ExZ;
       c7Ey1: // global
           I64[Hp - 24] = sat_s7E1l_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E1f_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7Eye_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       c7ExZ: // global
           I64[Hp - 24] = sat_s7E0T_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E0N_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7Ey8_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eye() //  [R1]
         { info_tbl: [(c7Eye,
                       label: block_c7Eye_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eye: // global
           I64[Sp] = block_c7Eyg_info;
           _s7E1o::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1o::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eyg() //  []
         { info_tbl: [(c7Eyg,
                       label: block_c7Eyg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eyg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ey8() //  [R1]
         { info_tbl: [(c7Ey8,
                       label: block_c7Ey8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ey8: // global
           I64[Sp] = block_c7Eya_info;
           _s7E0W::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E0W::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Eya() //  []
         { info_tbl: [(c7Eya,
                       label: block_c7Eya_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eya: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.386875148 UTC

[section ""data" . GHC.IO.finally_closure" {
     GHC.IO.finally_closure:
         const GHC.IO.finally_info;
 },
 GHC.IO.finally_entry() //  [R2, R3]
         { info_tbl: [(c7Eyp,
                       label: GHC.IO.finally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eyp: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.finally1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.388173915 UTC

[section ""data" . GHC.IO.uninterruptibleMask1_closure" {
     GHC.IO.uninterruptibleMask1_closure:
         const GHC.IO.uninterruptibleMask1_info;
 },
 sat_s7E1y_entry() //  [R2]
         { info_tbl: [(c7EyF,
                       label: sat_s7E1y_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EyF: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1A_entry() //  [R2]
         { info_tbl: [(c7EyO,
                       label: sat_s7E1A_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EyO: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1C_entry() //  [R2]
         { info_tbl: [(c7EyX,
                       label: sat_s7E1C_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EyX: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.uninterruptibleMask1_entry() //  [R2]
         { info_tbl: [(c7Ez4,
                       label: GHC.IO.uninterruptibleMask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ez4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ez5; else goto c7Ez6;
       c7Ez5: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ez6: // global
           I64[Sp - 16] = block_c7Eyw_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Eyw() //  [R1]
         { info_tbl: [(c7Eyw,
                       label: block_c7Eyw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eyw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Ez9; else goto c7Ez8;
       c7Ez9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ez8: // global
           _s7E1s::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7Ez2; else goto u7Ezg;
       c7Ez2: // global
           I64[Hp - 8] = sat_s7E1A_info;
           I64[Sp + 8] = block_c7Ezd_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7Ezg: // global
           if (R1 == 1) goto c7Ez3; else goto c7Ez1;
       c7Ez3: // global
           I64[Hp - 8] = sat_s7E1C_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7Ez1: // global
           I64[Hp - 8] = sat_s7E1y_info;
           I64[Sp + 8] = block_c7Eza_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ezd() //  [R1]
         { info_tbl: [(c7Ezd,
                       label: block_c7Ezd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ezd: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Eza() //  [R1]
         { info_tbl: [(c7Eza,
                       label: block_c7Eza_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Eza: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.390043397 UTC

[section ""data" . GHC.IO.uninterruptibleMask_closure" {
     GHC.IO.uninterruptibleMask_closure:
         const GHC.IO.uninterruptibleMask_info;
 },
 GHC.IO.uninterruptibleMask_entry() //  [R2]
         { info_tbl: [(c7Ezl,
                       label: GHC.IO.uninterruptibleMask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ezl: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.390991046 UTC

[section ""data" . GHC.IO.uninterruptibleMask_1_closure" {
     GHC.IO.uninterruptibleMask_1_closure:
         const GHC.IO.uninterruptibleMask_1_info;
 },
 GHC.IO.uninterruptibleMask_1_entry() //  [R2]
         { info_tbl: [(c7Ezy,
                       label: GHC.IO.uninterruptibleMask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ezy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ezz; else goto c7EzA;
       c7Ezz: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EzA: // global
           I64[Sp - 16] = block_c7Ezs_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Ezs() //  [R1]
         { info_tbl: [(c7Ezs,
                       label: block_c7Ezs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ezs: // global
           _s7E1D::P64 = P64[Sp + 8];
           if (R1 == 1) goto c7Ezx; else goto c7Ezw;
       c7Ezx: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7Ezw: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.392063658 UTC

[section ""data" . GHC.IO.uninterruptibleMask__closure" {
     GHC.IO.uninterruptibleMask__closure:
         const GHC.IO.uninterruptibleMask__info;
 },
 GHC.IO.uninterruptibleMask__entry() //  [R2]
         { info_tbl: [(c7EzG,
                       label: GHC.IO.uninterruptibleMask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EzG: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.392847194 UTC

[section ""data" . GHC.IO.evaluate1_closure" {
     GHC.IO.evaluate1_closure:
         const GHC.IO.evaluate1_info;
 },
 GHC.IO.evaluate1_entry() //  [R2]
         { info_tbl: [(c7EzN,
                       label: GHC.IO.evaluate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EzN: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.393694438 UTC

[section ""data" . GHC.IO.evaluate_closure" {
     GHC.IO.evaluate_closure:
         const GHC.IO.evaluate_info;
 },
 GHC.IO.evaluate_entry() //  [R2]
         { info_tbl: [(c7EzU,
                       label: GHC.IO.evaluate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EzU: // global
           R2 = R2;
           call GHC.IO.evaluate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.394331053 UTC

[section ""cstring" . GHC.IO.$trModule4_bytes" {
     GHC.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.394891157 UTC

[section ""data" . GHC.IO.$trModule3_closure" {
     GHC.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.395445165 UTC

[section ""cstring" . GHC.IO.$trModule2_bytes" {
     GHC.IO.$trModule2_bytes:
         I8[] [71,72,67,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.395982614 UTC

[section ""data" . GHC.IO.$trModule1_closure" {
     GHC.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.396558874 UTC

[section ""data" . GHC.IO.$trModule_closure" {
     GHC.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.$trModule3_closure+1;
         const GHC.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.397117994 UTC

[section ""cstring" . GHC.IO.$tcMaskingState2_bytes" {
     GHC.IO.$tcMaskingState2_bytes:
         I8[] [77,97,115,107,105,110,103,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.397689011 UTC

[section ""data" . GHC.IO.$tcMaskingState1_closure" {
     GHC.IO.$tcMaskingState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tcMaskingState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.398253776 UTC

[section ""data" . GHC.IO.$tcMaskingState_closure" {
     GHC.IO.$tcMaskingState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tcMaskingState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1377527551354837803;
         const 7593236071496752895;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.398830144 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible1_closure" {
     GHC.IO.$tc'MaskedInterruptible1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.$tcMaskingState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.399375874 UTC

[section ""cstring" . GHC.IO.$tc'Unmasked2_bytes" {
     GHC.IO.$tc'Unmasked2_bytes:
         I8[] [39,85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.399921825 UTC

[section ""data" . GHC.IO.$tc'Unmasked1_closure" {
     GHC.IO.$tc'Unmasked1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'Unmasked2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.400468851 UTC

[section ""data" . GHC.IO.$tc'Unmasked_closure" {
     GHC.IO.$tc'Unmasked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'Unmasked1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 16923189221218057084;
         const 12178290748160137861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.401060648 UTC

[section ""cstring" . GHC.IO.$tc'MaskedInterruptible3_bytes" {
     GHC.IO.$tc'MaskedInterruptible3_bytes:
         I8[] [39,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.40163706 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible2_closure" {
     GHC.IO.$tc'MaskedInterruptible2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedInterruptible3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.402165338 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible_closure" {
     GHC.IO.$tc'MaskedInterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedInterruptible2_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 8247192854047081576;
         const 3389631131447074398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.402755148 UTC

[section ""cstring" . GHC.IO.$tc'MaskedUninterruptible2_bytes" {
     GHC.IO.$tc'MaskedUninterruptible2_bytes:
         I8[] [39,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.403283053 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible1_closure" {
     GHC.IO.$tc'MaskedUninterruptible1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedUninterruptible2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.40383396 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible_closure" {
     GHC.IO.$tc'MaskedUninterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedUninterruptible1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 10964471758180118067;
         const 9988357998868476725;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.404420219 UTC

[section ""data" . GHC.IO.Unmasked_closure" {
     GHC.IO.Unmasked_closure:
         const GHC.IO.Unmasked_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.405003941 UTC

[section ""data" . GHC.IO.MaskedInterruptible_closure" {
     GHC.IO.MaskedInterruptible_closure:
         const GHC.IO.MaskedInterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.405640369 UTC

[section ""data" . GHC.IO.MaskedUninterruptible_closure" {
     GHC.IO.MaskedUninterruptible_closure:
         const GHC.IO.MaskedUninterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.407662652 UTC

[section ""relreadonly" . GHC.IO.MaskingState_closure_tbl" {
     GHC.IO.MaskingState_closure_tbl:
         const GHC.IO.Unmasked_closure+1;
         const GHC.IO.MaskedInterruptible_closure+2;
         const GHC.IO.MaskedUninterruptible_closure+3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.408334867 UTC

[GHC.IO.Unmasked_con_entry() //  [R1]
         { info_tbl: [(c7EzX,
                       label: GHC.IO.Unmasked_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,85,110,109,97,115,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EzX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.409119621 UTC

[GHC.IO.MaskedInterruptible_con_entry() //  [R1]
         { info_tbl: [(c7EzZ,
                       label: GHC.IO.MaskedInterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EzZ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.409825863 UTC

[GHC.IO.MaskedUninterruptible_con_entry() //  [R1]
         { info_tbl: [(c7EA1,
                       label: GHC.IO.MaskedUninterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EA1: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.41047349 UTC

[section ""relreadonly" . S7E2C_srt" {
     S7E2C_srt:
         const GHC.IO.$w$cshowsPrec_closure;
         const GHC.IO.$fShowMaskingState1_closure;
         const GHC.IO.$fShowMaskingState3_closure;
         const GHC.IO.$fShowMaskingState5_closure;
         const GHC.IO.$fShowMaskingState_$cshow_closure;
         const GHC.IO.Exception.userError_closure;
         const GHC.IO.Exception.$fxExceptionIOException_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.mplusIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.411314593 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:47.412387126 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState6_bytes" {
     GHC.IO.$fShowMaskingState6_bytes:
         I8[] [85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.414419818 UTC

[section ""data" . GHC.IO.$fShowMaskingState5_closure" {
     GHC.IO.$fShowMaskingState5_closure:
         const GHC.IO.$fShowMaskingState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState5_entry() //  [R1]
         { info_tbl: [(c7EAa,
                       label: GHC.IO.$fShowMaskingState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EAa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EAb; else goto c7EAc;
       c7EAb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EAc: // global
           (_c7EA7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7EA7::I64 == 0) goto c7EA9; else goto c7EA8;
       c7EA9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7EA8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7EA7::I64;
           R2 = GHC.IO.$fShowMaskingState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.41837498 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState4_bytes" {
     GHC.IO.$fShowMaskingState4_bytes:
         I8[] [77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.420189691 UTC

[section ""data" . GHC.IO.$fShowMaskingState3_closure" {
     GHC.IO.$fShowMaskingState3_closure:
         const GHC.IO.$fShowMaskingState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState3_entry() //  [R1]
         { info_tbl: [(c7EAr,
                       label: GHC.IO.$fShowMaskingState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EAr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EAs; else goto c7EAt;
       c7EAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EAt: // global
           (_c7EAo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7EAo::I64 == 0) goto c7EAq; else goto c7EAp;
       c7EAq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7EAp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7EAo::I64;
           R2 = GHC.IO.$fShowMaskingState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.424044565 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState2_bytes" {
     GHC.IO.$fShowMaskingState2_bytes:
         I8[] [77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.425919682 UTC

[section ""data" . GHC.IO.$fShowMaskingState1_closure" {
     GHC.IO.$fShowMaskingState1_closure:
         const GHC.IO.$fShowMaskingState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState1_entry() //  [R1]
         { info_tbl: [(c7EAI,
                       label: GHC.IO.$fShowMaskingState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EAI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EAJ; else goto c7EAK;
       c7EAJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EAK: // global
           (_c7EAF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7EAF::I64 == 0) goto c7EAH; else goto c7EAG;
       c7EAH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7EAG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7EAF::I64;
           R2 = GHC.IO.$fShowMaskingState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.430811576 UTC

[section ""data" . GHC.IO.$w$cshowsPrec_closure" {
     GHC.IO.$w$cshowsPrec_closure:
         const GHC.IO.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c7EB4,
                       label: GHC.IO.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EB5; else goto c7EB6;
       c7EB5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EB6: // global
           I64[Sp - 16] = block_c7EAW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EBh; else goto c7EAX;
       u7EBh: // global
           call _c7EAW(R1) args: 0, res: 0, upd: 0;
       c7EAX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EAW() //  [R1]
         { info_tbl: [(c7EAW,
                       label: block_c7EAW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EAW: // global
           _s7DXR::P64 = P64[Sp + 8];
           _c7EB3::P64 = R1 & 7;
           if (_c7EB3::P64 < 3) goto u7EBg; else goto c7EB2;
       u7EBg: // global
           if (_c7EB3::P64 < 2) goto c7EB0; else goto c7EB1;
       c7EB0: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7EB1: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7EB2: // global
           R3 = _s7DXR::P64;
           R2 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.436628629 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowsPrec_closure" {
     GHC.IO.$fShowMaskingState_$cshowsPrec_closure:
         const GHC.IO.$fShowMaskingState_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c7EBw,
                       label: GHC.IO.$fShowMaskingState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EBw: // global
           _s7DXU::P64 = R3;
           R3 = R4;
           R2 = _s7DXU::P64;
           call GHC.IO.$w$cshowsPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.441290396 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshow_closure" {
     GHC.IO.$fShowMaskingState_$cshow_closure:
         const GHC.IO.$fShowMaskingState_$cshow_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshow_entry() //  [R2]
         { info_tbl: [(c7EBP,
                       label: GHC.IO.$fShowMaskingState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EBP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7EBQ; else goto c7EBR;
       c7EBQ: // global
           R2 = R2;
           R1 = GHC.IO.$fShowMaskingState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EBR: // global
           I64[Sp - 8] = block_c7EBH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7EC2; else goto c7EBI;
       u7EC2: // global
           call _c7EBH(R1) args: 0, res: 0, upd: 0;
       c7EBI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EBH() //  [R1]
         { info_tbl: [(c7EBH,
                       label: block_c7EBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EBH: // global
           _c7EBO::P64 = R1 & 7;
           if (_c7EBO::P64 < 3) goto u7EC1; else goto c7EBN;
       u7EC1: // global
           if (_c7EBO::P64 < 2) goto c7EBL; else goto c7EBM;
       c7EBL: // global
           R1 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7EBM: // global
           R1 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7EBN: // global
           R1 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.446954985 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowList_closure" {
     GHC.IO.$fShowMaskingState_$cshowList_closure:
         const GHC.IO.$fShowMaskingState_$cshowList_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c7ECk,
                       label: GHC.IO.$fShowMaskingState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ECk: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.450311946 UTC

[section ""data" . GHC.IO.$fShowMaskingState_closure" {
     GHC.IO.$fShowMaskingState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.$fShowMaskingState_$cshowsPrec_closure+3;
         const GHC.IO.$fShowMaskingState_$cshow_closure+1;
         const GHC.IO.$fShowMaskingState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.452749579 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c==_closure" {
     GHC.IO.$fEqMaskingState_$c==_closure:
         const GHC.IO.$fEqMaskingState_$c==_info;
 },
 GHC.IO.$fEqMaskingState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7ECE,
                       label: GHC.IO.$fEqMaskingState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ECE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ECF; else goto c7ECG;
       c7ECF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ECG: // global
           I64[Sp - 16] = block_c7ECw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EDD; else goto c7ECx;
       u7EDD: // global
           call _c7ECw(R1) args: 0, res: 0, upd: 0;
       c7ECx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ECw() //  [R1]
         { info_tbl: [(c7ECw,
                       label: block_c7ECw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ECw: // global
           _s7DY1::P64 = P64[Sp + 8];
           _c7ECD::P64 = R1 & 7;
           if (_c7ECD::P64 < 3) goto u7EDt; else goto c7ECC;
       u7EDt: // global
           if (_c7ECD::P64 < 2) goto c7ECA; else goto c7ECB;
       c7ECA: // global
           I64[Sp + 8] = block_c7ECJ_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EDA; else goto c7ECL;
       u7EDA: // global
           call _c7ECJ(R1) args: 0, res: 0, upd: 0;
       c7ECL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ECB: // global
           I64[Sp + 8] = block_c7ECY_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EDB; else goto c7ED0;
       u7EDB: // global
           call _c7ECY(R1) args: 0, res: 0, upd: 0;
       c7ED0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7ECC: // global
           I64[Sp + 8] = block_c7EDd_info;
           R1 = _s7DY1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EDC; else goto c7EDf;
       u7EDC: // global
           call _c7EDd(R1) args: 0, res: 0, upd: 0;
       c7EDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ECJ() //  [R1]
         { info_tbl: [(c7ECJ,
                       label: block_c7ECJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ECJ: // global
           if (R1 & 7 == 1) goto u7EDu; else goto u7EDv;
       u7EDu: // global
           Sp = Sp + 8;
           call _c7EDp() args: 0, res: 0, upd: 0;
       u7EDv: // global
           Sp = Sp + 8;
           call _c7EDl() args: 0, res: 0, upd: 0;
     }
 },
 _c7ECY() //  [R1]
         { info_tbl: [(c7ECY,
                       label: block_c7ECY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ECY: // global
           if (R1 & 7 == 2) goto u7EDw; else goto u7EDx;
       u7EDw: // global
           Sp = Sp + 8;
           call _c7EDp() args: 0, res: 0, upd: 0;
       u7EDx: // global
           Sp = Sp + 8;
           call _c7EDl() args: 0, res: 0, upd: 0;
     }
 },
 _c7EDd() //  [R1]
         { info_tbl: [(c7EDd,
                       label: block_c7EDd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EDd: // global
           if (R1 & 7 == 3) goto u7EDy; else goto u7EDz;
       u7EDy: // global
           Sp = Sp + 8;
           call _c7EDp() args: 0, res: 0, upd: 0;
       u7EDz: // global
           Sp = Sp + 8;
           call _c7EDl() args: 0, res: 0, upd: 0;
     }
 },
 _c7EDp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EDp: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EDl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EDl: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.465868506 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c/=_closure" {
     GHC.IO.$fEqMaskingState_$c/=_closure:
         const GHC.IO.$fEqMaskingState_$c/=_info;
 },
 GHC.IO.$fEqMaskingState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7EEu,
                       label: GHC.IO.$fEqMaskingState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EEu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EEv; else goto c7EEw;
       c7EEv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EEw: // global
           I64[Sp - 16] = block_c7EEm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EFt; else goto c7EEn;
       u7EFt: // global
           call _c7EEm(R1) args: 0, res: 0, upd: 0;
       c7EEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EEm() //  [R1]
         { info_tbl: [(c7EEm,
                       label: block_c7EEm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EEm: // global
           _s7DY7::P64 = P64[Sp + 8];
           _c7EEt::P64 = R1 & 7;
           if (_c7EEt::P64 < 3) goto u7EFj; else goto c7EEs;
       u7EFj: // global
           if (_c7EEt::P64 < 2) goto c7EEq; else goto c7EEr;
       c7EEq: // global
           I64[Sp + 8] = block_c7EEz_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EFq; else goto c7EEB;
       u7EFq: // global
           call _c7EEz(R1) args: 0, res: 0, upd: 0;
       c7EEB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7EEr: // global
           I64[Sp + 8] = block_c7EEO_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EFr; else goto c7EEQ;
       u7EFr: // global
           call _c7EEO(R1) args: 0, res: 0, upd: 0;
       c7EEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7EEs: // global
           I64[Sp + 8] = block_c7EF3_info;
           R1 = _s7DY7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7EFs; else goto c7EF5;
       u7EFs: // global
           call _c7EF3(R1) args: 0, res: 0, upd: 0;
       c7EF5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EEz() //  [R1]
         { info_tbl: [(c7EEz,
                       label: block_c7EEz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EEz: // global
           if (R1 & 7 == 1) goto u7EFk; else goto u7EFl;
       u7EFk: // global
           Sp = Sp + 8;
           call _c7EFf() args: 0, res: 0, upd: 0;
       u7EFl: // global
           Sp = Sp + 8;
           call _c7EFb() args: 0, res: 0, upd: 0;
     }
 },
 _c7EEO() //  [R1]
         { info_tbl: [(c7EEO,
                       label: block_c7EEO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EEO: // global
           if (R1 & 7 == 2) goto u7EFm; else goto u7EFn;
       u7EFm: // global
           Sp = Sp + 8;
           call _c7EFf() args: 0, res: 0, upd: 0;
       u7EFn: // global
           Sp = Sp + 8;
           call _c7EFb() args: 0, res: 0, upd: 0;
     }
 },
 _c7EF3() //  [R1]
         { info_tbl: [(c7EF3,
                       label: block_c7EF3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EF3: // global
           if (R1 & 7 == 3) goto u7EFo; else goto u7EFp;
       u7EFo: // global
           Sp = Sp + 8;
           call _c7EFf() args: 0, res: 0, upd: 0;
       u7EFp: // global
           Sp = Sp + 8;
           call _c7EFb() args: 0, res: 0, upd: 0;
     }
 },
 _c7EFf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EFf: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EFb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EFb: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.478680168 UTC

[section ""data" . GHC.IO.$fEqMaskingState_closure" {
     GHC.IO.$fEqMaskingState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.$fEqMaskingState_$c==_closure+2;
         const GHC.IO.$fEqMaskingState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.480714026 UTC

[section ""data" . GHC.IO.liftIO_closure" {
     GHC.IO.liftIO_closure:
         const GHC.IO.liftIO_info;
 },
 GHC.IO.liftIO_entry() //  [R2]
         { info_tbl: [(c7EGg,
                       label: GHC.IO.liftIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EGg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7EGh; else goto c7EGi;
       c7EGh: // global
           R2 = R2;
           R1 = GHC.IO.liftIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EGi: // global
           I64[Sp - 8] = block_c7EGd_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EGd() //  [R1]
         { info_tbl: [(c7EGd,
                       label: block_c7EGd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EGd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EGl; else goto c7EGk;
       c7EGl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EGk: // global
           I64[Hp - 8] = GHC.ST.STret_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.486787159 UTC

[section ""data" . GHC.IO.failIO1_closure" {
     GHC.IO.failIO1_closure:
         const GHC.IO.failIO1_info;
         const 0;
 },
 sat_s7DYj_entry() //  [R1]
         { info_tbl: [(c7EGH,
                       label: sat_s7DYj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EGH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EGI; else goto c7EGJ;
       c7EGI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EGJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           R1 = GHC.IO.Exception.userError_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7DYk_entry() //  [R1]
         { info_tbl: [(c7EGK,
                       label: sat_s7DYk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EGK: // global
           _s7DYk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c7EGL; else goto c7EGM;
       c7EGM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EGO; else goto c7EGN;
       c7EGO: // global
           HpAlloc = 24;
           goto c7EGL;
       c7EGL: // global
           R1 = _s7DYk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EGN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7DYk::P64;
           _s7DYh::P64 = P64[_s7DYk::P64 + 16];
           I64[Hp - 16] = sat_s7DYj_info;
           P64[Hp] = _s7DYh::P64;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.failIO1_entry() //  [R2]
         { info_tbl: [(c7EGP,
                       label: GHC.IO.failIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EGP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EGT; else goto c7EGS;
       c7EGT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.failIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EGS: // global
           I64[Hp - 16] = sat_s7DYk_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.494237474 UTC

[section ""data" . GHC.IO.failIO_closure" {
     GHC.IO.failIO_closure:
         const GHC.IO.failIO_info;
         const 0;
 },
 GHC.IO.failIO_entry() //  [R2]
         { info_tbl: [(c7EHb,
                       label: GHC.IO.failIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EHb: // global
           R2 = R2;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.497363615 UTC

[section ""data" . GHC.IO.stToIO1_closure" {
     GHC.IO.stToIO1_closure:
         const GHC.IO.stToIO1_info;
 },
 GHC.IO.stToIO1_entry() //  [R2]
         { info_tbl: [(c7EHm,
                       label: GHC.IO.stToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EHm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.500423546 UTC

[section ""data" . GHC.IO.stToIO_closure" {
     GHC.IO.stToIO_closure:
         const GHC.IO.stToIO_info;
 },
 GHC.IO.stToIO_entry() //  [R2]
         { info_tbl: [(c7EHx,
                       label: GHC.IO.stToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EHx: // global
           R2 = R2;
           call GHC.IO.stToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.503884353 UTC

[section ""data" . GHC.IO.ioToST1_closure" {
     GHC.IO.ioToST1_closure:
         const GHC.IO.ioToST1_info;
 },
 GHC.IO.ioToST1_entry() //  [R2]
         { info_tbl: [(c7EHI,
                       label: GHC.IO.ioToST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EHI: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.507420976 UTC

[section ""data" . GHC.IO.ioToST_closure" {
     GHC.IO.ioToST_closure:
         const GHC.IO.ioToST_info;
 },
 GHC.IO.ioToST_entry() //  [R2]
         { info_tbl: [(c7EHT,
                       label: GHC.IO.ioToST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EHT: // global
           R2 = R2;
           call GHC.IO.ioToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.510576746 UTC

[section ""data" . GHC.IO.unsafeIOToST1_closure" {
     GHC.IO.unsafeIOToST1_closure:
         const GHC.IO.unsafeIOToST1_info;
 },
 GHC.IO.unsafeIOToST1_entry() //  [R2]
         { info_tbl: [(c7EI4,
                       label: GHC.IO.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EI4: // global
           R1 = R2;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.514203152 UTC

[section ""data" . GHC.IO.unsafeIOToST_closure" {
     GHC.IO.unsafeIOToST_closure:
         const GHC.IO.unsafeIOToST_info;
 },
 GHC.IO.unsafeIOToST_entry() //  [R2]
         { info_tbl: [(c7EIf,
                       label: GHC.IO.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EIf: // global
           R2 = R2;
           call GHC.IO.unsafeIOToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.5173798 UTC

[section ""data" . GHC.IO.unsafeSTToIO1_closure" {
     GHC.IO.unsafeSTToIO1_closure:
         const GHC.IO.unsafeSTToIO1_info;
 },
 GHC.IO.unsafeSTToIO1_entry() //  [R2]
         { info_tbl: [(c7EIq,
                       label: GHC.IO.unsafeSTToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EIq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.520582867 UTC

[section ""data" . GHC.IO.unsafeSTToIO_closure" {
     GHC.IO.unsafeSTToIO_closure:
         const GHC.IO.unsafeSTToIO_info;
 },
 GHC.IO.unsafeSTToIO_entry() //  [R2]
         { info_tbl: [(c7EIB,
                       label: GHC.IO.unsafeSTToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EIB: // global
           R2 = R2;
           call GHC.IO.unsafeSTToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.524398257 UTC

[section ""data" . GHC.IO.catch1_closure" {
     GHC.IO.catch1_closure:
         const GHC.IO.catch1_info;
 },
 sat_s7DYw_entry() //  [R1]
         { info_tbl: [(c7EJ0,
                       label: sat_s7DYw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EJ0: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYy_entry() //  [R1, R2]
         { info_tbl: [(c7EJ7,
                       label: sat_s7DYy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EJ7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7EJ8; else goto c7EJ9;
       c7EJ8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EJ9: // global
           I64[Sp - 24] = block_c7EIR_info;
           _s7DYu::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYu::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYu::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7EIR() //  [R1]
         { info_tbl: [(c7EIR,
                       label: block_c7EIR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EIR: // global
           if (R1 & 7 == 1) goto c7EJ4; else goto c7EJ5;
       c7EJ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EJc; else goto c7EJb;
       c7EJc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EJb: // global
           I64[Hp - 8] = sat_s7DYw_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7EJ5: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catch1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EJg,
                       label: GHC.IO.catch1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EJg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EJk; else goto c7EJj;
       c7EJk: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catch1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EJj: // global
           I64[Hp - 16] = sat_s7DYy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.533872898 UTC

[section ""data" . GHC.IO.catch_closure" {
     GHC.IO.catch_closure:
         const GHC.IO.catch_info;
 },
 GHC.IO.catch_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EJI,
                       label: GHC.IO.catch_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EJI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catch1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.537897317 UTC

[section ""data" . GHC.IO.catchException1_closure" {
     GHC.IO.catchException1_closure:
         const GHC.IO.catchException1_info;
 },
 sat_s7DYG_entry() //  [R1]
         { info_tbl: [(c7EK9,
                       label: sat_s7DYG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EK9: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYI_entry() //  [R1, R2]
         { info_tbl: [(c7EKg,
                       label: sat_s7DYI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EKg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7EKh; else goto c7EKi;
       c7EKh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EKi: // global
           I64[Sp - 24] = block_c7EK0_info;
           _s7DYE::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYE::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7DYE::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7EK0() //  [R1]
         { info_tbl: [(c7EK0,
                       label: block_c7EK0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EK0: // global
           if (R1 & 7 == 1) goto c7EKd; else goto c7EKe;
       c7EKd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EKl; else goto c7EKk;
       c7EKl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EKk: // global
           I64[Hp - 8] = sat_s7DYG_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7EKe: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchException1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EKp,
                       label: GHC.IO.catchException1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EKp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EKq; else goto c7EKr;
       c7EKq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchException1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EKr: // global
           I64[Sp - 24] = block_c7EJT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EJT() //  [R1]
         { info_tbl: [(c7EJT,
                       label: block_c7EJT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EJT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EKu; else goto c7EKt;
       c7EKu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EKt: // global
           I64[Hp - 16] = sat_s7DYI_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = R1;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.549733061 UTC

[section ""data" . GHC.IO.catchException_closure" {
     GHC.IO.catchException_closure:
         const GHC.IO.catchException_info;
 },
 GHC.IO.catchException_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EKY,
                       label: GHC.IO.catchException_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EKY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchException1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.55366276 UTC

[section ""data" . GHC.IO.mplusIO1_closure" {
     GHC.IO.mplusIO1_closure:
         const GHC.IO.mplusIO1_info;
         const 0;
 },
 sat_s7DYP_entry() //  [R1]
         { info_tbl: [(c7ELp,
                       label: sat_s7DYP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ELp: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DYR_entry() //  [R1, R2]
         { info_tbl: [(c7ELw,
                       label: sat_s7DYR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ELw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7ELx; else goto c7ELy;
       c7ELx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ELy: // global
           I64[Sp - 24] = block_c7ELg_info;
           _s7DYN::P64 = R2;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7DYN::P64;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = _s7DYN::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7ELg() //  [R1]
         { info_tbl: [(c7ELg,
                       label: block_c7ELg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ELg: // global
           if (R1 & 7 == 1) goto c7ELt; else goto c7ELu;
       c7ELt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ELB; else goto c7ELA;
       c7ELB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ELA: // global
           I64[Hp - 8] = sat_s7DYP_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7ELu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mplusIO1_entry() //  [R2, R3]
         { info_tbl: [(c7ELF,
                       label: GHC.IO.mplusIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ELF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ELG; else goto c7ELH;
       c7ELG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.mplusIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ELH: // global
           I64[Sp - 16] = block_c7EL9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EL9() //  [R1]
         { info_tbl: [(c7EL9,
                       label: block_c7EL9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EL9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7ELK; else goto c7ELJ;
       c7ELK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ELJ: // global
           I64[Hp - 8] = sat_s7DYR_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.564581571 UTC

[section ""data" . GHC.IO.mplusIO_closure" {
     GHC.IO.mplusIO_closure:
         const GHC.IO.mplusIO_info;
         const 0;
 },
 GHC.IO.mplusIO_entry() //  [R2, R3]
         { info_tbl: [(c7EMd,
                       label: GHC.IO.mplusIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EMd: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.mplusIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.568595226 UTC

[section ""data" . GHC.IO.catchAny1_closure" {
     GHC.IO.catchAny1_closure:
         const GHC.IO.catchAny1_info;
 },
 sat_s7DZ0_entry() //  [R1, R2]
         { info_tbl: [(c7EMy,
                       label: sat_s7DZ0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EMy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EMz; else goto c7EMA;
       c7EMz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EMA: // global
           I64[Sp - 16] = block_c7EMv_info;
           _s7DYT::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s7DYT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7EME; else goto c7EMw;
       u7EME: // global
           call _c7EMv(R1) args: 0, res: 0, upd: 0;
       c7EMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EMv() //  [R1]
         { info_tbl: [(c7EMv,
                       label: block_c7EMv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EMv: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchAny1_entry() //  [R2, R3]
         { info_tbl: [(c7EMF,
                       label: GHC.IO.catchAny1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EMF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EMG; else goto c7EMH;
       c7EMG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EMH: // global
           I64[Sp - 16] = block_c7EMo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EMo() //  [R1]
         { info_tbl: [(c7EMo,
                       label: block_c7EMo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EMo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EMK; else goto c7EMJ;
       c7EMK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EMJ: // global
           I64[Hp - 8] = sat_s7DZ0_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.578639216 UTC

[section ""data" . GHC.IO.catchAny_closure" {
     GHC.IO.catchAny_closure:
         const GHC.IO.catchAny_info;
 },
 GHC.IO.catchAny_entry() //  [R2, R3]
         { info_tbl: [(c7EN6,
                       label: GHC.IO.catchAny_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EN6: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchAny1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.582147754 UTC

[section ""data" . GHC.IO.throwIO1_closure" {
     GHC.IO.throwIO1_closure:
         const GHC.IO.throwIO1_info;
 },
 sat_s7DZ4_entry() //  [R1]
         { info_tbl: [(c7ENl,
                       label: sat_s7DZ4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ENl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ENm; else goto c7ENn;
       c7ENm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7ENn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.throwIO1_entry() //  [R2, R3]
         { info_tbl: [(c7ENo,
                       label: GHC.IO.throwIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ENo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ENs; else goto c7ENr;
       c7ENs: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.throwIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ENr: // global
           I64[Hp - 24] = sat_s7DZ4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.587539214 UTC

[section ""data" . GHC.IO.throwIO_closure" {
     GHC.IO.throwIO_closure:
         const GHC.IO.throwIO_info;
 },
 GHC.IO.throwIO_entry() //  [R2, R3]
         { info_tbl: [(c7ENG,
                       label: GHC.IO.throwIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ENG: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.591179079 UTC

[section ""data" . GHC.IO.onException1_closure" {
     GHC.IO.onException1_closure:
         const GHC.IO.onException1_info;
 },
 sat_s7DZe_entry() //  [R1, R2]
         { info_tbl: [(c7EO0,
                       label: sat_s7DZe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EO1; else goto c7EO2;
       c7EO1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EO2: // global
           I64[Sp - 16] = block_c7ENY_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ENY() //  []
         { info_tbl: [(c7ENY,
                       label: block_c7ENY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ENY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.onException1_entry() //  [R2, R3]
         { info_tbl: [(c7EO4,
                       label: GHC.IO.onException1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EO4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EO5; else goto c7EO6;
       c7EO5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.onException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EO6: // global
           I64[Sp - 16] = block_c7ENR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ENR() //  [R1]
         { info_tbl: [(c7ENR,
                       label: block_c7ENR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ENR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EO9; else goto c7EO8;
       c7EO9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7EO8: // global
           I64[Hp - 8] = sat_s7DZe_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.599943989 UTC

[section ""data" . GHC.IO.onException_closure" {
     GHC.IO.onException_closure:
         const GHC.IO.onException_info;
 },
 GHC.IO.onException_entry() //  [R2, R3]
         { info_tbl: [(c7EOu,
                       label: GHC.IO.onException_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EOu: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.onException1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.603129026 UTC

[section ""data" . GHC.IO.unsafeUnmask_closure" {
     GHC.IO.unsafeUnmask_closure:
         const GHC.IO.unsafeUnmask_info;
 },
 GHC.IO.unsafeUnmask_entry() //  [R2]
         { info_tbl: [(c7EOF,
                       label: GHC.IO.unsafeUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EOF: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.606680101 UTC

[section ""data" . GHC.IO.getMaskingState1_closure" {
     GHC.IO.getMaskingState1_closure:
         const GHC.IO.getMaskingState1_info;
 },
 sat_s7DZk_entry() //  [R1]
         { info_tbl: [(c7EP1,
                       label: sat_s7DZk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EP1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EP2; else goto c7EP3;
       c7EP2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7EP3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s7DZj::I64 = I64[R1 + 16];
           if (_s7DZj::I64 != 0) goto u7EP4; else goto c7EOZ;
       u7EP4: // global
           if (_s7DZj::I64 != 1) goto c7EOY; else goto c7EP0;
       c7EOY: // global
           R1 = GHC.IO.MaskedInterruptible_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7EP0: // global
           R1 = GHC.IO.MaskedUninterruptible_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7EOZ: // global
           R1 = GHC.IO.Unmasked_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.getMaskingState1_entry() //  []
         { info_tbl: [(c7EP5,
                       label: GHC.IO.getMaskingState1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EP5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7EP6; else goto c7EP7;
       c7EP6: // global
           R1 = GHC.IO.getMaskingState1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7EP7: // global
           I64[Sp - 8] = block_c7EOQ_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EOQ() //  [R1]
         { info_tbl: [(c7EOQ,
                       label: block_c7EOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EOQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7EPa; else goto c7EP9;
       c7EPa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EP9: // global
           I64[Hp - 16] = sat_s7DZk_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.61490357 UTC

[section ""data" . GHC.IO.getMaskingState_closure" {
     GHC.IO.getMaskingState_closure:
         const GHC.IO.getMaskingState_info;
 },
 GHC.IO.getMaskingState_entry() //  []
         { info_tbl: [(c7EPv,
                       label: GHC.IO.getMaskingState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EPv: // global
           call GHC.IO.getMaskingState1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.618333473 UTC

[section ""data" . GHC.IO.interruptible1_closure" {
     GHC.IO.interruptible1_closure:
         const GHC.IO.interruptible1_info;
 },
 GHC.IO.interruptible1_entry() //  [R2]
         { info_tbl: [(c7EPN,
                       label: GHC.IO.interruptible1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EPO; else goto c7EPP;
       c7EPO: // global
           R2 = R2;
           R1 = GHC.IO.interruptible1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EPP: // global
           I64[Sp - 16] = block_c7EPG_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EPG() //  [R1]
         { info_tbl: [(c7EPG,
                       label: block_c7EPG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EPG: // global
           _s7DZl::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EPM; else goto u7EPR;
       u7EPR: // global
           if (R1 == 1) goto c7EPM; else goto c7EPK;
       c7EPM: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7EPK: // global
           R1 = _s7DZl::P64;
           Sp = Sp + 16;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.623700186 UTC

[section ""data" . GHC.IO.interruptible_closure" {
     GHC.IO.interruptible_closure:
         const GHC.IO.interruptible_info;
 },
 GHC.IO.interruptible_entry() //  [R2]
         { info_tbl: [(c7EQ4,
                       label: GHC.IO.interruptible_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQ4: // global
           R2 = R2;
           call GHC.IO.interruptible1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.627802133 UTC

[section ""data" . GHC.IO.mask1_closure" {
     GHC.IO.mask1_closure:
         const GHC.IO.mask1_info;
 },
 sat_s7DZx_entry() //  [R2]
         { info_tbl: [(c7EQo,
                       label: sat_s7DZx_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQo: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZy_entry() //  [R2]
         { info_tbl: [(c7EQx,
                       label: sat_s7DZy_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQx: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZA_entry() //  [R2]
         { info_tbl: [(c7EQG,
                       label: sat_s7DZA_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQG: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mask1_entry() //  [R2]
         { info_tbl: [(c7EQN,
                       label: GHC.IO.mask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EQO; else goto c7EQP;
       c7EQO: // global
           R2 = R2;
           R1 = GHC.IO.mask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EQP: // global
           I64[Sp - 16] = block_c7EQf_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EQf() //  [R1]
         { info_tbl: [(c7EQf,
                       label: block_c7EQf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EQS; else goto c7EQR;
       c7EQS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EQR: // global
           _s7DZr::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EQL; else goto u7EQW;
       c7EQL: // global
           I64[Hp - 8] = sat_s7DZy_info;
           I64[Sp + 8] = block_c7EQT_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7EQW: // global
           if (R1 == 1) goto c7EQM; else goto c7EQK;
       c7EQM: // global
           I64[Hp - 8] = sat_s7DZA_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7EQK: // global
           I64[Hp - 8] = sat_s7DZx_info;
           R2 = Hp - 6;
           R1 = _s7DZr::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EQT() //  [R1]
         { info_tbl: [(c7EQT,
                       label: block_c7EQT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EQT: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.639496594 UTC

[section ""data" . GHC.IO.mask_closure" {
     GHC.IO.mask_closure:
         const GHC.IO.mask_info;
 },
 GHC.IO.mask_entry() //  [R2]
         { info_tbl: [(c7ERl,
                       label: GHC.IO.mask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ERl: // global
           R2 = R2;
           call GHC.IO.mask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.643507776 UTC

[section ""data" . GHC.IO.mask_1_closure" {
     GHC.IO.mask_1_closure:
         const GHC.IO.mask_1_info;
 },
 GHC.IO.mask_1_entry() //  [R2]
         { info_tbl: [(c7ERC,
                       label: GHC.IO.mask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ERC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ERD; else goto c7ERE;
       c7ERD: // global
           R2 = R2;
           R1 = GHC.IO.mask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ERE: // global
           I64[Sp - 16] = block_c7ERw_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7ERw() //  [R1]
         { info_tbl: [(c7ERw,
                       label: block_c7ERw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ERw: // global
           _s7DZB::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7ERB; else goto c7ERA;
       c7ERB: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c7ERA: // global
           R1 = _s7DZB::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.648600995 UTC

[section ""data" . GHC.IO.mask__closure" {
     GHC.IO.mask__closure:
         const GHC.IO.mask__info;
 },
 GHC.IO.mask__entry() //  [R2]
         { info_tbl: [(c7ERS,
                       label: GHC.IO.mask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ERS: // global
           R2 = R2;
           call GHC.IO.mask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.65426289 UTC

[section ""data" . GHC.IO.bracket1_closure" {
     GHC.IO.bracket1_closure:
         const GHC.IO.bracket1_info;
 },
 sat_s7DZZ_entry() //  [R1, R2]
         { info_tbl: [(c7ESg,
                       label: sat_s7DZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ESh; else goto c7ESi;
       c7ESh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ESi: // global
           I64[Sp - 16] = block_c7ESe_info;
           _s7DZU::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7DZU::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ESe() //  []
         { info_tbl: [(c7ESe,
                       label: block_c7ESe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7DZT_entry() //  [R1]
         { info_tbl: [(c7ESq,
                       label: sat_s7DZT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESq: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0h_entry() //  [R1, R2]
         { info_tbl: [(c7ESI,
                       label: sat_s7E0h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ESJ; else goto c7ESK;
       c7ESJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ESK: // global
           I64[Sp - 16] = block_c7ESG_info;
           _s7E0c::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0c::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ESG() //  []
         { info_tbl: [(c7ESG,
                       label: block_c7ESG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0b_entry() //  [R1]
         { info_tbl: [(c7ESS,
                       label: sat_s7E0b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESS: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0o_entry() //  [R1]
         { info_tbl: [(c7ESZ,
                       label: sat_s7E0o_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7ET0; else goto c7ET1;
       c7ET0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7ET1: // global
           I64[Sp - 24] = block_c7ESz_info;
           _s7DZI::P64 = P64[R1 + 15];
           _s7DZJ::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s7DZI::P64;
           P64[Sp - 8] = _s7DZJ::P64;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ESz() //  [R1]
         { info_tbl: [(c7ESz,
                       label: block_c7ESz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7ET4; else goto c7ET3;
       c7ET4: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ET3: // global
           I64[Hp - 64] = sat_s7E0h_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0b_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7ESV_info;
           R2 = Hp - 62;
           _s7E09::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E09::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ESV() //  [R1]
         { info_tbl: [(c7ESV,
                       label: block_c7ESV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESV: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7ESX_info;
           R2 = P64[Sp + 16];
           _s7E0k::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0k::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ESX() //  []
         { info_tbl: [(c7ESX,
                       label: block_c7ESX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ESX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0z_entry() //  [R1, R2]
         { info_tbl: [(c7ETh,
                       label: sat_s7E0z_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7ETi; else goto c7ETj;
       c7ETi: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7ETj: // global
           I64[Sp - 16] = block_c7ETf_info;
           _s7E0u::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7E0u::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ETf() //  []
         { info_tbl: [(c7ETf,
                       label: block_c7ETf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETf: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0t_entry() //  [R1]
         { info_tbl: [(c7ETr,
                       label: sat_s7E0t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETr: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.bracket1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7ETy,
                       label: GHC.IO.bracket1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7ETz; else goto c7ETA;
       c7ETz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.bracket1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7ETA: // global
           I64[Sp - 32] = block_c7ES3_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7ES3() //  [R1]
         { info_tbl: [(c7ES3,
                       label: block_c7ES3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ES3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7ETD; else goto c7ETC;
       c7ETD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7ETC: // global
           _s7DZH::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7ETw; else goto u7ETW;
       c7ETw: // global
           I64[Hp - 24] = sat_s7E0o_info;
           P64[Hp - 16] = _s7DZH::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7ETW: // global
           if (R1 == 1) goto c7ETx; else goto c7ETv;
       c7ETx: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7ET8_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c7ETv: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7ES7_info;
           R1 = _s7DZH::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ET8() //  [R1]
         { info_tbl: [(c7ET8,
                       label: block_c7ET8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ET8: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7ETS; else goto c7ETR;
       c7ETS: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ETR: // global
           I64[Hp - 64] = sat_s7E0z_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7E0t_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7ETN_info;
           R2 = Hp - 62;
           _s7E0r::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7E0r::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ETN() //  [R1]
         { info_tbl: [(c7ETN,
                       label: block_c7ETN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETN: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7ETP_info;
           R2 = P64[Sp + 16];
           _s7E0C::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E0C::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ETP() //  []
         { info_tbl: [(c7ETP,
                       label: block_c7ETP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7ES7() //  [R1]
         { info_tbl: [(c7ES7,
                       label: block_c7ES7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ES7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7ETJ; else goto c7ETI;
       c7ETJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7ETI: // global
           I64[Hp - 64] = sat_s7DZZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7DZT_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7ETE_info;
           R2 = Hp - 62;
           _s7DZR::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7DZR::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ETE() //  [R1]
         { info_tbl: [(c7ETE,
                       label: block_c7ETE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETE: // global
           _s7DZI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7ETG_info;
           R2 = P64[Sp + 16];
           _s7E02::P64 = R1;
           R1 = _s7DZI::P64;
           P64[Sp + 16] = _s7E02::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7ETG() //  []
         { info_tbl: [(c7ETG,
                       label: block_c7ETG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7ETG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.692144597 UTC

[section ""data" . GHC.IO.bracket_closure" {
     GHC.IO.bracket_closure:
         const GHC.IO.bracket_info;
 },
 GHC.IO.bracket_entry() //  [R2, R3, R4]
         { info_tbl: [(c7EVm,
                       label: GHC.IO.bracket_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EVm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.696792721 UTC

[section ""data" . GHC.IO.finally1_closure" {
     GHC.IO.finally1_closure:
         const GHC.IO.finally1_info;
 },
 sat_s7E0T_entry() //  [R1, R2]
         { info_tbl: [(c7EVI,
                       label: sat_s7E0T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EVI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EVJ; else goto c7EVK;
       c7EVJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EVK: // global
           I64[Sp - 16] = block_c7EVG_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EVG() //  []
         { info_tbl: [(c7EVG,
                       label: block_c7EVG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EVG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E0N_entry() //  [R1]
         { info_tbl: [(c7EVR,
                       label: sat_s7E0N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EVR: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E17_entry() //  [R1, R2]
         { info_tbl: [(c7EW7,
                       label: sat_s7E17_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EW7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EW8; else goto c7EW9;
       c7EW8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EW9: // global
           I64[Sp - 16] = block_c7EW5_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EW5() //  []
         { info_tbl: [(c7EW5,
                       label: block_c7EW5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EW5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E11_entry() //  [R1]
         { info_tbl: [(c7EWg,
                       label: sat_s7E11_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWg: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1e_entry() //  [R1]
         { info_tbl: [(c7EWn,
                       label: sat_s7E1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWn: // global
           _s7E1e::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7EWo; else goto c7EWp;
       c7EWp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7EWr; else goto c7EWq;
       c7EWr: // global
           HpAlloc = 32;
           goto c7EWo;
       c7EWo: // global
           R1 = _s7E1e::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7EWq: // global
           _s7E0G::P64 = P64[_s7E1e::P64 + 7];
           _s7E0H::P64 = P64[_s7E1e::P64 + 15];
           I64[Hp - 24] = sat_s7E17_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E11_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp - 16] = block_c7EWj_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           P64[Sp - 8] = _s7E0H::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EWj() //  [R1]
         { info_tbl: [(c7EWj,
                       label: block_c7EWj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWj: // global
           I64[Sp] = block_c7EWl_info;
           _s7E1a::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1a::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EWl() //  []
         { info_tbl: [(c7EWl,
                       label: block_c7EWl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1l_entry() //  [R1, R2]
         { info_tbl: [(c7EWC,
                       label: sat_s7E1l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EWD; else goto c7EWE;
       c7EWD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EWE: // global
           I64[Sp - 16] = block_c7EWA_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EWA() //  []
         { info_tbl: [(c7EWA,
                       label: block_c7EWA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1f_entry() //  [R1]
         { info_tbl: [(c7EWL,
                       label: sat_s7E1f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWL: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.finally1_entry() //  [R2, R3]
         { info_tbl: [(c7EWS,
                       label: GHC.IO.finally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7EWT; else goto c7EWU;
       c7EWT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.finally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7EWU: // global
           I64[Sp - 24] = block_c7EVx_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EVx() //  [R1]
         { info_tbl: [(c7EVx,
                       label: block_c7EVx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EVx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7EWX; else goto c7EWW;
       c7EWX: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EWW: // global
           _s7E0G::P64 = P64[Sp + 8];
           _s7E0H::P64 = P64[Sp + 16];
           if (R1 == 0) goto c7EWQ; else goto u7EXa;
       c7EWQ: // global
           I64[Hp - 24] = sat_s7E1e_info;
           P64[Hp - 16] = _s7E0G::P64;
           P64[Hp - 8] = _s7E0H::P64;
           _c7EVV::P64 = Hp - 23;
           Hp = Hp - 8;
           R1 = _c7EVV::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7EXa: // global
           if (R1 == 1) goto c7EWR; else goto c7EWP;
       c7EWR: // global
           I64[Hp - 24] = sat_s7E1l_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E1f_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7EX4_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       c7EWP: // global
           I64[Hp - 24] = sat_s7E0T_info;
           P64[Hp - 16] = _s7E0H::P64;
           I64[Hp - 8] = sat_s7E0N_info;
           P64[Hp] = _s7E0G::P64;
           I64[Sp + 8] = block_c7EWY_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EX4() //  [R1]
         { info_tbl: [(c7EX4,
                       label: block_c7EX4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EX4: // global
           I64[Sp] = block_c7EX6_info;
           _s7E1o::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E1o::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EX6() //  []
         { info_tbl: [(c7EX6,
                       label: block_c7EX6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EX6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EWY() //  [R1]
         { info_tbl: [(c7EWY,
                       label: block_c7EWY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EWY: // global
           I64[Sp] = block_c7EX0_info;
           _s7E0W::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7E0W::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EX0() //  []
         { info_tbl: [(c7EX0,
                       label: block_c7EX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EX0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.728724399 UTC

[section ""data" . GHC.IO.finally_closure" {
     GHC.IO.finally_closure:
         const GHC.IO.finally_info;
 },
 GHC.IO.finally_entry() //  [R2, R3]
         { info_tbl: [(c7EYg,
                       label: GHC.IO.finally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYg: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.finally1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.732620376 UTC

[section ""data" . GHC.IO.uninterruptibleMask1_closure" {
     GHC.IO.uninterruptibleMask1_closure:
         const GHC.IO.uninterruptibleMask1_info;
 },
 sat_s7E1y_entry() //  [R2]
         { info_tbl: [(c7EYA,
                       label: sat_s7E1y_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYA: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1A_entry() //  [R2]
         { info_tbl: [(c7EYJ,
                       label: sat_s7E1A_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYJ: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7E1C_entry() //  [R2]
         { info_tbl: [(c7EYS,
                       label: sat_s7E1C_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYS: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.uninterruptibleMask1_entry() //  [R2]
         { info_tbl: [(c7EYZ,
                       label: GHC.IO.uninterruptibleMask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EZ0; else goto c7EZ1;
       c7EZ0: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EZ1: // global
           I64[Sp - 16] = block_c7EYr_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EYr() //  [R1]
         { info_tbl: [(c7EYr,
                       label: block_c7EYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EYr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7EZ4; else goto c7EZ3;
       c7EZ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7EZ3: // global
           _s7E1s::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7EYX; else goto u7EZb;
       c7EYX: // global
           I64[Hp - 8] = sat_s7E1A_info;
           I64[Sp + 8] = block_c7EZ8_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7EZb: // global
           if (R1 == 1) goto c7EYY; else goto c7EYW;
       c7EYY: // global
           I64[Hp - 8] = sat_s7E1C_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7EYW: // global
           I64[Hp - 8] = sat_s7E1y_info;
           I64[Sp + 8] = block_c7EZ5_info;
           R2 = Hp - 6;
           R1 = _s7E1s::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7EZ8() //  [R1]
         { info_tbl: [(c7EZ8,
                       label: block_c7EZ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EZ8: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7EZ5() //  [R1]
         { info_tbl: [(c7EZ5,
                       label: block_c7EZ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EZ5: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.746063476 UTC

[section ""data" . GHC.IO.uninterruptibleMask_closure" {
     GHC.IO.uninterruptibleMask_closure:
         const GHC.IO.uninterruptibleMask_info;
 },
 GHC.IO.uninterruptibleMask_entry() //  [R2]
         { info_tbl: [(c7EZD,
                       label: GHC.IO.uninterruptibleMask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EZD: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.75006386 UTC

[section ""data" . GHC.IO.uninterruptibleMask_1_closure" {
     GHC.IO.uninterruptibleMask_1_closure:
         const GHC.IO.uninterruptibleMask_1_info;
 },
 GHC.IO.uninterruptibleMask_1_entry() //  [R2]
         { info_tbl: [(c7EZU,
                       label: GHC.IO.uninterruptibleMask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EZU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7EZV; else goto c7EZW;
       c7EZV: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7EZW: // global
           I64[Sp - 16] = block_c7EZO_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7EZO() //  [R1]
         { info_tbl: [(c7EZO,
                       label: block_c7EZO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7EZO: // global
           _s7E1D::P64 = P64[Sp + 8];
           if (R1 == 1) goto c7EZT; else goto c7EZS;
       c7EZT: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7EZS: // global
           R1 = _s7E1D::P64;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.755202557 UTC

[section ""data" . GHC.IO.uninterruptibleMask__closure" {
     GHC.IO.uninterruptibleMask__closure:
         const GHC.IO.uninterruptibleMask__info;
 },
 GHC.IO.uninterruptibleMask__entry() //  [R2]
         { info_tbl: [(c7F0a,
                       label: GHC.IO.uninterruptibleMask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F0a: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.758356254 UTC

[section ""data" . GHC.IO.evaluate1_closure" {
     GHC.IO.evaluate1_closure:
         const GHC.IO.evaluate1_info;
 },
 GHC.IO.evaluate1_entry() //  [R2]
         { info_tbl: [(c7F0l,
                       label: GHC.IO.evaluate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F0l: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.76160367 UTC

[section ""data" . GHC.IO.evaluate_closure" {
     GHC.IO.evaluate_closure:
         const GHC.IO.evaluate_info;
 },
 GHC.IO.evaluate_entry() //  [R2]
         { info_tbl: [(c7F0w,
                       label: GHC.IO.evaluate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F0w: // global
           R2 = R2;
           call GHC.IO.evaluate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.7646604 UTC

[section ""cstring" . GHC.IO.$trModule4_bytes" {
     GHC.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.766283119 UTC

[section ""data" . GHC.IO.$trModule3_closure" {
     GHC.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.767955486 UTC

[section ""cstring" . GHC.IO.$trModule2_bytes" {
     GHC.IO.$trModule2_bytes:
         I8[] [71,72,67,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.769604791 UTC

[section ""data" . GHC.IO.$trModule1_closure" {
     GHC.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.771249205 UTC

[section ""data" . GHC.IO.$trModule_closure" {
     GHC.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.$trModule3_closure+1;
         const GHC.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.772942025 UTC

[section ""cstring" . GHC.IO.$tcMaskingState2_bytes" {
     GHC.IO.$tcMaskingState2_bytes:
         I8[] [77,97,115,107,105,110,103,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.775055613 UTC

[section ""data" . GHC.IO.$tcMaskingState1_closure" {
     GHC.IO.$tcMaskingState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tcMaskingState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.777229382 UTC

[section ""data" . GHC.IO.$tcMaskingState_closure" {
     GHC.IO.$tcMaskingState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tcMaskingState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1377527551354837803;
         const 7593236071496752895;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.779000029 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible1_closure" {
     GHC.IO.$tc'MaskedInterruptible1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.$tcMaskingState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.780720321 UTC

[section ""cstring" . GHC.IO.$tc'Unmasked2_bytes" {
     GHC.IO.$tc'Unmasked2_bytes:
         I8[] [39,85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.782371904 UTC

[section ""data" . GHC.IO.$tc'Unmasked1_closure" {
     GHC.IO.$tc'Unmasked1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'Unmasked2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.784078524 UTC

[section ""data" . GHC.IO.$tc'Unmasked_closure" {
     GHC.IO.$tc'Unmasked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'Unmasked1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 16923189221218057084;
         const 12178290748160137861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.785857134 UTC

[section ""cstring" . GHC.IO.$tc'MaskedInterruptible3_bytes" {
     GHC.IO.$tc'MaskedInterruptible3_bytes:
         I8[] [39,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.787515084 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible2_closure" {
     GHC.IO.$tc'MaskedInterruptible2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedInterruptible3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.789302339 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible_closure" {
     GHC.IO.$tc'MaskedInterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedInterruptible2_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 8247192854047081576;
         const 3389631131447074398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.791091512 UTC

[section ""cstring" . GHC.IO.$tc'MaskedUninterruptible2_bytes" {
     GHC.IO.$tc'MaskedUninterruptible2_bytes:
         I8[] [39,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.792693825 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible1_closure" {
     GHC.IO.$tc'MaskedUninterruptible1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedUninterruptible2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.794333066 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible_closure" {
     GHC.IO.$tc'MaskedUninterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedUninterruptible1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 10964471758180118067;
         const 9988357998868476725;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.796107253 UTC

[section ""data" . GHC.IO.Unmasked_closure" {
     GHC.IO.Unmasked_closure:
         const GHC.IO.Unmasked_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.79846089 UTC

[section ""data" . GHC.IO.MaskedInterruptible_closure" {
     GHC.IO.MaskedInterruptible_closure:
         const GHC.IO.MaskedInterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.800043885 UTC

[section ""data" . GHC.IO.MaskedUninterruptible_closure" {
     GHC.IO.MaskedUninterruptible_closure:
         const GHC.IO.MaskedUninterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.802184591 UTC

[section ""relreadonly" . GHC.IO.MaskingState_closure_tbl" {
     GHC.IO.MaskingState_closure_tbl:
         const GHC.IO.Unmasked_closure+1;
         const GHC.IO.MaskedInterruptible_closure+2;
         const GHC.IO.MaskedUninterruptible_closure+3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.803914489 UTC

[GHC.IO.Unmasked_con_entry() //  [R1]
         { info_tbl: [(c7F0Z,
                       label: GHC.IO.Unmasked_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,85,110,109,97,115,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F0Z: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.807181736 UTC

[GHC.IO.MaskedInterruptible_con_entry() //  [R1]
         { info_tbl: [(c7F15,
                       label: GHC.IO.MaskedInterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F15: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.810293864 UTC

[GHC.IO.MaskedUninterruptible_con_entry() //  [R1]
         { info_tbl: [(c7F1b,
                       label: GHC.IO.MaskedUninterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F1b: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:47.813290599 UTC

[section ""relreadonly" . S7E2C_srt" {
     S7E2C_srt:
         const GHC.IO.$w$cshowsPrec_closure;
         const GHC.IO.$fShowMaskingState1_closure;
         const GHC.IO.$fShowMaskingState3_closure;
         const GHC.IO.$fShowMaskingState5_closure;
         const GHC.IO.$fShowMaskingState_$cshow_closure;
         const GHC.IO.Exception.userError_closure;
         const GHC.IO.Exception.$fxExceptionIOException_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.mplusIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.680891821 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:48.682044765 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState6_bytes" {
     GHC.IO.$fShowMaskingState6_bytes:
         I8[] [85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.684243635 UTC

[section ""data" . GHC.IO.$fShowMaskingState5_closure" {
     GHC.IO.$fShowMaskingState5_closure:
         const GHC.IO.$fShowMaskingState5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState5_entry() //  [R1]
         { info_tbl: [(c7F5k,
                       label: GHC.IO.$fShowMaskingState5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F5k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F5l; else goto c7F5m;
       c7F5l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7F5m: // global
           (_c7F5h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7F5h::I64 == 0) goto c7F5j; else goto c7F5i;
       c7F5j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7F5i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7F5h::I64;
           R2 = GHC.IO.$fShowMaskingState6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.68874664 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState4_bytes" {
     GHC.IO.$fShowMaskingState4_bytes:
         I8[] [77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.690898211 UTC

[section ""data" . GHC.IO.$fShowMaskingState3_closure" {
     GHC.IO.$fShowMaskingState3_closure:
         const GHC.IO.$fShowMaskingState3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState3_entry() //  [R1]
         { info_tbl: [(c7F5C,
                       label: GHC.IO.$fShowMaskingState3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F5D; else goto c7F5E;
       c7F5D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7F5E: // global
           (_c7F5z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7F5z::I64 == 0) goto c7F5B; else goto c7F5A;
       c7F5B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7F5A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7F5z::I64;
           R2 = GHC.IO.$fShowMaskingState4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.696853789 UTC

[section ""cstring" . GHC.IO.$fShowMaskingState2_bytes" {
     GHC.IO.$fShowMaskingState2_bytes:
         I8[] [77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.698837899 UTC

[section ""data" . GHC.IO.$fShowMaskingState1_closure" {
     GHC.IO.$fShowMaskingState1_closure:
         const GHC.IO.$fShowMaskingState1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.IO.$fShowMaskingState1_entry() //  [R1]
         { info_tbl: [(c7F5U,
                       label: GHC.IO.$fShowMaskingState1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F5U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F5V; else goto c7F5W;
       c7F5V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7F5W: // global
           (_c7F5R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7F5R::I64 == 0) goto c7F5T; else goto c7F5S;
       c7F5T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7F5S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7F5R::I64;
           R2 = GHC.IO.$fShowMaskingState2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.703225619 UTC

[section ""data" . GHC.IO.$w$cshowsPrec_closure" {
     GHC.IO.$w$cshowsPrec_closure:
         const GHC.IO.$w$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c7F6h,
                       label: GHC.IO.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F6h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F6i; else goto c7F6j;
       c7F6i: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7F6j: // global
           I64[Sp - 16] = block_c7F69_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7F6u; else goto c7F6a;
       u7F6u: // global
           call _c7F69(R1) args: 0, res: 0, upd: 0;
       c7F6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F69() //  [R1]
         { info_tbl: [(c7F69,
                       label: block_c7F69_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F69: // global
           _s7F1j::P64 = P64[Sp + 8];
           _c7F6g::P64 = R1 & 7;
           if (_c7F6g::P64 < 3) goto u7F6t; else goto c7F6f;
       u7F6t: // global
           if (_c7F6g::P64 < 2) goto c7F6d; else goto c7F6e;
       c7F6d: // global
           R3 = _s7F1j::P64;
           R2 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7F6e: // global
           R3 = _s7F1j::P64;
           R2 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c7F6f: // global
           R3 = _s7F1j::P64;
           R2 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.709174915 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowsPrec_closure" {
     GHC.IO.$fShowMaskingState_$cshowsPrec_closure:
         const GHC.IO.$fShowMaskingState_$cshowsPrec_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c7F6L,
                       label: GHC.IO.$fShowMaskingState_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F6L: // global
           _s7F1m::P64 = R3;
           R3 = R4;
           R2 = _s7F1m::P64;
           call GHC.IO.$w$cshowsPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.712777462 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshow_closure" {
     GHC.IO.$fShowMaskingState_$cshow_closure:
         const GHC.IO.$fShowMaskingState_$cshow_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshow_entry() //  [R2]
         { info_tbl: [(c7F74,
                       label: GHC.IO.$fShowMaskingState_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F74: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7F75; else goto c7F76;
       c7F75: // global
           R2 = R2;
           R1 = GHC.IO.$fShowMaskingState_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7F76: // global
           I64[Sp - 8] = block_c7F6W_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u7F7h; else goto c7F6X;
       u7F7h: // global
           call _c7F6W(R1) args: 0, res: 0, upd: 0;
       c7F6X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F6W() //  [R1]
         { info_tbl: [(c7F6W,
                       label: block_c7F6W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F6W: // global
           _c7F73::P64 = R1 & 7;
           if (_c7F73::P64 < 3) goto u7F7g; else goto c7F72;
       u7F7g: // global
           if (_c7F73::P64 < 2) goto c7F70; else goto c7F71;
       c7F70: // global
           R1 = GHC.IO.$fShowMaskingState5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7F71: // global
           R1 = GHC.IO.$fShowMaskingState3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c7F72: // global
           R1 = GHC.IO.$fShowMaskingState1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.718684542 UTC

[section ""data" . GHC.IO.$fShowMaskingState_$cshowList_closure" {
     GHC.IO.$fShowMaskingState_$cshowList_closure:
         const GHC.IO.$fShowMaskingState_$cshowList_info;
         const 0;
 },
 GHC.IO.$fShowMaskingState_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c7F7A,
                       label: GHC.IO.$fShowMaskingState_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F7A: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.IO.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.722043299 UTC

[section ""data" . GHC.IO.$fShowMaskingState_closure" {
     GHC.IO.$fShowMaskingState_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.IO.$fShowMaskingState_$cshowsPrec_closure+3;
         const GHC.IO.$fShowMaskingState_$cshow_closure+1;
         const GHC.IO.$fShowMaskingState_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.724527034 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c==_closure" {
     GHC.IO.$fEqMaskingState_$c==_closure:
         const GHC.IO.$fEqMaskingState_$c==_info;
 },
 GHC.IO.$fEqMaskingState_$c==_entry() //  [R2, R3]
         { info_tbl: [(c7F7U,
                       label: GHC.IO.$fEqMaskingState_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F7U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F7V; else goto c7F7W;
       c7F7V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7F7W: // global
           I64[Sp - 16] = block_c7F7M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7F8T; else goto c7F7N;
       u7F8T: // global
           call _c7F7M(R1) args: 0, res: 0, upd: 0;
       c7F7N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F7M() //  [R1]
         { info_tbl: [(c7F7M,
                       label: block_c7F7M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F7M: // global
           _s7F1t::P64 = P64[Sp + 8];
           _c7F7T::P64 = R1 & 7;
           if (_c7F7T::P64 < 3) goto u7F8J; else goto c7F7S;
       u7F8J: // global
           if (_c7F7T::P64 < 2) goto c7F7Q; else goto c7F7R;
       c7F7Q: // global
           I64[Sp + 8] = block_c7F7Z_info;
           R1 = _s7F1t::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7F8Q; else goto c7F81;
       u7F8Q: // global
           call _c7F7Z(R1) args: 0, res: 0, upd: 0;
       c7F81: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7F7R: // global
           I64[Sp + 8] = block_c7F8e_info;
           R1 = _s7F1t::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7F8R; else goto c7F8g;
       u7F8R: // global
           call _c7F8e(R1) args: 0, res: 0, upd: 0;
       c7F8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7F7S: // global
           I64[Sp + 8] = block_c7F8t_info;
           R1 = _s7F1t::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7F8S; else goto c7F8v;
       u7F8S: // global
           call _c7F8t(R1) args: 0, res: 0, upd: 0;
       c7F8v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F7Z() //  [R1]
         { info_tbl: [(c7F7Z,
                       label: block_c7F7Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F7Z: // global
           if (R1 & 7 == 1) goto u7F8K; else goto u7F8L;
       u7F8K: // global
           Sp = Sp + 8;
           call _c7F8F() args: 0, res: 0, upd: 0;
       u7F8L: // global
           Sp = Sp + 8;
           call _c7F8B() args: 0, res: 0, upd: 0;
     }
 },
 _c7F8e() //  [R1]
         { info_tbl: [(c7F8e,
                       label: block_c7F8e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F8e: // global
           if (R1 & 7 == 2) goto u7F8M; else goto u7F8N;
       u7F8M: // global
           Sp = Sp + 8;
           call _c7F8F() args: 0, res: 0, upd: 0;
       u7F8N: // global
           Sp = Sp + 8;
           call _c7F8B() args: 0, res: 0, upd: 0;
     }
 },
 _c7F8t() //  [R1]
         { info_tbl: [(c7F8t,
                       label: block_c7F8t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F8t: // global
           if (R1 & 7 == 3) goto u7F8O; else goto u7F8P;
       u7F8O: // global
           Sp = Sp + 8;
           call _c7F8F() args: 0, res: 0, upd: 0;
       u7F8P: // global
           Sp = Sp + 8;
           call _c7F8B() args: 0, res: 0, upd: 0;
     }
 },
 _c7F8F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F8F: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7F8B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F8B: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.738980857 UTC

[section ""data" . GHC.IO.$fEqMaskingState_$c/=_closure" {
     GHC.IO.$fEqMaskingState_$c/=_closure:
         const GHC.IO.$fEqMaskingState_$c/=_info;
 },
 GHC.IO.$fEqMaskingState_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c7F9Q,
                       label: GHC.IO.$fEqMaskingState_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F9Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7F9R; else goto c7F9S;
       c7F9R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.$fEqMaskingState_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7F9S: // global
           I64[Sp - 16] = block_c7F9I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7FaP; else goto c7F9J;
       u7FaP: // global
           call _c7F9I(R1) args: 0, res: 0, upd: 0;
       c7F9J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F9I() //  [R1]
         { info_tbl: [(c7F9I,
                       label: block_c7F9I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F9I: // global
           _s7F1z::P64 = P64[Sp + 8];
           _c7F9P::P64 = R1 & 7;
           if (_c7F9P::P64 < 3) goto u7FaF; else goto c7F9O;
       u7FaF: // global
           if (_c7F9P::P64 < 2) goto c7F9M; else goto c7F9N;
       c7F9M: // global
           I64[Sp + 8] = block_c7F9V_info;
           R1 = _s7F1z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7FaM; else goto c7F9X;
       u7FaM: // global
           call _c7F9V(R1) args: 0, res: 0, upd: 0;
       c7F9X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7F9N: // global
           I64[Sp + 8] = block_c7Faa_info;
           R1 = _s7F1z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7FaN; else goto c7Fac;
       u7FaN: // global
           call _c7Faa(R1) args: 0, res: 0, upd: 0;
       c7Fac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c7F9O: // global
           I64[Sp + 8] = block_c7Fap_info;
           R1 = _s7F1z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u7FaO; else goto c7Far;
       u7FaO: // global
           call _c7Fap(R1) args: 0, res: 0, upd: 0;
       c7Far: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7F9V() //  [R1]
         { info_tbl: [(c7F9V,
                       label: block_c7F9V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7F9V: // global
           if (R1 & 7 == 1) goto u7FaG; else goto u7FaH;
       u7FaG: // global
           Sp = Sp + 8;
           call _c7FaB() args: 0, res: 0, upd: 0;
       u7FaH: // global
           Sp = Sp + 8;
           call _c7Fax() args: 0, res: 0, upd: 0;
     }
 },
 _c7Faa() //  [R1]
         { info_tbl: [(c7Faa,
                       label: block_c7Faa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Faa: // global
           if (R1 & 7 == 2) goto u7FaI; else goto u7FaJ;
       u7FaI: // global
           Sp = Sp + 8;
           call _c7FaB() args: 0, res: 0, upd: 0;
       u7FaJ: // global
           Sp = Sp + 8;
           call _c7Fax() args: 0, res: 0, upd: 0;
     }
 },
 _c7Fap() //  [R1]
         { info_tbl: [(c7Fap,
                       label: block_c7Fap_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fap: // global
           if (R1 & 7 == 3) goto u7FaK; else goto u7FaL;
       u7FaK: // global
           Sp = Sp + 8;
           call _c7FaB() args: 0, res: 0, upd: 0;
       u7FaL: // global
           Sp = Sp + 8;
           call _c7Fax() args: 0, res: 0, upd: 0;
     }
 },
 _c7FaB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FaB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Fax() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fax: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.751066899 UTC

[section ""data" . GHC.IO.$fEqMaskingState_closure" {
     GHC.IO.$fEqMaskingState_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.IO.$fEqMaskingState_$c==_closure+2;
         const GHC.IO.$fEqMaskingState_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.753127141 UTC

[section ""data" . GHC.IO.liftIO_closure" {
     GHC.IO.liftIO_closure:
         const GHC.IO.liftIO_info;
 },
 GHC.IO.liftIO_entry() //  [R2]
         { info_tbl: [(c7FbI,
                       label: GHC.IO.liftIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FbI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7FbJ; else goto c7FbK;
       c7FbJ: // global
           R2 = R2;
           R1 = GHC.IO.liftIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FbK: // global
           I64[Sp - 8] = block_c7FbF_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FbF() //  [R1]
         { info_tbl: [(c7FbF,
                       label: block_c7FbF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FbF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7FbN; else goto c7FbM;
       c7FbN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7FbM: // global
           I64[Hp - 8] = GHC.ST.STret_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.759214973 UTC

[section ""data" . GHC.IO.failIO1_closure" {
     GHC.IO.failIO1_closure:
         const GHC.IO.failIO1_info;
         const 0;
 },
 sat_s7F1L_entry() //  [R1]
         { info_tbl: [(c7Fcb,
                       label: sat_s7F1L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fcb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fcc; else goto c7Fcd;
       c7Fcc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Fcd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           R1 = GHC.IO.Exception.userError_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s7F1M_entry() //  [R1]
         { info_tbl: [(c7Fce,
                       label: sat_s7F1M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fce: // global
           _s7F1M::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c7Fcf; else goto c7Fcg;
       c7Fcg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Fci; else goto c7Fch;
       c7Fci: // global
           HpAlloc = 24;
           goto c7Fcf;
       c7Fcf: // global
           R1 = _s7F1M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Fch: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7F1M::P64;
           _s7F1J::P64 = P64[_s7F1M::P64 + 16];
           I64[Hp - 16] = sat_s7F1L_info;
           P64[Hp] = _s7F1J::P64;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.failIO1_entry() //  [R2]
         { info_tbl: [(c7Fcj,
                       label: GHC.IO.failIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fcj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Fcn; else goto c7Fcm;
       c7Fcn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.IO.failIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Fcm: // global
           I64[Hp - 16] = sat_s7F1M_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.767462947 UTC

[section ""data" . GHC.IO.failIO_closure" {
     GHC.IO.failIO_closure:
         const GHC.IO.failIO_info;
         const 0;
 },
 GHC.IO.failIO_entry() //  [R2]
         { info_tbl: [(c7FcK,
                       label: GHC.IO.failIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FcK: // global
           R2 = R2;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.771250372 UTC

[section ""data" . GHC.IO.stToIO1_closure" {
     GHC.IO.stToIO1_closure:
         const GHC.IO.stToIO1_info;
 },
 GHC.IO.stToIO1_entry() //  [R2]
         { info_tbl: [(c7FcV,
                       label: GHC.IO.stToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FcV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.77454387 UTC

[section ""data" . GHC.IO.stToIO_closure" {
     GHC.IO.stToIO_closure:
         const GHC.IO.stToIO_info;
 },
 GHC.IO.stToIO_entry() //  [R2]
         { info_tbl: [(c7Fd6,
                       label: GHC.IO.stToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fd6: // global
           R2 = R2;
           call GHC.IO.stToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.777725285 UTC

[section ""data" . GHC.IO.ioToST1_closure" {
     GHC.IO.ioToST1_closure:
         const GHC.IO.ioToST1_info;
 },
 GHC.IO.ioToST1_entry() //  [R2]
         { info_tbl: [(c7Fdh,
                       label: GHC.IO.ioToST1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fdh: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.780969203 UTC

[section ""data" . GHC.IO.ioToST_closure" {
     GHC.IO.ioToST_closure:
         const GHC.IO.ioToST_info;
 },
 GHC.IO.ioToST_entry() //  [R2]
         { info_tbl: [(c7Fds,
                       label: GHC.IO.ioToST_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fds: // global
           R2 = R2;
           call GHC.IO.ioToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.784258693 UTC

[section ""data" . GHC.IO.unsafeIOToST1_closure" {
     GHC.IO.unsafeIOToST1_closure:
         const GHC.IO.unsafeIOToST1_info;
 },
 GHC.IO.unsafeIOToST1_entry() //  [R2]
         { info_tbl: [(c7FdD,
                       label: GHC.IO.unsafeIOToST1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FdD: // global
           R1 = R2;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.787545193 UTC

[section ""data" . GHC.IO.unsafeIOToST_closure" {
     GHC.IO.unsafeIOToST_closure:
         const GHC.IO.unsafeIOToST_info;
 },
 GHC.IO.unsafeIOToST_entry() //  [R2]
         { info_tbl: [(c7FdO,
                       label: GHC.IO.unsafeIOToST_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FdO: // global
           R2 = R2;
           call GHC.IO.unsafeIOToST1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.790810561 UTC

[section ""data" . GHC.IO.unsafeSTToIO1_closure" {
     GHC.IO.unsafeSTToIO1_closure:
         const GHC.IO.unsafeSTToIO1_info;
 },
 GHC.IO.unsafeSTToIO1_entry() //  [R2]
         { info_tbl: [(c7FdZ,
                       label: GHC.IO.unsafeSTToIO1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FdZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.794531662 UTC

[section ""data" . GHC.IO.unsafeSTToIO_closure" {
     GHC.IO.unsafeSTToIO_closure:
         const GHC.IO.unsafeSTToIO_info;
 },
 GHC.IO.unsafeSTToIO_entry() //  [R2]
         { info_tbl: [(c7Fea,
                       label: GHC.IO.unsafeSTToIO_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fea: // global
           R2 = R2;
           call GHC.IO.unsafeSTToIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.798962389 UTC

[section ""data" . GHC.IO.catch1_closure" {
     GHC.IO.catch1_closure:
         const GHC.IO.catch1_info;
 },
 sat_s7F1Y_entry() //  [R1]
         { info_tbl: [(c7Fez,
                       label: sat_s7F1Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fez: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F20_entry() //  [R1, R2]
         { info_tbl: [(c7FeG,
                       label: sat_s7F20_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FeG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7FeH; else goto c7FeI;
       c7FeH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FeI: // global
           I64[Sp - 24] = block_c7Feq_info;
           _s7F1W::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7F1W::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7F1W::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Feq() //  [R1]
         { info_tbl: [(c7Feq,
                       label: block_c7Feq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Feq: // global
           if (R1 & 7 == 1) goto c7FeD; else goto c7FeE;
       c7FeD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7FeL; else goto c7FeK;
       c7FeL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7FeK: // global
           I64[Hp - 8] = sat_s7F1Y_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7FeE: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catch1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7FeP,
                       label: GHC.IO.catch1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FeP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7FeT; else goto c7FeS;
       c7FeT: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catch1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7FeS: // global
           I64[Hp - 16] = sat_s7F20_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.808240483 UTC

[section ""data" . GHC.IO.catch_closure" {
     GHC.IO.catch_closure:
         const GHC.IO.catch_info;
 },
 GHC.IO.catch_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ffl,
                       label: GHC.IO.catch_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ffl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catch1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.812960835 UTC

[section ""data" . GHC.IO.catchException1_closure" {
     GHC.IO.catchException1_closure:
         const GHC.IO.catchException1_info;
 },
 sat_s7F28_entry() //  [R1]
         { info_tbl: [(c7FfM,
                       label: sat_s7F28_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FfM: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F2a_entry() //  [R1, R2]
         { info_tbl: [(c7FfT,
                       label: sat_s7F2a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FfT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7FfU; else goto c7FfV;
       c7FfU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FfV: // global
           I64[Sp - 24] = block_c7FfD_info;
           _s7F26::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7F26::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s7F26::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7FfD() //  [R1]
         { info_tbl: [(c7FfD,
                       label: block_c7FfD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FfD: // global
           if (R1 & 7 == 1) goto c7FfQ; else goto c7FfR;
       c7FfQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7FfY; else goto c7FfX;
       c7FfY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7FfX: // global
           I64[Hp - 8] = sat_s7F28_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7FfR: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchException1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Fg2,
                       label: GHC.IO.catchException1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fg2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Fg3; else goto c7Fg4;
       c7Fg3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchException1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Fg4: // global
           I64[Sp - 24] = block_c7Ffw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ffw() //  [R1]
         { info_tbl: [(c7Ffw,
                       label: block_c7Ffw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ffw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Fg7; else goto c7Fg6;
       c7Fg7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fg6: // global
           I64[Hp - 16] = sat_s7F2a_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 15;
           R1 = R1;
           Sp = Sp + 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.824607796 UTC

[section ""data" . GHC.IO.catchException_closure" {
     GHC.IO.catchException_closure:
         const GHC.IO.catchException_info;
 },
 GHC.IO.catchException_entry() //  [R2, R3, R4]
         { info_tbl: [(c7FgG,
                       label: GHC.IO.catchException_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FgG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchException1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.828753025 UTC

[section ""data" . GHC.IO.mplusIO1_closure" {
     GHC.IO.mplusIO1_closure:
         const GHC.IO.mplusIO1_info;
         const 0;
 },
 sat_s7F2h_entry() //  [R1]
         { info_tbl: [(c7Fh7,
                       label: sat_s7F2h_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fh7: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F2j_entry() //  [R1, R2]
         { info_tbl: [(c7Fhe,
                       label: sat_s7F2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fhe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c7Fhf; else goto c7Fhg;
       c7Fhf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Fhg: // global
           I64[Sp - 24] = block_c7FgY_info;
           _s7F2f::P64 = R2;
           R2 = GHC.IO.Exception.$fxExceptionIOException_closure;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s7F2f::P64;
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp - 8] = _s7F2f::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7FgY() //  [R1]
         { info_tbl: [(c7FgY,
                       label: block_c7FgY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FgY: // global
           if (R1 & 7 == 1) goto c7Fhb; else goto c7Fhc;
       c7Fhb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Fhj; else goto c7Fhi;
       c7Fhj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fhi: // global
           I64[Hp - 8] = sat_s7F2h_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c7Fhc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mplusIO1_entry() //  [R2, R3]
         { info_tbl: [(c7Fhn,
                       label: GHC.IO.mplusIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fhn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fho; else goto c7Fhp;
       c7Fho: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.mplusIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Fhp: // global
           I64[Sp - 16] = block_c7FgR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FgR() //  [R1]
         { info_tbl: [(c7FgR,
                       label: block_c7FgR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FgR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Fhs; else goto c7Fhr;
       c7Fhs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fhr: // global
           I64[Hp - 8] = sat_s7F2j_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.840366062 UTC

[section ""data" . GHC.IO.mplusIO_closure" {
     GHC.IO.mplusIO_closure:
         const GHC.IO.mplusIO_info;
         const 0;
 },
 GHC.IO.mplusIO_entry() //  [R2, R3]
         { info_tbl: [(c7Fi0,
                       label: GHC.IO.mplusIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fi0: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.mplusIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.844205539 UTC

[section ""data" . GHC.IO.catchAny1_closure" {
     GHC.IO.catchAny1_closure:
         const GHC.IO.catchAny1_info;
 },
 sat_s7F2s_entry() //  [R1, R2]
         { info_tbl: [(c7Fil,
                       label: sat_s7F2s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fil: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fim; else goto c7Fin;
       c7Fim: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Fin: // global
           I64[Sp - 16] = block_c7Fii_info;
           _s7F2l::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s7F2l::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Fir; else goto c7Fij;
       u7Fir: // global
           call _c7Fii(R1) args: 0, res: 0, upd: 0;
       c7Fij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fii() //  [R1]
         { info_tbl: [(c7Fii,
                       label: block_c7Fii_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fii: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.catchAny1_entry() //  [R2, R3]
         { info_tbl: [(c7Fis,
                       label: GHC.IO.catchAny1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fit; else goto c7Fiu;
       c7Fit: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.catchAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Fiu: // global
           I64[Sp - 16] = block_c7Fib_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fib() //  [R1]
         { info_tbl: [(c7Fib,
                       label: block_c7Fib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fib: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Fix; else goto c7Fiw;
       c7Fix: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fiw: // global
           I64[Hp - 8] = sat_s7F2s_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 7;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.853802587 UTC

[section ""data" . GHC.IO.catchAny_closure" {
     GHC.IO.catchAny_closure:
         const GHC.IO.catchAny_info;
 },
 GHC.IO.catchAny_entry() //  [R2, R3]
         { info_tbl: [(c7FiW,
                       label: GHC.IO.catchAny_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FiW: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.catchAny1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.857346971 UTC

[section ""data" . GHC.IO.throwIO1_closure" {
     GHC.IO.throwIO1_closure:
         const GHC.IO.throwIO1_info;
 },
 sat_s7F2w_entry() //  [R1]
         { info_tbl: [(c7Fjb,
                       label: sat_s7F2w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fjb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Fjc; else goto c7Fjd;
       c7Fjc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Fjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.IO.throwIO1_entry() //  [R2, R3]
         { info_tbl: [(c7Fje,
                       label: GHC.IO.throwIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fje: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Fji; else goto c7Fjh;
       c7Fji: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.throwIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Fjh: // global
           I64[Hp - 24] = sat_s7F2w_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.862934037 UTC

[section ""data" . GHC.IO.throwIO_closure" {
     GHC.IO.throwIO_closure:
         const GHC.IO.throwIO_info;
 },
 GHC.IO.throwIO_entry() //  [R2, R3]
         { info_tbl: [(c7Fjz,
                       label: GHC.IO.throwIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fjz: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.throwIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.866696587 UTC

[section ""data" . GHC.IO.onException1_closure" {
     GHC.IO.onException1_closure:
         const GHC.IO.onException1_info;
 },
 sat_s7F2G_entry() //  [R1, R2]
         { info_tbl: [(c7FjT,
                       label: sat_s7F2G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FjT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FjU; else goto c7FjV;
       c7FjU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FjV: // global
           I64[Sp - 16] = block_c7FjR_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FjR() //  []
         { info_tbl: [(c7FjR,
                       label: block_c7FjR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FjR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.onException1_entry() //  [R2, R3]
         { info_tbl: [(c7FjX,
                       label: GHC.IO.onException1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FjX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FjY; else goto c7FjZ;
       c7FjY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.onException1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7FjZ: // global
           I64[Sp - 16] = block_c7FjK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FjK() //  [R1]
         { info_tbl: [(c7FjK,
                       label: block_c7FjK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FjK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7Fk2; else goto c7Fk1;
       c7Fk2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fk1: // global
           I64[Hp - 8] = sat_s7F2G_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           R1 = R1;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.876618335 UTC

[section ""data" . GHC.IO.onException_closure" {
     GHC.IO.onException_closure:
         const GHC.IO.onException_info;
 },
 GHC.IO.onException_entry() //  [R2, R3]
         { info_tbl: [(c7Fkq,
                       label: GHC.IO.onException_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fkq: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.onException1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.879925027 UTC

[section ""data" . GHC.IO.unsafeUnmask_closure" {
     GHC.IO.unsafeUnmask_closure:
         const GHC.IO.unsafeUnmask_info;
 },
 GHC.IO.unsafeUnmask_entry() //  [R2]
         { info_tbl: [(c7FkB,
                       label: GHC.IO.unsafeUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FkB: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.883584379 UTC

[section ""data" . GHC.IO.getMaskingState1_closure" {
     GHC.IO.getMaskingState1_closure:
         const GHC.IO.getMaskingState1_info;
 },
 sat_s7F2M_entry() //  [R1]
         { info_tbl: [(c7FkX,
                       label: sat_s7F2M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FkX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FkY; else goto c7FkZ;
       c7FkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7FkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s7F2L::I64 = I64[R1 + 16];
           if (_s7F2L::I64 != 0) goto u7Fl0; else goto c7FkV;
       u7Fl0: // global
           if (_s7F2L::I64 != 1) goto c7FkU; else goto c7FkW;
       c7FkU: // global
           R1 = GHC.IO.MaskedInterruptible_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7FkW: // global
           R1 = GHC.IO.MaskedUninterruptible_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c7FkV: // global
           R1 = GHC.IO.Unmasked_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.IO.getMaskingState1_entry() //  []
         { info_tbl: [(c7Fl1,
                       label: GHC.IO.getMaskingState1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fl1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c7Fl2; else goto c7Fl3;
       c7Fl2: // global
           R1 = GHC.IO.getMaskingState1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7Fl3: // global
           I64[Sp - 8] = block_c7FkM_info;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7FkM() //  [R1]
         { info_tbl: [(c7FkM,
                       label: block_c7FkM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FkM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Fl6; else goto c7Fl5;
       c7Fl6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Fl5: // global
           I64[Hp - 16] = sat_s7F2M_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.891517666 UTC

[section ""data" . GHC.IO.getMaskingState_closure" {
     GHC.IO.getMaskingState_closure:
         const GHC.IO.getMaskingState_info;
 },
 GHC.IO.getMaskingState_entry() //  []
         { info_tbl: [(c7Flu,
                       label: GHC.IO.getMaskingState_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Flu: // global
           call GHC.IO.getMaskingState1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.89498034 UTC

[section ""data" . GHC.IO.interruptible1_closure" {
     GHC.IO.interruptible1_closure:
         const GHC.IO.interruptible1_info;
 },
 GHC.IO.interruptible1_entry() //  [R2]
         { info_tbl: [(c7FlM,
                       label: GHC.IO.interruptible1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FlM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FlN; else goto c7FlO;
       c7FlN: // global
           R2 = R2;
           R1 = GHC.IO.interruptible1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FlO: // global
           I64[Sp - 16] = block_c7FlF_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7FlF() //  [R1]
         { info_tbl: [(c7FlF,
                       label: block_c7FlF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FlF: // global
           _s7F2N::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7FlL; else goto u7FlQ;
       u7FlQ: // global
           if (R1 == 1) goto c7FlL; else goto c7FlJ;
       c7FlL: // global
           R1 = _s7F2N::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7FlJ: // global
           R1 = _s7F2N::P64;
           Sp = Sp + 16;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.900343234 UTC

[section ""data" . GHC.IO.interruptible_closure" {
     GHC.IO.interruptible_closure:
         const GHC.IO.interruptible_info;
 },
 GHC.IO.interruptible_entry() //  [R2]
         { info_tbl: [(c7Fm4,
                       label: GHC.IO.interruptible_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fm4: // global
           R2 = R2;
           call GHC.IO.interruptible1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.90469595 UTC

[section ""data" . GHC.IO.mask1_closure" {
     GHC.IO.mask1_closure:
         const GHC.IO.mask1_info;
 },
 sat_s7F2Z_entry() //  [R2]
         { info_tbl: [(c7Fmo,
                       label: sat_s7F2Z_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fmo: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F30_entry() //  [R2]
         { info_tbl: [(c7Fmx,
                       label: sat_s7F30_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fmx: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F32_entry() //  [R2]
         { info_tbl: [(c7FmG,
                       label: sat_s7F32_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FmG: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.mask1_entry() //  [R2]
         { info_tbl: [(c7FmN,
                       label: GHC.IO.mask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FmN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FmO; else goto c7FmP;
       c7FmO: // global
           R2 = R2;
           R1 = GHC.IO.mask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FmP: // global
           I64[Sp - 16] = block_c7Fmf_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Fmf() //  [R1]
         { info_tbl: [(c7Fmf,
                       label: block_c7Fmf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fmf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7FmS; else goto c7FmR;
       c7FmS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7FmR: // global
           _s7F2T::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7FmL; else goto u7FmW;
       c7FmL: // global
           I64[Hp - 8] = sat_s7F30_info;
           I64[Sp + 8] = block_c7FmT_info;
           R2 = Hp - 6;
           R1 = _s7F2T::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7FmW: // global
           if (R1 == 1) goto c7FmM; else goto c7FmK;
       c7FmM: // global
           I64[Hp - 8] = sat_s7F32_info;
           R2 = Hp - 6;
           R1 = _s7F2T::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7FmK: // global
           I64[Hp - 8] = sat_s7F2Z_info;
           R2 = Hp - 6;
           R1 = _s7F2T::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7FmT() //  [R1]
         { info_tbl: [(c7FmT,
                       label: block_c7FmT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FmT: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.916277898 UTC

[section ""data" . GHC.IO.mask_closure" {
     GHC.IO.mask_closure:
         const GHC.IO.mask_info;
 },
 GHC.IO.mask_entry() //  [R2]
         { info_tbl: [(c7Fnq,
                       label: GHC.IO.mask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fnq: // global
           R2 = R2;
           call GHC.IO.mask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.920117746 UTC

[section ""data" . GHC.IO.mask_1_closure" {
     GHC.IO.mask_1_closure:
         const GHC.IO.mask_1_info;
 },
 GHC.IO.mask_1_entry() //  [R2]
         { info_tbl: [(c7FnH,
                       label: GHC.IO.mask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FnH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FnI; else goto c7FnJ;
       c7FnI: // global
           R2 = R2;
           R1 = GHC.IO.mask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FnJ: // global
           I64[Sp - 16] = block_c7FnB_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7FnB() //  [R1]
         { info_tbl: [(c7FnB,
                       label: block_c7FnB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FnB: // global
           _s7F33::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7FnG; else goto c7FnF;
       c7FnG: // global
           R1 = _s7F33::P64;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c7FnF: // global
           R1 = _s7F33::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.925413637 UTC

[section ""data" . GHC.IO.mask__closure" {
     GHC.IO.mask__closure:
         const GHC.IO.mask__info;
 },
 GHC.IO.mask__entry() //  [R2]
         { info_tbl: [(c7FnY,
                       label: GHC.IO.mask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FnY: // global
           R2 = R2;
           call GHC.IO.mask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.931258961 UTC

[section ""data" . GHC.IO.bracket1_closure" {
     GHC.IO.bracket1_closure:
         const GHC.IO.bracket1_info;
 },
 sat_s7F3r_entry() //  [R1, R2]
         { info_tbl: [(c7Fom,
                       label: sat_s7F3r_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fon; else goto c7Foo;
       c7Fon: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Foo: // global
           I64[Sp - 16] = block_c7Fok_info;
           _s7F3m::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7F3m::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fok() //  []
         { info_tbl: [(c7Fok,
                       label: block_c7Fok_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fok: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F3l_entry() //  [R1]
         { info_tbl: [(c7Fow,
                       label: sat_s7F3l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fow: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F3J_entry() //  [R1, R2]
         { info_tbl: [(c7FoO,
                       label: sat_s7F3J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FoO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FoP; else goto c7FoQ;
       c7FoP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FoQ: // global
           I64[Sp - 16] = block_c7FoM_info;
           _s7F3E::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7F3E::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FoM() //  []
         { info_tbl: [(c7FoM,
                       label: block_c7FoM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FoM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F3D_entry() //  [R1]
         { info_tbl: [(c7FoY,
                       label: sat_s7F3D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FoY: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F3Q_entry() //  [R1]
         { info_tbl: [(c7Fp5,
                       label: sat_s7F3Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fp5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Fp6; else goto c7Fp7;
       c7Fp6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7Fp7: // global
           I64[Sp - 24] = block_c7FoF_info;
           _s7F3a::P64 = P64[R1 + 15];
           _s7F3b::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s7F3a::P64;
           P64[Sp - 8] = _s7F3b::P64;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FoF() //  [R1]
         { info_tbl: [(c7FoF,
                       label: block_c7FoF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FoF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7Fpa; else goto c7Fp9;
       c7Fpa: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Fp9: // global
           I64[Hp - 64] = sat_s7F3J_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7F3D_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7Fp1_info;
           R2 = Hp - 62;
           _s7F3B::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7F3B::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fp1() //  [R1]
         { info_tbl: [(c7Fp1,
                       label: block_c7Fp1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fp1: // global
           _s7F3a::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7Fp3_info;
           R2 = P64[Sp + 16];
           _s7F3M::P64 = R1;
           R1 = _s7F3a::P64;
           P64[Sp + 16] = _s7F3M::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fp3() //  []
         { info_tbl: [(c7Fp3,
                       label: block_c7Fp3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fp3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F41_entry() //  [R1, R2]
         { info_tbl: [(c7Fpn,
                       label: sat_s7F41_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fpn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fpo; else goto c7Fpp;
       c7Fpo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Fpp: // global
           I64[Sp - 16] = block_c7Fpl_info;
           _s7F3W::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _s7F3W::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fpl() //  []
         { info_tbl: [(c7Fpl,
                       label: block_c7Fpl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fpl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F3V_entry() //  [R1]
         { info_tbl: [(c7Fpx,
                       label: sat_s7F3V_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fpx: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.bracket1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7FpE,
                       label: GHC.IO.bracket1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FpE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7FpF; else goto c7FpG;
       c7FpF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.bracket1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7FpG: // global
           I64[Sp - 32] = block_c7Fo9_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Fo9() //  [R1]
         { info_tbl: [(c7Fo9,
                       label: block_c7Fo9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fo9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7FpJ; else goto c7FpI;
       c7FpJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7FpI: // global
           _s7F39::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7FpC; else goto u7Fq2;
       c7FpC: // global
           I64[Hp - 24] = sat_s7F3Q_info;
           P64[Hp - 16] = _s7F39::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7Fq2: // global
           if (R1 == 1) goto c7FpD; else goto c7FpB;
       c7FpD: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7Fpe_info;
           R1 = _s7F39::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c7FpB: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_c7Fod_info;
           R1 = _s7F39::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fpe() //  [R1]
         { info_tbl: [(c7Fpe,
                       label: block_c7Fpe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fpe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7FpY; else goto c7FpX;
       c7FpY: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7FpX: // global
           I64[Hp - 64] = sat_s7F41_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7F3V_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7FpT_info;
           R2 = Hp - 62;
           _s7F3T::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7F3T::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FpT() //  [R1]
         { info_tbl: [(c7FpT,
                       label: block_c7FpT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FpT: // global
           _s7F3a::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7FpV_info;
           R2 = P64[Sp + 16];
           _s7F44::P64 = R1;
           R1 = _s7F3a::P64;
           P64[Sp + 16] = _s7F44::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FpV() //  []
         { info_tbl: [(c7FpV,
                       label: block_c7FpV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FpV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Fod() //  [R1]
         { info_tbl: [(c7Fod,
                       label: block_c7Fod_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fod: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c7FpP; else goto c7FpO;
       c7FpP: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7FpO: // global
           I64[Hp - 64] = sat_s7F3r_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s7F3l_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c7FpK_info;
           R2 = Hp - 62;
           _s7F3j::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s7F3j::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FpK() //  [R1]
         { info_tbl: [(c7FpK,
                       label: block_c7FpK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FpK: // global
           _s7F3a::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c7FpM_info;
           R2 = P64[Sp + 16];
           _s7F3u::P64 = R1;
           R1 = _s7F3a::P64;
           P64[Sp + 16] = _s7F3u::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FpM() //  []
         { info_tbl: [(c7FpM,
                       label: block_c7FpM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FpM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.969965017 UTC

[section ""data" . GHC.IO.bracket_closure" {
     GHC.IO.bracket_closure:
         const GHC.IO.bracket_info;
 },
 GHC.IO.bracket_entry() //  [R2, R3, R4]
         { info_tbl: [(c7FrP,
                       label: GHC.IO.bracket_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FrP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:48.974766448 UTC

[section ""data" . GHC.IO.finally1_closure" {
     GHC.IO.finally1_closure:
         const GHC.IO.finally1_info;
 },
 sat_s7F4l_entry() //  [R1, R2]
         { info_tbl: [(c7Fsb,
                       label: sat_s7F4l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fsb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Fsc; else goto c7Fsd;
       c7Fsc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Fsd: // global
           I64[Sp - 16] = block_c7Fs9_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fs9() //  []
         { info_tbl: [(c7Fs9,
                       label: block_c7Fs9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fs9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4f_entry() //  [R1]
         { info_tbl: [(c7Fsk,
                       label: sat_s7F4f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fsk: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4z_entry() //  [R1, R2]
         { info_tbl: [(c7FsA,
                       label: sat_s7F4z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FsA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FsB; else goto c7FsC;
       c7FsB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FsC: // global
           I64[Sp - 16] = block_c7Fsy_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Fsy() //  []
         { info_tbl: [(c7Fsy,
                       label: block_c7Fsy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fsy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4t_entry() //  [R1]
         { info_tbl: [(c7FsJ,
                       label: sat_s7F4t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FsJ: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4G_entry() //  [R1]
         { info_tbl: [(c7FsQ,
                       label: sat_s7F4G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FsQ: // global
           _s7F4G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c7FsR; else goto c7FsS;
       c7FsS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7FsU; else goto c7FsT;
       c7FsU: // global
           HpAlloc = 32;
           goto c7FsR;
       c7FsR: // global
           R1 = _s7F4G::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c7FsT: // global
           _s7F48::P64 = P64[_s7F4G::P64 + 7];
           _s7F49::P64 = P64[_s7F4G::P64 + 15];
           I64[Hp - 24] = sat_s7F4z_info;
           P64[Hp - 16] = _s7F49::P64;
           I64[Hp - 8] = sat_s7F4t_info;
           P64[Hp] = _s7F48::P64;
           I64[Sp - 16] = block_c7FsM_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           P64[Sp - 8] = _s7F49::P64;
           Sp = Sp - 16;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FsM() //  [R1]
         { info_tbl: [(c7FsM,
                       label: block_c7FsM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FsM: // global
           I64[Sp] = block_c7FsO_info;
           _s7F4C::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7F4C::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FsO() //  []
         { info_tbl: [(c7FsO,
                       label: block_c7FsO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FsO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4N_entry() //  [R1, R2]
         { info_tbl: [(c7Ft5,
                       label: sat_s7F4N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ft5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ft6; else goto c7Ft7;
       c7Ft6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Ft7: // global
           I64[Sp - 16] = block_c7Ft3_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ft3() //  []
         { info_tbl: [(c7Ft3,
                       label: block_c7Ft3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ft3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F4H_entry() //  [R1]
         { info_tbl: [(c7Fte,
                       label: sat_s7F4H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fte: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.finally1_entry() //  [R2, R3]
         { info_tbl: [(c7Ftl,
                       label: GHC.IO.finally1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ftl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Ftm; else goto c7Ftn;
       c7Ftm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.IO.finally1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ftn: // global
           I64[Sp - 24] = block_c7Fs0_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Fs0() //  [R1]
         { info_tbl: [(c7Fs0,
                       label: block_c7Fs0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fs0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c7Ftq; else goto c7Ftp;
       c7Ftq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7Ftp: // global
           _s7F48::P64 = P64[Sp + 8];
           _s7F49::P64 = P64[Sp + 16];
           if (R1 == 0) goto c7Ftj; else goto u7FtD;
       c7Ftj: // global
           I64[Hp - 24] = sat_s7F4G_info;
           P64[Hp - 16] = _s7F48::P64;
           P64[Hp - 8] = _s7F49::P64;
           _c7Fso::P64 = Hp - 23;
           Hp = Hp - 8;
           R1 = _c7Fso::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u7FtD: // global
           if (R1 == 1) goto c7Ftk; else goto c7Fti;
       c7Ftk: // global
           I64[Hp - 24] = sat_s7F4N_info;
           P64[Hp - 16] = _s7F49::P64;
           I64[Hp - 8] = sat_s7F4H_info;
           P64[Hp] = _s7F48::P64;
           I64[Sp + 8] = block_c7Ftx_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
       c7Fti: // global
           I64[Hp - 24] = sat_s7F4l_info;
           P64[Hp - 16] = _s7F49::P64;
           I64[Hp - 8] = sat_s7F4f_info;
           P64[Hp] = _s7F48::P64;
           I64[Sp + 8] = block_c7Ftr_info;
           R2 = Hp - 22;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ftx() //  [R1]
         { info_tbl: [(c7Ftx,
                       label: block_c7Ftx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ftx: // global
           I64[Sp] = block_c7Ftz_info;
           _s7F4Q::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7F4Q::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ftz() //  []
         { info_tbl: [(c7Ftz,
                       label: block_c7Ftz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ftz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Ftr() //  [R1]
         { info_tbl: [(c7Ftr,
                       label: block_c7Ftr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ftr: // global
           I64[Sp] = block_c7Ftt_info;
           _s7F4o::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7F4o::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ftt() //  []
         { info_tbl: [(c7Ftt,
                       label: block_c7Ftt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ftt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.006313462 UTC

[section ""data" . GHC.IO.finally_closure" {
     GHC.IO.finally_closure:
         const GHC.IO.finally_info;
 },
 GHC.IO.finally_entry() //  [R2, R3]
         { info_tbl: [(c7Fv0,
                       label: GHC.IO.finally_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fv0: // global
           R3 = R3;
           R2 = R2;
           call GHC.IO.finally1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.010732212 UTC

[section ""data" . GHC.IO.uninterruptibleMask1_closure" {
     GHC.IO.uninterruptibleMask1_closure:
         const GHC.IO.uninterruptibleMask1_info;
 },
 sat_s7F50_entry() //  [R2]
         { info_tbl: [(c7Fvk,
                       label: sat_s7F50_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fvk: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F52_entry() //  [R2]
         { info_tbl: [(c7Fvt,
                       label: sat_s7F52_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fvt: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s7F54_entry() //  [R2]
         { info_tbl: [(c7FvC,
                       label: sat_s7F54_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FvC: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.IO.uninterruptibleMask1_entry() //  [R2]
         { info_tbl: [(c7FvJ,
                       label: GHC.IO.uninterruptibleMask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FvK; else goto c7FvL;
       c7FvK: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FvL: // global
           I64[Sp - 16] = block_c7Fvb_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7Fvb() //  [R1]
         { info_tbl: [(c7Fvb,
                       label: block_c7Fvb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fvb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c7FvO; else goto c7FvN;
       c7FvO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c7FvN: // global
           _s7F4U::P64 = P64[Sp + 8];
           if (R1 == 0) goto c7FvH; else goto u7FvV;
       c7FvH: // global
           I64[Hp - 8] = sat_s7F52_info;
           I64[Sp + 8] = block_c7FvS_info;
           R2 = Hp - 6;
           R1 = _s7F4U::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
       u7FvV: // global
           if (R1 == 1) goto c7FvI; else goto c7FvG;
       c7FvI: // global
           I64[Hp - 8] = sat_s7F54_info;
           R2 = Hp - 6;
           R1 = _s7F4U::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       c7FvG: // global
           I64[Hp - 8] = sat_s7F50_info;
           I64[Sp + 8] = block_c7FvP_info;
           R2 = Hp - 6;
           R1 = _s7F4U::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7FvS() //  [R1]
         { info_tbl: [(c7FvS,
                       label: block_c7FvS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FvS: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7FvP() //  [R1]
         { info_tbl: [(c7FvP,
                       label: block_c7FvP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FvP: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.023953177 UTC

[section ""data" . GHC.IO.uninterruptibleMask_closure" {
     GHC.IO.uninterruptibleMask_closure:
         const GHC.IO.uninterruptibleMask_info;
 },
 GHC.IO.uninterruptibleMask_entry() //  [R2]
         { info_tbl: [(c7Fwt,
                       label: GHC.IO.uninterruptibleMask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fwt: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.027325961 UTC

[section ""data" . GHC.IO.uninterruptibleMask_1_closure" {
     GHC.IO.uninterruptibleMask_1_closure:
         const GHC.IO.uninterruptibleMask_1_info;
 },
 GHC.IO.uninterruptibleMask_1_entry() //  [R2]
         { info_tbl: [(c7FwK,
                       label: GHC.IO.uninterruptibleMask_1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7FwL; else goto c7FwM;
       c7FwL: // global
           R2 = R2;
           R1 = GHC.IO.uninterruptibleMask_1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7FwM: // global
           I64[Sp - 16] = block_c7FwE_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c7FwE() //  [R1]
         { info_tbl: [(c7FwE,
                       label: block_c7FwE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FwE: // global
           _s7F55::P64 = P64[Sp + 8];
           if (R1 == 1) goto c7FwJ; else goto c7FwI;
       c7FwJ: // global
           R1 = _s7F55::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       c7FwI: // global
           R1 = _s7F55::P64;
           Sp = Sp + 16;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.032464788 UTC

[section ""data" . GHC.IO.uninterruptibleMask__closure" {
     GHC.IO.uninterruptibleMask__closure:
         const GHC.IO.uninterruptibleMask__info;
 },
 GHC.IO.uninterruptibleMask__entry() //  [R2]
         { info_tbl: [(c7Fx1,
                       label: GHC.IO.uninterruptibleMask__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fx1: // global
           R2 = R2;
           call GHC.IO.uninterruptibleMask_1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.035634423 UTC

[section ""data" . GHC.IO.evaluate1_closure" {
     GHC.IO.evaluate1_closure:
         const GHC.IO.evaluate1_info;
 },
 GHC.IO.evaluate1_entry() //  [R2]
         { info_tbl: [(c7Fxc,
                       label: GHC.IO.evaluate1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fxc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.038816316 UTC

[section ""data" . GHC.IO.evaluate_closure" {
     GHC.IO.evaluate_closure:
         const GHC.IO.evaluate_info;
 },
 GHC.IO.evaluate_entry() //  [R2]
         { info_tbl: [(c7Fxn,
                       label: GHC.IO.evaluate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fxn: // global
           R2 = R2;
           call GHC.IO.evaluate1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.042382781 UTC

[section ""cstring" . GHC.IO.$trModule4_bytes" {
     GHC.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.043938731 UTC

[section ""data" . GHC.IO.$trModule3_closure" {
     GHC.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.045598282 UTC

[section ""cstring" . GHC.IO.$trModule2_bytes" {
     GHC.IO.$trModule2_bytes:
         I8[] [71,72,67,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.047211038 UTC

[section ""data" . GHC.IO.$trModule1_closure" {
     GHC.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.048751766 UTC

[section ""data" . GHC.IO.$trModule_closure" {
     GHC.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.IO.$trModule3_closure+1;
         const GHC.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.050406184 UTC

[section ""cstring" . GHC.IO.$tcMaskingState2_bytes" {
     GHC.IO.$tcMaskingState2_bytes:
         I8[] [77,97,115,107,105,110,103,83,116,97,116,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.052042481 UTC

[section ""data" . GHC.IO.$tcMaskingState1_closure" {
     GHC.IO.$tcMaskingState1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tcMaskingState2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.053750619 UTC

[section ""data" . GHC.IO.$tcMaskingState_closure" {
     GHC.IO.$tcMaskingState_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tcMaskingState1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1377527551354837803;
         const 7593236071496752895;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.055457164 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible1_closure" {
     GHC.IO.$tc'MaskedInterruptible1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IO.$tcMaskingState_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.057104491 UTC

[section ""cstring" . GHC.IO.$tc'Unmasked2_bytes" {
     GHC.IO.$tc'Unmasked2_bytes:
         I8[] [39,85,110,109,97,115,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.058732309 UTC

[section ""data" . GHC.IO.$tc'Unmasked1_closure" {
     GHC.IO.$tc'Unmasked1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'Unmasked2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.060394525 UTC

[section ""data" . GHC.IO.$tc'Unmasked_closure" {
     GHC.IO.$tc'Unmasked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'Unmasked1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 16923189221218057084;
         const 12178290748160137861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.062143561 UTC

[section ""cstring" . GHC.IO.$tc'MaskedInterruptible3_bytes" {
     GHC.IO.$tc'MaskedInterruptible3_bytes:
         I8[] [39,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.06377779 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible2_closure" {
     GHC.IO.$tc'MaskedInterruptible2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedInterruptible3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.065898099 UTC

[section ""data" . GHC.IO.$tc'MaskedInterruptible_closure" {
     GHC.IO.$tc'MaskedInterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedInterruptible2_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 8247192854047081576;
         const 3389631131447074398;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.067575271 UTC

[section ""cstring" . GHC.IO.$tc'MaskedUninterruptible2_bytes" {
     GHC.IO.$tc'MaskedUninterruptible2_bytes:
         I8[] [39,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.069185526 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible1_closure" {
     GHC.IO.$tc'MaskedUninterruptible1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.IO.$tc'MaskedUninterruptible2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.070836601 UTC

[section ""data" . GHC.IO.$tc'MaskedUninterruptible_closure" {
     GHC.IO.$tc'MaskedUninterruptible_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.IO.$trModule_closure+1;
         const GHC.IO.$tc'MaskedUninterruptible1_closure+1;
         const GHC.IO.$tc'MaskedInterruptible1_closure+1;
         const 10964471758180118067;
         const 9988357998868476725;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.072592193 UTC

[section ""data" . GHC.IO.Unmasked_closure" {
     GHC.IO.Unmasked_closure:
         const GHC.IO.Unmasked_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.075290143 UTC

[section ""data" . GHC.IO.MaskedInterruptible_closure" {
     GHC.IO.MaskedInterruptible_closure:
         const GHC.IO.MaskedInterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.077041107 UTC

[section ""data" . GHC.IO.MaskedUninterruptible_closure" {
     GHC.IO.MaskedUninterruptible_closure:
         const GHC.IO.MaskedUninterruptible_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.07883295 UTC

[section ""relreadonly" . GHC.IO.MaskingState_closure_tbl" {
     GHC.IO.MaskingState_closure_tbl:
         const GHC.IO.Unmasked_closure+1;
         const GHC.IO.MaskedInterruptible_closure+2;
         const GHC.IO.MaskedUninterruptible_closure+3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.08078087 UTC

[GHC.IO.Unmasked_con_entry() //  [R1]
         { info_tbl: [(c7FxQ,
                       label: GHC.IO.Unmasked_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,85,110,109,97,115,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FxQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.0842604 UTC

[GHC.IO.MaskedInterruptible_con_entry() //  [R1]
         { info_tbl: [(c7FxX,
                       label: GHC.IO.MaskedInterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,73,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7FxX: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.08760393 UTC

[GHC.IO.MaskedUninterruptible_con_entry() //  [R1]
         { info_tbl: [(c7Fy4,
                       label: GHC.IO.MaskedUninterruptible_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,73,79,46,77,97,115,107,101,100,85,110,105,110,116,101,114,114,117,112,116,105,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Fy4: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:49.090872635 UTC

[section ""relreadonly" . S7F6v_srt" {
     S7F6v_srt:
         const GHC.IO.$w$cshowsPrec_closure;
         const GHC.IO.$fShowMaskingState1_closure;
         const GHC.IO.$fShowMaskingState3_closure;
         const GHC.IO.$fShowMaskingState5_closure;
         const GHC.IO.$fShowMaskingState_$cshow_closure;
         const GHC.IO.Exception.userError_closure;
         const GHC.IO.Exception.$fxExceptionIOException_closure;
         const GHC.IO.failIO1_closure;
         const GHC.IO.mplusIO1_closure;
 }]

