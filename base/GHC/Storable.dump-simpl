
==================== Tidy Core ====================
2018-03-16 15:59:27.368126566 UTC

Result size of Tidy Core
  = {terms: 788, types: 1,534, coercions: 318, joins: 0/0}

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWideCharOffPtr1
  :: Ptr Char
     -> Int -> State# RealWorld -> (# State# RealWorld, Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B53 [Occ=Once!] :: Ptr Char)
                 (ds1_d4B54 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B53 of { Ptr a_a4AMQ [Occ=Once] ->
                 case ds1_d4B54 of { I# i_a4AMR [Occ=Once] ->
                 case readWideCharOffAddr# @ RealWorld a_a4AMQ i_a4AMR eta_B1 of
                 { (# ipv_s4B5l [Occ=Once], ipv1_s4B5m [Occ=Once] #) ->
                 (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
                 }
                 }
                 }}]
GHC.Storable.readWideCharOffPtr1
  = \ (ds_d4B53 :: Ptr Char)
      (ds1_d4B54 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B53 of { Ptr a_a4AMQ ->
      case ds1_d4B54 of { I# i_a4AMR ->
      case readWideCharOffAddr# @ RealWorld a_a4AMQ i_a4AMR eta_B1 of
      { (# ipv_s4B5l, ipv1_s4B5m #) ->
      (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWideCharOffPtr :: Ptr Char -> Int -> IO Char
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWideCharOffPtr1
               `cast` (<Ptr Char>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
                       :: (Ptr Char
                           -> Int -> State# RealWorld -> (# State# RealWorld, Char #) :: *)
                          ~R# (Ptr Char -> Int -> IO Char :: *))}]
readWideCharOffPtr
  = GHC.Storable.readWideCharOffPtr1
    `cast` (<Ptr Char>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
            :: (Ptr Char
                -> Int -> State# RealWorld -> (# State# RealWorld, Char #) :: *)
               ~R# (Ptr Char -> Int -> IO Char :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readIntOffPtr1
  :: Ptr Int
     -> Int -> State# RealWorld -> (# State# RealWorld, Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B4Q [Occ=Once!] :: Ptr Int)
                 (ds1_d4B4R [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B4Q of { Ptr a_a4AMV [Occ=Once] ->
                 case ds1_d4B4R of { I# i_a4AMW [Occ=Once] ->
                 case readIntOffAddr# @ RealWorld a_a4AMV i_a4AMW eta_B1 of
                 { (# ipv_s4B5r [Occ=Once], ipv1_s4B5s [Occ=Once] #) ->
                 (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
                 }
                 }
                 }}]
GHC.Storable.readIntOffPtr1
  = \ (ds_d4B4Q :: Ptr Int)
      (ds1_d4B4R :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B4Q of { Ptr a_a4AMV ->
      case ds1_d4B4R of { I# i_a4AMW ->
      case readIntOffAddr# @ RealWorld a_a4AMV i_a4AMW eta_B1 of
      { (# ipv_s4B5r, ipv1_s4B5s #) ->
      (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readIntOffPtr :: Ptr Int -> Int -> IO Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readIntOffPtr1
               `cast` (<Ptr Int>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
                       :: (Ptr Int
                           -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                          ~R# (Ptr Int -> Int -> IO Int :: *))}]
readIntOffPtr
  = GHC.Storable.readIntOffPtr1
    `cast` (<Ptr Int>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
            :: (Ptr Int
                -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
               ~R# (Ptr Int -> Int -> IO Int :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWordOffPtr1
  :: Ptr Word
     -> Int -> State# RealWorld -> (# State# RealWorld, Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B4D [Occ=Once!] :: Ptr Word)
                 (ds1_d4B4E [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B4D of { Ptr a_a4AN0 [Occ=Once] ->
                 case ds1_d4B4E of { I# i_a4AN1 [Occ=Once] ->
                 case readWordOffAddr# @ RealWorld a_a4AN0 i_a4AN1 eta_B1 of
                 { (# ipv_s4B5x [Occ=Once], ipv1_s4B5y [Occ=Once] #) ->
                 (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
                 }
                 }
                 }}]
GHC.Storable.readWordOffPtr1
  = \ (ds_d4B4D :: Ptr Word)
      (ds1_d4B4E :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B4D of { Ptr a_a4AN0 ->
      case ds1_d4B4E of { I# i_a4AN1 ->
      case readWordOffAddr# @ RealWorld a_a4AN0 i_a4AN1 eta_B1 of
      { (# ipv_s4B5x, ipv1_s4B5y #) ->
      (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWordOffPtr :: Ptr Word -> Int -> IO Word
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWordOffPtr1
               `cast` (<Ptr Word>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
                       :: (Ptr Word
                           -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                          ~R# (Ptr Word -> Int -> IO Word :: *))}]
readWordOffPtr
  = GHC.Storable.readWordOffPtr1
    `cast` (<Ptr Word>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
            :: (Ptr Word
                -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
               ~R# (Ptr Word -> Int -> IO Word :: *))

-- RHS size: {terms: 20, types: 35, coercions: 0, joins: 0/0}
GHC.Storable.readPtrOffPtr1
  :: forall a.
     Ptr (Ptr a)
     -> Int -> State# RealWorld -> (# State# RealWorld, Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AYh)
                 (ds_d4B4q [Occ=Once!] :: Ptr (Ptr a_a4AYh))
                 (ds1_d4B4r [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B4q of { Ptr a1_a4AN5 [Occ=Once] ->
                 case ds1_d4B4r of { I# i_a4AN6 [Occ=Once] ->
                 case readAddrOffAddr# @ RealWorld a1_a4AN5 i_a4AN6 eta_B1 of
                 { (# ipv_s4B5D [Occ=Once], ipv1_s4B5E [Occ=Once] #) ->
                 (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4AYh ipv1_s4B5E #)
                 }
                 }
                 }}]
GHC.Storable.readPtrOffPtr1
  = \ (@ a_a4AYh)
      (ds_d4B4q :: Ptr (Ptr a_a4AYh))
      (ds1_d4B4r :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B4q of { Ptr a1_a4AN5 ->
      case ds1_d4B4r of { I# i_a4AN6 ->
      case readAddrOffAddr# @ RealWorld a1_a4AN5 i_a4AN6 eta_B1 of
      { (# ipv_s4B5D, ipv1_s4B5E #) ->
      (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4AYh ipv1_s4B5E #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
readPtrOffPtr :: forall a. Ptr (Ptr a) -> Int -> IO (Ptr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readPtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (Ptr a)>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Ptr a>_R)
                       :: (forall a.
                           Ptr (Ptr a)
                           -> Int -> State# RealWorld -> (# State# RealWorld, Ptr a #) :: *)
                          ~R# (forall a. Ptr (Ptr a) -> Int -> IO (Ptr a) :: *))}]
readPtrOffPtr
  = GHC.Storable.readPtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (Ptr a)>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Ptr a>_R)
            :: (forall a.
                Ptr (Ptr a)
                -> Int -> State# RealWorld -> (# State# RealWorld, Ptr a #) :: *)
               ~R# (forall a. Ptr (Ptr a) -> Int -> IO (Ptr a) :: *))

-- RHS size: {terms: 20, types: 35, coercions: 0, joins: 0/0}
GHC.Storable.readFunPtrOffPtr1
  :: forall a.
     Ptr (FunPtr a)
     -> Int -> State# RealWorld -> (# State# RealWorld, FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AY8)
                 (ds_d4B4d [Occ=Once!] :: Ptr (FunPtr a_a4AY8))
                 (ds1_d4B4e [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B4d of { Ptr a1_a4ANa [Occ=Once] ->
                 case ds1_d4B4e of { I# i_a4ANb [Occ=Once] ->
                 case readAddrOffAddr# @ RealWorld a1_a4ANa i_a4ANb eta_B1 of
                 { (# ipv_s4B5J [Occ=Once], ipv1_s4B5K [Occ=Once] #) ->
                 (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4AY8 ipv1_s4B5K #)
                 }
                 }
                 }}]
GHC.Storable.readFunPtrOffPtr1
  = \ (@ a_a4AY8)
      (ds_d4B4d :: Ptr (FunPtr a_a4AY8))
      (ds1_d4B4e :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B4d of { Ptr a1_a4ANa ->
      case ds1_d4B4e of { I# i_a4ANb ->
      case readAddrOffAddr# @ RealWorld a1_a4ANa i_a4ANb eta_B1 of
      { (# ipv_s4B5J, ipv1_s4B5K #) ->
      (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4AY8 ipv1_s4B5K #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
readFunPtrOffPtr
  :: forall a. Ptr (FunPtr a) -> Int -> IO (FunPtr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readFunPtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (FunPtr a)>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <FunPtr a>_R)
                       :: (forall a.
                           Ptr (FunPtr a)
                           -> Int
                           -> State# RealWorld
                           -> (# State# RealWorld, FunPtr a #) :: *)
                          ~R# (forall a. Ptr (FunPtr a) -> Int -> IO (FunPtr a) :: *))}]
readFunPtrOffPtr
  = GHC.Storable.readFunPtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (FunPtr a)>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <FunPtr a>_R)
            :: (forall a.
                Ptr (FunPtr a)
                -> Int
                -> State# RealWorld
                -> (# State# RealWorld, FunPtr a #) :: *)
               ~R# (forall a. Ptr (FunPtr a) -> Int -> IO (FunPtr a) :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readFloatOffPtr1
  :: Ptr Float
     -> Int -> State# RealWorld -> (# State# RealWorld, Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B40 [Occ=Once!] :: Ptr Float)
                 (ds1_d4B41 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B40 of { Ptr a_a4ANf [Occ=Once] ->
                 case ds1_d4B41 of { I# i_a4ANg [Occ=Once] ->
                 case readFloatOffAddr# @ RealWorld a_a4ANf i_a4ANg eta_B1 of
                 { (# ipv_s4B5P [Occ=Once], ipv1_s4B5Q [Occ=Once] #) ->
                 (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
                 }
                 }
                 }}]
GHC.Storable.readFloatOffPtr1
  = \ (ds_d4B40 :: Ptr Float)
      (ds1_d4B41 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B40 of { Ptr a_a4ANf ->
      case ds1_d4B41 of { I# i_a4ANg ->
      case readFloatOffAddr# @ RealWorld a_a4ANf i_a4ANg eta_B1 of
      { (# ipv_s4B5P, ipv1_s4B5Q #) ->
      (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readFloatOffPtr :: Ptr Float -> Int -> IO Float
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readFloatOffPtr1
               `cast` (<Ptr Float>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
                       :: (Ptr Float
                           -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                          ~R# (Ptr Float -> Int -> IO Float :: *))}]
readFloatOffPtr
  = GHC.Storable.readFloatOffPtr1
    `cast` (<Ptr Float>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
            :: (Ptr Float
                -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
               ~R# (Ptr Float -> Int -> IO Float :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readDoubleOffPtr1
  :: Ptr Double
     -> Int -> State# RealWorld -> (# State# RealWorld, Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B3N [Occ=Once!] :: Ptr Double)
                 (ds1_d4B3O [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B3N of { Ptr a_a4ANk [Occ=Once] ->
                 case ds1_d4B3O of { I# i_a4ANl [Occ=Once] ->
                 case readDoubleOffAddr# @ RealWorld a_a4ANk i_a4ANl eta_B1 of
                 { (# ipv_s4B5V [Occ=Once], ipv1_s4B5W [Occ=Once] #) ->
                 (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
                 }
                 }
                 }}]
GHC.Storable.readDoubleOffPtr1
  = \ (ds_d4B3N :: Ptr Double)
      (ds1_d4B3O :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B3N of { Ptr a_a4ANk ->
      case ds1_d4B3O of { I# i_a4ANl ->
      case readDoubleOffAddr# @ RealWorld a_a4ANk i_a4ANl eta_B1 of
      { (# ipv_s4B5V, ipv1_s4B5W #) ->
      (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readDoubleOffPtr :: Ptr Double -> Int -> IO Double
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readDoubleOffPtr1
               `cast` (<Ptr Double>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
                       :: (Ptr Double
                           -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                          ~R# (Ptr Double -> Int -> IO Double :: *))}]
readDoubleOffPtr
  = GHC.Storable.readDoubleOffPtr1
    `cast` (<Ptr Double>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
            :: (Ptr Double
                -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
               ~R# (Ptr Double -> Int -> IO Double :: *))

-- RHS size: {terms: 20, types: 38, coercions: 0, joins: 0/0}
GHC.Storable.readStablePtrOffPtr1
  :: forall a.
     Ptr (StablePtr a)
     -> Int -> State# RealWorld -> (# State# RealWorld, StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AXK)
                 (ds_d4B3A [Occ=Once!] :: Ptr (StablePtr a_a4AXK))
                 (ds1_d4B3B [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B3A of { Ptr a1_a4ANp [Occ=Once] ->
                 case ds1_d4B3B of { I# i_a4ANq [Occ=Once] ->
                 case readStablePtrOffAddr#
                        @ RealWorld @ a_a4AXK a1_a4ANp i_a4ANq eta_B1
                 of
                 { (# ipv_s4B61 [Occ=Once], ipv1_s4B62 [Occ=Once] #) ->
                 (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4AXK ipv1_s4B62 #)
                 }
                 }
                 }}]
GHC.Storable.readStablePtrOffPtr1
  = \ (@ a_a4AXK)
      (ds_d4B3A :: Ptr (StablePtr a_a4AXK))
      (ds1_d4B3B :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B3A of { Ptr a1_a4ANp ->
      case ds1_d4B3B of { I# i_a4ANq ->
      case readStablePtrOffAddr#
             @ RealWorld @ a_a4AXK a1_a4ANp i_a4ANq eta_B1
      of
      { (# ipv_s4B61, ipv1_s4B62 #) ->
      (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4AXK ipv1_s4B62 #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
readStablePtrOffPtr
  :: forall a. Ptr (StablePtr a) -> Int -> IO (StablePtr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readStablePtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (StablePtr a)>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <StablePtr a>_R)
                       :: (forall a.
                           Ptr (StablePtr a)
                           -> Int
                           -> State# RealWorld
                           -> (# State# RealWorld, StablePtr a #) :: *)
                          ~R# (forall a.
                               Ptr (StablePtr a) -> Int -> IO (StablePtr a) :: *))}]
readStablePtrOffPtr
  = GHC.Storable.readStablePtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (StablePtr a)>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <StablePtr a>_R)
            :: (forall a.
                Ptr (StablePtr a)
                -> Int
                -> State# RealWorld
                -> (# State# RealWorld, StablePtr a #) :: *)
               ~R# (forall a. Ptr (StablePtr a) -> Int -> IO (StablePtr a) :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readInt8OffPtr1
  :: Ptr Int8
     -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B3n [Occ=Once!] :: Ptr Int8)
                 (ds1_d4B3o [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B3n of { Ptr a_a4ANu [Occ=Once] ->
                 case ds1_d4B3o of { I# i_a4ANv [Occ=Once] ->
                 case readInt8OffAddr# @ RealWorld a_a4ANu i_a4ANv eta_B1 of
                 { (# ipv_s4B67 [Occ=Once], ipv1_s4B68 [Occ=Once] #) ->
                 (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
                 }
                 }
                 }}]
GHC.Storable.readInt8OffPtr1
  = \ (ds_d4B3n :: Ptr Int8)
      (ds1_d4B3o :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B3n of { Ptr a_a4ANu ->
      case ds1_d4B3o of { I# i_a4ANv ->
      case readInt8OffAddr# @ RealWorld a_a4ANu i_a4ANv eta_B1 of
      { (# ipv_s4B67, ipv1_s4B68 #) ->
      (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readInt8OffPtr :: Ptr Int8 -> Int -> IO Int8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readInt8OffPtr1
               `cast` (<Ptr Int8>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
                       :: (Ptr Int8
                           -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                          ~R# (Ptr Int8 -> Int -> IO Int8 :: *))}]
readInt8OffPtr
  = GHC.Storable.readInt8OffPtr1
    `cast` (<Ptr Int8>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
            :: (Ptr Int8
                -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
               ~R# (Ptr Int8 -> Int -> IO Int8 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWord8OffPtr1
  :: Ptr Word8
     -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B3a [Occ=Once!] :: Ptr Word8)
                 (ds1_d4B3b [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B3a of { Ptr a_a4ANz [Occ=Once] ->
                 case ds1_d4B3b of { I# i_a4ANA [Occ=Once] ->
                 case readWord8OffAddr# @ RealWorld a_a4ANz i_a4ANA eta_B1 of
                 { (# ipv_s4B6d [Occ=Once], ipv1_s4B6e [Occ=Once] #) ->
                 (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
                 }
                 }
                 }}]
GHC.Storable.readWord8OffPtr1
  = \ (ds_d4B3a :: Ptr Word8)
      (ds1_d4B3b :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B3a of { Ptr a_a4ANz ->
      case ds1_d4B3b of { I# i_a4ANA ->
      case readWord8OffAddr# @ RealWorld a_a4ANz i_a4ANA eta_B1 of
      { (# ipv_s4B6d, ipv1_s4B6e #) ->
      (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWord8OffPtr :: Ptr Word8 -> Int -> IO Word8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWord8OffPtr1
               `cast` (<Ptr Word8>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
                       :: (Ptr Word8
                           -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                          ~R# (Ptr Word8 -> Int -> IO Word8 :: *))}]
readWord8OffPtr
  = GHC.Storable.readWord8OffPtr1
    `cast` (<Ptr Word8>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
            :: (Ptr Word8
                -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
               ~R# (Ptr Word8 -> Int -> IO Word8 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readInt16OffPtr1
  :: Ptr Int16
     -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B2X [Occ=Once!] :: Ptr Int16)
                 (ds1_d4B2Y [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B2X of { Ptr a_a4ANE [Occ=Once] ->
                 case ds1_d4B2Y of { I# i_a4ANF [Occ=Once] ->
                 case readInt16OffAddr# @ RealWorld a_a4ANE i_a4ANF eta_B1 of
                 { (# ipv_s4B6j [Occ=Once], ipv1_s4B6k [Occ=Once] #) ->
                 (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
                 }
                 }
                 }}]
GHC.Storable.readInt16OffPtr1
  = \ (ds_d4B2X :: Ptr Int16)
      (ds1_d4B2Y :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B2X of { Ptr a_a4ANE ->
      case ds1_d4B2Y of { I# i_a4ANF ->
      case readInt16OffAddr# @ RealWorld a_a4ANE i_a4ANF eta_B1 of
      { (# ipv_s4B6j, ipv1_s4B6k #) ->
      (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readInt16OffPtr :: Ptr Int16 -> Int -> IO Int16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readInt16OffPtr1
               `cast` (<Ptr Int16>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
                       :: (Ptr Int16
                           -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                          ~R# (Ptr Int16 -> Int -> IO Int16 :: *))}]
readInt16OffPtr
  = GHC.Storable.readInt16OffPtr1
    `cast` (<Ptr Int16>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
            :: (Ptr Int16
                -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
               ~R# (Ptr Int16 -> Int -> IO Int16 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWord16OffPtr1
  :: Ptr Word16
     -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B2K [Occ=Once!] :: Ptr Word16)
                 (ds1_d4B2L [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B2K of { Ptr a_a4ANJ [Occ=Once] ->
                 case ds1_d4B2L of { I# i_a4ANK [Occ=Once] ->
                 case readWord16OffAddr# @ RealWorld a_a4ANJ i_a4ANK eta_B1 of
                 { (# ipv_s4B6p [Occ=Once], ipv1_s4B6q [Occ=Once] #) ->
                 (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
                 }
                 }
                 }}]
GHC.Storable.readWord16OffPtr1
  = \ (ds_d4B2K :: Ptr Word16)
      (ds1_d4B2L :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B2K of { Ptr a_a4ANJ ->
      case ds1_d4B2L of { I# i_a4ANK ->
      case readWord16OffAddr# @ RealWorld a_a4ANJ i_a4ANK eta_B1 of
      { (# ipv_s4B6p, ipv1_s4B6q #) ->
      (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWord16OffPtr :: Ptr Word16 -> Int -> IO Word16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWord16OffPtr1
               `cast` (<Ptr Word16>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
                       :: (Ptr Word16
                           -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                          ~R# (Ptr Word16 -> Int -> IO Word16 :: *))}]
readWord16OffPtr
  = GHC.Storable.readWord16OffPtr1
    `cast` (<Ptr Word16>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
            :: (Ptr Word16
                -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
               ~R# (Ptr Word16 -> Int -> IO Word16 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readInt32OffPtr1
  :: Ptr Int32
     -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B2x [Occ=Once!] :: Ptr Int32)
                 (ds1_d4B2y [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B2x of { Ptr a_a4ANO [Occ=Once] ->
                 case ds1_d4B2y of { I# i_a4ANP [Occ=Once] ->
                 case readInt32OffAddr# @ RealWorld a_a4ANO i_a4ANP eta_B1 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once] #) ->
                 (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
                 }
                 }
                 }}]
GHC.Storable.readInt32OffPtr1
  = \ (ds_d4B2x :: Ptr Int32)
      (ds1_d4B2y :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B2x of { Ptr a_a4ANO ->
      case ds1_d4B2y of { I# i_a4ANP ->
      case readInt32OffAddr# @ RealWorld a_a4ANO i_a4ANP eta_B1 of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readInt32OffPtr :: Ptr Int32 -> Int -> IO Int32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readInt32OffPtr1
               `cast` (<Ptr Int32>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
                       :: (Ptr Int32
                           -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                          ~R# (Ptr Int32 -> Int -> IO Int32 :: *))}]
readInt32OffPtr
  = GHC.Storable.readInt32OffPtr1
    `cast` (<Ptr Int32>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
            :: (Ptr Int32
                -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
               ~R# (Ptr Int32 -> Int -> IO Int32 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWord32OffPtr1
  :: Ptr Word32
     -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B2k [Occ=Once!] :: Ptr Word32)
                 (ds1_d4B2l [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B2k of { Ptr a_a4ANT [Occ=Once] ->
                 case ds1_d4B2l of { I# i_a4ANU [Occ=Once] ->
                 case readWord32OffAddr# @ RealWorld a_a4ANT i_a4ANU eta_B1 of
                 { (# ipv_s4B6B [Occ=Once], ipv1_s4B6C [Occ=Once] #) ->
                 (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
                 }
                 }
                 }}]
GHC.Storable.readWord32OffPtr1
  = \ (ds_d4B2k :: Ptr Word32)
      (ds1_d4B2l :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B2k of { Ptr a_a4ANT ->
      case ds1_d4B2l of { I# i_a4ANU ->
      case readWord32OffAddr# @ RealWorld a_a4ANT i_a4ANU eta_B1 of
      { (# ipv_s4B6B, ipv1_s4B6C #) ->
      (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWord32OffPtr :: Ptr Word32 -> Int -> IO Word32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWord32OffPtr1
               `cast` (<Ptr Word32>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
                       :: (Ptr Word32
                           -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                          ~R# (Ptr Word32 -> Int -> IO Word32 :: *))}]
readWord32OffPtr
  = GHC.Storable.readWord32OffPtr1
    `cast` (<Ptr Word32>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
            :: (Ptr Word32
                -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
               ~R# (Ptr Word32 -> Int -> IO Word32 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readInt64OffPtr1
  :: Ptr Int64
     -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B27 [Occ=Once!] :: Ptr Int64)
                 (ds1_d4B28 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B27 of { Ptr a_a4ANY [Occ=Once] ->
                 case ds1_d4B28 of { I# i_a4ANZ [Occ=Once] ->
                 case readInt64OffAddr# @ RealWorld a_a4ANY i_a4ANZ eta_B1 of
                 { (# ipv_s4B6H [Occ=Once], ipv1_s4B6I [Occ=Once] #) ->
                 (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
                 }
                 }
                 }}]
GHC.Storable.readInt64OffPtr1
  = \ (ds_d4B27 :: Ptr Int64)
      (ds1_d4B28 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B27 of { Ptr a_a4ANY ->
      case ds1_d4B28 of { I# i_a4ANZ ->
      case readInt64OffAddr# @ RealWorld a_a4ANY i_a4ANZ eta_B1 of
      { (# ipv_s4B6H, ipv1_s4B6I #) ->
      (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readInt64OffPtr :: Ptr Int64 -> Int -> IO Int64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readInt64OffPtr1
               `cast` (<Ptr Int64>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
                       :: (Ptr Int64
                           -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                          ~R# (Ptr Int64 -> Int -> IO Int64 :: *))}]
readInt64OffPtr
  = GHC.Storable.readInt64OffPtr1
    `cast` (<Ptr Int64>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
            :: (Ptr Int64
                -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
               ~R# (Ptr Int64 -> Int -> IO Int64 :: *))

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.readWord64OffPtr1
  :: Ptr Word64
     -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B1U [Occ=Once!] :: Ptr Word64)
                 (ds1_d4B1V [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B1U of { Ptr a_a4AO3 [Occ=Once] ->
                 case ds1_d4B1V of { I# i_a4AO4 [Occ=Once] ->
                 case readWord64OffAddr# @ RealWorld a_a4AO3 i_a4AO4 eta_B1 of
                 { (# ipv_s4B6N [Occ=Once], ipv1_s4B6O [Occ=Once] #) ->
                 (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
                 }
                 }
                 }}]
GHC.Storable.readWord64OffPtr1
  = \ (ds_d4B1U :: Ptr Word64)
      (ds1_d4B1V :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B1U of { Ptr a_a4AO3 ->
      case ds1_d4B1V of { I# i_a4AO4 ->
      case readWord64OffAddr# @ RealWorld a_a4AO3 i_a4AO4 eta_B1 of
      { (# ipv_s4B6N, ipv1_s4B6O #) ->
      (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
readWord64OffPtr :: Ptr Word64 -> Int -> IO Word64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.readWord64OffPtr1
               `cast` (<Ptr Word64>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
                       :: (Ptr Word64
                           -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                          ~R# (Ptr Word64 -> Int -> IO Word64 :: *))}]
readWord64OffPtr
  = GHC.Storable.readWord64OffPtr1
    `cast` (<Ptr Word64>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
            :: (Ptr Word64
                -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
               ~R# (Ptr Word64 -> Int -> IO Word64 :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWideCharOffPtr1
  :: Ptr Char
     -> Int -> Char -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B1I [Occ=Once!] :: Ptr Char)
                 (ds1_d4B1J [Occ=Once!] :: Int)
                 (ds2_d4B1K [Occ=Once!] :: Char)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B1I of { Ptr a_a4AO8 [Occ=Once] ->
                 case ds1_d4B1J of { I# i_a4AO9 [Occ=Once] ->
                 case ds2_d4B1K of { C# x_a4AOa [Occ=Once] ->
                 case writeWideCharOffAddr#
                        @ RealWorld a_a4AO8 i_a4AO9 x_a4AOa eta_B1
                 of s2_a4AOc
                 { __DEFAULT ->
                 (# s2_a4AOc, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWideCharOffPtr1
  = \ (ds_d4B1I :: Ptr Char)
      (ds1_d4B1J :: Int)
      (ds2_d4B1K :: Char)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B1I of { Ptr a_a4AO8 ->
      case ds1_d4B1J of { I# i_a4AO9 ->
      case ds2_d4B1K of { C# x_a4AOa ->
      case writeWideCharOffAddr#
             @ RealWorld a_a4AO8 i_a4AO9 x_a4AOa eta_B1
      of s2_a4AOc
      { __DEFAULT ->
      (# s2_a4AOc, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWideCharOffPtr :: Ptr Char -> Int -> Char -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWideCharOffPtr1
               `cast` (<Ptr Char>_R
                       ->_R <Int>_R
                       ->_R <Char>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Char
                           -> Int
                           -> Char
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Char -> Int -> Char -> IO () :: *))}]
writeWideCharOffPtr
  = GHC.Storable.writeWideCharOffPtr1
    `cast` (<Ptr Char>_R
            ->_R <Int>_R
            ->_R <Char>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Char
                -> Int
                -> Char
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Char -> Int -> Char -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeIntOffPtr1
  :: Ptr Int
     -> Int -> Int -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B1w [Occ=Once!] :: Ptr Int)
                 (ds1_d4B1x [Occ=Once!] :: Int)
                 (ds2_d4B1y [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B1w of { Ptr a_a4AOd [Occ=Once] ->
                 case ds1_d4B1x of { I# i_a4AOe [Occ=Once] ->
                 case ds2_d4B1y of { I# x_a4AOf [Occ=Once] ->
                 case writeIntOffAddr# @ RealWorld a_a4AOd i_a4AOe x_a4AOf eta_B1
                 of s2_a4AOh
                 { __DEFAULT ->
                 (# s2_a4AOh, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeIntOffPtr1
  = \ (ds_d4B1w :: Ptr Int)
      (ds1_d4B1x :: Int)
      (ds2_d4B1y :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B1w of { Ptr a_a4AOd ->
      case ds1_d4B1x of { I# i_a4AOe ->
      case ds2_d4B1y of { I# x_a4AOf ->
      case writeIntOffAddr# @ RealWorld a_a4AOd i_a4AOe x_a4AOf eta_B1
      of s2_a4AOh
      { __DEFAULT ->
      (# s2_a4AOh, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeIntOffPtr :: Ptr Int -> Int -> Int -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeIntOffPtr1
               `cast` (<Ptr Int>_R
                       ->_R <Int>_R
                       ->_R <Int>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Int
                           -> Int
                           -> Int
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Int -> Int -> Int -> IO () :: *))}]
writeIntOffPtr
  = GHC.Storable.writeIntOffPtr1
    `cast` (<Ptr Int>_R
            ->_R <Int>_R
            ->_R <Int>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Int
                -> Int
                -> Int
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Int -> Int -> Int -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWordOffPtr1
  :: Ptr Word
     -> Int -> Word -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B1k [Occ=Once!] :: Ptr Word)
                 (ds1_d4B1l [Occ=Once!] :: Int)
                 (ds2_d4B1m [Occ=Once!] :: Word)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B1k of { Ptr a_a4AOi [Occ=Once] ->
                 case ds1_d4B1l of { I# i_a4AOj [Occ=Once] ->
                 case ds2_d4B1m of { W# x_a4AOk [Occ=Once] ->
                 case writeWordOffAddr# @ RealWorld a_a4AOi i_a4AOj x_a4AOk eta_B1
                 of s2_a4AOm
                 { __DEFAULT ->
                 (# s2_a4AOm, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWordOffPtr1
  = \ (ds_d4B1k :: Ptr Word)
      (ds1_d4B1l :: Int)
      (ds2_d4B1m :: Word)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B1k of { Ptr a_a4AOi ->
      case ds1_d4B1l of { I# i_a4AOj ->
      case ds2_d4B1m of { W# x_a4AOk ->
      case writeWordOffAddr# @ RealWorld a_a4AOi i_a4AOj x_a4AOk eta_B1
      of s2_a4AOm
      { __DEFAULT ->
      (# s2_a4AOm, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWordOffPtr :: Ptr Word -> Int -> Word -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWordOffPtr1
               `cast` (<Ptr Word>_R
                       ->_R <Int>_R
                       ->_R <Word>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Word
                           -> Int
                           -> Word
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Word -> Int -> Word -> IO () :: *))}]
writeWordOffPtr
  = GHC.Storable.writeWordOffPtr1
    `cast` (<Ptr Word>_R
            ->_R <Int>_R
            ->_R <Word>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Word
                -> Int
                -> Word
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Word -> Int -> Word -> IO () :: *))

-- RHS size: {terms: 24, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.writePtrOffPtr1
  :: forall a.
     Ptr (Ptr a)
     -> Int -> Ptr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AWn)
                 (ds_d4B18 [Occ=Once!] :: Ptr (Ptr a_a4AWn))
                 (ds1_d4B19 [Occ=Once!] :: Int)
                 (ds2_d4B1a [Occ=Once!] :: Ptr a_a4AWn)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B18 of { Ptr a1_a4AOn [Occ=Once] ->
                 case ds1_d4B19 of { I# i_a4AOo [Occ=Once] ->
                 case ds2_d4B1a of { Ptr x_a4AOp [Occ=Once] ->
                 case writeAddrOffAddr# @ RealWorld a1_a4AOn i_a4AOo x_a4AOp eta_B1
                 of s2_a4AOr
                 { __DEFAULT ->
                 (# s2_a4AOr, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writePtrOffPtr1
  = \ (@ a_a4AWn)
      (ds_d4B18 :: Ptr (Ptr a_a4AWn))
      (ds1_d4B19 :: Int)
      (ds2_d4B1a :: Ptr a_a4AWn)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B18 of { Ptr a1_a4AOn ->
      case ds1_d4B19 of { I# i_a4AOo ->
      case ds2_d4B1a of { Ptr x_a4AOp ->
      case writeAddrOffAddr# @ RealWorld a1_a4AOn i_a4AOo x_a4AOp eta_B1
      of s2_a4AOr
      { __DEFAULT ->
      (# s2_a4AOr, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
writePtrOffPtr :: forall a. Ptr (Ptr a) -> Int -> Ptr a -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writePtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (Ptr a)>_R
                       ->_R <Int>_R
                       ->_R <Ptr a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (forall a.
                           Ptr (Ptr a)
                           -> Int
                           -> Ptr a
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (forall a. Ptr (Ptr a) -> Int -> Ptr a -> IO () :: *))}]
writePtrOffPtr
  = GHC.Storable.writePtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (Ptr a)>_R
            ->_R <Int>_R
            ->_R <Ptr a>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (forall a.
                Ptr (Ptr a)
                -> Int
                -> Ptr a
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (forall a. Ptr (Ptr a) -> Int -> Ptr a -> IO () :: *))

-- RHS size: {terms: 24, types: 29, coercions: 0, joins: 0/0}
GHC.Storable.writeFunPtrOffPtr1
  :: forall a.
     Ptr (FunPtr a)
     -> Int
     -> FunPtr a
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AWf)
                 (ds_d4B0W [Occ=Once!] :: Ptr (FunPtr a_a4AWf))
                 (ds1_d4B0X [Occ=Once!] :: Int)
                 (ds2_d4B0Y [Occ=Once!] :: FunPtr a_a4AWf)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B0W of { Ptr a1_a4AOs [Occ=Once] ->
                 case ds1_d4B0X of { I# i_a4AOt [Occ=Once] ->
                 case ds2_d4B0Y of { FunPtr x_a4AOu [Occ=Once] ->
                 case writeAddrOffAddr# @ RealWorld a1_a4AOs i_a4AOt x_a4AOu eta_B1
                 of s2_a4AOw
                 { __DEFAULT ->
                 (# s2_a4AOw, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeFunPtrOffPtr1
  = \ (@ a_a4AWf)
      (ds_d4B0W :: Ptr (FunPtr a_a4AWf))
      (ds1_d4B0X :: Int)
      (ds2_d4B0Y :: FunPtr a_a4AWf)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B0W of { Ptr a1_a4AOs ->
      case ds1_d4B0X of { I# i_a4AOt ->
      case ds2_d4B0Y of { FunPtr x_a4AOu ->
      case writeAddrOffAddr# @ RealWorld a1_a4AOs i_a4AOt x_a4AOu eta_B1
      of s2_a4AOw
      { __DEFAULT ->
      (# s2_a4AOw, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
writeFunPtrOffPtr
  :: forall a. Ptr (FunPtr a) -> Int -> FunPtr a -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeFunPtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (FunPtr a)>_R
                       ->_R <Int>_R
                       ->_R <FunPtr a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (forall a.
                           Ptr (FunPtr a)
                           -> Int
                           -> FunPtr a
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (forall a. Ptr (FunPtr a) -> Int -> FunPtr a -> IO () :: *))}]
writeFunPtrOffPtr
  = GHC.Storable.writeFunPtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (FunPtr a)>_R
            ->_R <Int>_R
            ->_R <FunPtr a>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (forall a.
                Ptr (FunPtr a)
                -> Int
                -> FunPtr a
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (forall a. Ptr (FunPtr a) -> Int -> FunPtr a -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeFloatOffPtr1
  :: Ptr Float
     -> Int -> Float -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B0K [Occ=Once!] :: Ptr Float)
                 (ds1_d4B0L [Occ=Once!] :: Int)
                 (ds2_d4B0M [Occ=Once!] :: Float)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B0K of { Ptr a_a4AOx [Occ=Once] ->
                 case ds1_d4B0L of { I# i_a4AOy [Occ=Once] ->
                 case ds2_d4B0M of { F# x_a4AOz [Occ=Once] ->
                 case writeFloatOffAddr# @ RealWorld a_a4AOx i_a4AOy x_a4AOz eta_B1
                 of s2_a4AOB
                 { __DEFAULT ->
                 (# s2_a4AOB, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeFloatOffPtr1
  = \ (ds_d4B0K :: Ptr Float)
      (ds1_d4B0L :: Int)
      (ds2_d4B0M :: Float)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B0K of { Ptr a_a4AOx ->
      case ds1_d4B0L of { I# i_a4AOy ->
      case ds2_d4B0M of { F# x_a4AOz ->
      case writeFloatOffAddr# @ RealWorld a_a4AOx i_a4AOy x_a4AOz eta_B1
      of s2_a4AOB
      { __DEFAULT ->
      (# s2_a4AOB, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeFloatOffPtr :: Ptr Float -> Int -> Float -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeFloatOffPtr1
               `cast` (<Ptr Float>_R
                       ->_R <Int>_R
                       ->_R <Float>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Float
                           -> Int
                           -> Float
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Float -> Int -> Float -> IO () :: *))}]
writeFloatOffPtr
  = GHC.Storable.writeFloatOffPtr1
    `cast` (<Ptr Float>_R
            ->_R <Int>_R
            ->_R <Float>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Float
                -> Int
                -> Float
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Float -> Int -> Float -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeDoubleOffPtr1
  :: Ptr Double
     -> Int -> Double -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B0y [Occ=Once!] :: Ptr Double)
                 (ds1_d4B0z [Occ=Once!] :: Int)
                 (ds2_d4B0A [Occ=Once!] :: Double)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B0y of { Ptr a_a4AOC [Occ=Once] ->
                 case ds1_d4B0z of { I# i_a4AOD [Occ=Once] ->
                 case ds2_d4B0A of { D# x_a4AOE [Occ=Once] ->
                 case writeDoubleOffAddr# @ RealWorld a_a4AOC i_a4AOD x_a4AOE eta_B1
                 of s2_a4AOG
                 { __DEFAULT ->
                 (# s2_a4AOG, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeDoubleOffPtr1
  = \ (ds_d4B0y :: Ptr Double)
      (ds1_d4B0z :: Int)
      (ds2_d4B0A :: Double)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B0y of { Ptr a_a4AOC ->
      case ds1_d4B0z of { I# i_a4AOD ->
      case ds2_d4B0A of { D# x_a4AOE ->
      case writeDoubleOffAddr# @ RealWorld a_a4AOC i_a4AOD x_a4AOE eta_B1
      of s2_a4AOG
      { __DEFAULT ->
      (# s2_a4AOG, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeDoubleOffPtr :: Ptr Double -> Int -> Double -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeDoubleOffPtr1
               `cast` (<Ptr Double>_R
                       ->_R <Int>_R
                       ->_R <Double>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Double
                           -> Int
                           -> Double
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Double -> Int -> Double -> IO () :: *))}]
writeDoubleOffPtr
  = GHC.Storable.writeDoubleOffPtr1
    `cast` (<Ptr Double>_R
            ->_R <Int>_R
            ->_R <Double>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Double
                -> Int
                -> Double
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Double -> Int -> Double -> IO () :: *))

-- RHS size: {terms: 24, types: 31, coercions: 0, joins: 0/0}
GHC.Storable.writeStablePtrOffPtr1
  :: forall a.
     Ptr (StablePtr a)
     -> Int
     -> StablePtr a
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AVS)
                 (ds_d4B0m [Occ=Once!] :: Ptr (StablePtr a_a4AVS))
                 (ds1_d4B0n [Occ=Once!] :: Int)
                 (ds2_d4B0o [Occ=Once!] :: StablePtr a_a4AVS)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B0m of { Ptr a1_a4AOH [Occ=Once] ->
                 case ds1_d4B0n of { I# i_a4AOI [Occ=Once] ->
                 case ds2_d4B0o of { StablePtr x_a4AOJ [Occ=Once] ->
                 case writeStablePtrOffAddr#
                        @ a_a4AVS @ RealWorld a1_a4AOH i_a4AOI x_a4AOJ eta_B1
                 of s2_a4AOL
                 { __DEFAULT ->
                 (# s2_a4AOL, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeStablePtrOffPtr1
  = \ (@ a_a4AVS)
      (ds_d4B0m :: Ptr (StablePtr a_a4AVS))
      (ds1_d4B0n :: Int)
      (ds2_d4B0o :: StablePtr a_a4AVS)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B0m of { Ptr a1_a4AOH ->
      case ds1_d4B0n of { I# i_a4AOI ->
      case ds2_d4B0o of { StablePtr x_a4AOJ ->
      case writeStablePtrOffAddr#
             @ a_a4AVS @ RealWorld a1_a4AOH i_a4AOI x_a4AOJ eta_B1
      of s2_a4AOL
      { __DEFAULT ->
      (# s2_a4AOL, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
writeStablePtrOffPtr
  :: forall a. Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeStablePtrOffPtr1
               `cast` (forall (a :: <*>_N).
                       <Ptr (StablePtr a)>_R
                       ->_R <Int>_R
                       ->_R <StablePtr a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (forall a.
                           Ptr (StablePtr a)
                           -> Int
                           -> StablePtr a
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (forall a.
                               Ptr (StablePtr a) -> Int -> StablePtr a -> IO () :: *))}]
writeStablePtrOffPtr
  = GHC.Storable.writeStablePtrOffPtr1
    `cast` (forall (a :: <*>_N).
            <Ptr (StablePtr a)>_R
            ->_R <Int>_R
            ->_R <StablePtr a>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (forall a.
                Ptr (StablePtr a)
                -> Int
                -> StablePtr a
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (forall a.
                    Ptr (StablePtr a) -> Int -> StablePtr a -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeInt8OffPtr1
  :: Ptr Int8
     -> Int -> Int8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4B0a [Occ=Once!] :: Ptr Int8)
                 (ds1_d4B0b [Occ=Once!] :: Int)
                 (ds2_d4B0c [Occ=Once!] :: Int8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4B0a of { Ptr a_a4AOM [Occ=Once] ->
                 case ds1_d4B0b of { I# i_a4AON [Occ=Once] ->
                 case ds2_d4B0c of { I8# x_a4AOO [Occ=Once] ->
                 case writeInt8OffAddr# @ RealWorld a_a4AOM i_a4AON x_a4AOO eta_B1
                 of s2_a4AOQ
                 { __DEFAULT ->
                 (# s2_a4AOQ, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeInt8OffPtr1
  = \ (ds_d4B0a :: Ptr Int8)
      (ds1_d4B0b :: Int)
      (ds2_d4B0c :: Int8)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4B0a of { Ptr a_a4AOM ->
      case ds1_d4B0b of { I# i_a4AON ->
      case ds2_d4B0c of { I8# x_a4AOO ->
      case writeInt8OffAddr# @ RealWorld a_a4AOM i_a4AON x_a4AOO eta_B1
      of s2_a4AOQ
      { __DEFAULT ->
      (# s2_a4AOQ, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeInt8OffPtr :: Ptr Int8 -> Int -> Int8 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeInt8OffPtr1
               `cast` (<Ptr Int8>_R
                       ->_R <Int>_R
                       ->_R <Int8>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Int8
                           -> Int
                           -> Int8
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Int8 -> Int -> Int8 -> IO () :: *))}]
writeInt8OffPtr
  = GHC.Storable.writeInt8OffPtr1
    `cast` (<Ptr Int8>_R
            ->_R <Int>_R
            ->_R <Int8>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Int8
                -> Int
                -> Int8
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Int8 -> Int -> Int8 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWord8OffPtr1
  :: Ptr Word8
     -> Int -> Word8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZY [Occ=Once!] :: Ptr Word8)
                 (ds1_d4AZZ [Occ=Once!] :: Int)
                 (ds2_d4B00 [Occ=Once!] :: Word8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZY of { Ptr a_a4AOR [Occ=Once] ->
                 case ds1_d4AZZ of { I# i_a4AOS [Occ=Once] ->
                 case ds2_d4B00 of { W8# x_a4AOT [Occ=Once] ->
                 case writeWord8OffAddr# @ RealWorld a_a4AOR i_a4AOS x_a4AOT eta_B1
                 of s2_a4AOV
                 { __DEFAULT ->
                 (# s2_a4AOV, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWord8OffPtr1
  = \ (ds_d4AZY :: Ptr Word8)
      (ds1_d4AZZ :: Int)
      (ds2_d4B00 :: Word8)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZY of { Ptr a_a4AOR ->
      case ds1_d4AZZ of { I# i_a4AOS ->
      case ds2_d4B00 of { W8# x_a4AOT ->
      case writeWord8OffAddr# @ RealWorld a_a4AOR i_a4AOS x_a4AOT eta_B1
      of s2_a4AOV
      { __DEFAULT ->
      (# s2_a4AOV, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWord8OffPtr :: Ptr Word8 -> Int -> Word8 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWord8OffPtr1
               `cast` (<Ptr Word8>_R
                       ->_R <Int>_R
                       ->_R <Word8>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Word8
                           -> Int
                           -> Word8
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Word8 -> Int -> Word8 -> IO () :: *))}]
writeWord8OffPtr
  = GHC.Storable.writeWord8OffPtr1
    `cast` (<Ptr Word8>_R
            ->_R <Int>_R
            ->_R <Word8>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Word8
                -> Int
                -> Word8
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Word8 -> Int -> Word8 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeInt16OffPtr1
  :: Ptr Int16
     -> Int -> Int16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZM [Occ=Once!] :: Ptr Int16)
                 (ds1_d4AZN [Occ=Once!] :: Int)
                 (ds2_d4AZO [Occ=Once!] :: Int16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZM of { Ptr a_a4AOW [Occ=Once] ->
                 case ds1_d4AZN of { I# i_a4AOX [Occ=Once] ->
                 case ds2_d4AZO of { I16# x_a4AOY [Occ=Once] ->
                 case writeInt16OffAddr# @ RealWorld a_a4AOW i_a4AOX x_a4AOY eta_B1
                 of s2_a4AP0
                 { __DEFAULT ->
                 (# s2_a4AP0, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeInt16OffPtr1
  = \ (ds_d4AZM :: Ptr Int16)
      (ds1_d4AZN :: Int)
      (ds2_d4AZO :: Int16)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZM of { Ptr a_a4AOW ->
      case ds1_d4AZN of { I# i_a4AOX ->
      case ds2_d4AZO of { I16# x_a4AOY ->
      case writeInt16OffAddr# @ RealWorld a_a4AOW i_a4AOX x_a4AOY eta_B1
      of s2_a4AP0
      { __DEFAULT ->
      (# s2_a4AP0, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeInt16OffPtr :: Ptr Int16 -> Int -> Int16 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeInt16OffPtr1
               `cast` (<Ptr Int16>_R
                       ->_R <Int>_R
                       ->_R <Int16>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Int16
                           -> Int
                           -> Int16
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Int16 -> Int -> Int16 -> IO () :: *))}]
writeInt16OffPtr
  = GHC.Storable.writeInt16OffPtr1
    `cast` (<Ptr Int16>_R
            ->_R <Int>_R
            ->_R <Int16>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Int16
                -> Int
                -> Int16
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Int16 -> Int -> Int16 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWord16OffPtr1
  :: Ptr Word16
     -> Int -> Word16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZA [Occ=Once!] :: Ptr Word16)
                 (ds1_d4AZB [Occ=Once!] :: Int)
                 (ds2_d4AZC [Occ=Once!] :: Word16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZA of { Ptr a_a4AP1 [Occ=Once] ->
                 case ds1_d4AZB of { I# i_a4AP2 [Occ=Once] ->
                 case ds2_d4AZC of { W16# x_a4AP3 [Occ=Once] ->
                 case writeWord16OffAddr# @ RealWorld a_a4AP1 i_a4AP2 x_a4AP3 eta_B1
                 of s2_a4AP5
                 { __DEFAULT ->
                 (# s2_a4AP5, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWord16OffPtr1
  = \ (ds_d4AZA :: Ptr Word16)
      (ds1_d4AZB :: Int)
      (ds2_d4AZC :: Word16)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZA of { Ptr a_a4AP1 ->
      case ds1_d4AZB of { I# i_a4AP2 ->
      case ds2_d4AZC of { W16# x_a4AP3 ->
      case writeWord16OffAddr# @ RealWorld a_a4AP1 i_a4AP2 x_a4AP3 eta_B1
      of s2_a4AP5
      { __DEFAULT ->
      (# s2_a4AP5, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWord16OffPtr :: Ptr Word16 -> Int -> Word16 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWord16OffPtr1
               `cast` (<Ptr Word16>_R
                       ->_R <Int>_R
                       ->_R <Word16>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Word16
                           -> Int
                           -> Word16
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Word16 -> Int -> Word16 -> IO () :: *))}]
writeWord16OffPtr
  = GHC.Storable.writeWord16OffPtr1
    `cast` (<Ptr Word16>_R
            ->_R <Int>_R
            ->_R <Word16>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Word16
                -> Int
                -> Word16
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Word16 -> Int -> Word16 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeInt32OffPtr1
  :: Ptr Int32
     -> Int -> Int32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZo [Occ=Once!] :: Ptr Int32)
                 (ds1_d4AZp [Occ=Once!] :: Int)
                 (ds2_d4AZq [Occ=Once!] :: Int32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZo of { Ptr a_a4AP6 [Occ=Once] ->
                 case ds1_d4AZp of { I# i_a4AP7 [Occ=Once] ->
                 case ds2_d4AZq of { I32# x_a4AP8 [Occ=Once] ->
                 case writeInt32OffAddr# @ RealWorld a_a4AP6 i_a4AP7 x_a4AP8 eta_B1
                 of s2_a4APa
                 { __DEFAULT ->
                 (# s2_a4APa, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeInt32OffPtr1
  = \ (ds_d4AZo :: Ptr Int32)
      (ds1_d4AZp :: Int)
      (ds2_d4AZq :: Int32)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZo of { Ptr a_a4AP6 ->
      case ds1_d4AZp of { I# i_a4AP7 ->
      case ds2_d4AZq of { I32# x_a4AP8 ->
      case writeInt32OffAddr# @ RealWorld a_a4AP6 i_a4AP7 x_a4AP8 eta_B1
      of s2_a4APa
      { __DEFAULT ->
      (# s2_a4APa, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeInt32OffPtr :: Ptr Int32 -> Int -> Int32 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeInt32OffPtr1
               `cast` (<Ptr Int32>_R
                       ->_R <Int>_R
                       ->_R <Int32>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Int32
                           -> Int
                           -> Int32
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Int32 -> Int -> Int32 -> IO () :: *))}]
writeInt32OffPtr
  = GHC.Storable.writeInt32OffPtr1
    `cast` (<Ptr Int32>_R
            ->_R <Int>_R
            ->_R <Int32>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Int32
                -> Int
                -> Int32
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Int32 -> Int -> Int32 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWord32OffPtr1
  :: Ptr Word32
     -> Int -> Word32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZc [Occ=Once!] :: Ptr Word32)
                 (ds1_d4AZd [Occ=Once!] :: Int)
                 (ds2_d4AZe [Occ=Once!] :: Word32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZc of { Ptr a_a4APb [Occ=Once] ->
                 case ds1_d4AZd of { I# i_a4APc [Occ=Once] ->
                 case ds2_d4AZe of { W32# x_a4APd [Occ=Once] ->
                 case writeWord32OffAddr# @ RealWorld a_a4APb i_a4APc x_a4APd eta_B1
                 of s2_a4APf
                 { __DEFAULT ->
                 (# s2_a4APf, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWord32OffPtr1
  = \ (ds_d4AZc :: Ptr Word32)
      (ds1_d4AZd :: Int)
      (ds2_d4AZe :: Word32)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZc of { Ptr a_a4APb ->
      case ds1_d4AZd of { I# i_a4APc ->
      case ds2_d4AZe of { W32# x_a4APd ->
      case writeWord32OffAddr# @ RealWorld a_a4APb i_a4APc x_a4APd eta_B1
      of s2_a4APf
      { __DEFAULT ->
      (# s2_a4APf, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWord32OffPtr :: Ptr Word32 -> Int -> Word32 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWord32OffPtr1
               `cast` (<Ptr Word32>_R
                       ->_R <Int>_R
                       ->_R <Word32>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Word32
                           -> Int
                           -> Word32
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Word32 -> Int -> Word32 -> IO () :: *))}]
writeWord32OffPtr
  = GHC.Storable.writeWord32OffPtr1
    `cast` (<Ptr Word32>_R
            ->_R <Int>_R
            ->_R <Word32>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Word32
                -> Int
                -> Word32
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Word32 -> Int -> Word32 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeInt64OffPtr1
  :: Ptr Int64
     -> Int -> Int64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AZ0 [Occ=Once!] :: Ptr Int64)
                 (ds1_d4AZ1 [Occ=Once!] :: Int)
                 (ds2_d4AZ2 [Occ=Once!] :: Int64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AZ0 of { Ptr a_a4APg [Occ=Once] ->
                 case ds1_d4AZ1 of { I# i_a4APh [Occ=Once] ->
                 case ds2_d4AZ2 of { I64# x_a4APi [Occ=Once] ->
                 case writeInt64OffAddr# @ RealWorld a_a4APg i_a4APh x_a4APi eta_B1
                 of s2_a4APk
                 { __DEFAULT ->
                 (# s2_a4APk, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeInt64OffPtr1
  = \ (ds_d4AZ0 :: Ptr Int64)
      (ds1_d4AZ1 :: Int)
      (ds2_d4AZ2 :: Int64)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AZ0 of { Ptr a_a4APg ->
      case ds1_d4AZ1 of { I# i_a4APh ->
      case ds2_d4AZ2 of { I64# x_a4APi ->
      case writeInt64OffAddr# @ RealWorld a_a4APg i_a4APh x_a4APi eta_B1
      of s2_a4APk
      { __DEFAULT ->
      (# s2_a4APk, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeInt64OffPtr :: Ptr Int64 -> Int -> Int64 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeInt64OffPtr1
               `cast` (<Ptr Int64>_R
                       ->_R <Int>_R
                       ->_R <Int64>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Int64
                           -> Int
                           -> Int64
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Int64 -> Int -> Int64 -> IO () :: *))}]
writeInt64OffPtr
  = GHC.Storable.writeInt64OffPtr1
    `cast` (<Ptr Int64>_R
            ->_R <Int>_R
            ->_R <Int64>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Int64
                -> Int
                -> Int64
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Int64 -> Int -> Int64 -> IO () :: *))

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/0}
GHC.Storable.writeWord64OffPtr1
  :: Ptr Word64
     -> Int -> Word64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4AYO [Occ=Once!] :: Ptr Word64)
                 (ds1_d4AYP [Occ=Once!] :: Int)
                 (ds2_d4AYQ [Occ=Once!] :: Word64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d4AYO of { Ptr a_a4APl [Occ=Once] ->
                 case ds1_d4AYP of { I# i_a4APm [Occ=Once] ->
                 case ds2_d4AYQ of { W64# x_a4APn [Occ=Once] ->
                 case writeWord64OffAddr# @ RealWorld a_a4APl i_a4APm x_a4APn eta_B1
                 of s2_a4APp
                 { __DEFAULT ->
                 (# s2_a4APp, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
GHC.Storable.writeWord64OffPtr1
  = \ (ds_d4AYO :: Ptr Word64)
      (ds1_d4AYP :: Int)
      (ds2_d4AYQ :: Word64)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4AYO of { Ptr a_a4APl ->
      case ds1_d4AYP of { I# i_a4APm ->
      case ds2_d4AYQ of { W64# x_a4APn ->
      case writeWord64OffAddr# @ RealWorld a_a4APl i_a4APm x_a4APn eta_B1
      of s2_a4APp
      { __DEFAULT ->
      (# s2_a4APp, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
writeWord64OffPtr :: Ptr Word64 -> Int -> Word64 -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Storable.writeWord64OffPtr1
               `cast` (<Ptr Word64>_R
                       ->_R <Int>_R
                       ->_R <Word64>_R
                       ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Ptr Word64
                           -> Int
                           -> Word64
                           -> State# RealWorld
                           -> (# State# RealWorld, () #) :: *)
                          ~R# (Ptr Word64 -> Int -> Word64 -> IO () :: *))}]
writeWord64OffPtr
  = GHC.Storable.writeWord64OffPtr1
    `cast` (<Ptr Word64>_R
            ->_R <Int>_R
            ->_R <Word64>_R
            ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Ptr Word64
                -> Int
                -> Word64
                -> State# RealWorld
                -> (# State# RealWorld, () #) :: *)
               ~R# (Ptr Word64 -> Int -> Word64 -> IO () :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Storable.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Storable.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Storable.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Storable.$trModule3 = GHC.Types.TrNameS GHC.Storable.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Storable.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Storable.$trModule2 = "GHC.Storable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Storable.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Storable.$trModule1 = GHC.Types.TrNameS GHC.Storable.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Storable.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Storable.$trModule
  = GHC.Types.Module GHC.Storable.$trModule3 GHC.Storable.$trModule1


