
==================== Output Cmm ====================
2018-03-16 16:05:16.732920683 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:16.733533514 UTC

[section ""cstring" . GHC.Environment.$trModule4_bytes" {
     GHC.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.734123664 UTC

[section ""data" . GHC.Environment.$trModule3_closure" {
     GHC.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.734684058 UTC

[section ""cstring" . GHC.Environment.$trModule2_bytes" {
     GHC.Environment.$trModule2_bytes:
         I8[] [71,72,67,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.735213011 UTC

[section ""data" . GHC.Environment.$trModule1_closure" {
     GHC.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.735769072 UTC

[section ""data" . GHC.Environment.$trModule_closure" {
     GHC.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Environment.$trModule3_closure+1;
         const GHC.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.738373289 UTC

[section ""data" . GHC.Environment.getFullArgs1_closure" {
     GHC.Environment.getFullArgs1_closure:
         const GHC.Environment.getFullArgs1_info;
         const 0;
 },
 go_safro_entry() //  [R1, R2]
         { info_tbl: [(cafsZ,
                       label: go_safro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto caft0; else goto caft1;
       caft0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caft1: // global
           I64[Sp - 24] = block_cafsS_info;
           _safro::P64 = R1;
           _safrk::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _safrk::P64;
           P64[Sp - 8] = _safro::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafto; else goto cafsT;
       uafto: // global
           call _cafsS(R1) args: 0, res: 0, upd: 0;
       cafsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafsS() //  [R1]
         { info_tbl: [(cafsS,
                       label: block_cafsS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsS: // global
           if (R1 & 7 == 1) goto cafsW; else goto cafsX;
       cafsW: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cafsX: // global
           I64[Sp - 8] = block_caft7_info;
           _safrt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _safrt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaftn; else goto caft8;
       uaftn: // global
           call _caft7(R1) args: 0, res: 0, upd: 0;
       caft8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caft7() //  [R1]
         { info_tbl: [(caft7,
                       label: block_caft7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caft7: // global
           I64[Sp] = block_caftc_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _caftc() //  [R1]
         { info_tbl: [(caftc,
                       label: block_caftc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caftc: // global
           I64[Sp + 16] = block_cafte_info;
           R2 = P64[Sp + 8];
           _safry::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _safry::P64;
           Sp = Sp + 16;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafte() //  [R1]
         { info_tbl: [(cafte,
                       label: block_cafte_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafte: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caftm; else goto caftl;
       caftm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caftl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Environment.getFullArgs1_entry() //  []
         { info_tbl: [(caftp,
                       label: GHC.Environment.getFullArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caftp: // global
           if ((Sp + -56) < SpLim) (likely: False) goto caftq; else goto caftr;
       caftq: // global
           R1 = GHC.Environment.getFullArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caftr: // global
           I64[Sp - 8] = block_cafs7_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafs7() //  [R1]
         { info_tbl: [(cafs7,
                       label: block_cafs7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafs7: // global
           I64[Sp - 8] = block_cafs9_info;
           R2 = 8;
           _safqX::P64 = R1;
           R1 = 8;
           P64[Sp] = _safqX::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafs9() //  [R1]
         { info_tbl: [(cafs9,
                       label: block_cafs9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafs9: // global
           _safr4::I64 = P64[Sp + 8] + 16;
           _safr5::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getFullProgArgv(_safr4::I64, _safr5::I64);
           _safrb::I64 = %MO_SS_Conv_W32_W64(I32[_safr4::I64]);
           _safre::I64 = I64[_safr5::I64];
           I64[Sp - 24] = block_cafsk_info;
           _safr3::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _safrb::I64;
           I64[Sp - 8] = _safre::I64;
           P64[Sp] = _safr3::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafu3; else goto cafsl;
       uafu3: // global
           call _cafsk(R1) args: 0, res: 0, upd: 0;
       cafsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafsk() //  [R1]
         { info_tbl: [(cafsk,
                       label: block_cafsk_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsk: // global
           I64[Sp] = block_cafsp_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafsp() //  [R1]
         { info_tbl: [(cafsp,
                       label: block_cafsp_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsp: // global
           _safrb::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_safrb::I64, 0)) goto caftP; else goto caftQ;
       caftP: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _safrb::I64 - 1;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cafsD() args: 0, res: 0, upd: 0;
       caftQ: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cafsL() args: 0, res: 0, upd: 0;
     }
 },
 _cafsD() //  []
         { info_tbl: [(cafsD,
                       label: block_cafsD_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto caftK; else goto caftJ;
       caftK: // global
           HpAlloc = 40;
           I64[Sp] = block_cafsD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caftJ: // global
           _safrT::P64 = P64[Sp + 8];
           _safrV::I64 = I64[Sp + 16];
           if (_safrV::I64 != 0) goto caftM; else goto caftN;
       caftM: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_safrV::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrT::P64;
           I64[Sp + 16] = _safrV::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _cafsD() args: 0, res: 0, upd: 0;
       caftN: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _safrT::P64;
           Sp = Sp + 16;
           call _caftD() args: 0, res: 0, upd: 0;
     }
 },
 _caftD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caftD: // global
           Hp = Hp + 40;
           _safrK::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto caftH; else goto caftG;
       caftH: // global
           HpAlloc = 40;
           I64[Sp] = block_caftC_info;
           R1 = _safrK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caftG: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrK::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _cafsL() args: 0, res: 0, upd: 0;
     }
 },
 _caftC() //  [R1]
         { info_tbl: [(caftC,
                       label: block_caftC_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caftC: // global
           P64[Sp] = R1;
           call _caftD() args: 0, res: 0, upd: 0;
     }
 },
 _cafsL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsL: // global
           Hp = Hp + 16;
           _safrn::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto caftz; else goto cafty;
       caftz: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cafsK_info;
           R1 = _safrn::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafty: // global
           I64[Hp - 8] = go_safro_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_caftw_info;
           R2 = _safrn::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafsK() //  [R1]
         { info_tbl: [(cafsK,
                       label: block_cafsK_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafsK: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cafsL() args: 0, res: 0, upd: 0;
     }
 },
 _caftw() //  [R1]
         { info_tbl: [(caftw,
                       label: block_caftw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caftw: // global
           _safqX::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_safqX::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.742510302 UTC

[section ""data" . GHC.Environment.getFullArgs_closure" {
     GHC.Environment.getFullArgs_closure:
         const GHC.Environment.getFullArgs_info;
         const 0;
 },
 GHC.Environment.getFullArgs_entry() //  []
         { info_tbl: [(cafug,
                       label: GHC.Environment.getFullArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafug: // global
           call GHC.Environment.getFullArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.74316994 UTC

[section ""relreadonly" . Safub_srt" {
     Safub_srt:
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const GHC.Environment.getFullArgs1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.743690287 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:16.744203288 UTC

[section ""cstring" . GHC.Environment.$trModule4_bytes" {
     GHC.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.744720059 UTC

[section ""data" . GHC.Environment.$trModule3_closure" {
     GHC.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.745272711 UTC

[section ""cstring" . GHC.Environment.$trModule2_bytes" {
     GHC.Environment.$trModule2_bytes:
         I8[] [71,72,67,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.745844417 UTC

[section ""data" . GHC.Environment.$trModule1_closure" {
     GHC.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.746394164 UTC

[section ""data" . GHC.Environment.$trModule_closure" {
     GHC.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Environment.$trModule3_closure+1;
         const GHC.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.748748694 UTC

[section ""data" . GHC.Environment.getFullArgs1_closure" {
     GHC.Environment.getFullArgs1_closure:
         const GHC.Environment.getFullArgs1_info;
         const 0;
 },
 go_safro_entry() //  [R1, R2]
         { info_tbl: [(cafvf,
                       label: go_safro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cafvg; else goto cafvh;
       cafvg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cafvh: // global
           I64[Sp - 24] = block_cafv8_info;
           _safro::P64 = R1;
           _safrk::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _safrk::P64;
           P64[Sp - 8] = _safro::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafvE; else goto cafv9;
       uafvE: // global
           call _cafv8(R1) args: 0, res: 0, upd: 0;
       cafv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafv8() //  [R1]
         { info_tbl: [(cafv8,
                       label: block_cafv8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafv8: // global
           if (R1 & 7 == 1) goto cafvc; else goto cafvd;
       cafvc: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cafvd: // global
           I64[Sp - 8] = block_cafvn_info;
           _safrt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _safrt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uafvD; else goto cafvo;
       uafvD: // global
           call _cafvn(R1) args: 0, res: 0, upd: 0;
       cafvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafvn() //  [R1]
         { info_tbl: [(cafvn,
                       label: block_cafvn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvn: // global
           I64[Sp] = block_cafvs_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cafvs() //  [R1]
         { info_tbl: [(cafvs,
                       label: block_cafvs_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvs: // global
           I64[Sp + 16] = block_cafvu_info;
           R2 = P64[Sp + 8];
           _safry::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _safry::P64;
           Sp = Sp + 16;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafvu() //  [R1]
         { info_tbl: [(cafvu,
                       label: block_cafvu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cafvC; else goto cafvB;
       cafvC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafvB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Environment.getFullArgs1_entry() //  []
         { info_tbl: [(cafvF,
                       label: GHC.Environment.getFullArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvF: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cafvG; else goto cafvH;
       cafvG: // global
           R1 = GHC.Environment.getFullArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafvH: // global
           I64[Sp - 8] = block_cafun_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafun() //  [R1]
         { info_tbl: [(cafun,
                       label: block_cafun_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafun: // global
           I64[Sp - 8] = block_cafup_info;
           R2 = 8;
           _safqX::P64 = R1;
           R1 = 8;
           P64[Sp] = _safqX::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafup() //  [R1]
         { info_tbl: [(cafup,
                       label: block_cafup_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafup: // global
           _safr4::I64 = P64[Sp + 8] + 16;
           _safr5::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getFullProgArgv(_safr4::I64, _safr5::I64);
           _safrb::I64 = %MO_SS_Conv_W32_W64(I32[_safr4::I64]);
           _safre::I64 = I64[_safr5::I64];
           I64[Sp - 24] = block_cafuA_info;
           _safr3::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _safrb::I64;
           I64[Sp - 8] = _safre::I64;
           P64[Sp] = _safr3::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafwj; else goto cafuB;
       uafwj: // global
           call _cafuA(R1) args: 0, res: 0, upd: 0;
       cafuB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafuA() //  [R1]
         { info_tbl: [(cafuA,
                       label: block_cafuA_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafuA: // global
           I64[Sp] = block_cafuF_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafuF() //  [R1]
         { info_tbl: [(cafuF,
                       label: block_cafuF_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafuF: // global
           _safrb::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_safrb::I64, 0)) goto cafw5; else goto cafw6;
       cafw5: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _safrb::I64 - 1;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cafuT() args: 0, res: 0, upd: 0;
       cafw6: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cafv1() args: 0, res: 0, upd: 0;
     }
 },
 _cafuT() //  []
         { info_tbl: [(cafuT,
                       label: block_cafuT_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafuT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafw0; else goto cafvZ;
       cafw0: // global
           HpAlloc = 40;
           I64[Sp] = block_cafuT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cafvZ: // global
           _safrT::P64 = P64[Sp + 8];
           _safrV::I64 = I64[Sp + 16];
           if (_safrV::I64 != 0) goto cafw2; else goto cafw3;
       cafw2: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_safrV::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrT::P64;
           I64[Sp + 16] = _safrV::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _cafuT() args: 0, res: 0, upd: 0;
       cafw3: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _safrT::P64;
           Sp = Sp + 16;
           call _cafvT() args: 0, res: 0, upd: 0;
     }
 },
 _cafvT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvT: // global
           Hp = Hp + 40;
           _safrK::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cafvX; else goto cafvW;
       cafvX: // global
           HpAlloc = 40;
           I64[Sp] = block_cafvS_info;
           R1 = _safrK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafvW: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrK::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _cafv1() args: 0, res: 0, upd: 0;
     }
 },
 _cafvS() //  [R1]
         { info_tbl: [(cafvS,
                       label: block_cafvS_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvS: // global
           P64[Sp] = R1;
           call _cafvT() args: 0, res: 0, upd: 0;
     }
 },
 _cafv1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafv1: // global
           Hp = Hp + 16;
           _safrn::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cafvP; else goto cafvO;
       cafvP: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cafv0_info;
           R1 = _safrn::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafvO: // global
           I64[Hp - 8] = go_safro_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_cafvM_info;
           R2 = _safrn::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafv0() //  [R1]
         { info_tbl: [(cafv0,
                       label: block_cafv0_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafv0: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cafv1() args: 0, res: 0, upd: 0;
     }
 },
 _cafvM() //  [R1]
         { info_tbl: [(cafvM,
                       label: block_cafvM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafvM: // global
           _safqX::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_safqX::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.752836066 UTC

[section ""data" . GHC.Environment.getFullArgs_closure" {
     GHC.Environment.getFullArgs_closure:
         const GHC.Environment.getFullArgs_info;
         const 0;
 },
 GHC.Environment.getFullArgs_entry() //  []
         { info_tbl: [(cafwv,
                       label: GHC.Environment.getFullArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafwv: // global
           call GHC.Environment.getFullArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.75369323 UTC

[section ""relreadonly" . Safub_srt" {
     Safub_srt:
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const GHC.Environment.getFullArgs1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.754475445 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:16.755591782 UTC

[section ""cstring" . GHC.Environment.$trModule4_bytes" {
     GHC.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.75738025 UTC

[section ""data" . GHC.Environment.$trModule3_closure" {
     GHC.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.759037222 UTC

[section ""cstring" . GHC.Environment.$trModule2_bytes" {
     GHC.Environment.$trModule2_bytes:
         I8[] [71,72,67,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.760706859 UTC

[section ""data" . GHC.Environment.$trModule1_closure" {
     GHC.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.762478755 UTC

[section ""data" . GHC.Environment.$trModule_closure" {
     GHC.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Environment.$trModule3_closure+1;
         const GHC.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.766165061 UTC

[section ""data" . GHC.Environment.getFullArgs1_closure" {
     GHC.Environment.getFullArgs1_closure:
         const GHC.Environment.getFullArgs1_info;
         const 0;
 },
 go_safro_entry() //  [R1, R2]
         { info_tbl: [(cafxz,
                       label: go_safro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cafxA; else goto cafxB;
       cafxA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cafxB: // global
           I64[Sp - 24] = block_cafxs_info;
           _safro::P64 = R1;
           _safrk::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _safrk::P64;
           P64[Sp - 8] = _safro::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafxY; else goto cafxt;
       uafxY: // global
           call _cafxs(R1) args: 0, res: 0, upd: 0;
       cafxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafxs() //  [R1]
         { info_tbl: [(cafxs,
                       label: block_cafxs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxs: // global
           if (R1 & 7 == 1) goto cafxw; else goto cafxx;
       cafxw: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cafxx: // global
           I64[Sp - 8] = block_cafxH_info;
           _safrt::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _safrt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uafxX; else goto cafxI;
       uafxX: // global
           call _cafxH(R1) args: 0, res: 0, upd: 0;
       cafxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafxH() //  [R1]
         { info_tbl: [(cafxH,
                       label: block_cafxH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxH: // global
           I64[Sp] = block_cafxM_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cafxM() //  [R1]
         { info_tbl: [(cafxM,
                       label: block_cafxM_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxM: // global
           I64[Sp + 16] = block_cafxO_info;
           R2 = P64[Sp + 8];
           _safry::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _safry::P64;
           Sp = Sp + 16;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafxO() //  [R1]
         { info_tbl: [(cafxO,
                       label: block_cafxO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cafxW; else goto cafxV;
       cafxW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafxV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Environment.getFullArgs1_entry() //  []
         { info_tbl: [(cafxZ,
                       label: GHC.Environment.getFullArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cafy0; else goto cafy1;
       cafy0: // global
           R1 = GHC.Environment.getFullArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafy1: // global
           I64[Sp - 8] = block_cafwH_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafwH() //  [R1]
         { info_tbl: [(cafwH,
                       label: block_cafwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafwH: // global
           I64[Sp - 8] = block_cafwJ_info;
           R2 = 8;
           _safqX::P64 = R1;
           R1 = 8;
           P64[Sp] = _safqX::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafwJ() //  [R1]
         { info_tbl: [(cafwJ,
                       label: block_cafwJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafwJ: // global
           _safr4::I64 = P64[Sp + 8] + 16;
           _safr5::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getFullProgArgv(_safr4::I64, _safr5::I64);
           _safrb::I64 = %MO_SS_Conv_W32_W64(I32[_safr4::I64]);
           _safre::I64 = I64[_safr5::I64];
           I64[Sp - 24] = block_cafwU_info;
           _safr3::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _safrb::I64;
           I64[Sp - 8] = _safre::I64;
           P64[Sp] = _safr3::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafyD; else goto cafwV;
       uafyD: // global
           call _cafwU(R1) args: 0, res: 0, upd: 0;
       cafwV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafwU() //  [R1]
         { info_tbl: [(cafwU,
                       label: block_cafwU_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafwU: // global
           I64[Sp] = block_cafwZ_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafwZ() //  [R1]
         { info_tbl: [(cafwZ,
                       label: block_cafwZ_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafwZ: // global
           _safrb::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_safrb::I64, 0)) goto cafyp; else goto cafyq;
       cafyp: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _safrb::I64 - 1;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cafxd() args: 0, res: 0, upd: 0;
       cafyq: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cafxl() args: 0, res: 0, upd: 0;
     }
 },
 _cafxd() //  []
         { info_tbl: [(cafxd,
                       label: block_cafxd_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafyk; else goto cafyj;
       cafyk: // global
           HpAlloc = 40;
           I64[Sp] = block_cafxd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cafyj: // global
           _safrT::P64 = P64[Sp + 8];
           _safrV::I64 = I64[Sp + 16];
           if (_safrV::I64 != 0) goto cafym; else goto cafyn;
       cafym: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_safrV::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrT::P64;
           I64[Sp + 16] = _safrV::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _cafxd() args: 0, res: 0, upd: 0;
       cafyn: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _safrT::P64;
           Sp = Sp + 16;
           call _cafyd() args: 0, res: 0, upd: 0;
     }
 },
 _cafyd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafyd: // global
           Hp = Hp + 40;
           _safrK::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cafyh; else goto cafyg;
       cafyh: // global
           HpAlloc = 40;
           I64[Sp] = block_cafyc_info;
           R1 = _safrK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafyg: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safrK::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _cafxl() args: 0, res: 0, upd: 0;
     }
 },
 _cafyc() //  [R1]
         { info_tbl: [(cafyc,
                       label: block_cafyc_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafyc: // global
           P64[Sp] = R1;
           call _cafyd() args: 0, res: 0, upd: 0;
     }
 },
 _cafxl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxl: // global
           Hp = Hp + 16;
           _safrn::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cafy9; else goto cafy8;
       cafy9: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cafxk_info;
           R1 = _safrn::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafy8: // global
           I64[Hp - 8] = go_safro_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_cafy6_info;
           R2 = _safrn::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_safro_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafxk() //  [R1]
         { info_tbl: [(cafxk,
                       label: block_cafxk_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafxk: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cafxl() args: 0, res: 0, upd: 0;
     }
 },
 _cafy6() //  [R1]
         { info_tbl: [(cafy6,
                       label: block_cafy6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafy6: // global
           _safqX::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_safqX::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.796802757 UTC

[section ""data" . GHC.Environment.getFullArgs_closure" {
     GHC.Environment.getFullArgs_closure:
         const GHC.Environment.getFullArgs_info;
         const 0;
 },
 GHC.Environment.getFullArgs_entry() //  []
         { info_tbl: [(cafzY,
                       label: GHC.Environment.getFullArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafzY: // global
           call GHC.Environment.getFullArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.800306507 UTC

[section ""relreadonly" . Safub_srt" {
     Safub_srt:
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const GHC.Environment.getFullArgs1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.905463278 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:16.906531542 UTC

[section ""cstring" . GHC.Environment.$trModule4_bytes" {
     GHC.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.908193303 UTC

[section ""data" . GHC.Environment.$trModule3_closure" {
     GHC.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.909856061 UTC

[section ""cstring" . GHC.Environment.$trModule2_bytes" {
     GHC.Environment.$trModule2_bytes:
         I8[] [71,72,67,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.911447157 UTC

[section ""data" . GHC.Environment.$trModule1_closure" {
     GHC.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.913099806 UTC

[section ""data" . GHC.Environment.$trModule_closure" {
     GHC.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Environment.$trModule3_closure+1;
         const GHC.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.916757683 UTC

[section ""data" . GHC.Environment.getFullArgs1_closure" {
     GHC.Environment.getFullArgs1_closure:
         const GHC.Environment.getFullArgs1_info;
         const 0;
 },
 go_safAD_entry() //  [R1, R2]
         { info_tbl: [(cafCj,
                       label: go_safAD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cafCk; else goto cafCl;
       cafCk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cafCl: // global
           I64[Sp - 24] = block_cafCc_info;
           _safAD::P64 = R1;
           _safAz::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _safAz::P64;
           P64[Sp - 8] = _safAD::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafCI; else goto cafCd;
       uafCI: // global
           call _cafCc(R1) args: 0, res: 0, upd: 0;
       cafCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafCc() //  [R1]
         { info_tbl: [(cafCc,
                       label: block_cafCc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCc: // global
           if (R1 & 7 == 1) goto cafCg; else goto cafCh;
       cafCg: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cafCh: // global
           I64[Sp - 8] = block_cafCr_info;
           _safAI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _safAI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uafCH; else goto cafCs;
       uafCH: // global
           call _cafCr(R1) args: 0, res: 0, upd: 0;
       cafCs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafCr() //  [R1]
         { info_tbl: [(cafCr,
                       label: block_cafCr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCr: // global
           I64[Sp] = block_cafCw_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cafCw() //  [R1]
         { info_tbl: [(cafCw,
                       label: block_cafCw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCw: // global
           I64[Sp + 16] = block_cafCy_info;
           R2 = P64[Sp + 8];
           _safAN::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _safAN::P64;
           Sp = Sp + 16;
           call go_safAD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafCy() //  [R1]
         { info_tbl: [(cafCy,
                       label: block_cafCy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cafCG; else goto cafCF;
       cafCG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafCF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Environment.getFullArgs1_entry() //  []
         { info_tbl: [(cafCJ,
                       label: GHC.Environment.getFullArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCJ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cafCK; else goto cafCL;
       cafCK: // global
           R1 = GHC.Environment.getFullArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cafCL: // global
           I64[Sp - 8] = block_cafBr_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafBr() //  [R1]
         { info_tbl: [(cafBr,
                       label: block_cafBr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafBr: // global
           I64[Sp - 8] = block_cafBt_info;
           R2 = 8;
           _safAc::P64 = R1;
           R1 = 8;
           P64[Sp] = _safAc::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafBt() //  [R1]
         { info_tbl: [(cafBt,
                       label: block_cafBt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafBt: // global
           _safAj::I64 = P64[Sp + 8] + 16;
           _safAk::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getFullProgArgv(_safAj::I64, _safAk::I64);
           _safAq::I64 = %MO_SS_Conv_W32_W64(I32[_safAj::I64]);
           _safAt::I64 = I64[_safAk::I64];
           I64[Sp - 24] = block_cafBE_info;
           _safAi::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _safAq::I64;
           I64[Sp - 8] = _safAt::I64;
           P64[Sp] = _safAi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uafDn; else goto cafBF;
       uafDn: // global
           call _cafBE(R1) args: 0, res: 0, upd: 0;
       cafBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafBE() //  [R1]
         { info_tbl: [(cafBE,
                       label: block_cafBE_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafBE: // global
           I64[Sp] = block_cafBJ_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafBJ() //  [R1]
         { info_tbl: [(cafBJ,
                       label: block_cafBJ_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafBJ: // global
           _safAq::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_safAq::I64, 0)) goto cafD9; else goto cafDa;
       cafD9: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _safAq::I64 - 1;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _cafBX() args: 0, res: 0, upd: 0;
       cafDa: // global
           P64[Sp + 8] = R1;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _cafC5() args: 0, res: 0, upd: 0;
     }
 },
 _cafBX() //  []
         { info_tbl: [(cafBX,
                       label: block_cafBX_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafBX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cafD4; else goto cafD3;
       cafD4: // global
           HpAlloc = 40;
           I64[Sp] = block_cafBX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cafD3: // global
           _safB8::P64 = P64[Sp + 8];
           _safBa::I64 = I64[Sp + 16];
           if (_safBa::I64 != 0) goto cafD6; else goto cafD7;
       cafD6: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_safBa::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safB8::P64;
           I64[Sp + 16] = _safBa::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _cafBX() args: 0, res: 0, upd: 0;
       cafD7: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _safB8::P64;
           Sp = Sp + 16;
           call _cafCX() args: 0, res: 0, upd: 0;
     }
 },
 _cafCX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCX: // global
           Hp = Hp + 40;
           _safAZ::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto cafD1; else goto cafD0;
       cafD1: // global
           HpAlloc = 40;
           I64[Sp] = block_cafCW_info;
           R1 = _safAZ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafD0: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _safAZ::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _cafC5() args: 0, res: 0, upd: 0;
     }
 },
 _cafCW() //  [R1]
         { info_tbl: [(cafCW,
                       label: block_cafCW_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCW: // global
           P64[Sp] = R1;
           call _cafCX() args: 0, res: 0, upd: 0;
     }
 },
 _cafC5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafC5: // global
           Hp = Hp + 16;
           _safAC::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto cafCT; else goto cafCS;
       cafCT: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_cafC4_info;
           R1 = _safAC::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cafCS: // global
           I64[Hp - 8] = go_safAD_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_cafCQ_info;
           R2 = _safAC::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_safAD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cafC4() //  [R1]
         { info_tbl: [(cafC4,
                       label: block_cafC4_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafC4: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _cafC5() args: 0, res: 0, upd: 0;
     }
 },
 _cafCQ() //  [R1]
         { info_tbl: [(cafCQ,
                       label: block_cafCQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafCQ: // global
           _safAc::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_safAc::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.947094019 UTC

[section ""data" . GHC.Environment.getFullArgs_closure" {
     GHC.Environment.getFullArgs_closure:
         const GHC.Environment.getFullArgs_info;
         const 0;
 },
 GHC.Environment.getFullArgs_entry() //  []
         { info_tbl: [(cafF6,
                       label: GHC.Environment.getFullArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cafF6: // global
           call GHC.Environment.getFullArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:16.950266498 UTC

[section ""relreadonly" . SafDv_srt" {
     SafDv_srt:
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const GHC.Environment.getFullArgs1_closure;
 }]

